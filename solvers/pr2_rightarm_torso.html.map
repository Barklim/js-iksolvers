{"version":3,"file":"./solvers/pr2_rightarm_torso.html","sources":["./solvers/pr2_rightarm_torso.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAIA;;;;;;;;;;;;;;;AAgwQA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAh9QA;AAAA;AAAA;;;;;;;;AAFA;AAAA;AAAA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-05-22 19:28:51.634886\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54;\nx0=IKcos(j[1]);\nx1=IKcos(j[4]);\nx2=IKcos(j[2]);\nx3=IKsin(j[4]);\nx4=IKsin(j[2]);\nx5=IKsin(j[3]);\nx6=IKcos(j[3]);\nx7=IKsin(j[1]);\nx8=IKcos(j[5]);\nx9=IKsin(j[5]);\nx10=IKsin(j[6]);\nx11=IKcos(j[6]);\nx12=IKsin(j[7]);\nx13=IKcos(j[7]);\nx14=((1.0)*x1);\nx15=((1.0)*x3);\nx16=((0.321)*x1);\nx17=((1.0)*x6);\nx18=((0.321)*x5);\nx19=((1.0)*x8);\nx20=((1.0)*x9);\nx21=((1.0)*x10);\nx22=((0.321)*x6);\nx23=((1.0)*x11);\nx24=(x2*x7);\nx25=((-1.0)*x3);\nx26=(x2*x5);\nx27=((-1.0)*x10);\nx28=(x0*x2);\nx29=((-1.0)*x1);\nx30=(x0*x4);\nx31=((-1.0)*x11);\nx32=(x2*x6);\nx33=(x5*x7);\nx34=(x4*x7);\nx35=(x15*x28);\nx36=(x14*x32);\nx37=(((x30*x5))+(((-1.0)*x17*x7)));\nx38=(((x0*x5))+(((-1.0)*x17*x34)));\nx39=(((x0*x6))+((x33*x4)));\nx40=(x36+(((-1.0)*x15*x4)));\nx41=((((-1.0)*x33))+(((-1.0)*x17*x30)));\nx42=(x37*x9);\nx43=(((x14*x4))+((x15*x32)));\nx44=(x39*x8);\nx45=((1.0)*x41);\nx46=(x40*x9);\nx47=(x1*x41);\nx48=(((x26*x9))+((x8*(((((-1.0)*x36))+((x3*x4)))))));\nx49=((((-1.0)*x14*x38))+((x15*x24)));\nx50=(x49*x9);\nx51=(((x8*((((x1*x38))+((x24*x25))))))+((x39*x9)));\nx52=(((x8*((x47+((x25*x28))))))+x42);\nx53=((((-1.0)*x21*x43))+(((-1.0)*x23*x48)));\nx54=(((x31*x51))+((x27*((((x24*x29))+((x25*x38)))))));\neerot[0]=(((x10*((x42+((x8*(((((-1.0)*x35))+x47))))))))+((x11*((((x1*x28))+((x3*x41)))))));\neerot[1]=((((-1.0)*x12*((((x21*(((((-1.0)*x15*x41))+(((-1.0)*x14*x28))))))+((x23*x52))))))+((x13*((((x9*((((x29*x41))+x35))))+((x37*x8)))))));\neerot[2]=((((-1.0)*x12*((((x19*x37))+((x20*(((((-1.0)*x14*x41))+x35))))))))+((x13*((((x27*((((x28*x29))+((x25*x41))))))+((x31*x52)))))));\neetrans[0]=((-0.05)+(((0.1)*x0))+((x16*x28))+((x3*(((((-1.0)*x18*x7))+(((-1.0)*x22*x30))))))+(((0.4)*x28)));\neerot[3]=(((x10*x51))+((x11*((((x1*x24))+((x3*x38)))))));\neerot[4]=(((x13*((x44+x50))))+((x12*x54)));\neerot[5]=(((x13*x54))+((x12*(((((-1.0)*x20*x49))+(((-1.0)*x19*x39)))))));\neetrans[1]=((-0.188)+(((0.1)*x7))+((x16*x24))+(((0.4)*x24))+((x3*((((x0*x18))+(((-1.0)*x22*x34)))))));\neerot[6]=(((x10*x48))+(((-1.0)*x11*x43)));\neerot[7]=(((x12*x53))+((x13*((x46+((x26*x8)))))));\neerot[8]=(((x13*x53))+((x12*(((((-1.0)*x20*x40))+(((-1.0)*x19*x26)))))));\neetrans[2]=((0.739675)+(((-1.0)*x2*x22*x3))+(((-1.0)*x16*x4))+(((-0.4)*x4))+j[0]);\n}\n\nIKFAST_API int GetNumFreeParameters() { return 2; }\nIKFAST_API int* GetFreeParameters() { static int freeparams[] = {0, 3}; return freeparams; }\nIKFAST_API int GetNumJoints() { return 8; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j27,cj27,sj27,htj27,j27mul,j28,cj28,sj28,htj28,j28mul,j30,cj30,sj30,htj30,j30mul,j31,cj31,sj31,htj31,j31mul,j32,cj32,sj32,htj32,j32mul,j33,cj33,sj33,htj33,j33mul,j12,cj12,sj12,htj12,j29,cj29,sj29,htj29,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij27[2], _nj27,_ij28[2], _nj28,_ij30[2], _nj30,_ij31[2], _nj31,_ij32[2], _nj32,_ij33[2], _nj33,_ij12[2], _nj12,_ij29[2], _nj29;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj27=numeric_limits<IkReal>::quiet_NaN(); _ij27[0] = -1; _ij27[1] = -1; _nj27 = -1; j28=numeric_limits<IkReal>::quiet_NaN(); _ij28[0] = -1; _ij28[1] = -1; _nj28 = -1; j30=numeric_limits<IkReal>::quiet_NaN(); _ij30[0] = -1; _ij30[1] = -1; _nj30 = -1; j31=numeric_limits<IkReal>::quiet_NaN(); _ij31[0] = -1; _ij31[1] = -1; _nj31 = -1; j32=numeric_limits<IkReal>::quiet_NaN(); _ij32[0] = -1; _ij32[1] = -1; _nj32 = -1; j33=numeric_limits<IkReal>::quiet_NaN(); _ij33[0] = -1; _ij33[1] = -1; _nj33 = -1;  _ij12[0] = -1; _ij12[1] = -1; _nj12 = 0;  _ij29[0] = -1; _ij29[1] = -1; _nj29 = 0; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nj12=pfree[0]; cj12=cos(pfree[0]); sj12=sin(pfree[0]), htj12=tan(pfree[0]*0.5);\nj29=pfree[1]; cj29=cos(pfree[1]); sj29=sin(pfree[1]), htj29=tan(pfree[1]*0.5);\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=((-1.0)*r02);\nnew_r01=r01;\nnew_r02=r00;\nnew_px=((0.05)+px);\nnew_r10=((-1.0)*r12);\nnew_r11=r11;\nnew_r12=r10;\nnew_py=((0.188)+py);\nnew_r20=((-1.0)*r22);\nnew_r21=r21;\nnew_r22=r20;\nnew_pz=((-0.739675)+(((-1.0)*j12))+pz);\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x55=((1.0)*px);\nIkReal x56=((1.0)*pz);\nIkReal x57=((1.0)*py);\npp=((px*px)+(py*py)+(pz*pz));\nnpx=(((px*r00))+((py*r10))+((pz*r20)));\nnpy=(((px*r01))+((py*r11))+((pz*r21)));\nnpz=(((px*r02))+((py*r12))+((pz*r22)));\nrxp0_0=((((-1.0)*r20*x57))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x56)));\nrxp0_2=((((-1.0)*r10*x55))+((py*r00)));\nrxp1_0=((((-1.0)*r21*x57))+((pz*r11)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x56)));\nrxp1_2=((((-1.0)*r11*x55))+((py*r01)));\nrxp2_0=(((pz*r12))+(((-1.0)*r22*x57)));\nrxp2_1=(((px*r22))+(((-1.0)*r02*x56)));\nrxp2_2=((((-1.0)*r12*x55))+((py*r02)));\nIkReal op[8+1], zeror[8];\nint numroots;\nIkReal x58=((0.2)*px);\nIkReal x59=((1.0)*pp);\nIkReal x60=((0.509841)+x58+(((-1.0)*x59)));\nIkReal x61=((-0.003759)+x58+(((-1.0)*x59)));\nIkReal x62=(x59+x58);\nIkReal x63=((0.509841)+(((-1.0)*x62)));\nIkReal x64=((-0.003759)+(((-1.0)*x62)));\nIkReal gconst0=x60;\nIkReal gconst1=x61;\nIkReal gconst2=x60;\nIkReal gconst3=x61;\nIkReal gconst4=x63;\nIkReal gconst5=x64;\nIkReal gconst6=x63;\nIkReal gconst7=x64;\nIkReal x65=py*py;\nIkReal x66=sj29*sj29;\nIkReal x67=px*px;\nIkReal x68=((1.0)*gconst4);\nIkReal x69=(gconst5*gconst7);\nIkReal x70=(gconst0*gconst3);\nIkReal x71=(gconst1*gconst2);\nIkReal x72=((2.0)*gconst5);\nIkReal x73=((1.0)*gconst0);\nIkReal x74=(gconst1*gconst7);\nIkReal x75=(gconst0*gconst6);\nIkReal x76=(gconst1*gconst3);\nIkReal x77=(gconst4*gconst7);\nIkReal x78=((2.0)*gconst0);\nIkReal x79=(gconst1*gconst6);\nIkReal x80=(gconst0*gconst7);\nIkReal x81=((2.0)*gconst4);\nIkReal x82=(gconst3*gconst5);\nIkReal x83=(gconst2*gconst5);\nIkReal x84=(gconst3*gconst4);\nIkReal x85=(gconst2*gconst4);\nIkReal x86=(gconst4*gconst6);\nIkReal x87=(gconst5*gconst6);\nIkReal x88=(gconst0*gconst2);\nIkReal x89=((1.05513984)*px*py);\nIkReal x90=(gconst6*x65);\nIkReal x91=((4.0)*px*py);\nIkReal x92=((4.0)*x67);\nIkReal x93=(gconst2*x65);\nIkReal x94=(py*x66);\nIkReal x95=((2.0)*x65);\nIkReal x96=((1.0)*x65);\nIkReal x97=((0.824328)*x66);\nIkReal x98=((0.412164)*x66);\nIkReal x99=(x65*x77);\nIkReal x100=(x65*x87);\nIkReal x101=(x65*x83);\nIkReal x102=(x65*x84);\nIkReal x103=(x65*x80);\nIkReal x104=(x65*x79);\nIkReal x105=((0.0834355125792)*x94);\nIkReal x106=(x65*x71);\nIkReal x107=(x65*x70);\nIkReal x108=(x66*x83);\nIkReal x109=(x65*x66);\nIkReal x110=(x69*x96);\nIkReal x111=(x68*x90);\nIkReal x112=(x87*x98);\nIkReal x113=(x85*x91);\nIkReal x114=(x74*x91);\nIkReal x115=(x82*x91);\nIkReal x116=(x75*x91);\nIkReal x117=(x84*x91);\nIkReal x118=(x80*x91);\nIkReal x119=(x83*x91);\nIkReal x120=(x79*x91);\nIkReal x121=(x83*x98);\nIkReal x122=((0.06594624)*x109);\nIkReal x123=(x74*x96);\nIkReal x124=(x68*x93);\nIkReal x125=(x73*x90);\nIkReal x126=(x79*x98);\nIkReal x127=(x82*x96);\nIkReal x128=((0.3297312)*pp*x94);\nIkReal x129=((0.06594624)*px*x94);\nIkReal x130=(x73*x93);\nIkReal x131=(x71*x98);\nIkReal x132=(x76*x96);\nIkReal x133=(x106+x107);\nIkReal x134=(x100+x99);\nIkReal x135=(x131+x130+x132);\nIkReal x136=(x112+x111+x110);\nIkReal x137=(x104+x101+x102+x103);\nIkReal x138=(x120+x117+x119+x118);\nIkReal x139=(x113+x116+x115+x114);\nIkReal x140=(x126+x127+x124+x125+x122+x123+x121);\nop[0]=(x134+(((-1.0)*x136)));\nop[1]=((((-1.0)*x105))+x128+x129+(((-1.0)*x89)));\nop[2]=((((-1.0)*x140))+((x87*x92))+((x81*x90))+(((-1.0)*x72*x90))+(((-1.0)*x77*x95))+x137+((x69*x95))+(((-1.0)*x87*x97))+(((-1.0)*x86*x92))+(((-1.0)*x69*x92))+((x77*x92)));\nop[3]=((((-0.3297312)*gconst5*x94))+(((-1.0)*x77*x91))+((x86*x91))+x138+((x69*x91))+(((-1.0)*x87*x91))+(((-1.0)*x139))+(((-0.1648656)*gconst2*x94))+(((-0.3297312)*gconst6*x94))+(((-0.1648656)*gconst1*x94)));\nop[4]=((((-1.0)*x82*x92))+((x79*x92))+((x81*x93))+(((-0.13189248)*x109))+(((-1.0)*x72*x93))+((gconst3*x65*x72))+(((-1.0)*x83*x97))+(((-1.0)*gconst7*x65*x78))+x134+x133+((x74*x95))+(((-1.0)*x136))+(((-1.0)*x135))+(((-1.0)*x74*x92))+(((-1.0)*x79*x97))+(((-1.0)*x79*x95))+((x75*x95))+(((-1.0)*x75*x92))+((x83*x92))+((x80*x92))+(((-1.0)*gconst3*x65*x81))+((x84*x92))+(((-1.0)*x85*x92)));\nop[5]=(((x71*x91))+(((-0.1648656)*gconst5*x94))+((x70*x91))+x139+(((-1.0)*x138))+(((-1.0)*x76*x91))+(((-0.1648656)*gconst6*x94))+(((-0.3297312)*gconst1*x94))+(((-1.0)*x88*x91))+(((-0.3297312)*gconst2*x94)));\nop[6]=((((-1.0)*x140))+((x71*x92))+(((-1.0)*x71*x97))+(((-1.0)*x71*x95))+((x78*x93))+(((-1.0)*x70*x95))+((x70*x92))+x137+((x76*x95))+(((-1.0)*x76*x92))+(((-1.0)*x88*x92)));\nop[7]=((((-1.0)*x105))+(((-1.0)*x129))+x128+x89);\nop[8]=(x133+(((-1.0)*x135)));\npolyroots8(op,zeror,numroots);\nIkReal j27array[8], cj27array[8], sj27array[8], tempj27array[1];\nint numsolutions = 0;\nfor(int ij27 = 0; ij27 < numroots; ++ij27)\n{\nIkReal htj27 = zeror[ij27];\ntempj27array[0]=((2.0)*(atan(htj27)));\nfor(int kj27 = 0; kj27 < 1; ++kj27)\n{\nj27array[numsolutions] = tempj27array[kj27];\nif( j27array[numsolutions] > IKPI )\n{\n    j27array[numsolutions]-=IK2PI;\n}\nelse if( j27array[numsolutions] < -IKPI )\n{\n    j27array[numsolutions]+=IK2PI;\n}\nsj27array[numsolutions] = IKsin(j27array[numsolutions]);\ncj27array[numsolutions] = IKcos(j27array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j27valid[8]={true,true,true,true,true,true,true,true};\n_nj27 = 8;\nfor(int ij27 = 0; ij27 < numsolutions; ++ij27)\n    {\nif( !j27valid[ij27] )\n{\n    continue;\n}\n    j27 = j27array[ij27]; cj27 = cj27array[ij27]; sj27 = sj27array[ij27];\nhtj27 = IKtan(j27/2);\n\n_ij27[0] = ij27; _ij27[1] = -1;\nfor(int iij27 = ij27+1; iij27 < numsolutions; ++iij27)\n{\nif( j27valid[iij27] && IKabs(cj27array[ij27]-cj27array[iij27]) < IKFAST_SOLUTION_THRESH && IKabs(sj27array[ij27]-sj27array[iij27]) < IKFAST_SOLUTION_THRESH )\n{\n    j27valid[iij27]=false; _ij27[1] = iij27; break; \n}\n}\n{\nIkReal j28eval[2];\nIkReal x141=cj27*cj27;\nIkReal x142=py*py;\nIkReal x143=px*px;\nIkReal x144=pz*pz;\nIkReal x145=((100.0)*sj29);\nIkReal x146=(py*sj27);\nIkReal x147=((4.0)*sj29);\nIkReal x148=(cj27*px*sj29);\nIkReal x149=(x141*x143);\nIkReal x150=(x142*x147);\nj28eval[0]=((((-1.0)*x142*x145))+(((20.0)*x148))+(((-1.0)*x144*x145))+(((-1.0)*sj29))+((x141*x142*x145))+(((-1.0)*x145*x149))+(((-200.0)*x146*x148))+(((20.0)*sj29*x146)));\nj28eval[1]=IKsign(((((-1.0)*x150))+(((0.8)*sj29*x146))+(((-8.0)*x146*x148))+(((-1.0)*x144*x147))+((x141*x150))+(((-1.0)*x147*x149))+(((-0.04)*sj29))+(((0.8)*x148))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[1];\nj30eval[0]=sj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x151=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));\nevalcond[1]=x151;\nevalcond[2]=x151;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[2], cj30array[2], sj30array[2];\nbool j30valid[2]={false};\n_nj30 = 2;\ncj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));\nif( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j30valid[0] = j30valid[1] = true;\n    j30array[0] = IKacos(cj30array[0]);\n    sj30array[0] = IKsin(j30array[0]);\n    cj30array[1] = cj30array[0];\n    j30array[1] = -j30array[0];\n    sj30array[1] = -sj30array[0];\n}\nelse if( isnan(cj30array[0]) )\n{\n    // probably any value will work\n    j30valid[0] = true;\n    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;\n}\nfor(int ij30 = 0; ij30 < 2; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 2; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n\n{\nIkReal j28eval[3];\nsj29=0;\ncj29=1.0;\nj29=0;\nIkReal x152=((321000.0)*cj30);\nIkReal x153=(py*sj27);\nIkReal x154=((321000.0)*sj30);\nIkReal x155=(cj27*px);\nj28eval[0]=((1.02430295950156)+cj30);\nj28eval[1]=((IKabs(((-40000.0)+(((-1.0)*pz*x154))+(((400000.0)*x153))+(((400000.0)*x155))+(((-32100.0)*cj30))+((x152*x153))+((x152*x155)))))+(IKabs(((((-1.0)*x154*x155))+(((-1.0)*x153*x154))+(((-1.0)*pz*x152))+(((32100.0)*sj30))+(((-400000.0)*pz))))));\nj28eval[2]=IKsign(((263041.0)+(((256800.0)*cj30))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[3];\nsj29=0;\ncj29=1.0;\nj29=0;\nIkReal x156=(pz*sj30);\nIkReal x157=(cj27*px);\nIkReal x158=(py*sj27);\nIkReal x159=((10.0)*cj30);\nIkReal x160=((321.0)*cj30);\nIkReal x161=((1000.0)*pz);\nj28eval[0]=((1.24610591900312)+(((-1.0)*x157*x159))+(((-1.0)*x158*x159))+cj30+(((-10.0)*x156))+(((-12.4610591900312)*x158))+(((-12.4610591900312)*x157)));\nj28eval[1]=((IKabs(((((-100.0)*pz))+((x157*x161))+(((128.4)*sj30))+((x158*x161))+(((103.041)*cj30*sj30)))))+(IKabs(((-160.0)+((pz*x161))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))))));\nj28eval[2]=IKsign(((40.0)+(((-1.0)*x157*x160))+(((-1.0)*x158*x160))+(((-400.0)*x157))+(((-400.0)*x158))+(((32.1)*cj30))+(((-321.0)*x156))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[3];\nsj29=0;\ncj29=1.0;\nj29=0;\nIkReal x162=cj27*cj27;\nIkReal x163=py*py;\nIkReal x164=pz*pz;\nIkReal x165=px*px;\nIkReal x166=(cj27*px);\nIkReal x167=((321.0)*sj30);\nIkReal x168=(py*sj27);\nIkReal x169=((321.0)*cj30);\nIkReal x170=((321.0)*x168);\nIkReal x171=((200.0)*x168);\nIkReal x172=(x162*x163);\nIkReal x173=(x162*x165);\nj28eval[0]=((-1.0)+(((-100.0)*x163))+(((-100.0)*x164))+(((-100.0)*x173))+(((20.0)*x168))+(((20.0)*x166))+(((-1.0)*x166*x171))+(((100.0)*x172)));\nj28eval[1]=((IKabs(((40.0)+(((-1.0)*x166*x169))+((pz*x167))+(((-400.0)*x166))+(((-400.0)*x168))+(((-1.0)*x168*x169))+(((32.1)*cj30)))))+(IKabs((((pz*x169))+(((400.0)*pz))+((x167*x168))+((x166*x167))+(((-32.1)*sj30))))));\nj28eval[2]=IKsign(((-10.0)+(((-2000.0)*x166*x168))+x171+(((-1000.0)*x163))+(((-1000.0)*x164))+(((-1000.0)*x173))+(((200.0)*x166))+(((1000.0)*x172))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j28]\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x174=py*py;\nIkReal x175=cj27*cj27;\nIkReal x176=(cj27*px);\nIkReal x177=(py*sj27);\nIkReal x178=((321.0)*cj30);\nIkReal x179=((321.0)*sj30);\nIkReal x180=((1000.0)*x175);\nCheckValue<IkReal> x181=IKPowWithIntegerCheck(IKsign(((-10.0)+(((-1000.0)*(pz*pz)))+((x174*x180))+(((-2000.0)*x176*x177))+(((-1000.0)*x174))+(((-1.0)*x180*(px*px)))+(((200.0)*x177))+(((200.0)*x176)))),-1);\nif(!x181.valid){\ncontinue;\n}\nCheckValue<IkReal> x182 = IKatan2WithCheck(IkReal((((pz*x178))+((x176*x179))+(((400.0)*pz))+(((-32.1)*sj30))+((x177*x179)))),((40.0)+((pz*x179))+(((-400.0)*x176))+(((-400.0)*x177))+(((-1.0)*x177*x178))+(((-1.0)*x176*x178))+(((32.1)*cj30))),IKFAST_ATAN2_MAGTHRESH);\nif(!x182.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x181.value)))+(x182.value));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x183=IKsin(j28);\nIkReal x184=IKcos(j28);\nIkReal x185=((0.321)*cj30);\nIkReal x186=((0.321)*sj30);\nIkReal x187=(cj27*px);\nIkReal x188=(py*sj27);\nIkReal x189=((1.0)*x188);\nIkReal x190=(pz*x183);\nIkReal x191=((0.8)*x184);\nevalcond[0]=((((0.4)*x183))+((x184*x186))+pz+((x183*x185)));\nevalcond[1]=(((pz*x184))+x186+(((-0.1)*x183))+((x183*x187))+((x183*x188)));\nevalcond[2]=((0.1)+(((0.4)*x184))+(((-1.0)*x189))+(((-1.0)*x187))+((x184*x185))+(((-1.0)*x183*x186)));\nevalcond[3]=((0.4)+(((0.1)*x184))+(((-1.0)*x184*x187))+x190+x185+(((-1.0)*x184*x189)));\nevalcond[4]=((-0.066959)+(((0.2)*x187))+(((0.2)*x188))+((x187*x191))+((x188*x191))+(((-1.0)*pp))+(((-0.08)*x184))+(((-0.8)*x190)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x603=((321.0)*cj30);\nIkReal x604=(py*sj27);\nIkReal x605=(cj27*px);\nIkReal x606=((1000.0)*pz);\nCheckValue<IkReal> x607=IKPowWithIntegerCheck(IKsign(((40.0)+(((-1.0)*x603*x604))+(((-1.0)*x603*x605))+(((-321.0)*pz*sj30))+(((-400.0)*x604))+(((-400.0)*x605))+(((32.1)*cj30)))),-1);\nif(!x607.valid){\ncontinue;\n}\nCheckValue<IkReal> x608 = IKatan2WithCheck(IkReal((((x605*x606))+(((-100.0)*pz))+((x604*x606))+(((128.4)*sj30))+(((103.041)*cj30*sj30)))),((-160.0)+((pz*x606))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))),IKFAST_ATAN2_MAGTHRESH);\nif(!x608.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x607.value)))+(x608.value));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x609=IKsin(j28);\nIkReal x610=IKcos(j28);\nIkReal x611=((0.321)*cj30);\nIkReal x612=((0.321)*sj30);\nIkReal x613=(cj27*px);\nIkReal x614=(py*sj27);\nIkReal x615=((1.0)*x614);\nIkReal x616=(pz*x609);\nIkReal x617=((0.8)*x610);\nevalcond[0]=((((0.4)*x609))+pz+((x609*x611))+((x610*x612)));\nevalcond[1]=(((pz*x610))+x612+(((-0.1)*x609))+((x609*x613))+((x609*x614)));\nevalcond[2]=((0.1)+(((-1.0)*x609*x612))+(((0.4)*x610))+(((-1.0)*x613))+(((-1.0)*x615))+((x610*x611)));\nevalcond[3]=((0.4)+(((-1.0)*x610*x615))+(((0.1)*x610))+(((-1.0)*x610*x613))+x616+x611);\nevalcond[4]=((-0.066959)+(((-0.08)*x610))+(((-0.8)*x616))+(((-1.0)*pp))+((x613*x617))+((x614*x617))+(((0.2)*x613))+(((0.2)*x614)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x618=((321000.0)*cj30);\nIkReal x619=(py*sj27);\nIkReal x620=(cj27*px);\nIkReal x621=((321000.0)*sj30);\nCheckValue<IkReal> x622=IKPowWithIntegerCheck(IKsign(((263041.0)+(((256800.0)*cj30)))),-1);\nif(!x622.valid){\ncontinue;\n}\nCheckValue<IkReal> x623 = IKatan2WithCheck(IkReal(((((32100.0)*sj30))+(((-1.0)*x620*x621))+(((-400000.0)*pz))+(((-1.0)*pz*x618))+(((-1.0)*x619*x621)))),((-40000.0)+(((-1.0)*pz*x621))+(((-32100.0)*cj30))+((x618*x620))+(((400000.0)*x619))+(((400000.0)*x620))+((x618*x619))),IKFAST_ATAN2_MAGTHRESH);\nif(!x623.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x622.value)))+(x623.value));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x624=IKsin(j28);\nIkReal x625=IKcos(j28);\nIkReal x626=((0.321)*cj30);\nIkReal x627=((0.321)*sj30);\nIkReal x628=(cj27*px);\nIkReal x629=(py*sj27);\nIkReal x630=((1.0)*x629);\nIkReal x631=(pz*x624);\nIkReal x632=((0.8)*x625);\nevalcond[0]=(((x625*x627))+pz+((x624*x626))+(((0.4)*x624)));\nevalcond[1]=(((pz*x625))+(((-0.1)*x624))+x627+((x624*x628))+((x624*x629)));\nevalcond[2]=((0.1)+((x625*x626))+(((-1.0)*x630))+(((-1.0)*x624*x627))+(((-1.0)*x628))+(((0.4)*x625)));\nevalcond[3]=((0.4)+x626+x631+(((-1.0)*x625*x630))+(((0.1)*x625))+(((-1.0)*x625*x628)));\nevalcond[4]=((-0.066959)+(((0.2)*x629))+(((0.2)*x628))+((x628*x632))+(((-0.08)*x625))+((x629*x632))+(((-1.0)*pp))+(((-0.8)*x631)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x633=(px*sj27);\nIkReal x634=(cj27*py);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));\nevalcond[1]=(x633+(((-1.0)*x634)));\nevalcond[2]=(x634+(((-1.0)*x633)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[2], cj30array[2], sj30array[2];\nbool j30valid[2]={false};\n_nj30 = 2;\ncj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));\nif( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j30valid[0] = j30valid[1] = true;\n    j30array[0] = IKacos(cj30array[0]);\n    sj30array[0] = IKsin(j30array[0]);\n    cj30array[1] = cj30array[0];\n    j30array[1] = -j30array[0];\n    sj30array[1] = -sj30array[0];\n}\nelse if( isnan(cj30array[0]) )\n{\n    // probably any value will work\n    j30valid[0] = true;\n    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;\n}\nfor(int ij30 = 0; ij30 < 2; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 2; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n\n{\nIkReal j28eval[3];\nsj29=0;\ncj29=-1.0;\nj29=3.14159265358979;\nIkReal x635=((321000.0)*cj30);\nIkReal x636=(py*sj27);\nIkReal x637=((321000.0)*sj30);\nIkReal x638=(cj27*px);\nj28eval[0]=((-1.02430295950156)+(((-1.0)*cj30)));\nj28eval[1]=IKsign(((-263041.0)+(((-256800.0)*cj30))));\nj28eval[2]=((IKabs(((40000.0)+(((-1.0)*pz*x637))+(((-400000.0)*x638))+(((-400000.0)*x636))+(((-1.0)*x635*x636))+(((-1.0)*x635*x638))+(((32100.0)*cj30)))))+(IKabs((((pz*x635))+(((-1.0)*x637*x638))+(((32100.0)*sj30))+(((400000.0)*pz))+(((-1.0)*x636*x637))))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[3];\nsj29=0;\ncj29=-1.0;\nj29=3.14159265358979;\nIkReal x639=(pz*sj30);\nIkReal x640=(cj27*px);\nIkReal x641=(py*sj27);\nIkReal x642=((10.0)*cj30);\nIkReal x643=((1000.0)*pz);\nIkReal x644=((321.0)*cj30);\nj28eval[0]=((-1.24610591900312)+(((12.4610591900312)*x640))+(((12.4610591900312)*x641))+((x640*x642))+(((-1.0)*cj30))+((x641*x642))+(((-10.0)*x639)));\nj28eval[1]=((IKabs(((((100.0)*pz))+(((-1.0)*x640*x643))+(((-1.0)*x641*x643))+(((128.4)*sj30))+(((103.041)*cj30*sj30)))))+(IKabs(((160.0)+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))+(((-1.0)*pz*x643))))));\nj28eval[2]=IKsign(((-40.0)+(((400.0)*x640))+(((400.0)*x641))+((x640*x644))+((x641*x644))+(((-321.0)*x639))+(((-32.1)*cj30))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[3];\nsj29=0;\ncj29=-1.0;\nj29=3.14159265358979;\nIkReal x645=cj27*cj27;\nIkReal x646=py*py;\nIkReal x647=pz*pz;\nIkReal x648=px*px;\nIkReal x649=(cj27*px);\nIkReal x650=((321.0)*sj30);\nIkReal x651=(py*sj27);\nIkReal x652=((321.0)*cj30);\nIkReal x653=((321.0)*x651);\nIkReal x654=((200.0)*x651);\nIkReal x655=(x645*x646);\nIkReal x656=(x645*x648);\nj28eval[0]=((-1.0)+(((100.0)*x655))+(((20.0)*x651))+(((20.0)*x649))+(((-100.0)*x656))+(((-100.0)*x646))+(((-100.0)*x647))+(((-1.0)*x649*x654)));\nj28eval[1]=((IKabs((((pz*x652))+(((400.0)*pz))+(((32.1)*sj30))+(((-1.0)*x650*x651))+(((-1.0)*x649*x650)))))+(IKabs(((40.0)+(((-1.0)*x651*x652))+(((-400.0)*x649))+(((-1.0)*pz*x650))+(((-1.0)*x649*x652))+(((-400.0)*x651))+(((32.1)*cj30))))));\nj28eval[2]=IKsign(((-10.0)+(((-2000.0)*x649*x651))+(((-1000.0)*x646))+(((-1000.0)*x647))+(((-1000.0)*x656))+x654+(((200.0)*x649))+(((1000.0)*x655))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j28]\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x657=py*py;\nIkReal x658=cj27*cj27;\nIkReal x659=(cj27*px);\nIkReal x660=(py*sj27);\nIkReal x661=((321.0)*cj30);\nIkReal x662=((321.0)*sj30);\nIkReal x663=((1000.0)*x658);\nCheckValue<IkReal> x664 = IKatan2WithCheck(IkReal(((((-1.0)*x659*x662))+(((-1.0)*x660*x662))+(((400.0)*pz))+(((32.1)*sj30))+((pz*x661)))),((40.0)+(((-1.0)*x659*x661))+(((-1.0)*x660*x661))+(((-1.0)*pz*x662))+(((-400.0)*x659))+(((32.1)*cj30))+(((-400.0)*x660))),IKFAST_ATAN2_MAGTHRESH);\nif(!x664.valid){\ncontinue;\n}\nCheckValue<IkReal> x665=IKPowWithIntegerCheck(IKsign(((-10.0)+(((200.0)*x660))+(((-1000.0)*(pz*pz)))+(((-1.0)*x663*(px*px)))+((x657*x663))+(((-1000.0)*x657))+(((-2000.0)*x659*x660))+(((200.0)*x659)))),-1);\nif(!x665.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(x664.value)+(((1.5707963267949)*(x665.value))));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x666=IKsin(j28);\nIkReal x667=IKcos(j28);\nIkReal x668=((0.321)*cj30);\nIkReal x669=((0.321)*sj30);\nIkReal x670=(py*sj27);\nIkReal x671=(cj27*px);\nIkReal x672=((1.0)*x670);\nIkReal x673=(pz*x666);\nIkReal x674=((1.0)*x667);\nIkReal x675=((0.8)*x667);\nevalcond[0]=(((x666*x668))+(((0.4)*x666))+pz+(((-1.0)*x667*x669)));\nevalcond[1]=((0.1)+((x666*x669))+((x667*x668))+(((0.4)*x667))+(((-1.0)*x671))+(((-1.0)*x672)));\nevalcond[2]=((0.4)+(((0.1)*x667))+(((-1.0)*x667*x672))+x668+x673+(((-1.0)*x671*x674)));\nevalcond[3]=((((0.1)*x666))+(((-1.0)*pz*x674))+(((-1.0)*x666*x672))+(((-1.0)*x666*x671))+x669);\nevalcond[4]=((-0.066959)+(((-0.08)*x667))+((x671*x675))+(((0.2)*x671))+(((0.2)*x670))+((x670*x675))+(((-1.0)*pp))+(((-0.8)*x673)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x676=((321.0)*cj30);\nIkReal x677=(py*sj27);\nIkReal x678=(cj27*px);\nIkReal x679=((1000.0)*pz);\nCheckValue<IkReal> x680 = IKatan2WithCheck(IkReal(((((-1.0)*x678*x679))+(((100.0)*pz))+(((128.4)*sj30))+(((-1.0)*x677*x679))+(((103.041)*cj30*sj30)))),((160.0)+(((-1.0)*pz*x679))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))),IKFAST_ATAN2_MAGTHRESH);\nif(!x680.valid){\ncontinue;\n}\nCheckValue<IkReal> x681=IKPowWithIntegerCheck(IKsign(((-40.0)+(((-321.0)*pz*sj30))+((x676*x678))+((x676*x677))+(((400.0)*x678))+(((400.0)*x677))+(((-32.1)*cj30)))),-1);\nif(!x681.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(x680.value)+(((1.5707963267949)*(x681.value))));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x682=IKsin(j28);\nIkReal x683=IKcos(j28);\nIkReal x684=((0.321)*cj30);\nIkReal x685=((0.321)*sj30);\nIkReal x686=(py*sj27);\nIkReal x687=(cj27*px);\nIkReal x688=((1.0)*x686);\nIkReal x689=(pz*x682);\nIkReal x690=((1.0)*x683);\nIkReal x691=((0.8)*x683);\nevalcond[0]=(((x682*x684))+pz+(((0.4)*x682))+(((-1.0)*x683*x685)));\nevalcond[1]=((0.1)+(((-1.0)*x688))+((x682*x685))+((x683*x684))+(((0.4)*x683))+(((-1.0)*x687)));\nevalcond[2]=((0.4)+(((-1.0)*x687*x690))+x689+x684+(((-1.0)*x683*x688))+(((0.1)*x683)));\nevalcond[3]=((((-1.0)*pz*x690))+x685+(((-1.0)*x682*x688))+(((0.1)*x682))+(((-1.0)*x682*x687)));\nevalcond[4]=((-0.066959)+((x687*x691))+((x686*x691))+(((0.2)*x686))+(((0.2)*x687))+(((-0.08)*x683))+(((-1.0)*pp))+(((-0.8)*x689)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x692=(cj27*px);\nIkReal x693=((321000.0)*cj30);\nIkReal x694=((321000.0)*sj30);\nIkReal x695=((321000.0)*py*sj27);\nCheckValue<IkReal> x696=IKPowWithIntegerCheck(IKsign(((-263041.0)+(((-256800.0)*cj30)))),-1);\nif(!x696.valid){\ncontinue;\n}\nCheckValue<IkReal> x697 = IKatan2WithCheck(IkReal(((((32100.0)*sj30))+((pz*x693))+(((400000.0)*pz))+(((-1.0)*py*sj27*x694))+(((-1.0)*x692*x694)))),((40000.0)+(((-400000.0)*py*sj27))+(((-1.0)*py*sj27*x693))+(((-1.0)*x692*x693))+(((-1.0)*pz*x694))+(((32100.0)*cj30))+(((-400000.0)*x692))),IKFAST_ATAN2_MAGTHRESH);\nif(!x697.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x696.value)))+(x697.value));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x698=IKsin(j28);\nIkReal x699=IKcos(j28);\nIkReal x700=((0.321)*cj30);\nIkReal x701=((0.321)*sj30);\nIkReal x702=(py*sj27);\nIkReal x703=(cj27*px);\nIkReal x704=((1.0)*x702);\nIkReal x705=(pz*x698);\nIkReal x706=((1.0)*x699);\nIkReal x707=((0.8)*x699);\nevalcond[0]=((((0.4)*x698))+pz+(((-1.0)*x699*x701))+((x698*x700)));\nevalcond[1]=((0.1)+(((-1.0)*x703))+(((0.4)*x699))+(((-1.0)*x704))+((x698*x701))+((x699*x700)));\nevalcond[2]=((0.4)+(((-1.0)*x703*x706))+(((0.1)*x699))+(((-1.0)*x699*x704))+x700+x705);\nevalcond[3]=((((-1.0)*pz*x706))+(((0.1)*x698))+x701+(((-1.0)*x698*x704))+(((-1.0)*x698*x703)));\nevalcond[4]=((-0.066959)+((x702*x707))+((x703*x707))+(((-0.8)*x705))+(((-1.0)*pp))+(((-0.08)*x699))+(((0.2)*x702))+(((0.2)*x703)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j28, j30]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x708=IKPowWithIntegerCheck(sj29,-1);\nif(!x708.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x708.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x708.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x708.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[2];\nevalcond[0]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*sj29*(IKsin(j30)))));\nevalcond[1]=((0.253041)+(((0.2568)*(IKcos(j30))))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j28eval[3];\nIkReal x709=(py*sj27);\nIkReal x710=(cj29*sj30);\nIkReal x711=(cj27*px);\nIkReal x712=((10.0)*cj30);\nIkReal x713=((1000.0)*pz);\nIkReal x714=((321.0)*cj30);\nj28eval[0]=((-1.24610591900312)+(((12.4610591900312)*x709))+(((12.4610591900312)*x711))+((x711*x712))+((x709*x712))+(((-1.0)*cj30))+(((10.0)*pz*x710)));\nj28eval[1]=IKsign(((-40.0)+(((400.0)*x709))+(((400.0)*x711))+((x711*x714))+((x709*x714))+(((321.0)*pz*x710))+(((-32.1)*cj30))));\nj28eval[2]=((IKabs(((160.0)+(((-1.0)*pz*x713))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30)))))+(IKabs(((((-128.4)*x710))+(((-1.0)*x711*x713))+(((100.0)*pz))+(((-1.0)*x709*x713))+(((-103.041)*cj30*x710))))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[3];\nIkReal x715=cj29*cj29;\nIkReal x716=cj30*cj30;\nIkReal x717=(cj27*px);\nIkReal x718=((321000.0)*cj30);\nIkReal x719=(py*sj27);\nIkReal x720=((321000.0)*cj29*sj30);\nIkReal x721=((103041.0)*x716);\nj28eval[0]=((1.5527799613746)+(((-1.0)*x715*x716))+x715+x716+(((2.49221183800623)*cj30)));\nj28eval[1]=IKsign(((160000.0)+(((256800.0)*cj30))+x721+(((-1.0)*x715*x721))+(((103041.0)*x715))));\nj28eval[2]=((IKabs(((((-1.0)*pz*x718))+(((32100.0)*cj29*sj30))+(((-1.0)*x717*x720))+(((-400000.0)*pz))+(((-1.0)*x719*x720)))))+(IKabs(((-40000.0)+(((-32100.0)*cj30))+(((400000.0)*x717))+(((400000.0)*x719))+((x717*x718))+((x718*x719))+(((-1.0)*pz*x720))))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[2];\nIkReal x722=(cj29*sj30);\nIkReal x723=(py*sj27);\nIkReal x724=(cj30*pz);\nIkReal x725=(cj27*px);\nj28eval[0]=((((-10.0)*x722*x725))+(((-10.0)*x722*x723))+(((10.0)*x724))+x722+(((12.4610591900312)*pz)));\nj28eval[1]=IKsign(((((321.0)*x724))+(((400.0)*pz))+(((-321.0)*x722*x723))+(((-321.0)*x722*x725))+(((32.1)*x722))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x726=((((0.321)*sj30))+(((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j29), 6.28318530717959))))));\nevalcond[1]=x726;\nevalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nevalcond[3]=x726;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28eval[1];\nIkReal x727=((-1.0)*py);\npz=0;\nj29=1.5707963267949;\nsj29=1.0;\ncj29=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x727);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x727);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x727);\nrxp2_1=(px*r22);\nj28eval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));\nif( IKabs(j28eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[1];\nIkReal x728=((-1.0)*py);\npz=0;\nj29=1.5707963267949;\nsj29=1.0;\ncj29=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x728);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x728);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x728);\nrxp2_1=(px*r22);\nj28eval[0]=((1.24610591900312)+cj30);\nif( IKabs(j28eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x729=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nif((x729) < -0.00001)\ncontinue;\nIkReal x730=IKabs(IKsqrt(x729));\nIkReal x736 = x729;\nif(IKabs(x736)==0){\ncontinue;\n}\nIkReal x731=pow(x736,-0.5);\nCheckValue<IkReal> x737=IKPowWithIntegerCheck(x730,-1);\nif(!x737.valid){\ncontinue;\n}\nIkReal x732=x737.value;\nIkReal x733=((10.0)*px*x731);\nIkReal x734=((10.0)*py*x731);\nif((((1.0)+(((-1.0)*(x732*x732))))) < -0.00001)\ncontinue;\nIkReal x735=IKsqrt(((1.0)+(((-1.0)*(x732*x732)))));\nif( (x732) < -1-IKFAST_SINCOS_THRESH || (x732) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x738 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x738.valid){\ncontinue;\n}\nIkReal gconst24=((((-1.0)*(IKasin(x732))))+(((-1.0)*(x738.value))));\nIkReal gconst25=(((x733*x735))+((x732*x734)));\nIkReal gconst26=((((-1.0)*x734*x735))+((x732*x733)));\nIkReal x739=px*px;\nIkReal x740=py*py;\nIkReal x741=(((gconst25*px))+(((0.321)*sj30))+(((-1.0)*gconst26*py)));\nCheckValue<IkReal> x742 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x742.valid){\ncontinue;\n}\nif((((((100.0)*x739))+(((100.0)*x740)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x743=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x739))+(((100.0)*x740))))),-1);\nif(!x743.valid){\ncontinue;\n}\nif( (x743.value) < -1-IKFAST_SINCOS_THRESH || (x743.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j27+(x742.value)+(IKasin(x743.value)))))), 6.28318530717959)));\nevalcond[1]=x741;\nevalcond[2]=((0.253041)+(((0.2568)*cj30))+(((0.2)*gconst25*py))+(((0.2)*gconst26*px))+(((-1.0)*x739))+(((-1.0)*x740)));\nevalcond[3]=x741;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x745=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst25*py))+(((-1.0)*gconst26*px))),-1);\nif(!x745.valid){\ncontinue;\n}\nIkReal x744=x745.value;\ncj28array[0]=((((-0.4)*x744))+(((-0.321)*cj30*x744)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x746=IKsin(j28);\nIkReal x747=IKcos(j28);\nIkReal x748=(gconst25*py);\nIkReal x749=(gconst26*px);\nIkReal x750=((0.321)*cj30);\nIkReal x751=((1.0)*x746);\nIkReal x752=((0.8)*x747);\nevalcond[0]=(((x746*x750))+(((0.4)*x746)));\nevalcond[1]=((((0.1)*x746))+(((-1.0)*x749*x751))+(((-1.0)*x748*x751)));\nevalcond[2]=((0.1)+((x747*x750))+(((-1.0)*x748))+(((-1.0)*x749))+(((0.4)*x747)));\nevalcond[3]=((-0.32)+(((-0.08)*x747))+(((-0.2568)*cj30))+((x749*x752))+((x748*x752)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x753=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nIkReal x760 = x753;\nif(IKabs(x760)==0){\ncontinue;\n}\nIkReal x754=pow(x760,-0.5);\nif((x753) < -0.00001)\ncontinue;\nIkReal x755=IKabs(IKsqrt(x753));\nCheckValue<IkReal> x761=IKPowWithIntegerCheck(x755,-1);\nif(!x761.valid){\ncontinue;\n}\nIkReal x756=x761.value;\nIkReal x757=((10.0)*px*x754);\nIkReal x758=((10.0)*py*x754);\nif((((1.0)+(((-1.0)*(x756*x756))))) < -0.00001)\ncontinue;\nIkReal x759=IKsqrt(((1.0)+(((-1.0)*(x756*x756)))));\nif( (x756) < -1-IKFAST_SINCOS_THRESH || (x756) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x762 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x762.valid){\ncontinue;\n}\nIkReal gconst27=((3.14159265358979)+(IKasin(x756))+(((-1.0)*(x762.value))));\nIkReal gconst28=(((x756*x758))+(((-1.0)*x757*x759)));\nIkReal gconst29=(((x756*x757))+((x758*x759)));\nIkReal x763=px*px;\nIkReal x764=py*py;\nIkReal x765=((((0.321)*sj30))+(((-1.0)*gconst29*py))+((gconst28*px)));\nif((((((100.0)*x763))+(((100.0)*x764)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x766=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x763))+(((100.0)*x764))))),-1);\nif(!x766.valid){\ncontinue;\n}\nif( (x766.value) < -1-IKFAST_SINCOS_THRESH || (x766.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x767 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x767.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(((-1.0)*(IKasin(x766.value))))+j27+(x767.value))))), 6.28318530717959)));\nevalcond[1]=x765;\nevalcond[2]=((0.253041)+(((0.2568)*cj30))+(((0.2)*gconst29*px))+(((-1.0)*x763))+(((-1.0)*x764))+(((0.2)*gconst28*py)));\nevalcond[3]=x765;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x769=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst29*px))+(((-1.0)*gconst28*py))),-1);\nif(!x769.valid){\ncontinue;\n}\nIkReal x768=x769.value;\ncj28array[0]=((((-0.321)*cj30*x768))+(((-0.4)*x768)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x770=IKsin(j28);\nIkReal x771=IKcos(j28);\nIkReal x772=(gconst28*py);\nIkReal x773=((0.321)*cj30);\nIkReal x774=((0.8)*x771);\nIkReal x775=((1.0)*gconst29*px);\nevalcond[0]=(((x770*x773))+(((0.4)*x770)));\nevalcond[1]=((((0.1)*x770))+(((-1.0)*x770*x772))+(((-1.0)*x770*x775)));\nevalcond[2]=((0.1)+((x771*x773))+(((0.4)*x771))+(((-1.0)*x775))+(((-1.0)*x772)));\nevalcond[3]=((-0.32)+((x772*x774))+((gconst29*px*x774))+(((-0.08)*x771))+(((-0.2568)*cj30)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j28]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x777=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj30))),-1);\nif(!x777.valid){\ncontinue;\n}\nIkReal x776=x777.value;\ncj28array[0]=(((cj27*px*x776))+(((-0.1)*x776))+((py*sj27*x776)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x778=IKsin(j28);\nIkReal x779=IKcos(j28);\nIkReal x780=((0.321)*cj30);\nIkReal x781=(cj27*px);\nIkReal x782=((1.0)*x778);\nIkReal x783=(py*sj27*x779);\nevalcond[0]=(((x778*x780))+(((0.4)*x778)));\nevalcond[1]=((((0.1)*x778))+(((-1.0)*x781*x782))+(((-1.0)*py*sj27*x782)));\nevalcond[2]=((0.4)+(((0.1)*x779))+x780+(((-1.0)*x783))+(((-1.0)*x779*x781)));\nevalcond[3]=((-0.32)+(((0.8)*x779*x781))+(((-0.08)*x779))+(((-0.2568)*cj30))+(((0.8)*x783)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x785=IKPowWithIntegerCheck(((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))),-1);\nif(!x785.valid){\ncontinue;\n}\nIkReal x784=x785.value;\ncj28array[0]=((((-0.321)*cj30*x784))+(((-0.4)*x784)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x786=IKsin(j28);\nIkReal x787=IKcos(j28);\nIkReal x788=(py*sj27);\nIkReal x789=(cj27*px);\nIkReal x790=((0.321)*cj30);\nIkReal x791=((0.8)*x787);\nIkReal x792=((1.0)*x786);\nevalcond[0]=(((x786*x790))+(((0.4)*x786)));\nevalcond[1]=((((-1.0)*x788*x792))+(((0.1)*x786))+(((-1.0)*x789*x792)));\nevalcond[2]=((0.1)+((x787*x790))+(((-1.0)*x789))+(((-1.0)*x788))+(((0.4)*x787)));\nevalcond[3]=((-0.32)+((x788*x791))+(((-0.08)*x787))+(((-0.2568)*cj30))+((x789*x791)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x793=((0.321)*sj30);\nIkReal x794=(cj27*py);\nIkReal x795=(px*sj27);\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j29), 6.28318530717959))))));\nevalcond[1]=((((-1.0)*x793))+x795+(((-1.0)*x794)));\nevalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nevalcond[3]=(x793+x794+(((-1.0)*x795)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28eval[1];\nIkReal x796=((-1.0)*py);\npz=0;\nj29=-1.5707963267949;\nsj29=-1.0;\ncj29=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x796);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x796);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x796);\nrxp2_1=(px*r22);\nj28eval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));\nif( IKabs(j28eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[1];\nIkReal x797=((-1.0)*py);\npz=0;\nj29=-1.5707963267949;\nsj29=-1.0;\ncj29=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x797);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x797);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x797);\nrxp2_1=(px*r22);\nj28eval[0]=((1.24610591900312)+cj30);\nif( IKabs(j28eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x798=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nif((x798) < -0.00001)\ncontinue;\nIkReal x799=IKabs(IKsqrt(x798));\nIkReal x805 = x798;\nif(IKabs(x805)==0){\ncontinue;\n}\nIkReal x800=pow(x805,-0.5);\nCheckValue<IkReal> x806=IKPowWithIntegerCheck(x799,-1);\nif(!x806.valid){\ncontinue;\n}\nIkReal x801=x806.value;\nIkReal x802=((10.0)*px*x800);\nIkReal x803=((10.0)*py*x800);\nif((((1.0)+(((-1.0)*(x801*x801))))) < -0.00001)\ncontinue;\nIkReal x804=IKsqrt(((1.0)+(((-1.0)*(x801*x801)))));\nif( (x801) < -1-IKFAST_SINCOS_THRESH || (x801) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x807 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x807.valid){\ncontinue;\n}\nIkReal gconst30=((((-1.0)*(IKasin(x801))))+(((-1.0)*(x807.value))));\nIkReal gconst31=(((x801*x803))+((x802*x804)));\nIkReal gconst32=((((-1.0)*x803*x804))+((x801*x802)));\nIkReal x808=px*px;\nIkReal x809=py*py;\nIkReal x810=((0.321)*sj30);\nIkReal x811=(gconst32*py);\nIkReal x812=(gconst31*px);\nif((((((100.0)*x809))+(((100.0)*x808)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x813=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x809))+(((100.0)*x808))))),-1);\nif(!x813.valid){\ncontinue;\n}\nif( (x813.value) < -1-IKFAST_SINCOS_THRESH || (x813.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x814 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x814.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x813.value))+j27+(x814.value))))), 6.28318530717959)));\nevalcond[1]=((((-1.0)*x810))+(((-1.0)*x811))+x812);\nevalcond[2]=((0.253041)+(((-1.0)*x808))+(((-1.0)*x809))+(((0.2568)*cj30))+(((0.2)*gconst32*px))+(((0.2)*gconst31*py)));\nevalcond[3]=((((-1.0)*x812))+x810+x811);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x816=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst32*px))+(((-1.0)*gconst31*py))),-1);\nif(!x816.valid){\ncontinue;\n}\nIkReal x815=x816.value;\ncj28array[0]=((((-0.4)*x815))+(((-0.321)*cj30*x815)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x817=IKsin(j28);\nIkReal x818=IKcos(j28);\nIkReal x819=(gconst31*py);\nIkReal x820=(gconst32*px);\nIkReal x821=((0.321)*cj30);\nIkReal x822=((0.8)*x818);\nevalcond[0]=(((x817*x821))+(((0.4)*x817)));\nevalcond[1]=(((x817*x820))+((x817*x819))+(((-0.1)*x817)));\nevalcond[2]=((0.1)+(((0.4)*x818))+(((-1.0)*x819))+(((-1.0)*x820))+((x818*x821)));\nevalcond[3]=((-0.32)+((x820*x822))+((x819*x822))+(((-0.2568)*cj30))+(((-0.08)*x818)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x823=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nIkReal x830 = x823;\nif(IKabs(x830)==0){\ncontinue;\n}\nIkReal x824=pow(x830,-0.5);\nif((x823) < -0.00001)\ncontinue;\nIkReal x825=IKabs(IKsqrt(x823));\nCheckValue<IkReal> x831=IKPowWithIntegerCheck(x825,-1);\nif(!x831.valid){\ncontinue;\n}\nIkReal x826=x831.value;\nIkReal x827=((10.0)*px*x824);\nIkReal x828=((10.0)*py*x824);\nif((((1.0)+(((-1.0)*(x826*x826))))) < -0.00001)\ncontinue;\nIkReal x829=IKsqrt(((1.0)+(((-1.0)*(x826*x826)))));\nif( (x826) < -1-IKFAST_SINCOS_THRESH || (x826) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x832 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x832.valid){\ncontinue;\n}\nIkReal gconst33=((3.14159265358979)+(IKasin(x826))+(((-1.0)*(x832.value))));\nIkReal gconst34=((((-1.0)*x827*x829))+((x826*x828)));\nIkReal gconst35=(((x828*x829))+((x826*x827)));\nIkReal x833=px*px;\nIkReal x834=py*py;\nIkReal x835=((0.321)*sj30);\nIkReal x836=(gconst35*py);\nIkReal x837=(gconst34*px);\nCheckValue<IkReal> x838 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x838.valid){\ncontinue;\n}\nif((((((100.0)*x833))+(((100.0)*x834)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x839=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x833))+(((100.0)*x834))))),-1);\nif(!x839.valid){\ncontinue;\n}\nif( (x839.value) < -1-IKFAST_SINCOS_THRESH || (x839.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j27+(x838.value)+(((-1.0)*(IKasin(x839.value)))))))), 6.28318530717959)));\nevalcond[1]=((((-1.0)*x835))+(((-1.0)*x836))+x837);\nevalcond[2]=((0.253041)+(((0.2568)*cj30))+(((0.2)*gconst35*px))+(((0.2)*gconst34*py))+(((-1.0)*x833))+(((-1.0)*x834)));\nevalcond[3]=((((-1.0)*x837))+x835+x836);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x841=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst34*py))+(((-1.0)*gconst35*px))),-1);\nif(!x841.valid){\ncontinue;\n}\nIkReal x840=x841.value;\ncj28array[0]=((((-0.4)*x840))+(((-0.321)*cj30*x840)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x842=IKsin(j28);\nIkReal x843=IKcos(j28);\nIkReal x844=(gconst34*py);\nIkReal x845=(gconst35*px);\nIkReal x846=((0.321)*cj30);\nIkReal x847=((0.8)*x843);\nevalcond[0]=((((0.4)*x842))+((x842*x846)));\nevalcond[1]=(((x842*x845))+((x842*x844))+(((-0.1)*x842)));\nevalcond[2]=((0.1)+(((0.4)*x843))+((x843*x846))+(((-1.0)*x845))+(((-1.0)*x844)));\nevalcond[3]=((-0.32)+(((-0.08)*x843))+(((-0.2568)*cj30))+((x845*x847))+((x844*x847)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j28]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x849=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj30))),-1);\nif(!x849.valid){\ncontinue;\n}\nIkReal x848=x849.value;\ncj28array[0]=(((py*sj27*x848))+((cj27*px*x848))+(((-0.1)*x848)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x850=IKsin(j28);\nIkReal x851=IKcos(j28);\nIkReal x852=((0.321)*cj30);\nIkReal x853=(py*sj27*x851);\nIkReal x854=(cj27*px*x851);\nevalcond[0]=(((x850*x852))+(((0.4)*x850)));\nevalcond[1]=((((-0.1)*x850))+((py*sj27*x850))+((cj27*px*x850)));\nevalcond[2]=((0.4)+(((0.1)*x851))+(((-1.0)*x854))+(((-1.0)*x853))+x852);\nevalcond[3]=((-0.32)+(((-0.2568)*cj30))+(((-0.08)*x851))+(((0.8)*x854))+(((0.8)*x853)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x856=IKPowWithIntegerCheck(((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))),-1);\nif(!x856.valid){\ncontinue;\n}\nIkReal x855=x856.value;\ncj28array[0]=((((-0.4)*x855))+(((-0.321)*cj30*x855)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x857=IKsin(j28);\nIkReal x858=IKcos(j28);\nIkReal x859=(py*sj27);\nIkReal x860=(cj27*px);\nIkReal x861=((0.321)*cj30);\nIkReal x862=((0.8)*x858);\nevalcond[0]=((((0.4)*x857))+((x857*x861)));\nevalcond[1]=((((-0.1)*x857))+((x857*x859))+((x857*x860)));\nevalcond[2]=((0.1)+(((-1.0)*x859))+(((-1.0)*x860))+((x858*x861))+(((0.4)*x858)));\nevalcond[3]=((-0.32)+(((-0.2568)*cj30))+((x859*x862))+(((-0.08)*x858))+((x860*x862)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));\nevalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[2]=((0.509841)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\ncj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27))+(((1.3869625520111)*cj27*px)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x863=IKcos(j28);\nIkReal x864=px*px;\nCheckValue<IkReal> x873=IKPowWithIntegerCheck(py,-1);\nif(!x873.valid){\ncontinue;\n}\nIkReal x865=x873.value;\nIkReal x866=IKsin(j28);\nIkReal x867=(py*sj27);\nIkReal x868=(x864*x865);\nIkReal x869=((1.0)*x863);\nIkReal x870=(sj29*x866);\nIkReal x871=(cj29*x866);\nIkReal x872=((0.8)*sj27*x863);\nevalcond[0]=((0.721)*x866);\nevalcond[1]=((0.721)+(((-1.0)*cj27*px*x869))+(((0.1)*x863))+(((-1.0)*x867*x869)));\nevalcond[2]=((-0.5768)+(((0.8)*x863*x867))+((x868*x872))+(((-0.08)*x863)));\nevalcond[3]=(((sj27*x868*x871))+((x867*x871))+(((-0.1)*x871)));\nevalcond[4]=((((0.1)*x870))+(((-1.0)*x867*x870))+(((-1.0)*sj27*x868*x870)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));\nevalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[2]=((-0.003759)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\ncj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27))+(((12.6582278481013)*cj27*px)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x874=IKcos(j28);\nIkReal x875=px*px;\nCheckValue<IkReal> x884=IKPowWithIntegerCheck(py,-1);\nif(!x884.valid){\ncontinue;\n}\nIkReal x876=x884.value;\nIkReal x877=IKsin(j28);\nIkReal x878=(py*sj27);\nIkReal x879=(x875*x876);\nIkReal x880=((1.0)*x874);\nIkReal x881=(sj29*x877);\nIkReal x882=(cj29*x877);\nIkReal x883=((0.8)*sj27*x874);\nevalcond[0]=((0.079)*x877);\nevalcond[1]=((0.079)+(((0.1)*x874))+(((-1.0)*cj27*px*x880))+(((-1.0)*x878*x880)));\nevalcond[2]=((-0.0632)+((x879*x883))+(((0.8)*x874*x878))+(((-0.08)*x874)));\nevalcond[3]=(((x878*x882))+((sj27*x879*x882))+(((-0.1)*x882)));\nevalcond[4]=((((-1.0)*x878*x881))+(((-1.0)*sj27*x879*x881))+(((0.1)*x881)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j28]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x885=cj27*cj27;\nIkReal x886=py*py;\nIkReal x887=(cj27*px);\nIkReal x888=(cj29*sj30);\nIkReal x889=(py*sj27);\nIkReal x890=((1000.0)*pz);\nIkReal x891=((1000.0)*x885);\nCheckValue<IkReal> x892=IKPowWithIntegerCheck(IKsign(((((321.0)*cj30*pz))+(((-321.0)*x888*x889))+(((400.0)*pz))+(((-321.0)*x887*x888))+(((32.1)*x888)))),-1);\nif(!x892.valid){\ncontinue;\n}\nCheckValue<IkReal> x893 = IKatan2WithCheck(IkReal(((-150.0)+(((1000.0)*x886))+(((2000.0)*x887*x889))+(((-200.0)*x887))+(((-200.0)*x889))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))+((x891*(px*px)))+(((-1.0)*x886*x891)))),((((-100.0)*pz))+(((-103.041)*cj30*x888))+((x889*x890))+(((-128.4)*x888))+((x887*x890))),IKFAST_ATAN2_MAGTHRESH);\nif(!x893.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x892.value)))+(x893.value));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[6];\nIkReal x894=IKsin(j28);\nIkReal x895=IKcos(j28);\nIkReal x896=((0.321)*cj30);\nIkReal x897=(py*sj27);\nIkReal x898=((0.321)*sj30);\nIkReal x899=((1.0)*sj29);\nIkReal x900=(px*sj27);\nIkReal x901=(cj27*px);\nIkReal x902=(cj27*py);\nIkReal x903=((1.0)*x897);\nIkReal x904=(pz*x894);\nIkReal x905=(cj29*x894);\nIkReal x906=(pz*x895);\nIkReal x907=((0.8)*x895);\nIkReal x908=(sj29*x894);\nevalcond[0]=(((x894*x896))+((cj29*x895*x898))+(((0.4)*x894))+pz);\nevalcond[1]=((0.1)+((x895*x896))+(((-1.0)*x903))+(((0.4)*x895))+(((-1.0)*x898*x905))+(((-1.0)*x901)));\nevalcond[2]=((0.4)+(((-1.0)*x895*x901))+(((-1.0)*x895*x903))+x896+x904+(((0.1)*x895)));\nevalcond[3]=((-0.066959)+(((0.2)*x901))+((x901*x907))+((x897*x907))+(((-1.0)*pp))+(((-0.8)*x904))+(((0.2)*x897))+(((-0.08)*x895)));\nevalcond[4]=(((cj29*x900))+(((-1.0)*cj29*x902))+(((-1.0)*x894*x897*x899))+(((-1.0)*x899*x906))+(((-1.0)*x894*x899*x901))+(((0.1)*x908)));\nevalcond[5]=(((cj29*x906))+((x901*x905))+((x897*x905))+((sj29*x900))+(((-0.1)*x905))+x898+(((-1.0)*x899*x902)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x909=cj29*cj29;\nIkReal x910=cj30*cj30;\nIkReal x911=(cj27*px);\nIkReal x912=((321000.0)*cj30);\nIkReal x913=(py*sj27);\nIkReal x914=((321000.0)*cj29*sj30);\nIkReal x915=((103041.0)*x909);\nCheckValue<IkReal> x916 = IKatan2WithCheck(IkReal(((((-1.0)*x913*x914))+(((32100.0)*cj29*sj30))+(((-1.0)*pz*x912))+(((-400000.0)*pz))+(((-1.0)*x911*x914)))),((-40000.0)+(((-32100.0)*cj30))+((x911*x912))+(((-1.0)*pz*x914))+((x912*x913))+(((400000.0)*x911))+(((400000.0)*x913))),IKFAST_ATAN2_MAGTHRESH);\nif(!x916.valid){\ncontinue;\n}\nCheckValue<IkReal> x917=IKPowWithIntegerCheck(IKsign(((160000.0)+(((256800.0)*cj30))+(((103041.0)*x910))+(((-1.0)*x910*x915))+x915)),-1);\nif(!x917.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(x916.value)+(((1.5707963267949)*(x917.value))));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[6];\nIkReal x918=IKsin(j28);\nIkReal x919=IKcos(j28);\nIkReal x920=((0.321)*cj30);\nIkReal x921=(py*sj27);\nIkReal x922=((0.321)*sj30);\nIkReal x923=((1.0)*sj29);\nIkReal x924=(px*sj27);\nIkReal x925=(cj27*px);\nIkReal x926=(cj27*py);\nIkReal x927=((1.0)*x921);\nIkReal x928=(pz*x918);\nIkReal x929=(cj29*x918);\nIkReal x930=(pz*x919);\nIkReal x931=((0.8)*x919);\nIkReal x932=(sj29*x918);\nevalcond[0]=(((x918*x920))+((cj29*x919*x922))+pz+(((0.4)*x918)));\nevalcond[1]=((0.1)+(((-1.0)*x927))+((x919*x920))+(((-1.0)*x925))+(((0.4)*x919))+(((-1.0)*x922*x929)));\nevalcond[2]=((0.4)+(((-1.0)*x919*x925))+(((-1.0)*x919*x927))+(((0.1)*x919))+x928+x920);\nevalcond[3]=((-0.066959)+(((-0.08)*x919))+(((0.2)*x921))+(((0.2)*x925))+(((-0.8)*x928))+((x921*x931))+(((-1.0)*pp))+((x925*x931)));\nevalcond[4]=((((0.1)*x932))+(((-1.0)*x918*x921*x923))+(((-1.0)*x918*x923*x925))+((cj29*x924))+(((-1.0)*cj29*x926))+(((-1.0)*x923*x930)));\nevalcond[5]=((((-0.1)*x929))+((x921*x929))+((cj29*x930))+((sj29*x924))+((x925*x929))+x922+(((-1.0)*x923*x926)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x933=(py*sj27);\nIkReal x934=(cj29*sj30);\nIkReal x935=((321.0)*cj30);\nIkReal x936=(cj27*px);\nIkReal x937=((1000.0)*pz);\nCheckValue<IkReal> x938=IKPowWithIntegerCheck(IKsign(((-40.0)+(((400.0)*x936))+(((400.0)*x933))+((x935*x936))+(((321.0)*pz*x934))+(((-32.1)*cj30))+((x933*x935)))),-1);\nif(!x938.valid){\ncontinue;\n}\nCheckValue<IkReal> x939 = IKatan2WithCheck(IkReal(((((-103.041)*cj30*x934))+(((100.0)*pz))+(((-128.4)*x934))+(((-1.0)*x936*x937))+(((-1.0)*x933*x937)))),((160.0)+(((-1.0)*pz*x937))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))),IKFAST_ATAN2_MAGTHRESH);\nif(!x939.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x938.value)))+(x939.value));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[6];\nIkReal x940=IKsin(j28);\nIkReal x941=IKcos(j28);\nIkReal x942=((0.321)*cj30);\nIkReal x943=(py*sj27);\nIkReal x944=((0.321)*sj30);\nIkReal x945=((1.0)*sj29);\nIkReal x946=(px*sj27);\nIkReal x947=(cj27*px);\nIkReal x948=(cj27*py);\nIkReal x949=((1.0)*x943);\nIkReal x950=(pz*x940);\nIkReal x951=(cj29*x940);\nIkReal x952=(pz*x941);\nIkReal x953=((0.8)*x941);\nIkReal x954=(sj29*x940);\nevalcond[0]=(pz+((cj29*x941*x944))+(((0.4)*x940))+((x940*x942)));\nevalcond[1]=((0.1)+(((-1.0)*x949))+(((-1.0)*x944*x951))+((x941*x942))+(((-1.0)*x947))+(((0.4)*x941)));\nevalcond[2]=((0.4)+(((-1.0)*x941*x947))+(((-1.0)*x941*x949))+x950+x942+(((0.1)*x941)));\nevalcond[3]=((-0.066959)+(((-0.08)*x941))+(((-0.8)*x950))+(((0.2)*x947))+(((0.2)*x943))+((x943*x953))+(((-1.0)*pp))+((x947*x953)));\nevalcond[4]=((((0.1)*x954))+(((-1.0)*cj29*x948))+(((-1.0)*x940*x943*x945))+(((-1.0)*x945*x952))+(((-1.0)*x940*x945*x947))+((cj29*x946)));\nevalcond[5]=(((sj29*x946))+(((-1.0)*x945*x948))+(((-0.1)*x951))+((x943*x951))+((cj29*x952))+((x947*x951))+x944);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x955=cj27*cj27;\nIkReal x956=px*px;\nIkReal x957=py*py;\nIkReal x958=((1.0)*pz);\nIkReal x959=(cj27*px);\nIkReal x960=((5.0)*pp);\nIkReal x961=(cj29*py);\nIkReal x962=((4.0)*cj27);\nIkReal x963=(pz*sj29);\nIkReal x964=(cj29*sj27);\nIkReal x965=(py*sj27*sj29);\nIkReal x966=((4.0)*cj29*px);\nIkReal x967=(sj29*x955);\nIkReal x968=((4.0)*x957);\nCheckValue<IkReal> x969 = IKatan2WithCheck(IkReal(((((-1.0)*x956*x962*x964))+(((0.334795)*x963))+(((-4.0)*px*x961))+(((0.4)*px*x964))+(((-1.0)*sj29*x958*x959))+(((-0.4)*cj27*x961))+((x960*x963))+(((8.0)*px*x955*x961))+(((-1.0)*x958*x965))+((x957*x962*x964)))),((((-1.0)*x960*x965))+(((0.5)*pp*sj29))+(((-1.0)*sj29*x959*x960))+((sj29*x957))+(((2.0)*x959*x965))+(((-0.434795)*sj29*x959))+((pz*x961*x962))+(((-4.0)*px*pz*x964))+(((0.0334795)*sj29))+(((-1.0)*x957*x967))+((x956*x967))+(((-0.434795)*x965))),IKFAST_ATAN2_MAGTHRESH);\nif(!x969.valid){\ncontinue;\n}\nCheckValue<IkReal> x970=IKPowWithIntegerCheck(IKsign(((((0.8)*x965))+(((-4.0)*pz*x963))+(((-1.0)*sj29*x968))+((x967*x968))+(((0.8)*sj29*x959))+(((-0.04)*sj29))+(((-4.0)*x956*x967))+(((-8.0)*x959*x965)))),-1);\nif(!x970.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(x969.value)+(((1.5707963267949)*(x970.value))));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[2];\nIkReal x971=IKcos(j28);\nIkReal x972=IKsin(j28);\nIkReal x973=(py*sj27);\nIkReal x974=((1.0)*cj27);\nIkReal x975=(cj27*px);\nIkReal x976=((0.8)*x971);\nIkReal x977=(sj29*x972);\nevalcond[0]=((-0.066959)+((x975*x976))+((x973*x976))+(((-1.0)*pp))+(((0.2)*x975))+(((0.2)*x973))+(((-0.08)*x971))+(((-0.8)*pz*x972)));\nevalcond[1]=(((cj29*px*sj27))+(((0.1)*x977))+(((-1.0)*px*x974*x977))+(((-1.0)*pz*sj29*x971))+(((-1.0)*x973*x977))+(((-1.0)*cj29*py*x974)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j30eval[1];\nj30eval[0]=sj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[2];\nj30eval[0]=cj28;\nj30eval[1]=cj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  || IKabs(j30eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[2];\nj30eval[0]=sj29;\nj30eval[1]=sj28;\nif( IKabs(j30eval[0]) < 0.0000010000000000  || IKabs(j30eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x978=(cj27*px);\nIkReal x979=((0.8)*cj28);\nIkReal x980=(py*sj27);\nIkReal x981=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));\nevalcond[1]=x981;\nevalcond[2]=((-0.066959)+((x978*x979))+((x979*x980))+(((-0.08)*cj28))+(((-1.0)*pp))+(((0.2)*x978))+(((0.2)*x980))+(((-0.8)*pz*sj28)));\nevalcond[3]=x981;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nIkReal x982=((3.11526479750779)*cj28);\nIkReal x983=(py*sj27);\nIkReal x984=((3.11526479750779)*sj28);\nIkReal x985=(cj27*px);\nif( IKabs(((((-1.0)*pz*x982))+(((-1.0)*x984*x985))+(((0.311526479750779)*sj28))+(((-1.0)*x983*x984)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x984))+((x982*x985))+((x982*x983)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*pz*x982))+(((-1.0)*x984*x985))+(((0.311526479750779)*sj28))+(((-1.0)*x983*x984))))+IKsqr(((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x984))+((x982*x985))+((x982*x983))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((-1.0)*pz*x982))+(((-1.0)*x984*x985))+(((0.311526479750779)*sj28))+(((-1.0)*x983*x984))), ((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x984))+((x982*x985))+((x982*x983))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x986=IKcos(j30);\nIkReal x987=IKsin(j30);\nIkReal x988=(py*sj27);\nIkReal x989=(cj27*px);\nIkReal x990=((0.321)*x986);\nIkReal x991=((0.321)*x987);\nevalcond[0]=((((0.4)*sj28))+((cj28*x991))+((sj28*x990))+pz);\nevalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x989))+(((0.2)*x988))+(((0.2568)*x986)));\nevalcond[2]=(((sj28*x989))+((sj28*x988))+((cj28*pz))+(((-0.1)*sj28))+x991);\nCheckValue<IkReal> x992=IKPowWithIntegerCheck(py,-1);\nif(!x992.valid){\ncontinue;\n}\nevalcond[3]=((0.31630125)+(((-1.25)*pp))+(((0.25)*x988))+x990+(((0.25)*sj27*(px*px)*(x992.value))));\nevalcond[4]=((0.1)+(((-1.0)*x988))+(((-1.0)*x989))+(((0.4)*cj28))+((cj28*x990))+(((-1.0)*sj28*x991)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x993=(cj27*px);\nIkReal x994=((0.8)*cj28);\nIkReal x995=(cj27*py);\nIkReal x996=(px*sj27);\nIkReal x997=(py*sj27);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));\nevalcond[1]=((((-1.0)*x995))+x996);\nevalcond[2]=((-0.066959)+((x993*x994))+((x994*x997))+(((-0.08)*cj28))+(((-1.0)*pp))+(((-0.8)*pz*sj28))+(((0.2)*x993))+(((0.2)*x997)));\nevalcond[3]=((((-1.0)*x996))+x995);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nIkReal x998=((3.11526479750779)*cj28);\nIkReal x999=(py*sj27);\nIkReal x1000=((3.11526479750779)*sj28);\nIkReal x1001=(cj27*px);\nif( IKabs((((x1000*x999))+((pz*x998))+((x1000*x1001))+(((-0.311526479750779)*sj28)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+((x998*x999))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1000))+((x1001*x998)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1000*x999))+((pz*x998))+((x1000*x1001))+(((-0.311526479750779)*sj28))))+IKsqr(((-1.24610591900312)+((x998*x999))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1000))+((x1001*x998))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2((((x1000*x999))+((pz*x998))+((x1000*x1001))+(((-0.311526479750779)*sj28))), ((-1.24610591900312)+((x998*x999))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1000))+((x1001*x998))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1002=IKcos(j30);\nIkReal x1003=IKsin(j30);\nIkReal x1004=(cj27*px);\nIkReal x1005=((1.0)*sj28);\nIkReal x1006=((0.25)*sj27);\nIkReal x1007=(py*sj27);\nIkReal x1008=((0.321)*x1002);\nIkReal x1009=((0.321)*x1003);\nevalcond[0]=((((0.4)*sj28))+(((-1.0)*cj28*x1009))+((sj28*x1008))+pz);\nevalcond[1]=((0.253041)+(((0.2)*x1007))+(((0.2)*x1004))+(((-1.0)*pp))+(((0.2568)*x1002)));\nCheckValue<IkReal> x1010=IKPowWithIntegerCheck(py,-1);\nif(!x1010.valid){\ncontinue;\n}\nevalcond[2]=((0.31630125)+x1008+(((-1.25)*pp))+((x1006*(px*px)*(x1010.value)))+((py*x1006)));\nevalcond[3]=(x1009+(((0.1)*sj28))+(((-1.0)*x1005*x1007))+(((-1.0)*x1004*x1005))+(((-1.0)*cj28*pz)));\nevalcond[4]=((0.1)+((cj28*x1008))+(((-1.0)*x1007))+(((-1.0)*x1004))+(((0.4)*cj28))+((sj28*x1009)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j28))), 6.28318530717959)));\nevalcond[1]=((-0.146959)+((cj27*px))+(((-1.0)*pp))+((py*sj27)));\nevalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+(((-1.0)*pz*sj29)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30eval[1];\nsj28=0;\ncj28=1.0;\nj28=0;\nj30eval[0]=cj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[1];\nsj28=0;\ncj28=1.0;\nj28=0;\nj30eval[0]=sj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1011=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));\nevalcond[1]=x1011;\nevalcond[2]=((-0.146959)+((cj27*px))+(((-1.0)*pp))+((py*sj27)));\nevalcond[3]=x1011;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.09981619937695)+(((3.11526479750779)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1012=IKcos(j30);\nevalcond[0]=(pz+(((0.321)*(IKsin(j30)))));\nevalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1012)));\nevalcond[2]=((0.353041)+(((0.321)*x1012))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1013=(cj27*py);\nIkReal x1014=(px*sj27);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));\nevalcond[1]=(x1014+(((-1.0)*x1013)));\nevalcond[2]=((-0.146959)+((cj27*px))+(((-1.0)*pp))+((py*sj27)));\nevalcond[3]=(x1013+(((-1.0)*x1014)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.09981619937695)+(((3.11526479750779)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1015=IKcos(j30);\nevalcond[0]=((((-0.321)*(IKsin(j30))))+pz);\nevalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1015)));\nevalcond[2]=((0.353041)+(((0.321)*x1015))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((-0.146959)+((cj27*px))+(((-1.0)*pp))+((py*sj27)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.09981619937695)+(((3.11526479750779)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1016=IKcos(j30);\nevalcond[0]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1016)));\nevalcond[1]=((0.353041)+(((0.321)*x1016))+(((-1.0)*pp)));\nevalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((-0.146959)+((cj27*px))+(((-1.0)*pp))+((py*sj27)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.09981619937695)+(((3.11526479750779)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1017=IKcos(j30);\nevalcond[0]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1017)));\nevalcond[1]=((0.353041)+(((0.321)*x1017))+(((-1.0)*pp)));\nevalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j30]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1018=IKPowWithIntegerCheck(sj29,-1);\nif(!x1018.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1018.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1018.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1018.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.09981619937695)+(((3.11526479750779)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1019=IKcos(j30);\nIkReal x1020=IKsin(j30);\nIkReal x1021=(px*sj27);\nIkReal x1022=((1.0)*cj27*py);\nIkReal x1023=((0.321)*x1020);\nevalcond[0]=(((cj29*x1023))+pz);\nevalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1019)));\nevalcond[2]=((0.353041)+(((0.321)*x1019))+(((-1.0)*pp)));\nevalcond[3]=(x1021+(((-1.0)*x1022))+((sj29*x1023)));\nevalcond[4]=(x1023+(((-1.0)*sj29*x1022))+((cj29*pz))+((sj29*x1021)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1024=IKPowWithIntegerCheck(cj29,-1);\nif(!x1024.valid){\ncontinue;\n}\nif( IKabs(((-3.11526479750779)*pz*(x1024.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz*(x1024.value)))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((-3.11526479750779)*pz*(x1024.value)), ((-1.09981619937695)+(((3.11526479750779)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1025=IKcos(j30);\nIkReal x1026=IKsin(j30);\nIkReal x1027=(px*sj27);\nIkReal x1028=((1.0)*cj27*py);\nIkReal x1029=((0.321)*x1026);\nevalcond[0]=(((cj29*x1029))+pz);\nevalcond[1]=((0.2824328)+(((0.2568)*x1025))+(((-0.8)*pp)));\nevalcond[2]=((0.353041)+(((-1.0)*pp))+(((0.321)*x1025)));\nevalcond[3]=(x1027+(((-1.0)*x1028))+((sj29*x1029)));\nevalcond[4]=(x1029+(((-1.0)*sj29*x1028))+((cj29*pz))+((sj29*x1027)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j28)))), 6.28318530717959)));\nevalcond[1]=((0.013041)+(((-0.6)*cj27*px))+(((-1.0)*pp))+(((-0.6)*py*sj27)));\nevalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+((pz*sj29)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30eval[1];\nsj28=0;\ncj28=-1.0;\nj28=3.14159265358979;\nj30eval[0]=cj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[1];\nsj28=0;\ncj28=-1.0;\nj28=3.14159265358979;\nj30eval[0]=sj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1030=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));\nevalcond[1]=x1030;\nevalcond[2]=((0.013041)+(((-0.6)*cj27*px))+(((-1.0)*pp))+(((-0.6)*py*sj27)));\nevalcond[3]=x1030;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.00228971962617)+(((5.19210799584631)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1031=IKcos(j30);\nevalcond[0]=((((-0.321)*(IKsin(j30))))+pz);\nevalcond[1]=((0.257388)+(((0.2568)*x1031))+(((-1.33333333333333)*pp)));\nevalcond[2]=((0.321735)+(((0.321)*x1031))+(((-1.66666666666667)*pp)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1032=(cj27*py);\nIkReal x1033=(px*sj27);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));\nevalcond[1]=(x1033+(((-1.0)*x1032)));\nevalcond[2]=((0.013041)+(((-0.6)*cj27*px))+(((-1.0)*pp))+(((-0.6)*py*sj27)));\nevalcond[3]=(x1032+(((-1.0)*x1033)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.00228971962617)+(((5.19210799584631)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1034=IKcos(j30);\nevalcond[0]=(pz+(((0.321)*(IKsin(j30)))));\nevalcond[1]=((0.257388)+(((0.2568)*x1034))+(((-1.33333333333333)*pp)));\nevalcond[2]=((0.321735)+(((0.321)*x1034))+(((-1.66666666666667)*pp)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((0.013041)+(((-0.6)*cj27*px))+(((-1.0)*pp))+(((-0.6)*py*sj27)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.00228971962617)+(((5.19210799584631)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1035=IKcos(j30);\nevalcond[0]=((0.257388)+(((0.2568)*x1035))+(((-1.33333333333333)*pp)));\nevalcond[1]=((0.321735)+(((0.321)*x1035))+(((-1.66666666666667)*pp)));\nevalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((0.013041)+(((-0.6)*cj27*px))+(((-1.0)*pp))+(((-0.6)*py*sj27)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.00228971962617)+(((5.19210799584631)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1036=IKcos(j30);\nevalcond[0]=((0.257388)+(((0.2568)*x1036))+(((-1.33333333333333)*pp)));\nevalcond[1]=((0.321735)+(((0.321)*x1036))+(((-1.66666666666667)*pp)));\nevalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j30]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1037=IKPowWithIntegerCheck(sj29,-1);\nif(!x1037.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1037.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1037.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1037.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.00228971962617)+(((5.19210799584631)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1038=IKcos(j30);\nIkReal x1039=IKsin(j30);\nIkReal x1040=(px*sj27);\nIkReal x1041=((1.0)*cj27*py);\nIkReal x1042=((0.321)*x1039);\nevalcond[0]=(pz+(((-1.0)*cj29*x1042)));\nevalcond[1]=((0.257388)+(((0.2568)*x1038))+(((-1.33333333333333)*pp)));\nevalcond[2]=((0.321735)+(((0.321)*x1038))+(((-1.66666666666667)*pp)));\nevalcond[3]=(((sj29*x1042))+x1040+(((-1.0)*x1041)));\nevalcond[4]=((((-1.0)*sj29*x1041))+((sj29*x1040))+x1042+(((-1.0)*cj29*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1043=IKPowWithIntegerCheck(cj29,-1);\nif(!x1043.valid){\ncontinue;\n}\nif( IKabs(((3.11526479750779)*pz*(x1043.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz*(x1043.value)))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((3.11526479750779)*pz*(x1043.value)), ((-1.00228971962617)+(((5.19210799584631)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1044=IKcos(j30);\nIkReal x1045=IKsin(j30);\nIkReal x1046=(px*sj27);\nIkReal x1047=((1.0)*cj27*py);\nIkReal x1048=((0.321)*x1045);\nevalcond[0]=(pz+(((-1.0)*cj29*x1048)));\nevalcond[1]=((0.257388)+(((0.2568)*x1044))+(((-1.33333333333333)*pp)));\nevalcond[2]=((0.321735)+(((0.321)*x1044))+(((-1.66666666666667)*pp)));\nevalcond[3]=(((sj29*x1048))+x1046+(((-1.0)*x1047)));\nevalcond[4]=((((-1.0)*sj29*x1047))+((sj29*x1046))+x1048+(((-1.0)*cj29*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1049=(cj27*px);\nIkReal x1050=((1.0)*py);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j28)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+(((0.2)*x1049))+(((-0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27)));\nevalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*x1050))+(((-1.0)*sj27*sj29*x1050))+(((0.1)*sj29))+(((-1.0)*sj29*x1049)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30eval[1];\nsj28=1.0;\ncj28=0;\nj28=1.5707963267949;\nj30eval[0]=sj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[1];\nsj28=1.0;\ncj28=0;\nj28=1.5707963267949;\nj30eval[0]=cj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1051=(py*sj27);\nIkReal x1052=(cj27*px);\nIkReal x1053=((0.1)+(((-1.0)*x1051))+(((-1.0)*x1052)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=x1053;\nevalcond[2]=((-0.066959)+(((-0.8)*pz))+(((0.2)*x1051))+(((0.2)*x1052))+(((-1.0)*pp)));\nevalcond[3]=x1053;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1054=IKcos(j30);\nevalcond[0]=((0.4)+(((0.321)*x1054))+pz);\nevalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1054)));\nevalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1055=(py*sj27);\nIkReal x1056=(cj27*px);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=((0.1)+(((-1.0)*x1055))+(((-1.0)*x1056)));\nevalcond[2]=((-0.066959)+(((-0.8)*pz))+(((0.2)*x1055))+(((0.2)*x1056))+(((-1.0)*pp)));\nevalcond[3]=((-0.1)+x1055+x1056);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1057=IKcos(j30);\nevalcond[0]=((0.4)+(((0.321)*x1057))+pz);\nevalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1057)));\nevalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1058=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));\nevalcond[1]=x1058;\nevalcond[2]=((-0.066959)+(((-0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nevalcond[3]=x1058;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1059=IKcos(j30);\nevalcond[0]=((0.4)+(((0.321)*x1059))+pz);\nevalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1059)));\nevalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1060=(cj27*py);\nIkReal x1061=(px*sj27);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));\nevalcond[1]=(x1061+(((-1.0)*x1060)));\nevalcond[2]=((-0.066959)+(((-0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nevalcond[3]=(x1060+(((-1.0)*x1061)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1062=IKcos(j30);\nevalcond[0]=((0.4)+(((0.321)*x1062))+pz);\nevalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1062)));\nevalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j30]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1063=IKPowWithIntegerCheck(cj29,-1);\nif(!x1063.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1063.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1063.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1063.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1064=IKcos(j30);\nIkReal x1065=IKsin(j30);\nIkReal x1066=((1.0)*py);\nIkReal x1067=(cj27*px);\nIkReal x1068=(px*sj27);\nIkReal x1069=((0.321)*x1065);\nevalcond[0]=((0.4)+(((0.321)*x1064))+pz);\nevalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1064)));\nevalcond[2]=((((-1.0)*cj27*x1066))+x1068+((sj29*x1069)));\nevalcond[3]=((0.1)+(((-1.0)*sj27*x1066))+(((-1.0)*x1067))+(((-1.0)*cj29*x1069)));\nevalcond[4]=(((cj29*py*sj27))+x1069+(((-1.0)*cj27*sj29*x1066))+((cj29*x1067))+((sj29*x1068))+(((-0.1)*cj29)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1070=IKPowWithIntegerCheck(sj29,-1);\nif(!x1070.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1070.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1070.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1070.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1071=IKcos(j30);\nIkReal x1072=IKsin(j30);\nIkReal x1073=((1.0)*py);\nIkReal x1074=(cj27*px);\nIkReal x1075=(px*sj27);\nIkReal x1076=((0.321)*x1072);\nevalcond[0]=((0.4)+(((0.321)*x1071))+pz);\nevalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1071)));\nevalcond[2]=(x1075+((sj29*x1076))+(((-1.0)*cj27*x1073)));\nevalcond[3]=((0.1)+(((-1.0)*sj27*x1073))+(((-1.0)*x1074))+(((-1.0)*cj29*x1076)));\nevalcond[4]=(((cj29*py*sj27))+x1076+(((-1.0)*cj27*sj29*x1073))+((cj29*x1074))+((sj29*x1075))+(((-0.1)*cj29)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1077=(py*sj27);\nIkReal x1078=(cj27*px);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j28)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+(((0.8)*pz))+(((0.2)*x1077))+(((0.2)*x1078))+(((-1.0)*pp)));\nevalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+(((-0.1)*sj29))+((sj29*x1077))+((sj29*x1078)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30eval[1];\nsj28=-1.0;\ncj28=0;\nj28=-1.5707963267949;\nj30eval[0]=sj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[1];\nsj28=-1.0;\ncj28=0;\nj28=-1.5707963267949;\nj30eval[0]=cj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1079=(py*sj27);\nIkReal x1080=(cj27*px);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=((0.1)+(((-1.0)*x1080))+(((-1.0)*x1079)));\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((0.2)*x1079))+(((0.2)*x1080))+(((-1.0)*pp)));\nevalcond[3]=((-0.1)+x1079+x1080);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1081=IKcos(j30);\nevalcond[0]=((-0.4)+(((-0.321)*x1081))+pz);\nevalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1081)));\nevalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1082=(py*sj27);\nIkReal x1083=(cj27*px);\nIkReal x1084=((0.1)+(((-1.0)*x1082))+(((-1.0)*x1083)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=x1084;\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((0.2)*x1083))+(((0.2)*x1082))+(((-1.0)*pp)));\nevalcond[3]=x1084;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1085=IKcos(j30);\nevalcond[0]=((-0.4)+(((-0.321)*x1085))+pz);\nevalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1085)));\nevalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1086=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));\nevalcond[1]=x1086;\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nevalcond[3]=x1086;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1087=IKcos(j30);\nevalcond[0]=((-0.4)+(((-0.321)*x1087))+pz);\nevalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1087)));\nevalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1088=(cj27*py);\nIkReal x1089=(px*sj27);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));\nevalcond[1]=(x1089+(((-1.0)*x1088)));\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nevalcond[3]=(x1088+(((-1.0)*x1089)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1090=IKcos(j30);\nevalcond[0]=((-0.4)+(((-0.321)*x1090))+pz);\nevalcond[1]=((0.32)+(((0.2568)*x1090))+(((-0.8)*pz)));\nevalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j30]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1091=IKPowWithIntegerCheck(cj29,-1);\nif(!x1091.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1091.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1091.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1091.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1092=IKcos(j30);\nIkReal x1093=IKsin(j30);\nIkReal x1094=((1.0)*py);\nIkReal x1095=(px*sj27);\nIkReal x1096=((1.0)*cj27*px);\nIkReal x1097=((0.321)*x1093);\nevalcond[0]=((-0.4)+(((-0.321)*x1092))+pz);\nevalcond[1]=((0.32)+(((0.2568)*x1092))+(((-0.8)*pz)));\nevalcond[2]=(x1095+((sj29*x1097))+(((-1.0)*cj27*x1094)));\nevalcond[3]=((0.1)+((cj29*x1097))+(((-1.0)*x1096))+(((-1.0)*sj27*x1094)));\nevalcond[4]=(x1097+(((-1.0)*cj29*sj27*x1094))+((sj29*x1095))+(((0.1)*cj29))+(((-1.0)*cj29*x1096))+(((-1.0)*cj27*sj29*x1094)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1098=IKPowWithIntegerCheck(sj29,-1);\nif(!x1098.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1098.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1098.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1098.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1099=IKcos(j30);\nIkReal x1100=IKsin(j30);\nIkReal x1101=((1.0)*py);\nIkReal x1102=(px*sj27);\nIkReal x1103=((1.0)*cj27*px);\nIkReal x1104=((0.321)*x1100);\nevalcond[0]=((-0.4)+(((-0.321)*x1099))+pz);\nevalcond[1]=((0.32)+(((0.2568)*x1099))+(((-0.8)*pz)));\nevalcond[2]=(x1102+(((-1.0)*cj27*x1101))+((sj29*x1104)));\nevalcond[3]=((0.1)+((cj29*x1104))+(((-1.0)*sj27*x1101))+(((-1.0)*x1103)));\nevalcond[4]=(x1104+(((-1.0)*cj27*sj29*x1101))+((sj29*x1102))+(((0.1)*cj29))+(((-1.0)*cj29*x1103))+(((-1.0)*cj29*sj27*x1101)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1105=(cj27*px);\nIkReal x1106=((0.8)*cj28);\nIkReal x1107=(py*sj27);\nIkReal x1108=((1.0)*sj28);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+((x1105*x1106))+(((-0.08)*cj28))+(((-1.0)*pp))+(((-0.8)*pz*sj28))+(((0.2)*x1105))+(((0.2)*x1107))+((x1106*x1107)));\nevalcond[2]=((((0.1)*sj28))+(((-1.0)*x1107*x1108))+(((-1.0)*cj28*pz))+(((-1.0)*x1105*x1108)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1109=IKcos(j30);\nIkReal x1110=((1.0)*py);\nIkReal x1111=(cj27*px);\nIkReal x1112=((0.321)*x1109);\nevalcond[0]=((((0.4)*sj28))+((sj28*x1112))+pz);\nevalcond[1]=((((-1.0)*cj27*x1110))+((px*sj27))+(((0.321)*(IKsin(j30)))));\nevalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*x1111))+(((0.2568)*x1109)));\nevalcond[3]=((0.1)+((cj28*x1112))+(((-1.0)*sj27*x1110))+(((0.4)*cj28))+(((-1.0)*x1111)));\nevalcond[4]=((0.4)+(((-1.0)*cj28*x1111))+(((-1.0)*cj28*sj27*x1110))+x1112+(((0.1)*cj28))+((pz*sj28)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1113=(cj27*px);\nIkReal x1114=((0.8)*cj28);\nIkReal x1115=(py*sj27);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+((x1114*x1115))+((x1113*x1114))+(((-0.08)*cj28))+(((-1.0)*pp))+(((0.2)*x1115))+(((0.2)*x1113))+(((-0.8)*pz*sj28)));\nevalcond[2]=(((cj28*pz))+((sj28*x1113))+((sj28*x1115))+(((-0.1)*sj28)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1116=IKcos(j30);\nIkReal x1117=((1.0)*py);\nIkReal x1118=(cj27*px);\nIkReal x1119=((0.321)*x1116);\nevalcond[0]=((((0.4)*sj28))+((sj28*x1119))+pz);\nevalcond[1]=((((-1.0)*cj27*x1117))+(((-0.321)*(IKsin(j30))))+((px*sj27)));\nevalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*x1118))+(((0.2568)*x1116)));\nevalcond[3]=((0.1)+((cj28*x1119))+(((-1.0)*sj27*x1117))+(((0.4)*cj28))+(((-1.0)*x1118)));\nevalcond[4]=((0.4)+(((-1.0)*cj28*x1118))+(((-1.0)*cj28*sj27*x1117))+x1119+(((0.1)*cj28))+((pz*sj28)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j30]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1125=IKPowWithIntegerCheck(sj29,-1);\nif(!x1125.valid){\ncontinue;\n}\nIkReal x1120=x1125.value;\nIkReal x1121=((0.00311526479750779)*x1120);\nIkReal x1122=(cj28*cj29);\nIkReal x1123=((1000.0)*cj27*py);\nIkReal x1124=((1000.0)*px*sj27);\nCheckValue<IkReal> x1126=IKPowWithIntegerCheck(sj28,-1);\nif(!x1126.valid){\ncontinue;\n}\nif( IKabs((x1121*((x1123+(((-1.0)*x1124)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1121*(x1126.value)*(((((-1.0)*x1122*x1123))+(((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+((x1122*x1124)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1121*((x1123+(((-1.0)*x1124))))))+IKsqr((x1121*(x1126.value)*(((((-1.0)*x1122*x1123))+(((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+((x1122*x1124))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2((x1121*((x1123+(((-1.0)*x1124))))), (x1121*(x1126.value)*(((((-1.0)*x1122*x1123))+(((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+((x1122*x1124))))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[6];\nIkReal x1127=IKsin(j30);\nIkReal x1128=IKcos(j30);\nIkReal x1129=((1.0)*py);\nIkReal x1130=(cj29*sj28);\nIkReal x1131=(cj27*px);\nIkReal x1132=(cj28*cj29);\nIkReal x1133=(py*sj27);\nIkReal x1134=(px*sj27);\nIkReal x1135=((0.321)*x1127);\nIkReal x1136=((0.321)*x1128);\nevalcond[0]=(x1134+((sj29*x1135))+(((-1.0)*cj27*x1129)));\nevalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1133))+(((0.2)*x1131))+(((0.2568)*x1128)));\nevalcond[2]=((((0.4)*sj28))+((sj28*x1136))+pz+((x1132*x1135)));\nevalcond[3]=((0.4)+x1136+(((-1.0)*cj28*sj27*x1129))+(((-1.0)*cj28*x1131))+(((0.1)*cj28))+((pz*sj28)));\nevalcond[4]=((0.1)+(((0.4)*cj28))+(((-1.0)*x1130*x1135))+(((-1.0)*sj27*x1129))+(((-1.0)*x1131))+((cj28*x1136)));\nevalcond[5]=(x1135+((x1130*x1133))+((x1130*x1131))+((sj29*x1134))+(((-0.1)*x1130))+((pz*x1132))+(((-1.0)*cj27*sj29*x1129)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nIkReal x1137=((250.0)*sj28);\nIkReal x1138=(py*sj27);\nIkReal x1139=(cj27*px);\nCheckValue<IkReal> x1140=IKPowWithIntegerCheck(cj28,-1);\nif(!x1140.valid){\ncontinue;\n}\nCheckValue<IkReal> x1141=IKPowWithIntegerCheck(cj29,-1);\nif(!x1141.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1140.value)*(x1141.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x1137*x1138))+((x1137*x1139))+(((-1250.0)*pp*sj28)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((-0.778816199376947)*x1139))+(((-0.778816199376947)*x1138))+(((3.89408099688474)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1140.value)*(x1141.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x1137*x1138))+((x1137*x1139))+(((-1250.0)*pp*sj28))))))+IKsqr(((-0.98536214953271)+(((-0.778816199376947)*x1139))+(((-0.778816199376947)*x1138))+(((3.89408099688474)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1140.value)*(x1141.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x1137*x1138))+((x1137*x1139))+(((-1250.0)*pp*sj28))))), ((-0.98536214953271)+(((-0.778816199376947)*x1139))+(((-0.778816199376947)*x1138))+(((3.89408099688474)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[6];\nIkReal x1142=IKsin(j30);\nIkReal x1143=IKcos(j30);\nIkReal x1144=((1.0)*py);\nIkReal x1145=(cj29*sj28);\nIkReal x1146=(cj27*px);\nIkReal x1147=(cj28*cj29);\nIkReal x1148=(py*sj27);\nIkReal x1149=(px*sj27);\nIkReal x1150=((0.321)*x1142);\nIkReal x1151=((0.321)*x1143);\nevalcond[0]=(x1149+((sj29*x1150))+(((-1.0)*cj27*x1144)));\nevalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1146))+(((0.2)*x1148))+(((0.2568)*x1143)));\nevalcond[2]=((((0.4)*sj28))+((sj28*x1151))+((x1147*x1150))+pz);\nevalcond[3]=((0.4)+x1151+(((-1.0)*cj28*sj27*x1144))+(((-1.0)*cj28*x1146))+(((0.1)*cj28))+((pz*sj28)));\nevalcond[4]=((0.1)+(((0.4)*cj28))+((cj28*x1151))+(((-1.0)*x1146))+(((-1.0)*x1145*x1150))+(((-1.0)*sj27*x1144)));\nevalcond[5]=(((x1145*x1148))+((x1145*x1146))+x1150+((pz*x1147))+(((-1.0)*cj27*sj29*x1144))+((sj29*x1149))+(((-0.1)*x1145)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1152=IKPowWithIntegerCheck(sj29,-1);\nif(!x1152.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1152.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1152.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1152.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[6];\nIkReal x1153=IKsin(j30);\nIkReal x1154=IKcos(j30);\nIkReal x1155=((1.0)*py);\nIkReal x1156=(cj29*sj28);\nIkReal x1157=(cj27*px);\nIkReal x1158=(cj28*cj29);\nIkReal x1159=(py*sj27);\nIkReal x1160=(px*sj27);\nIkReal x1161=((0.321)*x1153);\nIkReal x1162=((0.321)*x1154);\nevalcond[0]=(x1160+(((-1.0)*cj27*x1155))+((sj29*x1161)));\nevalcond[1]=((0.253041)+(((0.2)*x1159))+(((0.2)*x1157))+(((0.2568)*x1154))+(((-1.0)*pp)));\nevalcond[2]=((((0.4)*sj28))+pz+((x1158*x1161))+((sj28*x1162)));\nevalcond[3]=((0.4)+x1162+(((-1.0)*cj28*sj27*x1155))+(((-1.0)*cj28*x1157))+(((0.1)*cj28))+((pz*sj28)));\nevalcond[4]=((0.1)+(((-1.0)*x1156*x1161))+(((-1.0)*sj27*x1155))+(((0.4)*cj28))+(((-1.0)*x1157))+((cj28*x1162)));\nevalcond[5]=(((pz*x1158))+x1161+(((-1.0)*cj27*sj29*x1155))+(((-0.1)*x1156))+((x1156*x1159))+((x1156*x1157))+((sj29*x1160)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n    }\n}\nreturn solutions.GetNumSolutions()>0;\n}\ninline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {\nfor(int rotationiter = 0; rotationiter < 1; ++rotationiter) {\nIkReal x192=(sj27*sj29);\nIkReal x193=(cj27*sj29);\nIkReal x194=(cj28*sj29);\nIkReal x195=(cj28*cj30);\nIkReal x196=((1.0)*sj30);\nIkReal x197=((1.0)*cj29);\nIkReal x198=(cj29*x196);\nIkReal x199=((1.0)*cj30*sj28);\nIkReal x200=((((-1.0)*x195*x197))+((sj28*sj30)));\nIkReal x201=((((-1.0)*sj27*x197))+((sj28*x193)));\nIkReal x202=(((sj28*x192))+((cj27*cj29)));\nIkReal x203=((((-1.0)*sj28*x198))+x195);\nIkReal x204=(cj27*x203);\nIkReal x205=((((-1.0)*cj30*sj28*x197))+(((-1.0)*cj28*x196)));\nIkReal x206=((((-1.0)*x199))+(((-1.0)*cj28*x198)));\nIkReal x207=(cj27*x205);\nIkReal x208=(((sj30*x193))+((sj27*x203)));\nIkReal x209=((((-1.0)*sj30*x192))+x204);\nIkReal x210=(((cj30*x193))+((sj27*x205)));\nIkReal x211=((((-1.0)*cj30*x192))+x207);\nnew_r00=(((r00*(((((-1.0)*cj30*x192))+x207))))+((r20*x200))+((r10*x210)));\nnew_r01=(((r11*x210))+((r21*x200))+((r01*x211)));\nnew_r02=(((r22*x200))+((r12*x210))+((r02*x211)));\nnew_r10=(((r20*x194))+((r00*x201))+((r10*x202)));\nnew_r11=(((r11*x202))+((r01*x201))+((r21*x194)));\nnew_r12=(((r22*x194))+((r12*x202))+((r02*x201)));\nnew_r20=(((r00*x209))+((r10*x208))+((r20*x206)));\nnew_r21=(((r11*x208))+((r01*x209))+((r21*x206)));\nnew_r22=(((r22*x206))+((r02*(((((-1.0)*x192*x196))+x204))))+((r12*x208)));\n{\nIkReal j32array[2], cj32array[2], sj32array[2];\nbool j32valid[2]={false};\n_nj32 = 2;\ncj32array[0]=new_r22;\nif( cj32array[0] >= -1-IKFAST_SINCOS_THRESH && cj32array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j32valid[0] = j32valid[1] = true;\n    j32array[0] = IKacos(cj32array[0]);\n    sj32array[0] = IKsin(j32array[0]);\n    cj32array[1] = cj32array[0];\n    j32array[1] = -j32array[0];\n    sj32array[1] = -sj32array[0];\n}\nelse if( isnan(cj32array[0]) )\n{\n    // probably any value will work\n    j32valid[0] = true;\n    cj32array[0] = 1; sj32array[0] = 0; j32array[0] = 0;\n}\nfor(int ij32 = 0; ij32 < 2; ++ij32)\n{\nif( !j32valid[ij32] )\n{\n    continue;\n}\n_ij32[0] = ij32; _ij32[1] = -1;\nfor(int iij32 = ij32+1; iij32 < 2; ++iij32)\n{\nif( j32valid[iij32] && IKabs(cj32array[ij32]-cj32array[iij32]) < IKFAST_SOLUTION_THRESH && IKabs(sj32array[ij32]-sj32array[iij32]) < IKFAST_SOLUTION_THRESH )\n{\n    j32valid[iij32]=false; _ij32[1] = iij32; break; \n}\n}\nj32 = j32array[ij32]; cj32 = cj32array[ij32]; sj32 = sj32array[ij32];\n\n{\nIkReal j31eval[2];\nIkReal x212=(sj27*sj29);\nIkReal x213=(cj27*sj29);\nIkReal x214=(cj28*sj29);\nIkReal x215=(cj28*cj30);\nIkReal x216=((1.0)*sj30);\nIkReal x217=((1.0)*cj29);\nIkReal x218=(cj29*x216);\nIkReal x219=((1.0)*cj30*sj28);\nIkReal x220=x200;\nIkReal x221=x201;\nIkReal x222=x202;\nIkReal x223=(x215+(((-1.0)*sj28*x218)));\nIkReal x224=(cj27*x223);\nIkReal x225=x205;\nIkReal x226=((((-1.0)*cj28*x218))+(((-1.0)*x219)));\nIkReal x227=(cj27*x225);\nIkReal x228=(((sj30*x213))+((sj27*x223)));\nIkReal x229=(x224+(((-1.0)*sj30*x212)));\nIkReal x230=(((cj30*x213))+((sj27*x225)));\nIkReal x231=(x227+(((-1.0)*cj30*x212)));\nnew_r00=(((r20*x220))+((r10*x230))+((r00*((x227+(((-1.0)*cj30*x212)))))));\nnew_r01=(((r11*x230))+((r01*x231))+((r21*x220)));\nnew_r02=(((r02*x231))+((r22*x220))+((r12*x230)));\nnew_r10=(((r00*x221))+((r10*x222))+((r20*x214)));\nnew_r11=(((r21*x214))+((r01*x221))+((r11*x222)));\nnew_r12=(((r12*x222))+((r22*x214))+((r02*x221)));\nnew_r20=(((r20*x226))+((r00*x229))+((r10*x228)));\nnew_r21=(((r01*x229))+((r11*x228))+((r21*x226)));\nnew_r22=(((r12*x228))+((r22*x226))+((r02*((x224+(((-1.0)*x212*x216)))))));\nj31eval[0]=sj32;\nj31eval[1]=IKsign(sj32);\nif( IKabs(j31eval[0]) < 0.0000010000000000  || IKabs(j31eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j31eval[1];\nIkReal x232=(sj27*sj29);\nIkReal x233=(cj27*sj29);\nIkReal x234=(cj28*sj29);\nIkReal x235=(cj28*cj30);\nIkReal x236=((1.0)*sj30);\nIkReal x237=((1.0)*cj29);\nIkReal x238=(cj29*x236);\nIkReal x239=((1.0)*cj30*sj28);\nIkReal x240=x200;\nIkReal x241=x201;\nIkReal x242=x202;\nIkReal x243=(x235+(((-1.0)*sj28*x238)));\nIkReal x244=(cj27*x243);\nIkReal x245=x205;\nIkReal x246=((((-1.0)*cj28*x238))+(((-1.0)*x239)));\nIkReal x247=(cj27*x245);\nIkReal x248=(((sj27*x243))+((sj30*x233)));\nIkReal x249=(x244+(((-1.0)*sj30*x232)));\nIkReal x250=(((sj27*x245))+((cj30*x233)));\nIkReal x251=(x247+(((-1.0)*cj30*x232)));\nnew_r00=(((r10*x250))+((r00*((x247+(((-1.0)*cj30*x232))))))+((r20*x240)));\nnew_r01=(((r11*x250))+((r01*x251))+((r21*x240)));\nnew_r02=(((r22*x240))+((r12*x250))+((r02*x251)));\nnew_r10=(((r20*x234))+((r00*x241))+((r10*x242)));\nnew_r11=(((r01*x241))+((r11*x242))+((r21*x234)));\nnew_r12=(((r02*x241))+((r12*x242))+((r22*x234)));\nnew_r20=(((r00*x249))+((r10*x248))+((r20*x246)));\nnew_r21=(((r21*x246))+((r01*x249))+((r11*x248)));\nnew_r22=(((r22*x246))+((r12*x248))+((r02*((x244+(((-1.0)*x232*x236)))))));\nj31eval[0]=sj32;\nif( IKabs(j31eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j31array[2], cj31array[2], sj31array[2];\nbool j31valid[2]={false};\n_nj31 = 2;\nCheckValue<IkReal> x253 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x253.valid){\ncontinue;\n}\nIkReal x252=x253.value;\nj31array[0]=((-1.0)*x252);\nsj31array[0]=IKsin(j31array[0]);\ncj31array[0]=IKcos(j31array[0]);\nj31array[1]=((3.14159265358979)+(((-1.0)*x252)));\nsj31array[1]=IKsin(j31array[1]);\ncj31array[1]=IKcos(j31array[1]);\nif( j31array[0] > IKPI )\n{\n    j31array[0]-=IK2PI;\n}\nelse if( j31array[0] < -IKPI )\n{    j31array[0]+=IK2PI;\n}\nj31valid[0] = true;\nif( j31array[1] > IKPI )\n{\n    j31array[1]-=IK2PI;\n}\nelse if( j31array[1] < -IKPI )\n{    j31array[1]+=IK2PI;\n}\nj31valid[1] = true;\nfor(int ij31 = 0; ij31 < 2; ++ij31)\n{\nif( !j31valid[ij31] )\n{\n    continue;\n}\n_ij31[0] = ij31; _ij31[1] = -1;\nfor(int iij31 = ij31+1; iij31 < 2; ++iij31)\n{\nif( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )\n{\n    j31valid[iij31]=false; _ij31[1] = iij31; break; \n}\n}\nj31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];\n{\nIkReal evalcond[1];\nevalcond[0]=(((new_r12*(IKcos(j31))))+(((-1.0)*new_r02*(IKsin(j31)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nIkReal x254=((1.0)*sj31);\nif( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x254)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x254))+((cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x254))))+IKsqr(((((-1.0)*new_r01*x254))+((cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x254))), ((((-1.0)*new_r01*x254))+((cj31*new_r00))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x255=IKsin(j33);\nIkReal x256=IKcos(j33);\nIkReal x257=((1.0)*sj31);\nIkReal x258=((1.0)*x256);\nIkReal x259=(sj31*x255);\nIkReal x260=((1.0)*x255);\nIkReal x261=(cj31*x258);\nevalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x255);\nevalcond[1]=(((cj31*x255))+((sj31*x256))+new_r01);\nevalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x258)));\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*x260))+(((-1.0)*new_r00*x257)));\nevalcond[4]=((((-1.0)*new_r01*x257))+((cj31*new_r11))+(((-1.0)*x258)));\nevalcond[5]=(x259+new_r00+(((-1.0)*x261)));\nevalcond[6]=(x259+new_r11+(((-1.0)*x261)));\nevalcond[7]=((((-1.0)*x256*x257))+(((-1.0)*cj31*x260))+new_r10);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j31array[2], cj31array[2], sj31array[2];\nbool j31valid[2]={false};\n_nj31 = 2;\nCheckValue<IkReal> x263 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x263.valid){\ncontinue;\n}\nIkReal x262=x263.value;\nj31array[0]=((-1.0)*x262);\nsj31array[0]=IKsin(j31array[0]);\ncj31array[0]=IKcos(j31array[0]);\nj31array[1]=((3.14159265358979)+(((-1.0)*x262)));\nsj31array[1]=IKsin(j31array[1]);\ncj31array[1]=IKcos(j31array[1]);\nif( j31array[0] > IKPI )\n{\n    j31array[0]-=IK2PI;\n}\nelse if( j31array[0] < -IKPI )\n{    j31array[0]+=IK2PI;\n}\nj31valid[0] = true;\nif( j31array[1] > IKPI )\n{\n    j31array[1]-=IK2PI;\n}\nelse if( j31array[1] < -IKPI )\n{    j31array[1]+=IK2PI;\n}\nj31valid[1] = true;\nfor(int ij31 = 0; ij31 < 2; ++ij31)\n{\nif( !j31valid[ij31] )\n{\n    continue;\n}\n_ij31[0] = ij31; _ij31[1] = -1;\nfor(int iij31 = ij31+1; iij31 < 2; ++iij31)\n{\nif( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )\n{\n    j31valid[iij31]=false; _ij31[1] = iij31; break; \n}\n}\nj31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];\n{\nIkReal evalcond[1];\nevalcond[0]=(((new_r12*(IKcos(j31))))+(((-1.0)*new_r02*(IKsin(j31)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nIkReal x264=((1.0)*sj31);\nif( IKabs(((((-1.0)*new_r00*x264))+((cj31*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x264))+(((-1.0)*cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x264))+((cj31*new_r01))))+IKsqr(((((-1.0)*new_r01*x264))+(((-1.0)*cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((((-1.0)*new_r00*x264))+((cj31*new_r01))), ((((-1.0)*new_r01*x264))+(((-1.0)*cj31*new_r00))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x265=IKsin(j33);\nIkReal x266=IKcos(j33);\nIkReal x267=((1.0)*sj31);\nIkReal x268=((1.0)*x265);\nIkReal x269=(sj31*x266);\nIkReal x270=((1.0)*x266);\nIkReal x271=(cj31*x268);\nevalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x266);\nevalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x268)));\nevalcond[2]=(((sj31*x265))+((cj31*x266))+new_r00);\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x267))+(((-1.0)*x268)));\nevalcond[4]=((((-1.0)*new_r01*x267))+((cj31*new_r11))+(((-1.0)*x270)));\nevalcond[5]=(x269+(((-1.0)*x271))+new_r01);\nevalcond[6]=(x269+(((-1.0)*x271))+new_r10);\nevalcond[7]=((((-1.0)*cj31*x270))+(((-1.0)*x265*x267))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j31, j33]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j31array[1], cj31array[1], sj31array[1];\nbool j31valid[1]={false};\n_nj31 = 1;\nCheckValue<IkReal> x273=IKPowWithIntegerCheck(sj32,-1);\nif(!x273.valid){\ncontinue;\n}\nIkReal x272=x273.value;\nCheckValue<IkReal> x274=IKPowWithIntegerCheck(new_r12,-1);\nif(!x274.valid){\ncontinue;\n}\nif( IKabs((x272*(x274.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x272)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x272*(x274.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32)))))))+IKsqr((new_r02*x272))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj31array[0]=IKatan2((x272*(x274.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32)))))), (new_r02*x272));\nsj31array[0]=IKsin(j31array[0]);\ncj31array[0]=IKcos(j31array[0]);\nif( j31array[0] > IKPI )\n{\n    j31array[0]-=IK2PI;\n}\nelse if( j31array[0] < -IKPI )\n{    j31array[0]+=IK2PI;\n}\nj31valid[0] = true;\nfor(int ij31 = 0; ij31 < 1; ++ij31)\n{\nif( !j31valid[ij31] )\n{\n    continue;\n}\n_ij31[0] = ij31; _ij31[1] = -1;\nfor(int iij31 = ij31+1; iij31 < 1; ++iij31)\n{\nif( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )\n{\n    j31valid[iij31]=false; _ij31[1] = iij31; break; \n}\n}\nj31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];\n{\nIkReal evalcond[8];\nIkReal x275=IKcos(j31);\nIkReal x276=IKsin(j31);\nIkReal x277=((1.0)*sj32);\nIkReal x278=(new_r02*x275);\nIkReal x279=(new_r12*x276);\nIkReal x280=(sj32*x275);\nIkReal x281=(sj32*x276);\nevalcond[0]=((((-1.0)*x275*x277))+new_r02);\nevalcond[1]=(new_r12+(((-1.0)*x276*x277)));\nevalcond[2]=((((-1.0)*new_r02*x276))+((new_r12*x275)));\nevalcond[3]=(x278+x279+(((-1.0)*x277)));\nevalcond[4]=(((cj32*new_r20))+((new_r00*x280))+((new_r10*x281)));\nevalcond[5]=(((cj32*new_r21))+((new_r11*x281))+((new_r01*x280)));\nevalcond[6]=((-1.0)+((sj32*x278))+((sj32*x279))+((cj32*new_r22)));\nevalcond[7]=((((-1.0)*new_r22*x277))+((cj32*x279))+((cj32*x278)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j33eval[2];\nIkReal x282=(sj27*sj29);\nIkReal x283=(cj27*sj29);\nIkReal x284=(cj28*sj29);\nIkReal x285=(cj28*cj30);\nIkReal x286=((1.0)*sj30);\nIkReal x287=((1.0)*cj29);\nIkReal x288=(cj29*x286);\nIkReal x289=((1.0)*cj30*sj28);\nIkReal x290=x200;\nIkReal x291=x201;\nIkReal x292=x202;\nIkReal x293=(x285+(((-1.0)*sj28*x288)));\nIkReal x294=(cj27*x293);\nIkReal x295=x205;\nIkReal x296=((((-1.0)*cj28*x288))+(((-1.0)*x289)));\nIkReal x297=(cj27*x295);\nIkReal x298=(((sj30*x283))+((sj27*x293)));\nIkReal x299=(x294+(((-1.0)*sj30*x282)));\nIkReal x300=(((cj30*x283))+((sj27*x295)));\nIkReal x301=((((-1.0)*cj30*x282))+x297);\nnew_r00=(((r20*x290))+((r00*(((((-1.0)*cj30*x282))+x297))))+((r10*x300)));\nnew_r01=(((r11*x300))+((r01*x301))+((r21*x290)));\nnew_r02=(((r02*x301))+((r22*x290))+((r12*x300)));\nnew_r10=(((r00*x291))+((r10*x292))+((r20*x284)));\nnew_r11=(((r21*x284))+((r01*x291))+((r11*x292)));\nnew_r12=(((r12*x292))+((r22*x284))+((r02*x291)));\nnew_r20=(((r20*x296))+((r00*x299))+((r10*x298)));\nnew_r21=(((r01*x299))+((r21*x296))+((r11*x298)));\nnew_r22=(((r12*x298))+((r22*x296))+((r02*((x294+(((-1.0)*x282*x286)))))));\nj33eval[0]=sj32;\nj33eval[1]=IKsign(sj32);\nif( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j33eval[2];\nIkReal x302=(sj27*sj29);\nIkReal x303=(cj27*sj29);\nIkReal x304=(cj28*sj29);\nIkReal x305=(cj28*cj30);\nIkReal x306=((1.0)*sj30);\nIkReal x307=((1.0)*cj29);\nIkReal x308=(cj29*x306);\nIkReal x309=((1.0)*cj30*sj28);\nIkReal x310=x200;\nIkReal x311=x201;\nIkReal x312=x202;\nIkReal x313=((((-1.0)*sj28*x308))+x305);\nIkReal x314=(cj27*x313);\nIkReal x315=x205;\nIkReal x316=((((-1.0)*cj28*x308))+(((-1.0)*x309)));\nIkReal x317=(cj27*x315);\nIkReal x318=(((sj27*x313))+((sj30*x303)));\nIkReal x319=(x314+(((-1.0)*sj30*x302)));\nIkReal x320=(((cj30*x303))+((sj27*x315)));\nIkReal x321=((((-1.0)*cj30*x302))+x317);\nnew_r00=(((r20*x310))+((r10*x320))+((r00*(((((-1.0)*cj30*x302))+x317)))));\nnew_r01=(((r11*x320))+((r01*x321))+((r21*x310)));\nnew_r02=(((r02*x321))+((r12*x320))+((r22*x310)));\nnew_r10=(((r20*x304))+((r00*x311))+((r10*x312)));\nnew_r11=(((r11*x312))+((r21*x304))+((r01*x311)));\nnew_r12=(((r22*x304))+((r02*x311))+((r12*x312)));\nnew_r20=(((r20*x316))+((r00*x319))+((r10*x318)));\nnew_r21=(((r11*x318))+((r01*x319))+((r21*x316)));\nnew_r22=(((r02*(((((-1.0)*x302*x306))+x314))))+((r12*x318))+((r22*x316)));\nj33eval[0]=sj32;\nj33eval[1]=sj31;\nif( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j33eval[3];\nIkReal x322=(sj27*sj29);\nIkReal x323=(cj27*sj29);\nIkReal x324=(cj28*sj29);\nIkReal x325=(cj28*cj30);\nIkReal x326=((1.0)*sj30);\nIkReal x327=((1.0)*cj29);\nIkReal x328=(cj29*x326);\nIkReal x329=((1.0)*cj30*sj28);\nIkReal x330=x200;\nIkReal x331=x201;\nIkReal x332=x202;\nIkReal x333=(x325+(((-1.0)*sj28*x328)));\nIkReal x334=(cj27*x333);\nIkReal x335=x205;\nIkReal x336=((((-1.0)*cj28*x328))+(((-1.0)*x329)));\nIkReal x337=(cj27*x335);\nIkReal x338=(((sj30*x323))+((sj27*x333)));\nIkReal x339=((((-1.0)*sj30*x322))+x334);\nIkReal x340=(((sj27*x335))+((cj30*x323)));\nIkReal x341=(x337+(((-1.0)*cj30*x322)));\nnew_r00=(((r20*x330))+((r00*((x337+(((-1.0)*cj30*x322))))))+((r10*x340)));\nnew_r01=(((r01*x341))+((r21*x330))+((r11*x340)));\nnew_r02=(((r22*x330))+((r02*x341))+((r12*x340)));\nnew_r10=(((r00*x331))+((r20*x324))+((r10*x332)));\nnew_r11=(((r01*x331))+((r11*x332))+((r21*x324)));\nnew_r12=(((r12*x332))+((r02*x331))+((r22*x324)));\nnew_r20=(((r00*x339))+((r20*x336))+((r10*x338)));\nnew_r21=(((r01*x339))+((r11*x338))+((r21*x336)));\nnew_r22=(((r22*x336))+((r02*(((((-1.0)*x322*x326))+x334))))+((r12*x338)));\nj33eval[0]=cj32;\nj33eval[1]=sj31;\nj33eval[2]=sj32;\nif( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x342=((1.0)*sj31);\nIkReal x343=((((-1.0)*new_r02*x342))+((cj31*new_r12)));\nIkReal x344=(((cj31*new_r00))+((new_r10*sj31)));\nIkReal x345=(((cj31*new_r01))+((new_r11*sj31)));\nIkReal x346=((-1.0)+((cj31*new_r02))+((new_r12*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*cj31))+new_r02);\nevalcond[3]=(new_r12+(((-1.0)*x342)));\nevalcond[4]=x343;\nevalcond[5]=x343;\nevalcond[6]=x346;\nevalcond[7]=x345;\nevalcond[8]=x344;\nevalcond[9]=x344;\nevalcond[10]=x345;\nevalcond[11]=x346;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x347=IKcos(j33);\nIkReal x348=IKsin(j33);\nIkReal x349=((1.0)*new_r12);\nIkReal x350=((1.0)*x348);\nIkReal x351=((1.0)*x347);\nevalcond[0]=(x347+new_r20);\nevalcond[1]=((((-1.0)*x350))+new_r21);\nevalcond[2]=(((new_r12*x347))+new_r01);\nevalcond[3]=(((new_r12*x348))+new_r00);\nevalcond[4]=((((-1.0)*new_r02*x351))+new_r11);\nevalcond[5]=((((-1.0)*new_r02*x350))+new_r10);\nevalcond[6]=((((-1.0)*x350))+(((-1.0)*new_r00*x349))+((new_r02*new_r10)));\nevalcond[7]=((((-1.0)*x351))+((new_r02*new_r11))+(((-1.0)*new_r01*x349)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x352=(new_r10*sj31);\nIkReal x353=(cj31*new_r00);\nIkReal x354=(cj31*new_r02);\nIkReal x355=(new_r11*sj31);\nIkReal x356=(new_r12*sj31);\nIkReal x357=(cj31*new_r01);\nIkReal x358=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(cj31+new_r02);\nevalcond[3]=(sj31+new_r12);\nevalcond[4]=x358;\nevalcond[5]=x358;\nevalcond[6]=((1.0)+x354+x356);\nevalcond[7]=(x355+x357);\nevalcond[8]=(x353+x352);\nevalcond[9]=((((-1.0)*x353))+(((-1.0)*x352)));\nevalcond[10]=((((-1.0)*x357))+(((-1.0)*x355)));\nevalcond[11]=((-1.0)+(((-1.0)*x356))+(((-1.0)*x354)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((-1.0)*new_r21), new_r20);\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x359=IKcos(j33);\nIkReal x360=IKsin(j33);\nIkReal x361=((1.0)*new_r02);\nIkReal x362=((1.0)*x359);\nIkReal x363=((1.0)*x360);\nevalcond[0]=(x360+new_r21);\nevalcond[1]=((((-1.0)*x362))+new_r20);\nevalcond[2]=(new_r11+((new_r02*x359)));\nevalcond[3]=(new_r10+((new_r02*x360)));\nevalcond[4]=((((-1.0)*new_r12*x362))+new_r01);\nevalcond[5]=((((-1.0)*new_r12*x363))+new_r00);\nevalcond[6]=((((-1.0)*x363))+((new_r00*new_r12))+(((-1.0)*new_r10*x361)));\nevalcond[7]=((((-1.0)*x362))+((new_r01*new_r12))+(((-1.0)*new_r11*x361)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x364=((((-1.0)*cj32))+new_r22);\nIkReal x365=((((-1.0)*sj32))+new_r02);\nIkReal x366=((1.0)*sj32);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));\nevalcond[1]=x364;\nevalcond[2]=x364;\nevalcond[3]=x365;\nevalcond[4]=new_r12;\nevalcond[5]=x365;\nevalcond[6]=(((new_r00*sj32))+((cj32*new_r20)));\nevalcond[7]=(((new_r01*sj32))+((cj32*new_r21)));\nevalcond[8]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));\nevalcond[9]=(((cj32*new_r02))+(((-1.0)*new_r22*x366)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(new_r10, new_r11);\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x367=IKcos(j33);\nIkReal x368=IKsin(j33);\nIkReal x369=((1.0)*new_r02);\nIkReal x370=((1.0)*x367);\nevalcond[0]=(new_r20+((new_r02*x367)));\nevalcond[1]=((((-1.0)*x368))+new_r10);\nevalcond[2]=((((-1.0)*x370))+new_r11);\nevalcond[3]=(((new_r22*x368))+new_r01);\nevalcond[4]=(new_r21+(((-1.0)*x368*x369)));\nevalcond[5]=((((-1.0)*new_r22*x370))+new_r00);\nevalcond[6]=(((new_r01*new_r22))+x368+(((-1.0)*new_r21*x369)));\nevalcond[7]=((((-1.0)*new_r20*x369))+((new_r00*new_r22))+(((-1.0)*x370)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x371=((((-1.0)*cj32))+new_r22);\nIkReal x372=((1.0)*sj32);\nIkReal x373=((1.0)*new_r02);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));\nevalcond[1]=x371;\nevalcond[2]=x371;\nevalcond[3]=(sj32+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x372))+(((-1.0)*x373)));\nevalcond[6]=((((-1.0)*new_r00*x372))+((cj32*new_r20)));\nevalcond[7]=(((cj32*new_r21))+(((-1.0)*new_r01*x372)));\nevalcond[8]=((-1.0)+((cj32*new_r22))+(((-1.0)*new_r02*x372)));\nevalcond[9]=((((-1.0)*new_r22*x372))+(((-1.0)*cj32*x373)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x374=IKsin(j33);\nIkReal x375=IKcos(j33);\nIkReal x376=((1.0)*new_r22);\nIkReal x377=((1.0)*x375);\nevalcond[0]=(new_r21+((new_r02*x374)));\nevalcond[1]=(new_r20+(((-1.0)*new_r02*x377)));\nevalcond[2]=((((-1.0)*x374))+(((-1.0)*new_r10)));\nevalcond[3]=((((-1.0)*x377))+(((-1.0)*new_r11)));\nevalcond[4]=((((-1.0)*new_r01))+((new_r22*x374)));\nevalcond[5]=((((-1.0)*new_r00))+(((-1.0)*x375*x376)));\nevalcond[6]=(x374+((new_r02*new_r21))+(((-1.0)*new_r01*x376)));\nevalcond[7]=((((-1.0)*new_r00*x376))+(((-1.0)*x377))+((new_r02*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x378=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));\nIkReal x379=(((cj31*new_r02))+((new_r12*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x378;\nevalcond[7]=x378;\nevalcond[8]=x379;\nevalcond[9]=x379;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nIkReal x380=((1.0)*sj31);\nif( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x380)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj31*new_r00))+(((-1.0)*new_r01*x380)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x380))))+IKsqr((((cj31*new_r00))+(((-1.0)*new_r01*x380))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x380))), (((cj31*new_r00))+(((-1.0)*new_r01*x380))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x381=IKsin(j33);\nIkReal x382=IKcos(j33);\nIkReal x383=((1.0)*sj31);\nIkReal x384=((1.0)*x382);\nIkReal x385=(sj31*x381);\nIkReal x386=((1.0)*x381);\nIkReal x387=(cj31*x384);\nevalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x381);\nevalcond[1]=(((sj31*x382))+((cj31*x381))+new_r01);\nevalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x384)));\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x383))+(((-1.0)*x386)));\nevalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x383))+(((-1.0)*x384)));\nevalcond[5]=(x385+(((-1.0)*x387))+new_r00);\nevalcond[6]=(x385+(((-1.0)*x387))+new_r11);\nevalcond[7]=(new_r10+(((-1.0)*cj31*x386))+(((-1.0)*x382*x383)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x388=(cj31*new_r02);\nIkReal x389=(new_r12*sj31);\nIkReal x390=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x390;\nevalcond[7]=x390;\nevalcond[8]=(x388+x389);\nevalcond[9]=((((-1.0)*x388))+(((-1.0)*x389)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nIkReal x391=((1.0)*sj31);\nif( IKabs((((cj31*new_r01))+(((-1.0)*new_r00*x391)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x391))+(((-1.0)*cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj31*new_r01))+(((-1.0)*new_r00*x391))))+IKsqr(((((-1.0)*new_r01*x391))+(((-1.0)*cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2((((cj31*new_r01))+(((-1.0)*new_r00*x391))), ((((-1.0)*new_r01*x391))+(((-1.0)*cj31*new_r00))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x392=IKsin(j33);\nIkReal x393=IKcos(j33);\nIkReal x394=((1.0)*sj31);\nIkReal x395=((1.0)*x392);\nIkReal x396=(sj31*x393);\nIkReal x397=((1.0)*x393);\nIkReal x398=(cj31*x395);\nevalcond[0]=(((cj31*new_r00))+x393+((new_r10*sj31)));\nevalcond[1]=((((-1.0)*x395))+((cj31*new_r01))+((new_r11*sj31)));\nevalcond[2]=(((cj31*x393))+((sj31*x392))+new_r00);\nevalcond[3]=((((-1.0)*x395))+((cj31*new_r10))+(((-1.0)*new_r00*x394)));\nevalcond[4]=((((-1.0)*new_r01*x394))+(((-1.0)*x397))+((cj31*new_r11)));\nevalcond[5]=((((-1.0)*x398))+x396+new_r01);\nevalcond[6]=((((-1.0)*x398))+x396+new_r10);\nevalcond[7]=((((-1.0)*cj31*x397))+new_r11+(((-1.0)*x392*x394)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j33]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x400=IKPowWithIntegerCheck(sj32,-1);\nif(!x400.valid){\ncontinue;\n}\nIkReal x399=x400.value;\nCheckValue<IkReal> x401=IKPowWithIntegerCheck(cj32,-1);\nif(!x401.valid){\ncontinue;\n}\nCheckValue<IkReal> x402=IKPowWithIntegerCheck(sj31,-1);\nif(!x402.valid){\ncontinue;\n}\nif( IKabs((x399*(x401.value)*(x402.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x399)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x399*(x401.value)*(x402.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20))))))+IKsqr(((-1.0)*new_r20*x399))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2((x399*(x401.value)*(x402.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20))))), ((-1.0)*new_r20*x399));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[12];\nIkReal x403=IKsin(j33);\nIkReal x404=IKcos(j33);\nIkReal x405=(cj31*cj32);\nIkReal x406=((1.0)*sj31);\nIkReal x407=(new_r11*sj31);\nIkReal x408=(new_r10*sj31);\nIkReal x409=((1.0)*sj32);\nIkReal x410=((1.0)*x404);\nIkReal x411=((1.0)*x403);\nIkReal x412=(sj31*x403);\nevalcond[0]=(new_r20+((sj32*x404)));\nevalcond[1]=((((-1.0)*x403*x409))+new_r21);\nevalcond[2]=(((cj32*x403))+((cj31*new_r01))+x407);\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x406))+(((-1.0)*x411)));\nevalcond[4]=(((cj31*new_r11))+(((-1.0)*x410))+(((-1.0)*new_r01*x406)));\nevalcond[5]=(((sj31*x404))+new_r01+((x403*x405)));\nevalcond[6]=(((cj31*new_r00))+x408+(((-1.0)*cj32*x410)));\nevalcond[7]=(x412+(((-1.0)*x405*x410))+new_r00);\nevalcond[8]=(((cj32*x412))+(((-1.0)*cj31*x410))+new_r11);\nevalcond[9]=((((-1.0)*cj32*x404*x406))+(((-1.0)*cj31*x411))+new_r10);\nevalcond[10]=(((cj32*x407))+x403+(((-1.0)*new_r21*x409))+((new_r01*x405)));\nevalcond[11]=(((cj32*x408))+(((-1.0)*new_r20*x409))+(((-1.0)*x410))+((new_r00*x405)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x414=IKPowWithIntegerCheck(sj32,-1);\nif(!x414.valid){\ncontinue;\n}\nIkReal x413=x414.value;\nCheckValue<IkReal> x415=IKPowWithIntegerCheck(sj31,-1);\nif(!x415.valid){\ncontinue;\n}\nif( IKabs((new_r21*x413)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x413*(x415.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x413))+IKsqr((x413*(x415.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2((new_r21*x413), (x413*(x415.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[12];\nIkReal x416=IKsin(j33);\nIkReal x417=IKcos(j33);\nIkReal x418=(cj31*cj32);\nIkReal x419=((1.0)*sj31);\nIkReal x420=(new_r11*sj31);\nIkReal x421=(new_r10*sj31);\nIkReal x422=((1.0)*sj32);\nIkReal x423=((1.0)*x417);\nIkReal x424=((1.0)*x416);\nIkReal x425=(sj31*x416);\nevalcond[0]=(((sj32*x417))+new_r20);\nevalcond[1]=((((-1.0)*x416*x422))+new_r21);\nevalcond[2]=(((cj32*x416))+((cj31*new_r01))+x420);\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*x424))+(((-1.0)*new_r00*x419)));\nevalcond[4]=(((cj31*new_r11))+(((-1.0)*x423))+(((-1.0)*new_r01*x419)));\nevalcond[5]=(((x416*x418))+((sj31*x417))+new_r01);\nevalcond[6]=(((cj31*new_r00))+x421+(((-1.0)*cj32*x423)));\nevalcond[7]=(x425+(((-1.0)*x418*x423))+new_r00);\nevalcond[8]=((((-1.0)*cj31*x423))+((cj32*x425))+new_r11);\nevalcond[9]=((((-1.0)*cj32*x417*x419))+(((-1.0)*cj31*x424))+new_r10);\nevalcond[10]=(x416+((cj32*x420))+(((-1.0)*new_r21*x422))+((new_r01*x418)));\nevalcond[11]=((((-1.0)*x423))+((cj32*x421))+(((-1.0)*new_r20*x422))+((new_r00*x418)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x426=IKPowWithIntegerCheck(IKsign(sj32),-1);\nif(!x426.valid){\ncontinue;\n}\nCheckValue<IkReal> x427 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x427.valid){\ncontinue;\n}\nj33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x426.value)))+(x427.value));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[12];\nIkReal x428=IKsin(j33);\nIkReal x429=IKcos(j33);\nIkReal x430=(cj31*cj32);\nIkReal x431=((1.0)*sj31);\nIkReal x432=(new_r11*sj31);\nIkReal x433=(new_r10*sj31);\nIkReal x434=((1.0)*sj32);\nIkReal x435=((1.0)*x429);\nIkReal x436=((1.0)*x428);\nIkReal x437=(sj31*x428);\nevalcond[0]=(new_r20+((sj32*x429)));\nevalcond[1]=(new_r21+(((-1.0)*x428*x434)));\nevalcond[2]=(((cj31*new_r01))+x432+((cj32*x428)));\nevalcond[3]=((((-1.0)*new_r00*x431))+(((-1.0)*x436))+((cj31*new_r10)));\nevalcond[4]=((((-1.0)*x435))+(((-1.0)*new_r01*x431))+((cj31*new_r11)));\nevalcond[5]=(((x428*x430))+((sj31*x429))+new_r01);\nevalcond[6]=(((cj31*new_r00))+x433+(((-1.0)*cj32*x435)));\nevalcond[7]=((((-1.0)*x430*x435))+x437+new_r00);\nevalcond[8]=(((cj32*x437))+(((-1.0)*cj31*x435))+new_r11);\nevalcond[9]=((((-1.0)*cj32*x429*x431))+(((-1.0)*cj31*x436))+new_r10);\nevalcond[10]=(((new_r01*x430))+((cj32*x432))+x428+(((-1.0)*new_r21*x434)));\nevalcond[11]=((((-1.0)*x435))+((new_r00*x430))+((cj32*x433))+(((-1.0)*new_r20*x434)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j31array[1], cj31array[1], sj31array[1];\nbool j31valid[1]={false};\n_nj31 = 1;\nCheckValue<IkReal> x438=IKPowWithIntegerCheck(IKsign(sj32),-1);\nif(!x438.valid){\ncontinue;\n}\nCheckValue<IkReal> x439 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);\nif(!x439.valid){\ncontinue;\n}\nj31array[0]=((-1.5707963267949)+(((1.5707963267949)*(x438.value)))+(x439.value));\nsj31array[0]=IKsin(j31array[0]);\ncj31array[0]=IKcos(j31array[0]);\nif( j31array[0] > IKPI )\n{\n    j31array[0]-=IK2PI;\n}\nelse if( j31array[0] < -IKPI )\n{    j31array[0]+=IK2PI;\n}\nj31valid[0] = true;\nfor(int ij31 = 0; ij31 < 1; ++ij31)\n{\nif( !j31valid[ij31] )\n{\n    continue;\n}\n_ij31[0] = ij31; _ij31[1] = -1;\nfor(int iij31 = ij31+1; iij31 < 1; ++iij31)\n{\nif( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )\n{\n    j31valid[iij31]=false; _ij31[1] = iij31; break; \n}\n}\nj31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];\n{\nIkReal evalcond[8];\nIkReal x440=IKcos(j31);\nIkReal x441=IKsin(j31);\nIkReal x442=((1.0)*sj32);\nIkReal x443=(new_r02*x440);\nIkReal x444=(new_r12*x441);\nIkReal x445=(sj32*x440);\nIkReal x446=(sj32*x441);\nevalcond[0]=(new_r02+(((-1.0)*x440*x442)));\nevalcond[1]=(new_r12+(((-1.0)*x441*x442)));\nevalcond[2]=(((new_r12*x440))+(((-1.0)*new_r02*x441)));\nevalcond[3]=((((-1.0)*x442))+x444+x443);\nevalcond[4]=(((new_r00*x445))+((new_r10*x446))+((cj32*new_r20)));\nevalcond[5]=(((new_r01*x445))+((new_r11*x446))+((cj32*new_r21)));\nevalcond[6]=((-1.0)+((sj32*x444))+((sj32*x443))+((cj32*new_r22)));\nevalcond[7]=(((cj32*x443))+((cj32*x444))+(((-1.0)*new_r22*x442)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j33eval[2];\nIkReal x447=(sj27*sj29);\nIkReal x448=(cj27*sj29);\nIkReal x449=(cj28*sj29);\nIkReal x450=(cj28*cj30);\nIkReal x451=((1.0)*sj30);\nIkReal x452=((1.0)*cj29);\nIkReal x453=(cj29*x451);\nIkReal x454=((1.0)*cj30*sj28);\nIkReal x455=x200;\nIkReal x456=x201;\nIkReal x457=x202;\nIkReal x458=((((-1.0)*sj28*x453))+x450);\nIkReal x459=(cj27*x458);\nIkReal x460=x205;\nIkReal x461=((((-1.0)*cj28*x453))+(((-1.0)*x454)));\nIkReal x462=(cj27*x460);\nIkReal x463=(((sj30*x448))+((sj27*x458)));\nIkReal x464=(x459+(((-1.0)*sj30*x447)));\nIkReal x465=(((sj27*x460))+((cj30*x448)));\nIkReal x466=((((-1.0)*cj30*x447))+x462);\nnew_r00=(((r20*x455))+((r00*(((((-1.0)*cj30*x447))+x462))))+((r10*x465)));\nnew_r01=(((r11*x465))+((r01*x466))+((r21*x455)));\nnew_r02=(((r12*x465))+((r02*x466))+((r22*x455)));\nnew_r10=(((r00*x456))+((r20*x449))+((r10*x457)));\nnew_r11=(((r21*x449))+((r11*x457))+((r01*x456)));\nnew_r12=(((r22*x449))+((r12*x457))+((r02*x456)));\nnew_r20=(((r20*x461))+((r00*x464))+((r10*x463)));\nnew_r21=(((r11*x463))+((r01*x464))+((r21*x461)));\nnew_r22=(((r22*x461))+((r12*x463))+((r02*(((((-1.0)*x447*x451))+x459)))));\nj33eval[0]=sj32;\nj33eval[1]=IKsign(sj32);\nif( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j33eval[2];\nIkReal x467=(sj27*sj29);\nIkReal x468=(cj27*sj29);\nIkReal x469=(cj28*sj29);\nIkReal x470=(cj28*cj30);\nIkReal x471=((1.0)*sj30);\nIkReal x472=((1.0)*cj29);\nIkReal x473=(cj29*x471);\nIkReal x474=((1.0)*cj30*sj28);\nIkReal x475=x200;\nIkReal x476=x201;\nIkReal x477=x202;\nIkReal x478=((((-1.0)*sj28*x473))+x470);\nIkReal x479=(cj27*x478);\nIkReal x480=x205;\nIkReal x481=((((-1.0)*cj28*x473))+(((-1.0)*x474)));\nIkReal x482=(cj27*x480);\nIkReal x483=(((sj27*x478))+((sj30*x468)));\nIkReal x484=((((-1.0)*sj30*x467))+x479);\nIkReal x485=(((sj27*x480))+((cj30*x468)));\nIkReal x486=(x482+(((-1.0)*cj30*x467)));\nnew_r00=(((r20*x475))+((r00*((x482+(((-1.0)*cj30*x467))))))+((r10*x485)));\nnew_r01=(((r21*x475))+((r11*x485))+((r01*x486)));\nnew_r02=(((r02*x486))+((r12*x485))+((r22*x475)));\nnew_r10=(((r10*x477))+((r20*x469))+((r00*x476)));\nnew_r11=(((r11*x477))+((r21*x469))+((r01*x476)));\nnew_r12=(((r22*x469))+((r02*x476))+((r12*x477)));\nnew_r20=(((r20*x481))+((r10*x483))+((r00*x484)));\nnew_r21=(((r11*x483))+((r21*x481))+((r01*x484)));\nnew_r22=(((r12*x483))+((r02*(((((-1.0)*x467*x471))+x479))))+((r22*x481)));\nj33eval[0]=sj32;\nj33eval[1]=sj31;\nif( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j33eval[3];\nIkReal x487=(sj27*sj29);\nIkReal x488=(cj27*sj29);\nIkReal x489=(cj28*sj29);\nIkReal x490=(cj28*cj30);\nIkReal x491=((1.0)*sj30);\nIkReal x492=((1.0)*cj29);\nIkReal x493=(cj29*x491);\nIkReal x494=((1.0)*cj30*sj28);\nIkReal x495=x200;\nIkReal x496=x201;\nIkReal x497=x202;\nIkReal x498=(x490+(((-1.0)*sj28*x493)));\nIkReal x499=(cj27*x498);\nIkReal x500=x205;\nIkReal x501=((((-1.0)*x494))+(((-1.0)*cj28*x493)));\nIkReal x502=(cj27*x500);\nIkReal x503=(((sj27*x498))+((sj30*x488)));\nIkReal x504=((((-1.0)*sj30*x487))+x499);\nIkReal x505=(((sj27*x500))+((cj30*x488)));\nIkReal x506=((((-1.0)*cj30*x487))+x502);\nnew_r00=(((r10*x505))+((r00*(((((-1.0)*cj30*x487))+x502))))+((r20*x495)));\nnew_r01=(((r01*x506))+((r11*x505))+((r21*x495)));\nnew_r02=(((r22*x495))+((r12*x505))+((r02*x506)));\nnew_r10=(((r20*x489))+((r10*x497))+((r00*x496)));\nnew_r11=(((r11*x497))+((r21*x489))+((r01*x496)));\nnew_r12=(((r02*x496))+((r12*x497))+((r22*x489)));\nnew_r20=(((r20*x501))+((r10*x503))+((r00*x504)));\nnew_r21=(((r21*x501))+((r01*x504))+((r11*x503)));\nnew_r22=(((r02*((x499+(((-1.0)*x487*x491))))))+((r22*x501))+((r12*x503)));\nj33eval[0]=cj32;\nj33eval[1]=sj31;\nj33eval[2]=sj32;\nif( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x507=((1.0)*sj31);\nIkReal x508=(((cj31*new_r12))+(((-1.0)*new_r02*x507)));\nIkReal x509=(((cj31*new_r00))+((new_r10*sj31)));\nIkReal x510=(((cj31*new_r01))+((new_r11*sj31)));\nIkReal x511=((-1.0)+((cj31*new_r02))+((new_r12*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*cj31))+new_r02);\nevalcond[3]=((((-1.0)*x507))+new_r12);\nevalcond[4]=x508;\nevalcond[5]=x508;\nevalcond[6]=x511;\nevalcond[7]=x510;\nevalcond[8]=x509;\nevalcond[9]=x509;\nevalcond[10]=x510;\nevalcond[11]=x511;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x512=IKcos(j33);\nIkReal x513=IKsin(j33);\nIkReal x514=((1.0)*new_r12);\nIkReal x515=((1.0)*x513);\nIkReal x516=((1.0)*x512);\nevalcond[0]=(x512+new_r20);\nevalcond[1]=(new_r21+(((-1.0)*x515)));\nevalcond[2]=(((new_r12*x512))+new_r01);\nevalcond[3]=(((new_r12*x513))+new_r00);\nevalcond[4]=((((-1.0)*new_r02*x516))+new_r11);\nevalcond[5]=((((-1.0)*new_r02*x515))+new_r10);\nevalcond[6]=(((new_r02*new_r10))+(((-1.0)*new_r00*x514))+(((-1.0)*x515)));\nevalcond[7]=((((-1.0)*new_r01*x514))+((new_r02*new_r11))+(((-1.0)*x516)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x517=(new_r10*sj31);\nIkReal x518=(cj31*new_r00);\nIkReal x519=(cj31*new_r02);\nIkReal x520=(new_r11*sj31);\nIkReal x521=(new_r12*sj31);\nIkReal x522=(cj31*new_r01);\nIkReal x523=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(cj31+new_r02);\nevalcond[3]=(sj31+new_r12);\nevalcond[4]=x523;\nevalcond[5]=x523;\nevalcond[6]=((1.0)+x521+x519);\nevalcond[7]=(x522+x520);\nevalcond[8]=(x518+x517);\nevalcond[9]=((((-1.0)*x518))+(((-1.0)*x517)));\nevalcond[10]=((((-1.0)*x520))+(((-1.0)*x522)));\nevalcond[11]=((-1.0)+(((-1.0)*x521))+(((-1.0)*x519)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((-1.0)*new_r21), new_r20);\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x524=IKcos(j33);\nIkReal x525=IKsin(j33);\nIkReal x526=((1.0)*new_r02);\nIkReal x527=((1.0)*x524);\nIkReal x528=((1.0)*x525);\nevalcond[0]=(x525+new_r21);\nevalcond[1]=((((-1.0)*x527))+new_r20);\nevalcond[2]=(((new_r02*x524))+new_r11);\nevalcond[3]=(((new_r02*x525))+new_r10);\nevalcond[4]=((((-1.0)*new_r12*x527))+new_r01);\nevalcond[5]=((((-1.0)*new_r12*x528))+new_r00);\nevalcond[6]=((((-1.0)*x528))+((new_r00*new_r12))+(((-1.0)*new_r10*x526)));\nevalcond[7]=(((new_r01*new_r12))+(((-1.0)*x527))+(((-1.0)*new_r11*x526)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x529=((((-1.0)*cj32))+new_r22);\nIkReal x530=((((-1.0)*sj32))+new_r02);\nIkReal x531=((1.0)*sj32);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));\nevalcond[1]=x529;\nevalcond[2]=x529;\nevalcond[3]=x530;\nevalcond[4]=new_r12;\nevalcond[5]=x530;\nevalcond[6]=(((new_r00*sj32))+((cj32*new_r20)));\nevalcond[7]=(((new_r01*sj32))+((cj32*new_r21)));\nevalcond[8]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));\nevalcond[9]=((((-1.0)*new_r22*x531))+((cj32*new_r02)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(new_r10, new_r11);\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x532=IKcos(j33);\nIkReal x533=IKsin(j33);\nIkReal x534=((1.0)*new_r02);\nIkReal x535=((1.0)*x532);\nevalcond[0]=(((new_r02*x532))+new_r20);\nevalcond[1]=((((-1.0)*x533))+new_r10);\nevalcond[2]=((((-1.0)*x535))+new_r11);\nevalcond[3]=(((new_r22*x533))+new_r01);\nevalcond[4]=((((-1.0)*x533*x534))+new_r21);\nevalcond[5]=((((-1.0)*new_r22*x535))+new_r00);\nevalcond[6]=(((new_r01*new_r22))+(((-1.0)*new_r21*x534))+x533);\nevalcond[7]=(((new_r00*new_r22))+(((-1.0)*x535))+(((-1.0)*new_r20*x534)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x536=((((-1.0)*cj32))+new_r22);\nIkReal x537=((1.0)*sj32);\nIkReal x538=((1.0)*new_r02);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));\nevalcond[1]=x536;\nevalcond[2]=x536;\nevalcond[3]=(sj32+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x538))+(((-1.0)*x537)));\nevalcond[6]=((((-1.0)*new_r00*x537))+((cj32*new_r20)));\nevalcond[7]=((((-1.0)*new_r01*x537))+((cj32*new_r21)));\nevalcond[8]=((-1.0)+((cj32*new_r22))+(((-1.0)*new_r02*x537)));\nevalcond[9]=((((-1.0)*new_r22*x537))+(((-1.0)*cj32*x538)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x539=IKsin(j33);\nIkReal x540=IKcos(j33);\nIkReal x541=((1.0)*new_r22);\nIkReal x542=((1.0)*x540);\nevalcond[0]=(((new_r02*x539))+new_r21);\nevalcond[1]=(new_r20+(((-1.0)*new_r02*x542)));\nevalcond[2]=((((-1.0)*x539))+(((-1.0)*new_r10)));\nevalcond[3]=((((-1.0)*x542))+(((-1.0)*new_r11)));\nevalcond[4]=((((-1.0)*new_r01))+((new_r22*x539)));\nevalcond[5]=((((-1.0)*x540*x541))+(((-1.0)*new_r00)));\nevalcond[6]=((((-1.0)*new_r01*x541))+x539+((new_r02*new_r21)));\nevalcond[7]=((((-1.0)*new_r00*x541))+(((-1.0)*x542))+((new_r02*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x543=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));\nIkReal x544=(((cj31*new_r02))+((new_r12*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x543;\nevalcond[7]=x543;\nevalcond[8]=x544;\nevalcond[9]=x544;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nIkReal x545=((1.0)*sj31);\nif( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x545)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj31*new_r00))+(((-1.0)*new_r01*x545)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x545))))+IKsqr((((cj31*new_r00))+(((-1.0)*new_r01*x545))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x545))), (((cj31*new_r00))+(((-1.0)*new_r01*x545))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x546=IKsin(j33);\nIkReal x547=IKcos(j33);\nIkReal x548=((1.0)*sj31);\nIkReal x549=((1.0)*x547);\nIkReal x550=(sj31*x546);\nIkReal x551=((1.0)*x546);\nIkReal x552=(cj31*x549);\nevalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x546);\nevalcond[1]=(((sj31*x547))+((cj31*x546))+new_r01);\nevalcond[2]=(((cj31*new_r00))+(((-1.0)*x549))+((new_r10*sj31)));\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x548))+(((-1.0)*x551)));\nevalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x548))+(((-1.0)*x549)));\nevalcond[5]=((((-1.0)*x552))+x550+new_r00);\nevalcond[6]=((((-1.0)*x552))+x550+new_r11);\nevalcond[7]=((((-1.0)*x547*x548))+new_r10+(((-1.0)*cj31*x551)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x553=(cj31*new_r02);\nIkReal x554=(new_r12*sj31);\nIkReal x555=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x555;\nevalcond[7]=x555;\nevalcond[8]=(x553+x554);\nevalcond[9]=((((-1.0)*x554))+(((-1.0)*x553)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nIkReal x556=((1.0)*sj31);\nif( IKabs((((cj31*new_r01))+(((-1.0)*new_r00*x556)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x556)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj31*new_r01))+(((-1.0)*new_r00*x556))))+IKsqr(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x556))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2((((cj31*new_r01))+(((-1.0)*new_r00*x556))), ((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x556))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x557=IKsin(j33);\nIkReal x558=IKcos(j33);\nIkReal x559=((1.0)*sj31);\nIkReal x560=((1.0)*x557);\nIkReal x561=(sj31*x558);\nIkReal x562=((1.0)*x558);\nIkReal x563=(cj31*x560);\nevalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x558);\nevalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x560)));\nevalcond[2]=(((cj31*x558))+((sj31*x557))+new_r00);\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x559))+(((-1.0)*x560)));\nevalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x559))+(((-1.0)*x562)));\nevalcond[5]=(x561+new_r01+(((-1.0)*x563)));\nevalcond[6]=(x561+new_r10+(((-1.0)*x563)));\nevalcond[7]=((((-1.0)*cj31*x562))+new_r11+(((-1.0)*x557*x559)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j33]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x565=IKPowWithIntegerCheck(sj32,-1);\nif(!x565.valid){\ncontinue;\n}\nIkReal x564=x565.value;\nCheckValue<IkReal> x566=IKPowWithIntegerCheck(cj32,-1);\nif(!x566.valid){\ncontinue;\n}\nCheckValue<IkReal> x567=IKPowWithIntegerCheck(sj31,-1);\nif(!x567.valid){\ncontinue;\n}\nif( IKabs((x564*(x566.value)*(x567.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x564)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x564*(x566.value)*(x567.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20))))))+IKsqr(((-1.0)*new_r20*x564))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2((x564*(x566.value)*(x567.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20))))), ((-1.0)*new_r20*x564));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[12];\nIkReal x568=IKsin(j33);\nIkReal x569=IKcos(j33);\nIkReal x570=(cj31*cj32);\nIkReal x571=((1.0)*sj31);\nIkReal x572=(new_r11*sj31);\nIkReal x573=(new_r10*sj31);\nIkReal x574=((1.0)*sj32);\nIkReal x575=((1.0)*x569);\nIkReal x576=((1.0)*x568);\nIkReal x577=(sj31*x568);\nevalcond[0]=(((sj32*x569))+new_r20);\nevalcond[1]=((((-1.0)*x568*x574))+new_r21);\nevalcond[2]=(((cj31*new_r01))+x572+((cj32*x568)));\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*x576))+(((-1.0)*new_r00*x571)));\nevalcond[4]=(((cj31*new_r11))+(((-1.0)*x575))+(((-1.0)*new_r01*x571)));\nevalcond[5]=(((sj31*x569))+((x568*x570))+new_r01);\nevalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x575))+x573);\nevalcond[7]=((((-1.0)*x570*x575))+x577+new_r00);\nevalcond[8]=(((cj32*x577))+new_r11+(((-1.0)*cj31*x575)));\nevalcond[9]=((((-1.0)*cj32*x569*x571))+new_r10+(((-1.0)*cj31*x576)));\nevalcond[10]=(((new_r01*x570))+((cj32*x572))+x568+(((-1.0)*new_r21*x574)));\nevalcond[11]=(((new_r00*x570))+((cj32*x573))+(((-1.0)*x575))+(((-1.0)*new_r20*x574)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x579=IKPowWithIntegerCheck(sj32,-1);\nif(!x579.valid){\ncontinue;\n}\nIkReal x578=x579.value;\nCheckValue<IkReal> x580=IKPowWithIntegerCheck(sj31,-1);\nif(!x580.valid){\ncontinue;\n}\nif( IKabs((new_r21*x578)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x578*(x580.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x578))+IKsqr((x578*(x580.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2((new_r21*x578), (x578*(x580.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[12];\nIkReal x581=IKsin(j33);\nIkReal x582=IKcos(j33);\nIkReal x583=(cj31*cj32);\nIkReal x584=((1.0)*sj31);\nIkReal x585=(new_r11*sj31);\nIkReal x586=(new_r10*sj31);\nIkReal x587=((1.0)*sj32);\nIkReal x588=((1.0)*x582);\nIkReal x589=((1.0)*x581);\nIkReal x590=(sj31*x581);\nevalcond[0]=(((sj32*x582))+new_r20);\nevalcond[1]=(new_r21+(((-1.0)*x581*x587)));\nevalcond[2]=(((cj32*x581))+((cj31*new_r01))+x585);\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*x589))+(((-1.0)*new_r00*x584)));\nevalcond[4]=((((-1.0)*new_r01*x584))+((cj31*new_r11))+(((-1.0)*x588)));\nevalcond[5]=(((x581*x583))+((sj31*x582))+new_r01);\nevalcond[6]=(((cj31*new_r00))+x586+(((-1.0)*cj32*x588)));\nevalcond[7]=((((-1.0)*x583*x588))+x590+new_r00);\nevalcond[8]=((((-1.0)*cj31*x588))+((cj32*x590))+new_r11);\nevalcond[9]=((((-1.0)*cj31*x589))+new_r10+(((-1.0)*cj32*x582*x584)));\nevalcond[10]=(((cj32*x585))+(((-1.0)*new_r21*x587))+x581+((new_r01*x583)));\nevalcond[11]=(((cj32*x586))+(((-1.0)*new_r20*x587))+((new_r00*x583))+(((-1.0)*x588)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x591=IKPowWithIntegerCheck(IKsign(sj32),-1);\nif(!x591.valid){\ncontinue;\n}\nCheckValue<IkReal> x592 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x592.valid){\ncontinue;\n}\nj33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x591.value)))+(x592.value));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[12];\nIkReal x593=IKsin(j33);\nIkReal x594=IKcos(j33);\nIkReal x595=(cj31*cj32);\nIkReal x596=((1.0)*sj31);\nIkReal x597=(new_r11*sj31);\nIkReal x598=(new_r10*sj31);\nIkReal x599=((1.0)*sj32);\nIkReal x600=((1.0)*x594);\nIkReal x601=((1.0)*x593);\nIkReal x602=(sj31*x593);\nevalcond[0]=(((sj32*x594))+new_r20);\nevalcond[1]=((((-1.0)*x593*x599))+new_r21);\nevalcond[2]=(((cj31*new_r01))+((cj32*x593))+x597);\nevalcond[3]=((((-1.0)*new_r00*x596))+((cj31*new_r10))+(((-1.0)*x601)));\nevalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x596))+(((-1.0)*x600)));\nevalcond[5]=(((sj31*x594))+new_r01+((x593*x595)));\nevalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x600))+x598);\nevalcond[7]=(x602+new_r00+(((-1.0)*x595*x600)));\nevalcond[8]=((((-1.0)*cj31*x600))+((cj32*x602))+new_r11);\nevalcond[9]=((((-1.0)*cj32*x594*x596))+(((-1.0)*cj31*x601))+new_r10);\nevalcond[10]=((((-1.0)*new_r21*x599))+((new_r01*x595))+((cj32*x597))+x593);\nevalcond[11]=((((-1.0)*new_r20*x599))+((new_r00*x595))+((cj32*x598))+(((-1.0)*x600)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j27;\nvinfos[1].indices[0] = _ij27[0];\nvinfos[1].indices[1] = _ij27[1];\nvinfos[1].maxsolutions = _nj27;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j28;\nvinfos[2].indices[0] = _ij28[0];\nvinfos[2].indices[1] = _ij28[1];\nvinfos[2].maxsolutions = _nj28;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j29;\nvinfos[3].indices[0] = _ij29[0];\nvinfos[3].indices[1] = _ij29[1];\nvinfos[3].maxsolutions = _nj29;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j30;\nvinfos[4].indices[0] = _ij30[0];\nvinfos[4].indices[1] = _ij30[1];\nvinfos[4].maxsolutions = _nj30;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j31;\nvinfos[5].indices[0] = _ij31[0];\nvinfos[5].indices[1] = _ij31[1];\nvinfos[5].maxsolutions = _nj31;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j32;\nvinfos[6].indices[0] = _ij32[0];\nvinfos[6].indices[1] = _ij32[1];\nvinfos[6].maxsolutions = _nj32;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j33;\nvinfos[7].indices[0] = _ij33[0];\nvinfos[7].indices[1] = _ij33[1];\nvinfos[7].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\n}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[3];\n    const int maxsteps = 110;\n    for(int i = 0; i < 3; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[3];\n    IkReal err[3];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 3; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 3; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 3; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 3; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[3] = {false};\n    for(int i = 0; i < 3; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 3; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {\n    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];\n    if( det < 0 ) {\n        numroots=0;\n    }\n    else if( det == 0 ) {\n        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];\n        numroots = 1;\n    }\n    else {\n        det = IKsqrt(det);\n        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);\n        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);\n        numroots = 2;\n    }\n}\nstatic inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[5];\n    const int maxsteps = 110;\n    for(int i = 0; i < 5; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[5];\n    IkReal err[5];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 5; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 5; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 5; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 5; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[5] = {false};\n    for(int i = 0; i < 5; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 5; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[4];\n    const int maxsteps = 110;\n    for(int i = 0; i < 4; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[4];\n    IkReal err[4];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 4; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 4; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 4; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 4; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[4] = {false};\n    for(int i = 0; i < 4; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 4; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[7];\n    const int maxsteps = 110;\n    for(int i = 0; i < 7; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[7];\n    IkReal err[7];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 7; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 7; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 7; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 7; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[7] = {false};\n    for(int i = 0; i < 7; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 7; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[6];\n    const int maxsteps = 110;\n    for(int i = 0; i < 6; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[6];\n    IkReal err[6];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 6; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 6; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 6; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 6; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[6] = {false};\n    for(int i = 0; i < 6; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 6; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[8];\n    const int maxsteps = 110;\n    for(int i = 0; i < 8; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[8];\n    IkReal err[8];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 8; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 8; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 8; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 8; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[8] = {false};\n    for(int i = 0; i < 8; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 8; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\n};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"4f95c55204252b6edd6332624a20624c\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\nchar* ComputeFkWrapper(const IkReal* j) {\n    IkReal eetrans[3];\n    IkReal eerot[9];\n    IkReal res[3 + 9];\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n\nstd::vector<IkReal> TrueComputeIk(int argc, char** argv)\n{\n    std::vector<IkReal> solvalues(GetNumJoints());\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return solvalues;\n}\n"]}