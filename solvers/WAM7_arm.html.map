{"version":3,"file":"./solvers/WAM7_arm.html","sources":["./solvers/WAM7_arm.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAzNA;AAAA;AAAA;;;;;;;;AAFA;AAAA;AAAA;;;;;AA+NA;;;;;;;;;;;;;;;AA+jgBA;AACA;AACA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-05-22 07:20:15.541882\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68,x69,x70,x71,x72,x73;\nx0=IKcos(j[0]);\nx1=IKcos(j[1]);\nx2=IKcos(j[2]);\nx3=IKsin(j[0]);\nx4=IKsin(j[2]);\nx5=IKsin(j[3]);\nx6=IKcos(j[3]);\nx7=IKsin(j[1]);\nx8=IKcos(j[4]);\nx9=IKsin(j[4]);\nx10=IKsin(j[6]);\nx11=IKsin(j[5]);\nx12=IKcos(j[5]);\nx13=IKcos(j[6]);\nx14=((0.06)*x5);\nx15=((0.045)*x1);\nx16=((1.0)*x5);\nx17=((0.06)*x9);\nx18=((0.3)*x1);\nx19=((0.06)*x6);\nx20=((1.0)*x11);\nx21=((0.045)*x5);\nx22=((1.0)*x1);\nx23=((1.0)*x12);\nx24=((0.06)*x8);\nx25=((1.0)*x6);\nx26=(x0*x4);\nx27=(x0*x2);\nx28=(x2*x7);\nx29=(x3*x4);\nx30=(x0*x7);\nx31=(x2*x3);\nx32=(x3*x7);\nx33=((1.0)*x29);\nx34=((0.045)*x29);\nx35=((0.045)*x26);\nx36=(x22*x6);\nx37=(x32*x6);\nx38=(x4*x7*x9);\nx39=(x16*x30);\nx40=(x25*x30);\nx41=(x15*x27);\nx42=(x16*x32);\nx43=(x25*x32);\nx44=(x15*x31);\nx45=((((-1.0)*x33))+((x1*x27)));\nx46=(x26+((x1*x31)));\nx47=(x27+(((-1.0)*x22*x29)));\nx48=((((-1.0)*x36))+((x28*x5)));\nx49=(x33+(((-1.0)*x22*x27)));\nx50=((((-1.0)*x31))+(((-1.0)*x22*x26)));\nx51=((((-1.0)*x26))+(((-1.0)*x22*x31)));\nx52=(((x1*x16))+((x25*x28)));\nx53=((-1.0)*x52);\nx54=(x35+x44);\nx55=(x46*x6);\nx56=(x11*x48);\nx57=(x45*x6);\nx58=(x5*x51);\nx59=(x50*x9);\nx60=(x53*x8);\nx61=((((-1.0)*x39))+x57);\nx62=((((-1.0)*x42))+x55);\nx63=((((-1.0)*x40))+((x49*x5)));\nx64=((((-1.0)*x43))+x58);\nx65=(((x4*x7*x8))+((x52*x9)));\nx66=(x38+x60);\nx67=(x61*x8);\nx68=(x11*x64);\nx69=(((x47*x9))+((x62*x8)));\nx70=(((x47*x8))+((x9*(((((-1.0)*x25*x46))+x42)))));\nx71=(x59+x67);\nx72=(x12*x69);\nx73=(((x50*x8))+((x9*((x39+(((-1.0)*x57)))))));\neerot[0]=(((x10*x73))+((x13*((((x11*x63))+((x12*x71)))))));\neerot[1]=(((x10*(((((-1.0)*x20*x63))+(((-1.0)*x23*x71))))))+((x13*x73)));\neerot[2]=(((x12*(((((-1.0)*x16*x49))+x40))))+((x11*x71)));\neetrans[0]=((0.22)+(((-1.0)*x34))+((x12*((((x19*x30))+(((-1.0)*x14*x49))))))+((x11*((((x17*x50))+((x24*x61))))))+((x21*x30))+(((0.3)*x30*x6))+(((0.55)*x30))+x41+((x5*((((x18*x27))+(((-0.3)*x29))))))+((x6*(((((-1.0)*x41))+x34)))));\neerot[3]=(((x10*x70))+((x13*((x72+x68)))));\neerot[4]=(((x10*(((((-1.0)*x20*x64))+(((-1.0)*x23*x69))))))+((x13*x70)));\neerot[5]=(((x11*x69))+((x12*((x43+(((-1.0)*x16*x51)))))));\neetrans[1]=((0.14)+((x5*((((x18*x31))+(((0.3)*x26))))))+(((-1.0)*x54*x6))+((x21*x32))+(((0.55)*x32))+x54+((x12*((((x19*x32))+(((-1.0)*x14*x51))))))+((x11*((((x17*x47))+((x24*x62))))))+(((0.3)*x37)));\neerot[6]=(((x13*((((x12*x66))+x56))))+((x10*x65)));\neerot[7]=(((x13*x65))+((x10*(((((-1.0)*x20*x48))+(((-1.0)*x23*x66)))))));\neerot[8]=(((x11*x66))+((x12*(((((-1.0)*x16*x28))+x36)))));\nIkReal x74=((0.045)*x28);\neetrans[2]=((0.346)+((x18*x6))+((x11*((((x24*x53))+((x17*x4*x7))))))+(((-0.3)*x28*x5))+(((-1.0)*x74))+((x12*((((x1*x19))+(((-1.0)*x14*x28))))))+((x6*x74))+(((0.55)*x1))+((x15*x5)));\n}\n\nIKFAST_API int GetNumFreeParameters() { return 1; }\nIKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }\nIKFAST_API int GetNumJoints() { return 7; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j2,cj2,sj2,htj2,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij2[2], _nj2;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij2[0] = -1; _ij2[1] = -1; _nj2 = 0; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nj2=pfree[0]; cj2=cos(pfree[0]); sj2=sin(pfree[0]), htj2=tan(pfree[0]*0.5);\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=r00;\nnew_r01=r01;\nnew_r02=r02;\nnew_px=((-0.22)+(((-0.06)*r02))+px);\nnew_r10=r10;\nnew_r11=r11;\nnew_r12=r12;\nnew_py=((-0.14)+py+(((-0.06)*r12)));\nnew_r20=r20;\nnew_r21=r21;\nnew_r22=r22;\nnew_pz=((-0.346)+(((-0.06)*r22))+pz);\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x75=((1.0)*px);\nIkReal x76=((1.0)*pz);\nIkReal x77=((1.0)*py);\npp=((px*px)+(py*py)+(pz*pz));\nnpx=(((px*r00))+((py*r10))+((pz*r20)));\nnpy=(((px*r01))+((py*r11))+((pz*r21)));\nnpz=(((px*r02))+((py*r12))+((pz*r22)));\nrxp0_0=((((-1.0)*r20*x77))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x76)));\nrxp0_2=((((-1.0)*r10*x75))+((py*r00)));\nrxp1_0=((((-1.0)*r21*x77))+((pz*r11)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x76)));\nrxp1_2=(((py*r01))+(((-1.0)*r11*x75)));\nrxp2_0=((((-1.0)*r22*x77))+((pz*r12)));\nrxp2_1=(((px*r22))+(((-1.0)*r02*x76)));\nrxp2_2=(((py*r02))+(((-1.0)*r12*x75)));\n{\nIkReal j3array[2], cj3array[2], sj3array[2];\nbool j3valid[2]={false};\n_nj3 = 2;\nif( (((1.18441410190393)+(((-2.9867963734811)*pp)))) < -1-IKFAST_SINCOS_THRESH || (((1.18441410190393)+(((-2.9867963734811)*pp)))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x78=IKasin(((1.18441410190393)+(((-2.9867963734811)*pp))));\nj3array[0]=((-1.34027003705633)+(((-1.0)*x78)));\nsj3array[0]=IKsin(j3array[0]);\ncj3array[0]=IKcos(j3array[0]);\nj3array[1]=((1.80132261653346)+x78);\nsj3array[1]=IKsin(j3array[1]);\ncj3array[1]=IKcos(j3array[1]);\nif( j3array[0] > IKPI )\n{\n    j3array[0]-=IK2PI;\n}\nelse if( j3array[0] < -IKPI )\n{    j3array[0]+=IK2PI;\n}\nj3valid[0] = true;\nif( j3array[1] > IKPI )\n{\n    j3array[1]-=IK2PI;\n}\nelse if( j3array[1] < -IKPI )\n{    j3array[1]+=IK2PI;\n}\nj3valid[1] = true;\nfor(int ij3 = 0; ij3 < 2; ++ij3)\n{\nif( !j3valid[ij3] )\n{\n    continue;\n}\n_ij3[0] = ij3; _ij3[1] = -1;\nfor(int iij3 = ij3+1; iij3 < 2; ++iij3)\n{\nif( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )\n{\n    j3valid[iij3]=false; _ij3[1] = iij3; break; \n}\n}\nj3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];\n\n{\nIkReal j0eval[2];\nj0eval[0]=((px*px)+(py*py));\nj0eval[1]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nIkReal x79=cj2*cj2;\nIkReal x80=sj3*sj3;\nIkReal x81=cj3*cj3;\nIkReal x82=((3.0)*cj2);\nIkReal x83=((13.3333333333333)*cj3*sj3);\nj1eval[0]=((IKabs(((((20.0)*cj2*sj3))+x82+(((-1.0)*cj3*x82)))))+(((66.6666666666667)*(IKabs(((-0.55)+(((-0.045)*sj3))+(((-0.3)*cj3))))))));\nj1eval[1]=((149.382716049383)+((x79*x81))+(((24.4444444444444)*sj3))+(((13.3333333333333)*sj3*x79))+(((-1.0)*x79*x83))+(((-2.0)*cj3*x79))+(((44.4444444444444)*x79*x80))+x79+x83+x80+(((44.4444444444444)*x81))+(((162.962962962963)*cj3)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[2];\nIkReal x84=cj2*cj2;\nIkReal x85=sj2*sj2;\nIkReal x86=px*px;\nIkReal x87=py*py;\nIkReal x88=py*py*py*py;\nIkReal x89=sj2*sj2*sj2*sj2;\nIkReal x90=cj2*cj2*cj2*cj2;\nIkReal x91=((1.0)*px*py);\nIkReal x92=(x86*x87);\nIkReal x93=((2.0)*x84*x85);\nj0eval[0]=(((x89*x92))+((x92*x93))+((x90*x92))+((x88*x93))+((x88*x90))+((x88*x89)));\nj0eval[1]=((IKabs((((x84*x87))+((x85*x87)))))+(IKabs(((((-1.0)*x84*x91))+(((-1.0)*x85*x91))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0, j1]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x94=cj2*cj2;\nIkReal x95=py*py;\nIkReal x96=sj2*sj2;\nIkReal x97=((0.045)*py*sj2);\nIkReal x98=((1.0)*px*py);\nIkReal x99=(((x95*x96))+((x94*x95)));\nIkReal x100=((((-1.0)*x94*x98))+(((-1.0)*x96*x98)));\nCheckValue<IkReal> x103 = IKatan2WithCheck(IkReal(x99),x100,IKFAST_ATAN2_MAGTHRESH);\nif(!x103.valid){\ncontinue;\n}\nIkReal x101=((1.0)*(x103.value));\nif((((x99*x99)+(x100*x100))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x104=IKPowWithIntegerCheck(IKabs(IKsqrt(((x99*x99)+(x100*x100)))),-1);\nif(!x104.valid){\ncontinue;\n}\nif( (((x104.value)*(((((-0.3)*py*sj2*sj3))+((cj3*x97))+(((-1.0)*x97)))))) < -1-IKFAST_SINCOS_THRESH || (((x104.value)*(((((-0.3)*py*sj2*sj3))+((cj3*x97))+(((-1.0)*x97)))))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x102=IKasin(((x104.value)*(((((-0.3)*py*sj2*sj3))+((cj3*x97))+(((-1.0)*x97))))));\nj0array[0]=((((-1.0)*x101))+(((-1.0)*x102)));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x101))+x102);\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x105=sj2*sj2;\nIkReal x106=cj2*cj2;\nIkReal x107=px*px;\nIkReal x108=IKsin(j0);\nIkReal x109=IKcos(j0);\nIkReal x110=(px*py);\nIkReal x111=((0.045)*sj2);\nIkReal x112=((1.0)*x107);\nIkReal x113=((0.3)*sj2*sj3);\nevalcond[0]=(((x108*(((((-1.0)*x106*x112))+(((-1.0)*x105*x112))))))+(((-1.0)*px*x113))+(((-1.0)*px*x111))+((x109*((((x106*x110))+((x105*x110))))))+((cj3*px*x111)));\nevalcond[1]=((((-1.0)*cj3*x111))+x113+x111+((px*x108))+(((-1.0)*py*x109)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j1eval[2];\nIkReal x114=(py*sj0);\nIkReal x115=((0.3)*cj3);\nIkReal x116=((0.045)*sj3);\nIkReal x117=(cj2*pz);\nIkReal x118=((6.66666666666667)*cj3);\nIkReal x119=(cj0*px);\nIkReal x120=((1.0)*sj3);\nj1eval[0]=((((-1.0)*x119*x120))+((cj3*x117))+(((-1.0)*x118*x119))+(((-6.66666666666667)*sj3*x117))+(((-12.2222222222222)*x119))+(((-12.2222222222222)*x114))+(((-1.0)*x114*x118))+(((-1.0)*x114*x120))+(((-1.0)*x117)));\nj1eval[1]=IKsign(((((-0.55)*x119))+(((-0.55)*x114))+(((-1.0)*x116*x119))+(((-1.0)*x115*x119))+(((-1.0)*x114*x116))+(((-1.0)*x114*x115))+(((-0.3)*sj3*x117))+(((0.045)*cj3*x117))+(((-0.045)*x117))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nIkReal x121=cj0*cj0;\nIkReal x122=py*py;\nIkReal x123=(sj2*x121);\nIkReal x124=(((x123*(px*px)))+((sj2*x122))+(((-1.0)*x122*x123))+((sj2*(pz*pz)))+(((2.0)*cj0*px*py*sj0*sj2)));\nj1eval[0]=x124;\nj1eval[1]=IKsign(x124);\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nIkReal x125=(pz*sj2);\nIkReal x126=(py*sj0);\nIkReal x127=(cj0*px);\nIkReal x128=(cj2*sj2);\nIkReal x129=((1.0)*cj3);\nIkReal x130=((0.045)*x128);\nIkReal x131=(sj3*x128);\nIkReal x132=(x126*x131);\nj1eval[0]=((((-12.2222222222222)*x125))+(((6.66666666666667)*x132))+(((-6.66666666666667)*cj3*x125))+(((-1.0)*x126*x128*x129))+(((6.66666666666667)*x127*x131))+(((-1.0)*x127*x128*x129))+((x126*x128))+(((-1.0)*sj3*x125))+((x127*x128)));\nj1eval[1]=IKsign((((x127*x130))+(((-0.55)*x125))+(((-1.0)*cj3*x126*x130))+(((-0.3)*cj3*x125))+(((0.3)*x132))+(((-1.0)*cj3*x127*x130))+((x126*x130))+(((0.3)*x127*x131))+(((-0.045)*sj3*x125))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x133=(((px*sj0))+(((-1.0)*cj0*py)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=x133;\nevalcond[3]=x133;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[2];\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x134=(cj0*px);\nIkReal x135=((0.310561435803037)*sj3);\nIkReal x136=(pp*pz);\nIkReal x137=(py*sj0);\nIkReal x138=((0.138057984353428)*pp);\nIkReal x139=((12.2222222222222)*sj3);\nIkReal x140=((5.4333061668025)*pp);\nIkReal x141=(pz*sj3);\nj1eval[0]=((((7.28153581454315)*pz))+(((-1.0)*x134*x139))+((x137*x140))+(((-1.0)*x137*x139))+(((-1.0)*x141))+(((36.2220411120167)*x136))+((x134*x140))+(((-3.92556370551481)*x134))+(((-3.92556370551481)*x137)));\nj1eval[1]=IKsign(((((-1.0)*x135*x137))+(((-1.0)*x134*x135))+((x137*x138))+(((0.185020708697653)*pz))+((x134*x138))+(((-0.099746893695352)*x137))+(((-0.099746893695352)*x134))+(((-0.0254095720202485)*x141))+(((0.92038656235619)*x136))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x142=(cj0*px);\nIkReal x143=(py*sj0);\nIkReal x144=((0.3)*sj3);\nIkReal x145=((0.045)*cj3);\nIkReal x146=(pz*sj3);\nIkReal x147=((6.66666666666667)*sj3);\nIkReal x148=((1.0)*cj3);\nIkReal x149=(cj3*pz);\nj1eval[0]=(((x142*x147))+(((-1.0)*x143*x148))+(((-1.0)*x142*x148))+(((-6.66666666666667)*x149))+x142+x143+(((-1.0)*x146))+(((-12.2222222222222)*pz))+((x143*x147)));\nj1eval[1]=IKsign(((((-0.55)*pz))+(((-0.3)*x149))+((x142*x144))+(((-1.0)*x143*x145))+(((-1.0)*x142*x145))+(((-0.045)*x146))+(((0.045)*x143))+(((0.045)*x142))+((x143*x144))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x150=(py*sj0);\nIkReal x151=(cj0*px);\nIkReal x152=(pp*pz);\nIkReal x153=((0.92038656235619)*pp);\nIkReal x154=(pz*sj3);\nIkReal x155=((36.2220411120167)*pp);\nIkReal x156=((0.0254095720202485)*sj3);\nj1eval[0]=((((-1.0)*x151*x155))+(((-1.0)*x150*x155))+(((-3.92556370551481)*pz))+(((5.4333061668025)*x152))+((sj3*x150))+((sj3*x151))+(((-7.28153581454315)*x150))+(((-7.28153581454315)*x151))+(((-12.2222222222222)*x154)));\nj1eval[1]=IKsign(((((-0.310561435803037)*x154))+(((-0.099746893695352)*pz))+(((-1.0)*x151*x153))+((x150*x156))+(((-1.0)*x150*x153))+((x151*x156))+(((0.138057984353428)*x152))+(((-0.185020708697653)*x151))+(((-0.185020708697653)*x150))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x157=x133;\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=x157;\nevalcond[3]=x157;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x158=((-1.0)*py);\nsj2=0;\ncj2=1.0;\nj2=0;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x158);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x158);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x158);\nrxp2_1=(px*r22);\nj1eval[0]=(((cj0*px))+((py*sj0)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(px))+(IKabs(py)));\nevalcond[1]=0.7225;\nevalcond[2]=-0.85;\nevalcond[3]=0;\nevalcond[4]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nsj2=0;\ncj2=1.0;\nj2=0;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=0;\nnpx=0;\nnpy=0;\nnpz=0;\nrxp0_0=0;\nrxp0_1=0;\nrxp1_0=0;\nrxp1_1=0;\nrxp2_0=0;\nrxp2_1=0;\npx=0;\npy=0;\nrxp0_2=0;\nrxp1_2=0;\nrxp2_2=0;\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));\nevalcond[1]=((0.7225)+(((-1.0)*(py*py))));\nevalcond[2]=-0.85;\nevalcond[3]=((-1.0)*py);\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x594=((-1.0)*py);\nsj2=0;\ncj2=1.0;\nj2=0;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=py*py;\nnpx=(py*r10);\nnpy=(py*r11);\nnpz=(py*r12);\nrxp0_0=(r20*x594);\nrxp0_1=0;\nrxp1_0=(r21*x594);\nrxp1_1=0;\nrxp2_0=(r22*x594);\nrxp2_1=0;\npx=0;\nj0=0;\nsj0=0;\ncj0=1.0;\nrxp0_2=(py*r00);\nrxp1_2=(py*r01);\nrxp2_2=(py*r02);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*(py*py))));\nevalcond[2]=-0.85;\nevalcond[3]=py;\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x595=((-1.0)*py);\nsj2=0;\ncj2=1.0;\nj2=0;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=py*py;\nnpx=(py*r10);\nnpy=(py*r11);\nnpz=(py*r12);\nrxp0_0=(r20*x595);\nrxp0_1=0;\nrxp1_0=(r21*x595);\nrxp1_1=0;\nrxp2_0=(r22*x595);\nrxp2_1=0;\npx=0;\nj0=3.14159265358979;\nsj0=0;\ncj0=-1.0;\nrxp0_2=(py*r00);\nrxp1_2=(py*r01);\nrxp2_2=(py*r02);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*(px*px))));\nevalcond[2]=-0.85;\nevalcond[3]=px;\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x596=((-1.0)*px);\nsj2=0;\ncj2=1.0;\nj2=0;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=px*px;\nnpx=(px*r00);\nnpy=(px*r01);\nnpz=(px*r02);\nrxp0_0=0;\nrxp0_1=(px*r20);\nrxp1_0=0;\nrxp1_1=(px*r21);\nrxp2_0=0;\nrxp2_1=(px*r22);\npy=0;\nj0=1.5707963267949;\nsj0=1.0;\ncj0=0;\nrxp0_2=(r10*x596);\nrxp1_2=(r11*x596);\nrxp2_2=(r12*x596);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*(px*px))));\nevalcond[2]=-0.85;\nevalcond[3]=((-1.0)*px);\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x597=((-1.0)*px);\nsj2=0;\ncj2=1.0;\nj2=0;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=px*px;\nnpx=(px*r00);\nnpy=(px*r01);\nnpz=(px*r02);\nrxp0_0=0;\nrxp0_1=(px*r20);\nrxp1_0=0;\nrxp1_1=(px*r21);\nrxp2_0=0;\nrxp2_1=(px*r22);\npy=0;\nj0=-1.5707963267949;\nsj0=-1.0;\ncj0=0;\nrxp0_2=(r10*x597);\nrxp1_2=(r11*x597);\nrxp2_2=(r12*x597);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x598=py*py;\nIkReal x599=cj0*cj0;\nIkReal x600=(cj0*px);\nIkReal x601=(py*sj0);\nIkReal x602=((4400.0)*x598);\nCheckValue<IkReal> x603=IKPowWithIntegerCheck(((((306.0)*x601))+(((306.0)*x600))),-1);\nif(!x603.valid){\ncontinue;\n}\nif( IKabs(((((1.17647058823529)*x600))+(((1.17647058823529)*x601)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x603.value)*(((3179.0)+(((-4400.0)*x599*(px*px)))+(((-8800.0)*x600*x601))+(((-1.0)*x602))+((x599*x602)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((1.17647058823529)*x600))+(((1.17647058823529)*x601))))+IKsqr(((x603.value)*(((3179.0)+(((-4400.0)*x599*(px*px)))+(((-8800.0)*x600*x601))+(((-1.0)*x602))+((x599*x602))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj1array[0]=IKatan2(((((1.17647058823529)*x600))+(((1.17647058823529)*x601))), ((x603.value)*(((3179.0)+(((-4400.0)*x599*(px*px)))+(((-8800.0)*x600*x601))+(((-1.0)*x602))+((x599*x602))))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x604=IKsin(j1);\nIkReal x605=IKcos(j1);\nIkReal x606=(py*sj0);\nIkReal x607=(cj0*px);\nIkReal x608=((0.09)*x605);\nIkReal x609=((1.0)*x605);\nIkReal x610=((1.1)*x604);\nevalcond[0]=((-0.85)*x605);\nevalcond[1]=((-0.85)+((x604*x606))+((x604*x607)));\nevalcond[2]=((((0.85)*x604))+(((-1.0)*x607))+(((-1.0)*x606)));\nevalcond[3]=((((-1.0)*x606*x609))+(((-1.0)*x607*x609)));\nevalcond[4]=((-0.935)+((x607*x608))+((x606*x608))+((x606*x610))+((x607*x610)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x611=cj3*cj3;\nIkReal x612=(cj3*sj3);\nIkReal x613=(cj0*px);\nIkReal x614=((0.92038656235619)*pp);\nIkReal x615=((0.0254095720202485)*sj3);\nIkReal x616=(py*sj0);\nIkReal x617=(pp*sj3);\nIkReal x618=((1.0)*pz);\nIkReal x619=(cj3*pp);\nCheckValue<IkReal> x620 = IKatan2WithCheck(IkReal(((-0.100617959042798)+(((-0.0414173953060285)*x617))+(((0.00762287160607455)*x612))+(pz*pz)+(((-0.00114343074091118)*x611))+(((-0.506212609295904)*pp))+(((0.00564933271974229)*sj3))+(((-0.276115968706857)*x619))+(((-0.0555062126092959)*cj3)))),((-0.0688360561435803)+(((0.00621260929590428)*x617))+(((-0.0299240681086056)*cj3))+(((-0.0931684307409112)*x612))+(((0.0759318913943856)*pp))+(((0.0139752646111367)*x611))+(((-0.175297399907961)*sj3))+(((-1.0)*x613*x618))+(((-1.0)*x616*x618))+(((0.0414173953060285)*x619))),IKFAST_ATAN2_MAGTHRESH);\nif(!x620.valid){\ncontinue;\n}\nCheckValue<IkReal> x621=IKPowWithIntegerCheck(IKsign(((((-1.0)*x614*x616))+(((-0.099746893695352)*pz))+(((-0.310561435803037)*pz*sj3))+(((-0.185020708697653)*x613))+(((-0.185020708697653)*x616))+((x613*x615))+((x615*x616))+(((-1.0)*x613*x614))+(((0.138057984353428)*pp*pz)))),-1);\nif(!x621.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x620.value)+(((1.5707963267949)*(x621.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x622=IKsin(j1);\nIkReal x623=IKcos(j1);\nIkReal x624=((0.045)*sj3);\nIkReal x625=((0.3)*cj3);\nIkReal x626=((0.045)*cj3);\nIkReal x627=(cj0*px);\nIkReal x628=(py*sj0);\nIkReal x629=((1.0)*x623);\nIkReal x630=(sj3*x623);\nIkReal x631=(pz*x622);\nIkReal x632=(pz*x623);\nIkReal x633=((0.09)*x623);\nIkReal x634=((1.1)*x622);\nevalcond[0]=((-0.55)+(((-1.0)*x624))+(((-1.0)*x625))+x632+((x622*x627))+((x622*x628)));\nevalcond[1]=((0.045)+(((-1.0)*x628*x629))+(((-1.0)*x626))+(((-1.0)*x627*x629))+x631+(((0.3)*sj3)));\nevalcond[2]=((((-0.185020708697653)*x623))+(((0.0254095720202485)*x630))+(((0.310561435803037)*sj3*x622))+(((0.099746893695352)*x622))+(((-0.138057984353428)*pp*x622))+(((-0.92038656235619)*pp*x623))+pz);\nevalcond[3]=((((-1.0)*x623*x626))+(((0.3)*x630))+(((-1.0)*x628))+(((-1.0)*x627))+(((0.55)*x622))+(((0.045)*x623))+((x622*x624))+((x622*x625)));\nevalcond[4]=((-0.2125)+((x628*x634))+((x628*x633))+(((1.1)*x632))+(((-0.09)*x631))+(((-1.0)*pp))+((x627*x634))+((x627*x633)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x635=cj0*cj0;\nIkReal x636=py*py;\nIkReal x637=cj3*cj3;\nIkReal x638=(py*sj0);\nIkReal x639=((0.3)*sj3);\nIkReal x640=((0.045)*cj3);\nIkReal x641=(cj0*px);\nIkReal x642=(cj3*sj3);\nIkReal x643=((1.0)*pz);\nCheckValue<IkReal> x644=IKPowWithIntegerCheck(IKsign(((((-0.55)*pz))+(((-0.3)*cj3*pz))+((x639*x641))+(((-1.0)*x640*x641))+(((-0.045)*pz*sj3))+((x638*x639))+(((0.045)*x641))+(((-1.0)*x638*x640))+(((0.045)*x638)))),-1);\nif(!x644.valid){\ncontinue;\n}\nCheckValue<IkReal> x645 = IKatan2WithCheck(IkReal(((0.03825)+(((0.087975)*x642))+(((-0.01125)*cj3))+(((-1.0)*x641*x643))+(((-0.027)*x637))+(((0.167025)*sj3))+(((-1.0)*x638*x643)))),((-0.304525)+(((2.0)*x638*x641))+(((-0.0495)*sj3))+(((-1.0)*x635*x636))+(((-0.027)*x642))+((x635*(px*px)))+(((-0.087975)*x637))+x636+(((-0.33)*cj3))),IKFAST_ATAN2_MAGTHRESH);\nif(!x645.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x644.value)))+(x645.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x646=IKsin(j1);\nIkReal x647=IKcos(j1);\nIkReal x648=((0.045)*sj3);\nIkReal x649=((0.3)*cj3);\nIkReal x650=((0.045)*cj3);\nIkReal x651=(cj0*px);\nIkReal x652=(py*sj0);\nIkReal x653=((1.0)*x647);\nIkReal x654=(sj3*x647);\nIkReal x655=(pz*x646);\nIkReal x656=(pz*x647);\nIkReal x657=((0.09)*x647);\nIkReal x658=((1.1)*x646);\nevalcond[0]=((-0.55)+((x646*x652))+((x646*x651))+(((-1.0)*x648))+(((-1.0)*x649))+x656);\nevalcond[1]=((0.045)+(((-1.0)*x651*x653))+(((-1.0)*x650))+x655+(((0.3)*sj3))+(((-1.0)*x652*x653)));\nevalcond[2]=((((0.310561435803037)*sj3*x646))+(((0.0254095720202485)*x654))+(((-0.138057984353428)*pp*x646))+(((0.099746893695352)*x646))+pz+(((-0.92038656235619)*pp*x647))+(((-0.185020708697653)*x647)));\nevalcond[3]=((((0.55)*x646))+(((-1.0)*x651))+(((-1.0)*x652))+(((-1.0)*x647*x650))+(((0.045)*x647))+(((0.3)*x654))+((x646*x648))+((x646*x649)));\nevalcond[4]=((-0.2125)+(((-0.09)*x655))+((x652*x658))+((x652*x657))+((x651*x657))+((x651*x658))+(((-1.0)*pp))+(((1.1)*x656)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x659=cj3*cj3;\nIkReal x660=(cj0*px);\nIkReal x661=((0.00621260929590428)*pp);\nIkReal x662=(cj3*sj3);\nIkReal x663=(py*sj0);\nIkReal x664=((0.138057984353428)*pp);\nIkReal x665=((0.0414173953060285)*pp);\nIkReal x666=((0.310561435803037)*sj3);\nCheckValue<IkReal> x667=IKPowWithIntegerCheck(IKsign(((((-0.0254095720202485)*pz*sj3))+(((-1.0)*x663*x666))+(((-1.0)*x660*x666))+((x663*x664))+(((-0.099746893695352)*x660))+(((-0.099746893695352)*x663))+(((0.185020708697653)*pz))+((x660*x664))+(((0.92038656235619)*pp*pz)))),-1);\nif(!x667.valid){\ncontinue;\n}\nCheckValue<IkReal> x668 = IKatan2WithCheck(IkReal(((-0.000703060285319834)+((cj3*x665))+(((-0.276115968706857)*pp*sj3))+(((-0.00762287160607455)*x659))+(((-1.0)*x665))+((pz*x663))+((pz*x660))+(((-0.00114343074091118)*x662))+(((-0.0543627818683847)*sj3))+(((0.00832593189139439)*cj3)))),((-0.097657040957202)+(((-1.0)*cj3*x661))+(((0.0931684307409112)*x659))+(pz*pz)+(((0.00448861021629084)*cj3))+(((0.0139752646111367)*x662))+x661+((sj3*x665))+(((-0.0438993327197423)*sj3))),IKFAST_ATAN2_MAGTHRESH);\nif(!x668.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x667.value)))+(x668.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x669=IKsin(j1);\nIkReal x670=IKcos(j1);\nIkReal x671=((0.045)*sj3);\nIkReal x672=((0.3)*cj3);\nIkReal x673=((0.045)*cj3);\nIkReal x674=(cj0*px);\nIkReal x675=(py*sj0);\nIkReal x676=((1.0)*x670);\nIkReal x677=(sj3*x670);\nIkReal x678=(pz*x669);\nIkReal x679=(pz*x670);\nIkReal x680=((0.09)*x670);\nIkReal x681=((1.1)*x669);\nevalcond[0]=((-0.55)+((x669*x675))+((x669*x674))+x679+(((-1.0)*x671))+(((-1.0)*x672)));\nevalcond[1]=((0.045)+(((-1.0)*x675*x676))+x678+(((0.3)*sj3))+(((-1.0)*x674*x676))+(((-1.0)*x673)));\nevalcond[2]=((((-0.138057984353428)*pp*x669))+(((-0.92038656235619)*pp*x670))+(((-0.185020708697653)*x670))+(((0.0254095720202485)*x677))+pz+(((0.099746893695352)*x669))+(((0.310561435803037)*sj3*x669)));\nevalcond[3]=((((0.045)*x670))+(((0.55)*x669))+(((0.3)*x677))+((x669*x671))+((x669*x672))+(((-1.0)*x670*x673))+(((-1.0)*x674))+(((-1.0)*x675)));\nevalcond[4]=((-0.2125)+((x674*x681))+((x674*x680))+(((1.1)*x679))+(((-1.0)*pp))+(((-0.09)*x678))+((x675*x681))+((x675*x680)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x682=(px*sj0);\nIkReal x683=(cj0*py);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=(x682+(((-1.0)*x683)));\nevalcond[3]=(x683+(((-1.0)*x682)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[2];\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x684=cj0*cj0;\nIkReal x685=py*py;\nIkReal x686=((((-1.0)*x684*x685))+((x684*(px*px)))+(pz*pz)+x685+(((2.0)*cj0*px*py*sj0)));\nj1eval[0]=x686;\nj1eval[1]=IKsign(x686);\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x687=(py*sj0);\nIkReal x688=((0.3)*sj3);\nIkReal x689=(cj0*px);\nIkReal x690=((6.66666666666667)*sj3);\nIkReal x691=(pz*sj3);\nIkReal x692=(cj3*pz);\nIkReal x693=((0.045)*x689);\nj1eval[0]=((((-1.0)*x687*x690))+(((-6.66666666666667)*x692))+(((-12.2222222222222)*pz))+(((-1.0)*x689*x690))+(((-1.0)*x687))+(((-1.0)*x689))+((cj3*x689))+((cj3*x687))+(((-1.0)*x691)));\nj1eval[1]=IKsign(((((-0.55)*pz))+(((-1.0)*x687*x688))+(((-1.0)*x688*x689))+(((-0.045)*x687))+((cj3*x693))+(((-1.0)*x693))+(((-0.045)*x691))+(((0.045)*cj3*x687))+(((-0.3)*x692))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x694=(py*sj0);\nIkReal x695=(cj0*px);\nIkReal x696=(pp*pz);\nIkReal x697=((0.92038656235619)*pp);\nIkReal x698=(pz*sj3);\nIkReal x699=((36.2220411120167)*pp);\nIkReal x700=((0.0254095720202485)*sj3);\nj1eval[0]=((((-5.4333061668025)*x696))+(((12.2222222222222)*x698))+(((-7.28153581454315)*x695))+(((-7.28153581454315)*x694))+(((3.92556370551481)*pz))+(((-1.0)*x695*x699))+(((-1.0)*x694*x699))+((sj3*x695))+((sj3*x694)));\nj1eval[1]=IKsign(((((0.310561435803037)*x698))+((x694*x700))+((x695*x700))+(((0.099746893695352)*pz))+(((-1.0)*x695*x697))+(((-0.138057984353428)*x696))+(((-1.0)*x694*x697))+(((-0.185020708697653)*x694))+(((-0.185020708697653)*x695))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x701=(px*sj0);\nIkReal x702=(cj0*py);\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((((-1.0)*x702))+x701);\nevalcond[3]=((((-1.0)*x701))+x702);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x703=((-1.0)*py);\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x703);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x703);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x703);\nrxp2_1=(px*r22);\nj1eval[0]=((((-1.0)*py*sj0))+(((-1.0)*cj0*px)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(px))+(IKabs(py)));\nevalcond[1]=0.7225;\nevalcond[2]=-0.85;\nevalcond[3]=0;\nevalcond[4]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=0;\nnpx=0;\nnpy=0;\nnpz=0;\nrxp0_0=0;\nrxp0_1=0;\nrxp1_0=0;\nrxp1_1=0;\nrxp2_0=0;\nrxp2_1=0;\npx=0;\npy=0;\nrxp0_2=0;\nrxp1_2=0;\nrxp2_2=0;\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));\nevalcond[1]=((0.7225)+(((-1.0)*(py*py))));\nevalcond[2]=-0.85;\nevalcond[3]=((-1.0)*py);\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x704=((-1.0)*py);\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=py*py;\nnpx=(py*r10);\nnpy=(py*r11);\nnpz=(py*r12);\nrxp0_0=(r20*x704);\nrxp0_1=0;\nrxp1_0=(r21*x704);\nrxp1_1=0;\nrxp2_0=(r22*x704);\nrxp2_1=0;\npx=0;\nj0=0;\nsj0=0;\ncj0=1.0;\nrxp0_2=(py*r00);\nrxp1_2=(py*r01);\nrxp2_2=(py*r02);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*(py*py))));\nevalcond[2]=-0.85;\nevalcond[3]=py;\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x705=((-1.0)*py);\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=py*py;\nnpx=(py*r10);\nnpy=(py*r11);\nnpz=(py*r12);\nrxp0_0=(r20*x705);\nrxp0_1=0;\nrxp1_0=(r21*x705);\nrxp1_1=0;\nrxp2_0=(r22*x705);\nrxp2_1=0;\npx=0;\nj0=3.14159265358979;\nsj0=0;\ncj0=-1.0;\nrxp0_2=(py*r00);\nrxp1_2=(py*r01);\nrxp2_2=(py*r02);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*(px*px))));\nevalcond[2]=-0.85;\nevalcond[3]=px;\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x706=((-1.0)*px);\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=px*px;\nnpx=(px*r00);\nnpy=(px*r01);\nnpz=(px*r02);\nrxp0_0=0;\nrxp0_1=(px*r20);\nrxp1_0=0;\nrxp1_1=(px*r21);\nrxp2_0=0;\nrxp2_1=(px*r22);\npy=0;\nj0=1.5707963267949;\nsj0=1.0;\ncj0=0;\nrxp0_2=(r10*x706);\nrxp1_2=(r11*x706);\nrxp2_2=(r12*x706);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*(px*px))));\nevalcond[2]=-0.85;\nevalcond[3]=((-1.0)*px);\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x707=((-1.0)*px);\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=px*px;\nnpx=(px*r00);\nnpy=(px*r01);\nnpz=(px*r02);\nrxp0_0=0;\nrxp0_1=(px*r20);\nrxp1_0=0;\nrxp1_1=(px*r21);\nrxp2_0=0;\nrxp2_1=(px*r22);\npy=0;\nj0=-1.5707963267949;\nsj0=-1.0;\ncj0=0;\nrxp0_2=(r10*x707);\nrxp1_2=(r11*x707);\nrxp2_2=(r12*x707);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x708=py*py;\nIkReal x709=cj0*cj0;\nIkReal x710=(cj0*px);\nIkReal x711=(py*sj0);\nIkReal x712=((4400.0)*x708);\nCheckValue<IkReal> x713=IKPowWithIntegerCheck(((((-306.0)*x711))+(((-306.0)*x710))),-1);\nif(!x713.valid){\ncontinue;\n}\nif( IKabs(((((1.17647058823529)*x710))+(((1.17647058823529)*x711)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x713.value)*(((3179.0)+(((-4400.0)*x709*(px*px)))+((x709*x712))+(((-1.0)*x712))+(((-8800.0)*x710*x711)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((1.17647058823529)*x710))+(((1.17647058823529)*x711))))+IKsqr(((x713.value)*(((3179.0)+(((-4400.0)*x709*(px*px)))+((x709*x712))+(((-1.0)*x712))+(((-8800.0)*x710*x711))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj1array[0]=IKatan2(((((1.17647058823529)*x710))+(((1.17647058823529)*x711))), ((x713.value)*(((3179.0)+(((-4400.0)*x709*(px*px)))+((x709*x712))+(((-1.0)*x712))+(((-8800.0)*x710*x711))))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x714=IKcos(j1);\nIkReal x715=IKsin(j1);\nIkReal x716=(py*sj0);\nIkReal x717=(cj0*px);\nIkReal x718=((0.09)*x714);\nIkReal x719=(x715*x716);\nevalcond[0]=((-0.85)*x714);\nevalcond[1]=(((x714*x717))+((x714*x716)));\nevalcond[2]=((-0.85)+((x715*x717))+x719);\nevalcond[3]=((((-1.0)*x717))+(((-1.0)*x716))+(((0.85)*x715)));\nevalcond[4]=((-0.935)+(((1.1)*x719))+(((1.1)*x715*x717))+(((-1.0)*x717*x718))+(((-1.0)*x716*x718)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x720=cj3*cj3;\nIkReal x721=(cj3*sj3);\nIkReal x722=(cj0*px);\nIkReal x723=((0.92038656235619)*pp);\nIkReal x724=((0.0254095720202485)*sj3);\nIkReal x725=(py*sj0);\nIkReal x726=((0.0414173953060285)*pp);\nIkReal x727=((1.0)*pz);\nCheckValue<IkReal> x728 = IKatan2WithCheck(IkReal(((-0.100617959042798)+(((0.00762287160607455)*x721))+(((-0.276115968706857)*cj3*pp))+(pz*pz)+(((-0.506212609295904)*pp))+(((0.00564933271974229)*sj3))+(((-0.00114343074091118)*x720))+(((-1.0)*sj3*x726))+(((-0.0555062126092959)*cj3)))),((0.0688360561435803)+(((0.175297399907961)*sj3))+(((-1.0)*cj3*x726))+(((-1.0)*x722*x727))+(((0.0931684307409112)*x721))+(((-1.0)*x725*x727))+(((-0.00621260929590428)*pp*sj3))+(((-0.0139752646111367)*x720))+(((-0.0759318913943856)*pp))+(((0.0299240681086056)*cj3))),IKFAST_ATAN2_MAGTHRESH);\nif(!x728.valid){\ncontinue;\n}\nCheckValue<IkReal> x729=IKPowWithIntegerCheck(IKsign(((((-0.138057984353428)*pp*pz))+(((-1.0)*x723*x725))+(((0.310561435803037)*pz*sj3))+(((-1.0)*x722*x723))+((x722*x724))+(((0.099746893695352)*pz))+(((-0.185020708697653)*x722))+(((-0.185020708697653)*x725))+((x724*x725)))),-1);\nif(!x729.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x728.value)+(((1.5707963267949)*(x729.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x730=IKsin(j1);\nIkReal x731=IKcos(j1);\nIkReal x732=((0.045)*sj3);\nIkReal x733=((0.3)*cj3);\nIkReal x734=((0.045)*cj3);\nIkReal x735=(cj0*px);\nIkReal x736=(py*sj0);\nIkReal x737=(sj3*x731);\nIkReal x738=(pz*x730);\nIkReal x739=(pz*x731);\nIkReal x740=((0.09)*x731);\nIkReal x741=((1.1)*x730);\nevalcond[0]=((-0.55)+(((-1.0)*x733))+(((-1.0)*x732))+x739+((x730*x735))+((x730*x736)));\nevalcond[1]=((0.045)+((x731*x736))+((x731*x735))+(((-1.0)*x738))+(((-1.0)*x734))+(((0.3)*sj3)));\nevalcond[2]=((((0.138057984353428)*pp*x730))+(((0.0254095720202485)*x737))+(((-0.099746893695352)*x730))+(((-0.310561435803037)*sj3*x730))+pz+(((-0.185020708697653)*x731))+(((-0.92038656235619)*pp*x731)));\nevalcond[3]=(((x731*x734))+(((0.55)*x730))+(((-0.045)*x731))+(((-1.0)*x736))+(((-1.0)*x735))+(((-0.3)*x737))+((x730*x732))+((x730*x733)));\nevalcond[4]=((-0.2125)+(((1.1)*x739))+(((0.09)*x738))+(((-1.0)*pp))+(((-1.0)*x735*x740))+(((-1.0)*x736*x740))+((x735*x741))+((x736*x741)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x742=cj0*cj0;\nIkReal x743=py*py;\nIkReal x744=cj3*cj3;\nIkReal x745=(py*sj0);\nIkReal x746=((0.3)*sj3);\nIkReal x747=((0.045)*cj3);\nIkReal x748=(cj0*px);\nIkReal x749=(cj3*sj3);\nIkReal x750=((1.0)*pz);\nCheckValue<IkReal> x751 = IKatan2WithCheck(IkReal(((-0.03825)+(((0.027)*x744))+(((0.01125)*cj3))+(((-1.0)*x745*x750))+(((-0.167025)*sj3))+(((-0.087975)*x749))+(((-1.0)*x748*x750)))),((-0.304525)+(((-0.0495)*sj3))+((x742*(px*px)))+(((-1.0)*x742*x743))+(((2.0)*x745*x748))+(((-0.087975)*x744))+x743+(((-0.027)*x749))+(((-0.33)*cj3))),IKFAST_ATAN2_MAGTHRESH);\nif(!x751.valid){\ncontinue;\n}\nCheckValue<IkReal> x752=IKPowWithIntegerCheck(IKsign(((((-0.55)*pz))+(((-0.3)*cj3*pz))+((x745*x747))+(((-1.0)*x745*x746))+(((-1.0)*x746*x748))+(((-0.045)*pz*sj3))+((x747*x748))+(((-0.045)*x748))+(((-0.045)*x745)))),-1);\nif(!x752.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x751.value)+(((1.5707963267949)*(x752.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x753=IKsin(j1);\nIkReal x754=IKcos(j1);\nIkReal x755=((0.045)*sj3);\nIkReal x756=((0.3)*cj3);\nIkReal x757=((0.045)*cj3);\nIkReal x758=(cj0*px);\nIkReal x759=(py*sj0);\nIkReal x760=(sj3*x754);\nIkReal x761=(pz*x753);\nIkReal x762=(pz*x754);\nIkReal x763=((0.09)*x754);\nIkReal x764=((1.1)*x753);\nevalcond[0]=((-0.55)+x762+((x753*x759))+((x753*x758))+(((-1.0)*x756))+(((-1.0)*x755)));\nevalcond[1]=((0.045)+(((-1.0)*x761))+(((0.3)*sj3))+(((-1.0)*x757))+((x754*x758))+((x754*x759)));\nevalcond[2]=((((-0.92038656235619)*pp*x754))+(((-0.310561435803037)*sj3*x753))+(((-0.185020708697653)*x754))+pz+(((-0.099746893695352)*x753))+(((0.0254095720202485)*x760))+(((0.138057984353428)*pp*x753)));\nevalcond[3]=((((0.55)*x753))+(((-0.3)*x760))+(((-1.0)*x759))+(((-1.0)*x758))+(((-0.045)*x754))+((x753*x756))+((x753*x755))+((x754*x757)));\nevalcond[4]=((-0.2125)+(((-1.0)*x758*x763))+(((0.09)*x761))+(((1.1)*x762))+((x759*x764))+((x758*x764))+(((-1.0)*pp))+(((-1.0)*x759*x763)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x765=cj0*cj0;\nIkReal x766=py*py;\nIkReal x767=(pz*sj3);\nIkReal x768=(py*sj0);\nIkReal x769=((0.3)*cj3);\nIkReal x770=((0.045)*sj3);\nIkReal x771=((0.045)*cj3);\nIkReal x772=(cj0*px);\nIkReal x773=((0.3)*sj3);\nCheckValue<IkReal> x774=IKPowWithIntegerCheck(IKsign(((pz*pz)+(((2.0)*x768*x772))+(((-1.0)*x765*x766))+x766+((x765*(px*px))))),-1);\nif(!x774.valid){\ncontinue;\n}\nCheckValue<IkReal> x775 = IKatan2WithCheck(IkReal((((x770*x772))+((x768*x769))+(((0.045)*pz))+((x769*x772))+(((-1.0)*pz*x771))+(((0.55)*x772))+(((0.3)*x767))+(((0.55)*x768))+((x768*x770)))),((((-1.0)*x768*x773))+((x771*x772))+(((-0.045)*x768))+(((0.045)*x767))+((pz*x769))+(((-0.045)*x772))+(((-1.0)*x772*x773))+(((0.55)*pz))+((x768*x771))),IKFAST_ATAN2_MAGTHRESH);\nif(!x775.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x774.value)))+(x775.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x776=IKsin(j1);\nIkReal x777=IKcos(j1);\nIkReal x778=((0.045)*sj3);\nIkReal x779=((0.3)*cj3);\nIkReal x780=((0.045)*cj3);\nIkReal x781=(cj0*px);\nIkReal x782=(py*sj0);\nIkReal x783=(sj3*x777);\nIkReal x784=(pz*x776);\nIkReal x785=(pz*x777);\nIkReal x786=((0.09)*x777);\nIkReal x787=((1.1)*x776);\nevalcond[0]=((-0.55)+x785+(((-1.0)*x778))+(((-1.0)*x779))+((x776*x781))+((x776*x782)));\nevalcond[1]=((0.045)+(((-1.0)*x780))+(((0.3)*sj3))+(((-1.0)*x784))+((x777*x781))+((x777*x782)));\nevalcond[2]=((((-0.185020708697653)*x777))+(((-0.099746893695352)*x776))+pz+(((-0.310561435803037)*sj3*x776))+(((0.138057984353428)*pp*x776))+(((0.0254095720202485)*x783))+(((-0.92038656235619)*pp*x777)));\nevalcond[3]=(((x776*x778))+((x776*x779))+(((-0.045)*x777))+(((0.55)*x776))+(((-1.0)*x781))+(((-1.0)*x782))+(((-0.3)*x783))+((x777*x780)));\nevalcond[4]=((-0.2125)+((x781*x787))+(((0.09)*x784))+(((1.1)*x785))+((x782*x787))+(((-1.0)*x781*x786))+(((-1.0)*pp))+(((-1.0)*x782*x786)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x788=cj2*cj2;\nIkReal x789=((0.045)*px);\nIkReal x790=(sj0*sj2);\nIkReal x791=(pz*sj2);\nIkReal x792=(cj0*cj3);\nIkReal x793=((0.55)*cj2);\nIkReal x794=(px*sj0);\nIkReal x795=(cj0*py);\nIkReal x796=((0.3)*cj3);\nIkReal x797=((0.3)*sj3);\nIkReal x798=((0.045)*sj3);\nIkReal x799=(sj0*x788);\nIkReal x800=(cj0*cj2*sj2);\nIkReal x801=((0.3)*cj2*py);\nIkReal x802=((0.045)*x788);\nIkReal x803=((0.045)*cj2*py);\nCheckValue<IkReal> x804 = IKatan2WithCheck(IkReal(((((-1.0)*cj0*px*x791))+((x793*x795))+(((-1.0)*x793*x794))+((cj2*x795*x798))+(((-1.0)*cj2*x794*x796))+((x792*x801))+(((-1.0)*py*pz*x790))+(((-1.0)*cj2*sj0*sj3*x789)))),((((-1.0)*x788*x794*x797))+((cj3*x789*x799))+((x795*x802))+(((-1.0)*pz*x791))+(((-1.0)*x789*x799))+(((-1.0)*py*x792*x802))+((x788*x795*x797))),IKFAST_ATAN2_MAGTHRESH);\nif(!x804.valid){\ncontinue;\n}\nCheckValue<IkReal> x805=IKPowWithIntegerCheck(IKsign(((((-0.55)*x791))+((x790*x803))+((px*x797*x800))+((x789*x800))+(((-1.0)*x791*x798))+(((-1.0)*x791*x796))+(((-1.0)*cj2*sj2*x789*x792))+(((-1.0)*cj3*x790*x803))+((cj2*py*x790*x797)))),-1);\nif(!x805.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x804.value)+(((1.5707963267949)*(x805.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x806=IKsin(j1);\nIkReal x807=IKcos(j1);\nIkReal x808=(px*sj2);\nIkReal x809=((0.3)*sj3);\nIkReal x810=((0.09)*sj0);\nIkReal x811=(cj2*px);\nIkReal x812=((0.045)*cj3);\nIkReal x813=((0.045)*cj2);\nIkReal x814=(py*sj0);\nIkReal x815=((0.045)*sj3);\nIkReal x816=((1.0)*cj0);\nIkReal x817=((0.3)*cj3);\nIkReal x818=(py*sj2);\nIkReal x819=(cj0*x807);\nIkReal x820=(cj3*x806);\nIkReal x821=(cj2*x807);\nIkReal x822=(cj2*x806);\nIkReal x823=(pz*x807);\nIkReal x824=(cj0*px*x806);\nevalcond[0]=((-0.55)+(((-1.0)*x815))+(((-1.0)*x817))+((x806*x814))+x823+x824);\nevalcond[1]=((((-1.0)*pz*sj2*x806))+((sj0*x811))+((sj2*x807*x814))+((x808*x819))+(((-1.0)*cj2*py*x816)));\nevalcond[2]=(((x809*x822))+(((-1.0)*x812*x822))+(((-0.55)*x807))+pz+(((-1.0)*x807*x815))+(((-1.0)*x807*x817))+((x806*x813)));\nevalcond[3]=((0.045)+((pz*x822))+(((-1.0)*x814*x821))+(((-1.0)*x816*x818))+(((-1.0)*x812))+(((-1.0)*x807*x811*x816))+((sj0*x808))+x809);\nevalcond[4]=(((x809*x821))+(((-1.0)*x812*x821))+(((-1.0)*x814))+((x807*x813))+(((-1.0)*px*x816))+((x806*x817))+((x806*x815))+(((0.55)*x806)));\nevalcond[5]=((-0.2125)+(((-0.09)*pz*x822))+((py*x810*x821))+(((-1.0)*x808*x810))+(((0.09)*x811*x819))+(((0.09)*cj0*x818))+(((-1.0)*pp))+(((1.1)*x824))+(((1.1)*x823))+(((1.1)*x806*x814)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x825=cj0*cj0;\nIkReal x826=py*py;\nIkReal x827=px*px;\nIkReal x828=(px*py);\nIkReal x829=((1.0)*cj2);\nIkReal x830=(cj0*sj2);\nIkReal x831=(cj2*sj0);\nIkReal x832=((0.3)*cj3);\nIkReal x833=(pz*sj2);\nIkReal x834=((0.045)*sj3);\nIkReal x835=(sj2*x826);\nIkReal x836=(py*sj0*sj2);\nCheckValue<IkReal> x837 = IKatan2WithCheck(IkReal((((x832*x836))+(((0.55)*x836))+((x834*x836))+(((-1.0)*cj0*py*pz*x829))+((px*pz*x831))+(((0.55)*px*x830))+((px*x830*x834))+((px*x830*x832)))),((((-1.0)*x828*x829))+((x832*x833))+((x833*x834))+(((0.55)*x833))+(((2.0)*cj2*x825*x828))+((cj0*x826*x831))+(((-1.0)*cj0*sj0*x827*x829))),IKFAST_ATAN2_MAGTHRESH);\nif(!x837.valid){\ncontinue;\n}\nCheckValue<IkReal> x838=IKPowWithIntegerCheck(IKsign((((sj2*x825*x827))+(((2.0)*sj0*x828*x830))+((pz*x833))+x835+(((-1.0)*x825*x835)))),-1);\nif(!x838.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x837.value)+(((1.5707963267949)*(x838.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x839=IKsin(j1);\nIkReal x840=IKcos(j1);\nIkReal x841=(px*sj2);\nIkReal x842=((0.3)*sj3);\nIkReal x843=((0.09)*sj0);\nIkReal x844=(cj2*px);\nIkReal x845=((0.045)*cj3);\nIkReal x846=((0.045)*cj2);\nIkReal x847=(py*sj0);\nIkReal x848=((0.045)*sj3);\nIkReal x849=((1.0)*cj0);\nIkReal x850=((0.3)*cj3);\nIkReal x851=(py*sj2);\nIkReal x852=(cj0*x840);\nIkReal x853=(cj3*x839);\nIkReal x854=(cj2*x840);\nIkReal x855=(cj2*x839);\nIkReal x856=(pz*x840);\nIkReal x857=(cj0*px*x839);\nevalcond[0]=((-0.55)+(((-1.0)*x850))+((x839*x847))+(((-1.0)*x848))+x856+x857);\nevalcond[1]=((((-1.0)*pz*sj2*x839))+((x841*x852))+(((-1.0)*cj2*py*x849))+((sj2*x840*x847))+((sj0*x844)));\nevalcond[2]=(((x842*x855))+((x839*x846))+(((-1.0)*x845*x855))+(((-1.0)*x840*x848))+pz+(((-1.0)*x840*x850))+(((-0.55)*x840)));\nevalcond[3]=((0.045)+(((-1.0)*x847*x854))+(((-1.0)*x849*x851))+(((-1.0)*x845))+(((-1.0)*x840*x844*x849))+x842+((sj0*x841))+((pz*x855)));\nevalcond[4]=(((x842*x854))+((x840*x846))+((x839*x848))+(((-1.0)*x845*x854))+(((-1.0)*px*x849))+(((0.55)*x839))+(((-1.0)*x847))+((x839*x850)));\nevalcond[5]=((-0.2125)+(((-1.0)*x841*x843))+(((0.09)*cj0*x851))+((py*x843*x854))+(((1.1)*x856))+(((1.1)*x857))+(((0.09)*x844*x852))+(((1.1)*x839*x847))+(((-0.09)*pz*x855))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x858=cj3*cj3;\nIkReal x859=(cj2*sj3);\nIkReal x860=(py*sj0);\nIkReal x861=((0.3)*cj3);\nIkReal x862=((0.045)*sj3);\nIkReal x863=(cj0*px);\nIkReal x864=(cj2*cj3);\nIkReal x865=((0.045)*pz);\nIkReal x866=((1.0)*pz);\nCheckValue<IkReal> x867=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj2*x865))+(((-0.3)*pz*x859))+(((-1.0)*x862*x863))+(((-1.0)*x861*x863))+(((-1.0)*x860*x861))+(((-1.0)*x860*x862))+(((-0.55)*x863))+(((-0.55)*x860))+((x864*x865)))),-1);\nif(!x867.valid){\ncontinue;\n}\nCheckValue<IkReal> x868 = IKatan2WithCheck(IkReal(((-0.304525)+(((-0.087975)*x858))+(((-0.0495)*sj3))+(((-0.027)*cj3*sj3))+(pz*pz)+(((-0.33)*cj3)))),((((-0.167025)*x859))+(((-0.087975)*cj3*x859))+(((-1.0)*x860*x866))+(((0.027)*cj2*x858))+(((0.01125)*x864))+(((-0.03825)*cj2))+(((-1.0)*x863*x866))),IKFAST_ATAN2_MAGTHRESH);\nif(!x868.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x867.value)))+(x868.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x869=IKsin(j1);\nIkReal x870=IKcos(j1);\nIkReal x871=(px*sj2);\nIkReal x872=((0.3)*sj3);\nIkReal x873=((0.09)*sj0);\nIkReal x874=(cj2*px);\nIkReal x875=((0.045)*cj3);\nIkReal x876=((0.045)*cj2);\nIkReal x877=(py*sj0);\nIkReal x878=((0.045)*sj3);\nIkReal x879=((1.0)*cj0);\nIkReal x880=((0.3)*cj3);\nIkReal x881=(py*sj2);\nIkReal x882=(cj0*x870);\nIkReal x883=(cj3*x869);\nIkReal x884=(cj2*x870);\nIkReal x885=(cj2*x869);\nIkReal x886=(pz*x870);\nIkReal x887=(cj0*px*x869);\nevalcond[0]=((-0.55)+(((-1.0)*x880))+((x869*x877))+x887+x886+(((-1.0)*x878)));\nevalcond[1]=(((sj2*x870*x877))+(((-1.0)*cj2*py*x879))+((sj0*x874))+((x871*x882))+(((-1.0)*pz*sj2*x869)));\nevalcond[2]=((((-1.0)*x870*x880))+pz+(((-0.55)*x870))+(((-1.0)*x870*x878))+((x869*x876))+((x872*x885))+(((-1.0)*x875*x885)));\nevalcond[3]=((0.045)+(((-1.0)*x879*x881))+((pz*x885))+(((-1.0)*x870*x874*x879))+((sj0*x871))+(((-1.0)*x877*x884))+x872+(((-1.0)*x875)));\nevalcond[4]=(((x870*x876))+(((0.55)*x869))+(((-1.0)*x877))+((x869*x880))+((x869*x878))+(((-1.0)*px*x879))+((x872*x884))+(((-1.0)*x875*x884)));\nevalcond[5]=((-0.2125)+(((1.1)*x887))+(((1.1)*x886))+(((1.1)*x869*x877))+(((0.09)*x874*x882))+(((-1.0)*x871*x873))+((py*x873*x884))+(((-1.0)*pp))+(((0.09)*cj0*x881))+(((-0.09)*pz*x885)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nIkReal x888=((0.045)*cj2);\nIkReal x889=((-0.55)+(((-0.045)*sj3))+(((-0.3)*cj3)));\nIkReal x890=((((-1.0)*cj3*x888))+(((0.3)*cj2*sj3))+x888);\nCheckValue<IkReal> x893 = IKatan2WithCheck(IkReal(x889),x890,IKFAST_ATAN2_MAGTHRESH);\nif(!x893.valid){\ncontinue;\n}\nIkReal x891=((1.0)*(x893.value));\nif((((x889*x889)+(x890*x890))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x894=IKPowWithIntegerCheck(IKabs(IKsqrt(((x889*x889)+(x890*x890)))),-1);\nif(!x894.valid){\ncontinue;\n}\nif( ((pz*(x894.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x894.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x892=IKasin((pz*(x894.value)));\nj1array[0]=((((-1.0)*x891))+(((-1.0)*x892)));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nj1array[1]=((3.14159265358979)+(((-1.0)*x891))+x892);\nsj1array[1]=IKsin(j1array[1]);\ncj1array[1]=IKcos(j1array[1]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nif( j1array[1] > IKPI )\n{\n    j1array[1]-=IK2PI;\n}\nelse if( j1array[1] < -IKPI )\n{    j1array[1]+=IK2PI;\n}\nj1valid[1] = true;\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n\n{\nIkReal j0eval[2];\nIkReal x895=(((pp*sj1))+(((-1.0)*sj1*(pz*pz))));\nj0eval[0]=x895;\nj0eval[1]=IKsign(x895);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[2];\nIkReal x896=(cj2*sj1);\nIkReal x897=(((x896*(pz*pz)))+(((-1.0)*pp*x896)));\nj0eval[0]=x897;\nj0eval[1]=IKsign(x897);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[2];\nIkReal x898=(pp+(((-1.0)*(pz*pz))));\nj0eval[0]=x898;\nj0eval[1]=IKsign(x898);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=((((-0.045)*cj1*sj3))+(((-0.55)*cj1))+pz+(((-0.3)*cj1*cj3)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nIkReal x899=(cj1*px);\nIkReal x900=((0.3)*sj3);\nIkReal x901=(cj1*py);\nIkReal x902=(pz*sj1);\nIkReal x903=((0.045)*cj3);\nIkReal x904=(((cj1*pp))+(((-1.0)*cj1*(pz*pz))));\nj0eval[0]=x904;\nj0eval[1]=((IKabs((((px*x902))+((x900*x901))+(((0.045)*x901))+(((-1.0)*x901*x903)))))+(IKabs(((((-0.045)*x899))+((x899*x903))+(((-1.0)*x899*x900))+((py*x902))))));\nj0eval[2]=IKsign(x904);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nIkReal x905=pz*pz;\nIkReal x906=((1.1)*pz);\nIkReal x907=(cj1*pp);\nIkReal x908=((0.2125)*cj1);\nIkReal x909=(cj1*x905);\nIkReal x910=((0.09)*pz*sj1);\nj0eval[0]=((((-1.0)*x909))+x907);\nj0eval[1]=((IKabs(((((-1.0)*px*x908))+((px*x906))+(((-1.0)*px*x907))+((py*x910)))))+(IKabs((((px*x910))+(((-1.0)*py*x906))+((py*x907))+((py*x908))))));\nj0eval[2]=IKsign(((((0.09)*x907))+(((-0.09)*x909))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nIkReal x911=((0.3)*sj3);\nIkReal x912=(py*sj1);\nIkReal x913=((0.3)*cj3);\nIkReal x914=(px*sj1);\nIkReal x915=((0.045)*sj3);\nIkReal x916=((0.045)*px);\nIkReal x917=((0.045)*py);\nIkReal x918=(pp+(((-1.0)*(pz*pz))));\nj0eval[0]=x918;\nj0eval[1]=((IKabs(((((-1.0)*px*x911))+(((-1.0)*x916))+((cj3*x916))+(((0.55)*x912))+((x912*x915))+((x912*x913)))))+(IKabs(((((-1.0)*cj3*x917))+((x914*x915))+(((0.55)*x914))+((x913*x914))+x917+((py*x911))))));\nj0eval[2]=IKsign(x918);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=((-1.0)*pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj1=1.0;\ncj1=0;\nj1=1.5707963267949;\nIkReal x919=pz*pz;\nIkReal x920=sj3*sj3;\nIkReal x921=cj3*cj3;\nIkReal x922=((4.26078431372549)*cj3);\nIkReal x923=((((-1.0)*pp))+x919);\nIkReal x924=((1.20294117647059)*x921);\nIkReal x925=((1.20294117647059)*x920);\nj0eval[0]=x923;\nj0eval[1]=((((-3.98071895424837)*x919))+(((-1.0)*sj3*x919))+((pp*sj3))+((pp*x925))+((pp*x922))+((pp*x924))+(((-1.0)*x919*x925))+(((-1.0)*x919*x922))+(((-1.0)*x919*x924))+(((3.98071895424837)*pp)));\nj0eval[2]=IKsign(x923);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj1=1.0;\ncj1=0;\nj1=1.5707963267949;\nIkReal x926=pz*pz;\nIkReal x927=((0.00405)*sj3);\nIkReal x928=((0.33)*cj3);\nIkReal x929=((0.027)*cj3);\nIkReal x930=((0.0495)*sj3);\nj0eval[0]=((((-1.0)*x926))+pp);\nj0eval[1]=IKsign(((((-0.09)*x926))+(((0.09)*pp))));\nj0eval[2]=((IKabs(((((0.0495)*px))+(((-1.0)*py*x928))+(((-1.0)*py*x930))+((px*x927))+((px*x929))+(((-0.3925)*py))+((pp*py)))))+(IKabs(((((-1.0)*pp*px))+(((0.0495)*py))+((py*x929))+((py*x927))+((px*x928))+((px*x930))+(((0.3925)*px))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj1=1.0;\ncj1=0;\nj1=1.5707963267949;\nIkReal x931=pz*pz;\nIkReal x932=(cj3*py);\nIkReal x933=(py*sj3);\nIkReal x934=((1.0)*pp);\nIkReal x935=(cj3*px);\nIkReal x936=(px*sj3);\nj0eval[0]=(x931+(((-1.0)*x934)));\nj0eval[1]=IKsign(((((1.1)*x931))+(((-1.1)*pp))));\nj0eval[2]=((IKabs(((((0.33)*x936))+(((0.0495)*px))+(((-0.0495)*x935))+(((0.027)*x933))+(((-1.0)*py*x934))+(((-0.00405)*x932))+(((-0.20845)*py)))))+(IKabs(((((0.0495)*x932))+(((-1.0)*px*x934))+(((-0.0495)*py))+(((-0.33)*x933))+(((0.027)*x936))+(((-0.00405)*x935))+(((-0.20845)*px))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x937=(cj3*py);\nIkReal x938=(py*sj3);\nIkReal x939=((1.0)*pp);\nIkReal x940=(cj3*px);\nIkReal x941=(px*sj3);\nCheckValue<IkReal> x942=IKPowWithIntegerCheck(IKsign(((((-1.1)*pp))+(((1.1)*(pz*pz))))),-1);\nif(!x942.valid){\ncontinue;\n}\nCheckValue<IkReal> x943 = IKatan2WithCheck(IkReal(((((0.0495)*px))+(((0.33)*x941))+(((-0.0495)*x940))+(((0.027)*x938))+(((-1.0)*py*x939))+(((-0.00405)*x937))+(((-0.20845)*py)))),((((0.0495)*x937))+(((-0.00405)*x940))+(((-1.0)*px*x939))+(((-0.0495)*py))+(((0.027)*x941))+(((-0.33)*x938))+(((-0.20845)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x943.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x942.value)))+(x943.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x944=IKsin(j0);\nIkReal x945=IKcos(j0);\nIkReal x946=(px*x944);\nIkReal x947=(py*x945);\nIkReal x948=(px*x945);\nIkReal x949=(py*x944);\nevalcond[0]=((-0.55)+(((-0.045)*sj3))+(((-0.3)*cj3))+x948+x949);\nevalcond[1]=((0.045)+(((-1.0)*x947))+(((-0.045)*cj3))+(((0.3)*sj3))+x946);\nevalcond[2]=((-0.2125)+(((0.09)*x947))+(((-1.0)*pp))+(((1.1)*x948))+(((1.1)*x949))+(((-0.09)*x946)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x950=((0.33)*cj3);\nIkReal x951=((0.027)*cj3);\nIkReal x952=((0.00405)*sj3);\nIkReal x953=((0.0495)*sj3);\nCheckValue<IkReal> x954=IKPowWithIntegerCheck(IKsign(((((-0.09)*(pz*pz)))+(((0.09)*pp)))),-1);\nif(!x954.valid){\ncontinue;\n}\nCheckValue<IkReal> x955 = IKatan2WithCheck(IkReal((((px*x953))+((px*x950))+(((-1.0)*pp*px))+(((0.0495)*py))+((py*x951))+((py*x952))+(((0.3925)*px)))),((((-1.0)*py*x950))+(((-1.0)*py*x953))+((px*x951))+((px*x952))+(((0.0495)*px))+(((-0.3925)*py))+((pp*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x955.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x954.value)))+(x955.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x956=IKsin(j0);\nIkReal x957=IKcos(j0);\nIkReal x958=(px*x956);\nIkReal x959=(py*x957);\nIkReal x960=(px*x957);\nIkReal x961=(py*x956);\nevalcond[0]=((-0.55)+(((-0.045)*sj3))+(((-0.3)*cj3))+x960+x961);\nevalcond[1]=((0.045)+(((-1.0)*x959))+(((-0.045)*cj3))+(((0.3)*sj3))+x958);\nevalcond[2]=((-0.2125)+(((-0.09)*x958))+(((0.09)*x959))+(((-1.0)*pp))+(((1.1)*x960))+(((1.1)*x961)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x962=((0.3)*py);\nIkReal x963=((0.045)*px);\nIkReal x964=((0.045)*py);\nIkReal x965=((0.3)*px);\nCheckValue<IkReal> x966=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp))+(pz*pz))),-1);\nif(!x966.valid){\ncontinue;\n}\nCheckValue<IkReal> x967 = IKatan2WithCheck(IkReal(((((-0.55)*py))+(((-1.0)*cj3*x963))+(((-1.0)*cj3*x962))+(((-1.0)*sj3*x964))+((sj3*x965))+x963)),((((-0.55)*px))+(((-1.0)*cj3*x965))+(((-1.0)*sj3*x963))+(((-1.0)*sj3*x962))+((cj3*x964))+(((-1.0)*x964))),IKFAST_ATAN2_MAGTHRESH);\nif(!x967.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x966.value)))+(x967.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x968=IKsin(j0);\nIkReal x969=IKcos(j0);\nIkReal x970=(px*x968);\nIkReal x971=(py*x969);\nIkReal x972=(px*x969);\nIkReal x973=(py*x968);\nevalcond[0]=((-0.55)+(((-0.045)*sj3))+(((-0.3)*cj3))+x973+x972);\nevalcond[1]=((0.045)+(((-1.0)*x971))+(((-0.045)*cj3))+(((0.3)*sj3))+x970);\nevalcond[2]=((-0.2125)+(((-0.09)*x970))+(((0.09)*x971))+(((-1.0)*pp))+(((1.1)*x973))+(((1.1)*x972)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=pz;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj1=-1.0;\ncj1=0;\nj1=-1.5707963267949;\nIkReal x974=pz*pz;\nIkReal x975=sj3*sj3;\nIkReal x976=cj3*cj3;\nIkReal x977=((4.26078431372549)*cj3);\nIkReal x978=((((-1.0)*x974))+pp);\nIkReal x979=((1.20294117647059)*x976);\nIkReal x980=((1.0)*x974);\nIkReal x981=((1.20294117647059)*x975);\nj0eval[0]=x978;\nj0eval[1]=(((pp*x981))+(((-1.0)*x974*x981))+((pp*sj3))+((pp*x977))+((pp*x979))+(((-1.0)*x974*x977))+(((-1.0)*x974*x979))+(((-3.98071895424837)*x974))+(((3.98071895424837)*pp))+(((-1.0)*sj3*x980)));\nj0eval[2]=IKsign(x978);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj1=-1.0;\ncj1=0;\nj1=-1.5707963267949;\nIkReal x982=pz*pz;\nIkReal x983=((0.00405)*sj3);\nIkReal x984=((0.33)*cj3);\nIkReal x985=((0.027)*cj3);\nIkReal x986=((0.0495)*sj3);\nj0eval[0]=((((-1.0)*x982))+pp);\nj0eval[1]=IKsign(((((-0.09)*x982))+(((0.09)*pp))));\nj0eval[2]=((IKabs(((((-1.0)*pp*px))+(((-1.0)*py*x983))+(((-1.0)*py*x985))+(((-0.0495)*py))+(((0.3925)*px))+((px*x986))+((px*x984)))))+(IKabs(((((-1.0)*px*x983))+(((-1.0)*px*x985))+(((-1.0)*py*x986))+(((-1.0)*py*x984))+(((-0.0495)*px))+(((-0.3925)*py))+((pp*py))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj1=-1.0;\ncj1=0;\nj1=-1.5707963267949;\nIkReal x987=pz*pz;\nIkReal x988=(cj3*py);\nIkReal x989=(py*sj3);\nIkReal x990=((1.0)*pp);\nIkReal x991=(cj3*px);\nIkReal x992=(px*sj3);\nj0eval[0]=((((-1.0)*x987))+pp);\nj0eval[1]=IKsign(((((-1.1)*x987))+(((1.1)*pp))));\nj0eval[2]=((IKabs(((((-1.0)*px*x990))+(((0.0495)*py))+(((-0.00405)*x991))+(((0.33)*x989))+(((-0.0495)*x988))+(((0.027)*x992))+(((-0.20845)*px)))))+(IKabs(((((-0.33)*x992))+(((-1.0)*py*x990))+(((0.0495)*x991))+(((0.027)*x989))+(((-0.0495)*px))+(((-0.00405)*x988))+(((-0.20845)*py))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x993=(cj3*py);\nIkReal x994=(py*sj3);\nIkReal x995=((1.0)*pp);\nIkReal x996=(cj3*px);\nIkReal x997=(px*sj3);\nCheckValue<IkReal> x998 = IKatan2WithCheck(IkReal(((((-0.33)*x997))+(((-1.0)*py*x995))+(((0.0495)*x996))+(((-0.00405)*x993))+(((-0.0495)*px))+(((0.027)*x994))+(((-0.20845)*py)))),((((-1.0)*px*x995))+(((0.0495)*py))+(((-0.00405)*x996))+(((0.33)*x994))+(((0.027)*x997))+(((-0.0495)*x993))+(((-0.20845)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x998.valid){\ncontinue;\n}\nCheckValue<IkReal> x999=IKPowWithIntegerCheck(IKsign(((((-1.1)*(pz*pz)))+(((1.1)*pp)))),-1);\nif(!x999.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x998.value)+(((1.5707963267949)*(x999.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1000=IKcos(j0);\nIkReal x1001=IKsin(j0);\nIkReal x1002=(px*x1001);\nIkReal x1003=((1.0)*x1000);\nIkReal x1004=(py*x1001);\nevalcond[0]=((0.045)+x1002+(((-1.0)*py*x1003))+(((-0.045)*cj3))+(((0.3)*sj3)));\nevalcond[1]=((-0.55)+(((-0.045)*sj3))+(((-1.0)*x1004))+(((-0.3)*cj3))+(((-1.0)*px*x1003)));\nevalcond[2]=((-0.2125)+(((-1.1)*px*x1000))+(((-1.1)*x1004))+(((0.09)*py*x1000))+(((-1.0)*pp))+(((-0.09)*x1002)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1005=((0.00405)*sj3);\nIkReal x1006=((0.33)*cj3);\nIkReal x1007=((0.027)*cj3);\nIkReal x1008=((0.0495)*sj3);\nCheckValue<IkReal> x1009 = IKatan2WithCheck(IkReal((((px*x1008))+((px*x1006))+(((-1.0)*pp*px))+(((-1.0)*py*x1005))+(((-1.0)*py*x1007))+(((-0.0495)*py))+(((0.3925)*px)))),((((-1.0)*py*x1008))+(((-1.0)*py*x1006))+(((-0.0495)*px))+(((-0.3925)*py))+(((-1.0)*px*x1007))+(((-1.0)*px*x1005))+((pp*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1009.valid){\ncontinue;\n}\nCheckValue<IkReal> x1010=IKPowWithIntegerCheck(IKsign(((((-0.09)*(pz*pz)))+(((0.09)*pp)))),-1);\nif(!x1010.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1009.value)+(((1.5707963267949)*(x1010.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1011=IKcos(j0);\nIkReal x1012=IKsin(j0);\nIkReal x1013=(px*x1012);\nIkReal x1014=((1.0)*x1011);\nIkReal x1015=(py*x1012);\nevalcond[0]=((0.045)+x1013+(((-1.0)*py*x1014))+(((-0.045)*cj3))+(((0.3)*sj3)));\nevalcond[1]=((-0.55)+(((-0.045)*sj3))+(((-1.0)*px*x1014))+(((-0.3)*cj3))+(((-1.0)*x1015)));\nevalcond[2]=((-0.2125)+(((-1.1)*px*x1011))+(((0.09)*py*x1011))+(((-1.1)*x1015))+(((-0.09)*x1013))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1016=((0.3)*py);\nIkReal x1017=((0.045)*px);\nIkReal x1018=((0.045)*py);\nIkReal x1019=((0.3)*px);\nCheckValue<IkReal> x1020=IKPowWithIntegerCheck(IKsign((pp+(((-1.0)*(pz*pz))))),-1);\nif(!x1020.valid){\ncontinue;\n}\nCheckValue<IkReal> x1021 = IKatan2WithCheck(IkReal(((((-0.55)*py))+(((-1.0)*x1017))+((cj3*x1017))+(((-1.0)*cj3*x1016))+(((-1.0)*sj3*x1019))+(((-1.0)*sj3*x1018)))),((((-0.55)*px))+x1018+((sj3*x1016))+(((-1.0)*cj3*x1018))+(((-1.0)*cj3*x1019))+(((-1.0)*sj3*x1017))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1021.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1020.value)))+(x1021.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1022=IKcos(j0);\nIkReal x1023=IKsin(j0);\nIkReal x1024=(px*x1023);\nIkReal x1025=((1.0)*x1022);\nIkReal x1026=(py*x1023);\nevalcond[0]=((0.045)+x1024+(((-1.0)*py*x1025))+(((-0.045)*cj3))+(((0.3)*sj3)));\nevalcond[1]=((-0.55)+(((-0.045)*sj3))+(((-1.0)*x1026))+(((-0.3)*cj3))+(((-1.0)*px*x1025)));\nevalcond[2]=((-0.2125)+(((-1.1)*x1026))+(((-1.1)*px*x1022))+(((-0.09)*x1024))+(((-1.0)*pp))+(((0.09)*py*x1022)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)*cj1);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nIkReal x1027=((-1.0)*py);\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1027);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1027);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1027);\nrxp2_1=(px*r22);\nIkReal x1028=px*px;\nIkReal x1029=py*py;\nIkReal x1030=(sj1*x1028);\nIkReal x1031=(sj1*x1029);\nj0eval[0]=(x1030+x1031);\nj0eval[1]=IKsign(((((20.0)*x1031))+(((20.0)*x1030))));\nj0eval[2]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[4];\nIkReal x1032=((-1.0)*py);\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1032);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1032);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1032);\nrxp2_1=(px*r22);\nIkReal x1033=px*px;\nIkReal x1034=py*py;\nj0eval[0]=(x1033+x1034);\nj0eval[1]=289.0;\nj0eval[2]=sj1;\nj0eval[3]=IKsign(((((20.0)*x1033))+(((20.0)*x1034))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*(px*px)))+(((-1.0)*(py*py))));\nevalcond[2]=-0.85;\nevalcond[3]=-0.85;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nIkReal x1035=((-1.0)*py);\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1035);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1035);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1035);\nrxp2_1=(px*r22);\nsj1=0;\ncj1=1.0;\nj1=0;\nIkReal x1036=py*py;\nIkReal x1037=px*px;\nj0eval[0]=((((-1.0)*x1037))+(((-1.0)*x1036)));\nj0eval[1]=((IKabs(px))+(IKabs(py)));\nj0eval[2]=IKsign(((((-18.0)*x1036))+(((-18.0)*x1037))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nCheckValue<IkReal> x1038=IKPowWithIntegerCheck(IKsign(((((-18.0)*(px*px)))+(((-18.0)*(py*py))))),-1);\nif(!x1038.valid){\ncontinue;\n}\nCheckValue<IkReal> x1039 = IKatan2WithCheck(IkReal(((187.0)*px)),((-187.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x1039.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1038.value)))+(x1039.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1040=IKcos(j0);\nIkReal x1041=IKsin(j0);\nIkReal x1042=(px*x1041);\nIkReal x1043=((1.0)*x1040);\nevalcond[0]=(x1042+(((-1.0)*py*x1043)));\nevalcond[1]=((((-1.0)*py*x1041))+(((-1.0)*px*x1043)));\nevalcond[2]=((-0.935)+(((0.09)*py*x1040))+(((-0.09)*x1042)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*(px*px)))+(((-1.0)*(py*py))));\nevalcond[2]=-0.85;\nevalcond[3]=0.85;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nIkReal x1044=((-1.0)*py);\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1044);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1044);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1044);\nrxp2_1=(px*r22);\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nIkReal x1045=py*py;\nIkReal x1046=px*px;\nj0eval[0]=((((-1.0)*x1046))+(((-1.0)*x1045)));\nj0eval[1]=((IKabs(px))+(IKabs(py)));\nj0eval[2]=IKsign(((((-18.0)*x1045))+(((-18.0)*x1046))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nCheckValue<IkReal> x1047=IKPowWithIntegerCheck(IKsign(((((-18.0)*(px*px)))+(((-18.0)*(py*py))))),-1);\nif(!x1047.valid){\ncontinue;\n}\nCheckValue<IkReal> x1048 = IKatan2WithCheck(IkReal(((187.0)*px)),((-187.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x1048.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1047.value)))+(x1048.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1049=IKcos(j0);\nIkReal x1050=IKsin(j0);\nIkReal x1051=(px*x1050);\nIkReal x1052=((1.0)*x1049);\nevalcond[0]=(x1051+(((-1.0)*py*x1052)));\nevalcond[1]=((((-1.0)*py*x1050))+(((-1.0)*px*x1052)));\nevalcond[2]=((-0.935)+(((0.09)*py*x1049))+(((-0.09)*x1051)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1053=((17.0)*sj1);\nCheckValue<IkReal> x1054=IKPowWithIntegerCheck(IKsign(((((20.0)*(px*px)))+(((20.0)*(py*py))))),-1);\nif(!x1054.valid){\ncontinue;\n}\nCheckValue<IkReal> x1055 = IKatan2WithCheck(IkReal((py*x1053)),(px*x1053),IKFAST_ATAN2_MAGTHRESH);\nif(!x1055.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1054.value)))+(x1055.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x1056=IKcos(j0);\nIkReal x1057=IKsin(j0);\nIkReal x1058=((1.0)*py);\nIkReal x1059=((1.1)*sj1);\nIkReal x1060=(px*x1057);\nIkReal x1061=(px*x1056);\nIkReal x1062=(py*x1057);\nevalcond[0]=(x1060+(((-1.0)*x1056*x1058)));\nevalcond[1]=((-0.85)+((sj1*x1062))+((sj1*x1061)));\nevalcond[2]=((((0.85)*sj1))+(((-1.0)*x1057*x1058))+(((-1.0)*x1061)));\nevalcond[3]=((-0.935)+(((0.09)*py*x1056))+((x1059*x1062))+((x1059*x1061))+(((-0.09)*x1060)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1063=((20.0)*sj1);\nCheckValue<IkReal> x1064 = IKatan2WithCheck(IkReal(((17.0)*py)),((17.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x1064.valid){\ncontinue;\n}\nCheckValue<IkReal> x1065=IKPowWithIntegerCheck(IKsign((((x1063*(py*py)))+((x1063*(px*px))))),-1);\nif(!x1065.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1064.value)+(((1.5707963267949)*(x1065.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x1066=IKcos(j0);\nIkReal x1067=IKsin(j0);\nIkReal x1068=((1.0)*py);\nIkReal x1069=((1.1)*sj1);\nIkReal x1070=(px*x1067);\nIkReal x1071=(px*x1066);\nIkReal x1072=(py*x1067);\nevalcond[0]=(x1070+(((-1.0)*x1066*x1068)));\nevalcond[1]=((-0.85)+((sj1*x1071))+((sj1*x1072)));\nevalcond[2]=((((0.85)*sj1))+(((-1.0)*x1071))+(((-1.0)*x1067*x1068)));\nevalcond[3]=((-0.935)+((x1069*x1072))+((x1069*x1071))+(((0.09)*py*x1066))+(((-0.09)*x1070)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nj3=0;\nsj3=0;\ncj3=1.0;\nj1=0;\nsj1=0;\ncj1=1.0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nj3=0;\nsj3=0;\ncj3=1.0;\nj1=0;\nsj1=0;\ncj1=1.0;\nj0eval[0]=(pp+(((-1.0)*(pz*pz))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1074 = IKatan2WithCheck(IkReal(((0.09)*py)),((-0.09)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x1074.valid){\ncontinue;\n}\nIkReal x1073=x1074.value;\nj0array[0]=((-1.0)*x1073);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1073)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1075=IKsin(j0);\nIkReal x1076=IKcos(j0);\nevalcond[0]=(((px*x1076))+((py*x1075)));\nevalcond[1]=((((-1.0)*py*x1076))+((px*x1075)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1078 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1078.valid){\ncontinue;\n}\nIkReal x1077=x1078.value;\nj0array[0]=((-1.0)*x1077);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1077)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1079=IKcos(j0);\nIkReal x1080=IKsin(j0);\nIkReal x1081=(px*x1080);\nIkReal x1082=(py*x1079);\nevalcond[0]=(x1081+(((-1.0)*x1082)));\nevalcond[1]=((((-0.09)*x1081))+(((0.09)*x1082)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+(((-1.0)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nj3=0;\nsj3=0;\ncj3=1.0;\nj1=3.14159265358979;\nsj1=0;\ncj1=-1.0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nj3=0;\nsj3=0;\ncj3=1.0;\nj1=3.14159265358979;\nsj1=0;\ncj1=-1.0;\nj0eval[0]=(pp+(((-1.0)*(pz*pz))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1084 = IKatan2WithCheck(IkReal(((0.09)*py)),((-0.09)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x1084.valid){\ncontinue;\n}\nIkReal x1083=x1084.value;\nj0array[0]=((-1.0)*x1083);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1083)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1085=IKcos(j0);\nIkReal x1086=IKsin(j0);\nIkReal x1087=((1.0)*x1085);\nevalcond[0]=((((-1.0)*py*x1087))+((px*x1086)));\nevalcond[1]=((((-1.0)*py*x1086))+(((-1.0)*px*x1087)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1089 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x1089.valid){\ncontinue;\n}\nIkReal x1088=x1089.value;\nj0array[0]=((-1.0)*x1088);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1088)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1090=IKcos(j0);\nIkReal x1091=IKsin(j0);\nevalcond[0]=((((-1.0)*px*x1090))+(((-1.0)*py*x1091)));\nevalcond[1]=((((0.09)*py*x1090))+(((-0.09)*px*x1091)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1092=((0.3)*py);\nIkReal x1093=(cj3*sj1);\nIkReal x1094=(px*sj1);\nIkReal x1095=((0.3)*px);\nIkReal x1096=((0.045)*py);\nIkReal x1097=((0.045)*px);\nCheckValue<IkReal> x1098 = IKatan2WithCheck(IkReal(((((0.55)*py*sj1))+(((-1.0)*x1097))+((sj1*sj3*x1096))+((x1092*x1093))+(((-1.0)*sj3*x1095))+((cj3*x1097)))),(x1096+(((-1.0)*cj3*x1096))+(((0.045)*sj3*x1094))+((x1093*x1095))+((sj3*x1092))+(((0.55)*x1094))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1098.valid){\ncontinue;\n}\nCheckValue<IkReal> x1099=IKPowWithIntegerCheck(IKsign((pp+(((-1.0)*(pz*pz))))),-1);\nif(!x1099.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1098.value)+(((1.5707963267949)*(x1099.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x1100=IKsin(j0);\nIkReal x1101=IKcos(j0);\nIkReal x1102=((0.3)*cj3);\nIkReal x1103=((0.045)*sj3);\nIkReal x1104=(cj1*pz);\nIkReal x1105=(px*x1100);\nIkReal x1106=(px*x1101);\nIkReal x1107=(py*x1100);\nIkReal x1108=(py*x1101);\nIkReal x1109=(sj1*x1107);\nevalcond[0]=(((cj1*x1106))+((cj1*x1107))+(((-1.0)*pz*sj1)));\nevalcond[1]=((0.045)+x1105+(((-1.0)*x1108))+(((-0.045)*cj3))+(((0.3)*sj3)));\nevalcond[2]=((-0.55)+x1104+x1109+((sj1*x1106))+(((-1.0)*x1103))+(((-1.0)*x1102)));\nevalcond[3]=((((-1.0)*x1106))+(((-1.0)*x1107))+((sj1*x1103))+((sj1*x1102))+(((0.55)*sj1)));\nevalcond[4]=((-0.2125)+(((0.09)*x1108))+(((-1.0)*pp))+(((1.1)*x1109))+(((1.1)*x1104))+(((-0.09)*x1105))+(((1.1)*sj1*x1106)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1110=((1.1)*pz);\nIkReal x1111=((0.09)*cj1);\nIkReal x1112=((0.2125)*cj1);\nIkReal x1113=(cj1*pp);\nIkReal x1114=((0.09)*pz*sj1);\nCheckValue<IkReal> x1115=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1111*(pz*pz)))+((pp*x1111)))),-1);\nif(!x1115.valid){\ncontinue;\n}\nCheckValue<IkReal> x1116 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1112))+((py*x1114))+(((-1.0)*px*x1113))+((px*x1110)))),((((-1.0)*py*x1110))+((py*x1112))+((py*x1113))+((px*x1114))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1116.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1115.value)))+(x1116.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x1117=IKsin(j0);\nIkReal x1118=IKcos(j0);\nIkReal x1119=((0.3)*cj3);\nIkReal x1120=((0.045)*sj3);\nIkReal x1121=(cj1*pz);\nIkReal x1122=(px*x1117);\nIkReal x1123=(px*x1118);\nIkReal x1124=(py*x1117);\nIkReal x1125=(py*x1118);\nIkReal x1126=(sj1*x1124);\nevalcond[0]=((((-1.0)*pz*sj1))+((cj1*x1124))+((cj1*x1123)));\nevalcond[1]=((0.045)+x1122+(((-0.045)*cj3))+(((-1.0)*x1125))+(((0.3)*sj3)));\nevalcond[2]=((-0.55)+x1121+x1126+((sj1*x1123))+(((-1.0)*x1120))+(((-1.0)*x1119)));\nevalcond[3]=(((sj1*x1120))+(((-1.0)*x1124))+(((-1.0)*x1123))+((sj1*x1119))+(((0.55)*sj1)));\nevalcond[4]=((-0.2125)+(((1.1)*sj1*x1123))+(((0.09)*x1125))+(((-1.0)*pp))+(((1.1)*x1121))+(((1.1)*x1126))+(((-0.09)*x1122)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1127=((0.045)*cj1);\nIkReal x1128=(pz*sj1);\nIkReal x1129=((0.3)*cj1*sj3);\nCheckValue<IkReal> x1130=IKPowWithIntegerCheck(IKsign((((cj1*pp))+(((-1.0)*cj1*(pz*pz))))),-1);\nif(!x1130.valid){\ncontinue;\n}\nCheckValue<IkReal> x1131 = IKatan2WithCheck(IkReal((((cj3*px*x1127))+((py*x1128))+(((-1.0)*px*x1127))+(((-1.0)*px*x1129)))),(((px*x1128))+((py*x1129))+((py*x1127))+(((-1.0)*cj3*py*x1127))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1131.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1130.value)))+(x1131.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x1132=IKsin(j0);\nIkReal x1133=IKcos(j0);\nIkReal x1134=((0.3)*cj3);\nIkReal x1135=((0.045)*sj3);\nIkReal x1136=(cj1*pz);\nIkReal x1137=(px*x1132);\nIkReal x1138=(px*x1133);\nIkReal x1139=(py*x1132);\nIkReal x1140=(py*x1133);\nIkReal x1141=(sj1*x1139);\nevalcond[0]=((((-1.0)*pz*sj1))+((cj1*x1139))+((cj1*x1138)));\nevalcond[1]=((0.045)+x1137+(((-1.0)*x1140))+(((-0.045)*cj3))+(((0.3)*sj3)));\nevalcond[2]=((-0.55)+x1141+x1136+((sj1*x1138))+(((-1.0)*x1134))+(((-1.0)*x1135)));\nevalcond[3]=(((sj1*x1134))+((sj1*x1135))+(((-1.0)*x1139))+(((-1.0)*x1138))+(((0.55)*sj1)));\nevalcond[4]=((-0.2125)+(((1.1)*x1141))+(((1.1)*sj1*x1138))+(((-1.0)*pp))+(((-0.09)*x1137))+(((0.09)*x1140))+(((1.1)*x1136)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=((((-0.045)*cj1*sj3))+(((-0.55)*cj1))+pz+(((-0.3)*cj1*cj3)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nIkReal x1142=((0.045)*cj1);\nIkReal x1143=(pz*sj1);\nIkReal x1144=((0.3)*cj1*sj3);\nIkReal x1145=(((cj1*pp))+(((-1.0)*cj1*(pz*pz))));\nj0eval[0]=x1145;\nj0eval[1]=IKsign(x1145);\nj0eval[2]=((IKabs((((cj3*py*x1142))+((px*x1143))+(((-1.0)*py*x1144))+(((-1.0)*py*x1142)))))+(IKabs((((py*x1143))+(((-1.0)*cj3*px*x1142))+((px*x1142))+((px*x1144))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nIkReal x1146=pz*pz;\nIkReal x1147=(cj1*pp);\nIkReal x1148=((1.1)*pz);\nIkReal x1149=((0.2125)*cj1);\nIkReal x1150=(cj1*x1146);\nIkReal x1151=((0.09)*pz*sj1);\nj0eval[0]=(x1150+(((-1.0)*x1147)));\nj0eval[1]=((IKabs(((((-1.0)*px*x1149))+(((-1.0)*py*x1151))+(((-1.0)*px*x1147))+((px*x1148)))))+(IKabs(((((-1.0)*px*x1151))+((py*x1147))+((py*x1149))+(((-1.0)*py*x1148))))));\nj0eval[2]=IKsign(((((-0.09)*x1147))+(((0.09)*x1150))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nIkReal x1152=((0.3)*py);\nIkReal x1153=(cj3*sj1);\nIkReal x1154=((0.55)*sj1);\nIkReal x1155=((0.3)*px);\nIkReal x1156=((0.045)*py);\nIkReal x1157=(sj1*sj3);\nIkReal x1158=((0.045)*px);\nIkReal x1159=(pp+(((-1.0)*(pz*pz))));\nj0eval[0]=x1159;\nj0eval[1]=((IKabs(((((-1.0)*x1156))+((cj3*x1156))+((x1153*x1155))+(((-1.0)*sj3*x1152))+((px*x1154))+((x1157*x1158)))))+(IKabs((x1158+((sj3*x1155))+((x1152*x1153))+(((-1.0)*cj3*x1158))+((x1156*x1157))+((py*x1154))))));\nj0eval[2]=IKsign(x1159);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=pz;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj1=1.0;\ncj1=0;\nj1=1.5707963267949;\nIkReal x1160=pz*pz;\nIkReal x1161=sj3*sj3;\nIkReal x1162=cj3*cj3;\nIkReal x1163=((4.26078431372549)*cj3);\nIkReal x1164=(x1160+(((-1.0)*pp)));\nIkReal x1165=((1.20294117647059)*x1162);\nIkReal x1166=((1.20294117647059)*x1161);\nj0eval[0]=x1164;\nj0eval[1]=(((pp*sj3))+(((-1.0)*sj3*x1160))+(((3.98071895424837)*pp))+((pp*x1163))+((pp*x1165))+((pp*x1166))+(((-1.0)*x1160*x1163))+(((-1.0)*x1160*x1165))+(((-1.0)*x1160*x1166))+(((-3.98071895424837)*x1160)));\nj0eval[2]=IKsign(x1164);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj1=1.0;\ncj1=0;\nj1=1.5707963267949;\nIkReal x1167=pz*pz;\nIkReal x1168=((0.33)*cj3);\nIkReal x1169=((1.0)*pp);\nIkReal x1170=((0.027)*cj3);\nIkReal x1171=((0.00405)*sj3);\nIkReal x1172=((0.0495)*sj3);\nj0eval[0]=(x1167+(((-1.0)*x1169)));\nj0eval[1]=((IKabs(((((-1.0)*py*x1172))+(((-1.0)*py*x1168))+(((-0.0495)*px))+(((-1.0)*px*x1170))+(((-1.0)*px*x1171))+(((-0.3925)*py))+((pp*py)))))+(IKabs((((px*x1168))+((px*x1172))+(((-1.0)*py*x1171))+(((-1.0)*py*x1170))+(((-0.0495)*py))+(((-1.0)*px*x1169))+(((0.3925)*px))))));\nj0eval[2]=IKsign(((((-0.09)*pp))+(((0.09)*x1167))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj1=1.0;\ncj1=0;\nj1=1.5707963267949;\nIkReal x1173=pz*pz;\nIkReal x1174=(cj3*py);\nIkReal x1175=(py*sj3);\nIkReal x1176=((1.0)*pp);\nIkReal x1177=(cj3*px);\nIkReal x1178=(px*sj3);\nj0eval[0]=(x1173+(((-1.0)*x1176)));\nj0eval[1]=IKsign(((((-1.1)*pp))+(((1.1)*x1173))));\nj0eval[2]=((IKabs(((((-0.33)*x1178))+(((0.027)*x1175))+(((-0.00405)*x1174))+(((0.0495)*x1177))+(((-1.0)*py*x1176))+(((-0.0495)*px))+(((-0.20845)*py)))))+(IKabs(((((0.0495)*py))+(((0.027)*x1178))+(((-0.00405)*x1177))+(((-0.0495)*x1174))+(((-1.0)*px*x1176))+(((0.33)*x1175))+(((-0.20845)*px))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1179=(cj3*py);\nIkReal x1180=(py*sj3);\nIkReal x1181=((1.0)*pp);\nIkReal x1182=(cj3*px);\nIkReal x1183=(px*sj3);\nCheckValue<IkReal> x1184=IKPowWithIntegerCheck(IKsign(((((-1.1)*pp))+(((1.1)*(pz*pz))))),-1);\nif(!x1184.valid){\ncontinue;\n}\nCheckValue<IkReal> x1185 = IKatan2WithCheck(IkReal(((((0.027)*x1180))+(((0.0495)*x1182))+(((-0.33)*x1183))+(((-0.00405)*x1179))+(((-1.0)*py*x1181))+(((-0.0495)*px))+(((-0.20845)*py)))),((((0.027)*x1183))+(((0.33)*x1180))+(((0.0495)*py))+(((-0.0495)*x1179))+(((-1.0)*px*x1181))+(((-0.00405)*x1182))+(((-0.20845)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1185.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1184.value)))+(x1185.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1186=IKsin(j0);\nIkReal x1187=IKcos(j0);\nIkReal x1188=(px*x1186);\nIkReal x1189=(py*x1187);\nIkReal x1190=(px*x1187);\nIkReal x1191=(py*x1186);\nevalcond[0]=((-0.55)+(((-0.045)*sj3))+x1191+x1190+(((-0.3)*cj3)));\nevalcond[1]=((-0.045)+x1188+(((0.045)*cj3))+(((-1.0)*x1189))+(((-0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((-0.09)*x1189))+(((0.09)*x1188))+(((-1.0)*pp))+(((1.1)*x1191))+(((1.1)*x1190)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1192=((0.00405)*sj3);\nIkReal x1193=((0.33)*cj3);\nIkReal x1194=((0.027)*cj3);\nIkReal x1195=((0.0495)*sj3);\nCheckValue<IkReal> x1196=IKPowWithIntegerCheck(IKsign(((((-0.09)*pp))+(((0.09)*(pz*pz))))),-1);\nif(!x1196.valid){\ncontinue;\n}\nCheckValue<IkReal> x1197 = IKatan2WithCheck(IkReal(((((-1.0)*pp*px))+(((-1.0)*py*x1192))+(((-1.0)*py*x1194))+(((-0.0495)*py))+((px*x1195))+((px*x1193))+(((0.3925)*px)))),((((-1.0)*py*x1193))+(((-1.0)*py*x1195))+(((-0.0495)*px))+(((-1.0)*px*x1194))+(((-1.0)*px*x1192))+(((-0.3925)*py))+((pp*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1197.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1196.value)))+(x1197.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1198=IKsin(j0);\nIkReal x1199=IKcos(j0);\nIkReal x1200=(px*x1198);\nIkReal x1201=(py*x1199);\nIkReal x1202=(px*x1199);\nIkReal x1203=(py*x1198);\nevalcond[0]=((-0.55)+(((-0.045)*sj3))+x1203+x1202+(((-0.3)*cj3)));\nevalcond[1]=((-0.045)+x1200+(((0.045)*cj3))+(((-1.0)*x1201))+(((-0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((0.09)*x1200))+(((-1.0)*pp))+(((-0.09)*x1201))+(((1.1)*x1203))+(((1.1)*x1202)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1204=((0.3)*py);\nIkReal x1205=((0.045)*px);\nIkReal x1206=((0.045)*py);\nIkReal x1207=((0.3)*px);\nCheckValue<IkReal> x1208=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp))+(pz*pz))),-1);\nif(!x1208.valid){\ncontinue;\n}\nCheckValue<IkReal> x1209 = IKatan2WithCheck(IkReal(((((-0.55)*py))+(((-1.0)*sj3*x1206))+(((-1.0)*sj3*x1207))+(((-1.0)*cj3*x1204))+((cj3*x1205))+(((-1.0)*x1205)))),((((-0.55)*px))+x1206+(((-1.0)*sj3*x1205))+(((-1.0)*cj3*x1207))+(((-1.0)*cj3*x1206))+((sj3*x1204))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1209.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1208.value)))+(x1209.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1210=IKsin(j0);\nIkReal x1211=IKcos(j0);\nIkReal x1212=(px*x1210);\nIkReal x1213=(py*x1211);\nIkReal x1214=(px*x1211);\nIkReal x1215=(py*x1210);\nevalcond[0]=((-0.55)+(((-0.045)*sj3))+x1214+x1215+(((-0.3)*cj3)));\nevalcond[1]=((-0.045)+x1212+(((0.045)*cj3))+(((-0.3)*sj3))+(((-1.0)*x1213)));\nevalcond[2]=((-0.2125)+(((-0.09)*x1213))+(((0.09)*x1212))+(((-1.0)*pp))+(((1.1)*x1215))+(((1.1)*x1214)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=((-1.0)*pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj1=-1.0;\ncj1=0;\nj1=-1.5707963267949;\nIkReal x1216=pz*pz;\nIkReal x1217=sj3*sj3;\nIkReal x1218=cj3*cj3;\nIkReal x1219=((4.26078431372549)*cj3);\nIkReal x1220=(pp+(((-1.0)*x1216)));\nIkReal x1221=((1.20294117647059)*x1218);\nIkReal x1222=((1.0)*x1216);\nIkReal x1223=((1.20294117647059)*x1217);\nj0eval[0]=x1220;\nj0eval[1]=(((pp*x1219))+(((-1.0)*x1216*x1219))+((pp*sj3))+((pp*x1221))+((pp*x1223))+(((3.98071895424837)*pp))+(((-3.98071895424837)*x1216))+(((-1.0)*x1216*x1223))+(((-1.0)*x1216*x1221))+(((-1.0)*sj3*x1222)));\nj0eval[2]=IKsign(x1220);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj1=-1.0;\ncj1=0;\nj1=-1.5707963267949;\nIkReal x1224=pz*pz;\nIkReal x1225=((0.33)*cj3);\nIkReal x1226=((1.0)*pp);\nIkReal x1227=((0.027)*cj3);\nIkReal x1228=((0.00405)*sj3);\nIkReal x1229=((0.0495)*sj3);\nj0eval[0]=(x1224+(((-1.0)*x1226)));\nj0eval[1]=((IKabs(((((0.0495)*px))+(((-1.0)*py*x1229))+(((-1.0)*py*x1225))+((px*x1228))+((px*x1227))+(((-0.3925)*py))+((pp*py)))))+(IKabs(((((-1.0)*px*x1226))+((py*x1228))+((py*x1227))+(((0.0495)*py))+((px*x1225))+((px*x1229))+(((0.3925)*px))))));\nj0eval[2]=IKsign(((((-0.09)*pp))+(((0.09)*x1224))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj1=-1.0;\ncj1=0;\nj1=-1.5707963267949;\nIkReal x1230=pz*pz;\nIkReal x1231=(cj3*py);\nIkReal x1232=(py*sj3);\nIkReal x1233=((1.0)*pp);\nIkReal x1234=(cj3*px);\nIkReal x1235=(px*sj3);\nj0eval[0]=((((-1.0)*x1230))+pp);\nj0eval[1]=((IKabs(((((0.0495)*px))+(((-0.0495)*x1234))+(((0.027)*x1232))+(((-1.0)*py*x1233))+(((-0.00405)*x1231))+(((0.33)*x1235))+(((-0.20845)*py)))))+(IKabs(((((-1.0)*px*x1233))+(((0.0495)*x1231))+(((-0.0495)*py))+(((0.027)*x1235))+(((-0.00405)*x1234))+(((-0.33)*x1232))+(((-0.20845)*px))))));\nj0eval[2]=IKsign(((((1.1)*pp))+(((-1.1)*x1230))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1236=(cj3*py);\nIkReal x1237=(py*sj3);\nIkReal x1238=((1.0)*pp);\nIkReal x1239=(cj3*px);\nIkReal x1240=(px*sj3);\nCheckValue<IkReal> x1241 = IKatan2WithCheck(IkReal(((((0.0495)*px))+(((-0.0495)*x1239))+(((0.027)*x1237))+(((0.33)*x1240))+(((-1.0)*py*x1238))+(((-0.00405)*x1236))+(((-0.20845)*py)))),((((-1.0)*px*x1238))+(((0.0495)*x1236))+(((-0.0495)*py))+(((-0.00405)*x1239))+(((0.027)*x1240))+(((-0.33)*x1237))+(((-0.20845)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1241.valid){\ncontinue;\n}\nCheckValue<IkReal> x1242=IKPowWithIntegerCheck(IKsign(((((-1.1)*(pz*pz)))+(((1.1)*pp)))),-1);\nif(!x1242.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1241.value)+(((1.5707963267949)*(x1242.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1243=IKcos(j0);\nIkReal x1244=IKsin(j0);\nIkReal x1245=(px*x1244);\nIkReal x1246=((1.0)*x1243);\nIkReal x1247=(py*x1244);\nevalcond[0]=((-0.045)+x1245+(((0.045)*cj3))+(((-1.0)*py*x1246))+(((-0.3)*sj3)));\nevalcond[1]=((-0.55)+(((-0.045)*sj3))+(((-1.0)*px*x1246))+(((-0.3)*cj3))+(((-1.0)*x1247)));\nevalcond[2]=((-0.2125)+(((0.09)*x1245))+(((-0.09)*py*x1243))+(((-1.1)*x1247))+(((-1.0)*pp))+(((-1.1)*px*x1243)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1248=((0.33)*cj3);\nIkReal x1249=((0.027)*cj3);\nIkReal x1250=((0.00405)*sj3);\nIkReal x1251=((0.0495)*sj3);\nCheckValue<IkReal> x1252=IKPowWithIntegerCheck(IKsign(((((-0.09)*pp))+(((0.09)*(pz*pz))))),-1);\nif(!x1252.valid){\ncontinue;\n}\nCheckValue<IkReal> x1253 = IKatan2WithCheck(IkReal(((((-1.0)*pp*px))+(((0.0495)*py))+((py*x1249))+((px*x1248))+(((0.3925)*px))+((px*x1251))+((py*x1250)))),((((-1.0)*py*x1248))+(((0.0495)*px))+((px*x1249))+(((-1.0)*py*x1251))+((px*x1250))+(((-0.3925)*py))+((pp*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1253.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1252.value)))+(x1253.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1254=IKcos(j0);\nIkReal x1255=IKsin(j0);\nIkReal x1256=(px*x1255);\nIkReal x1257=((1.0)*x1254);\nIkReal x1258=(py*x1255);\nevalcond[0]=((-0.045)+x1256+(((0.045)*cj3))+(((-1.0)*py*x1257))+(((-0.3)*sj3)));\nevalcond[1]=((-0.55)+(((-0.045)*sj3))+(((-0.3)*cj3))+(((-1.0)*px*x1257))+(((-1.0)*x1258)));\nevalcond[2]=((-0.2125)+(((-1.1)*px*x1254))+(((-1.0)*pp))+(((0.09)*x1256))+(((-0.09)*py*x1254))+(((-1.1)*x1258)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1259=((0.3)*py);\nIkReal x1260=((0.045)*px);\nIkReal x1261=((0.045)*py);\nIkReal x1262=((0.3)*px);\nCheckValue<IkReal> x1263=IKPowWithIntegerCheck(IKsign((pp+(((-1.0)*(pz*pz))))),-1);\nif(!x1263.valid){\ncontinue;\n}\nCheckValue<IkReal> x1264 = IKatan2WithCheck(IkReal(((((-0.55)*py))+x1260+(((-1.0)*cj3*x1260))+(((-1.0)*cj3*x1259))+(((-1.0)*sj3*x1261))+((sj3*x1262)))),((((-0.55)*px))+(((-1.0)*cj3*x1262))+((cj3*x1261))+(((-1.0)*sj3*x1259))+(((-1.0)*sj3*x1260))+(((-1.0)*x1261))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1264.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1263.value)))+(x1264.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1265=IKcos(j0);\nIkReal x1266=IKsin(j0);\nIkReal x1267=(px*x1266);\nIkReal x1268=((1.0)*x1265);\nIkReal x1269=(py*x1266);\nevalcond[0]=((-0.045)+x1267+(((0.045)*cj3))+(((-1.0)*py*x1268))+(((-0.3)*sj3)));\nevalcond[1]=((-0.55)+(((-0.045)*sj3))+(((-0.3)*cj3))+(((-1.0)*px*x1268))+(((-1.0)*x1269)));\nevalcond[2]=((-0.2125)+(((-1.1)*px*x1265))+(((-1.0)*pp))+(((0.09)*x1267))+(((-0.09)*py*x1265))+(((-1.1)*x1269)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)*cj1);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nIkReal x1270=((-1.0)*py);\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1270);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1270);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1270);\nrxp2_1=(px*r22);\nIkReal x1271=px*px;\nIkReal x1272=py*py;\nIkReal x1273=(sj1*x1271);\nIkReal x1274=(sj1*x1272);\nj0eval[0]=(x1273+x1274);\nj0eval[1]=IKsign(((((20.0)*x1274))+(((20.0)*x1273))));\nj0eval[2]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[4];\nIkReal x1275=((-1.0)*py);\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1275);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1275);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1275);\nrxp2_1=(px*r22);\nIkReal x1276=px*px;\nIkReal x1277=py*py;\nj0eval[0]=(x1276+x1277);\nj0eval[1]=289.0;\nj0eval[2]=sj1;\nj0eval[3]=IKsign(((((20.0)*x1277))+(((20.0)*x1276))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*(px*px)))+(((-1.0)*(py*py))));\nevalcond[2]=-0.85;\nevalcond[3]=-0.85;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nIkReal x1278=((-1.0)*py);\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1278);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1278);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1278);\nrxp2_1=(px*r22);\nsj1=0;\ncj1=1.0;\nj1=0;\nIkReal x1279=py*py;\nIkReal x1280=px*px;\nj0eval[0]=(x1279+x1280);\nj0eval[1]=IKsign(((((18.0)*x1279))+(((18.0)*x1280))));\nj0eval[2]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nCheckValue<IkReal> x1281=IKPowWithIntegerCheck(IKsign(((((18.0)*(py*py)))+(((18.0)*(px*px))))),-1);\nif(!x1281.valid){\ncontinue;\n}\nCheckValue<IkReal> x1282 = IKatan2WithCheck(IkReal(((187.0)*px)),((-187.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x1282.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1281.value)))+(x1282.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1283=IKcos(j0);\nIkReal x1284=IKsin(j0);\nIkReal x1285=(px*x1284);\nIkReal x1286=((1.0)*x1283);\nevalcond[0]=(x1285+(((-1.0)*py*x1286)));\nevalcond[1]=((((-1.0)*py*x1284))+(((-1.0)*px*x1286)));\nevalcond[2]=((-0.935)+(((0.09)*x1285))+(((-0.09)*py*x1283)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*(px*px)))+(((-1.0)*(py*py))));\nevalcond[2]=-0.85;\nevalcond[3]=0.85;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nIkReal x1287=((-1.0)*py);\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1287);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1287);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1287);\nrxp2_1=(px*r22);\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nIkReal x1288=py*py;\nIkReal x1289=px*px;\nj0eval[0]=(x1289+x1288);\nj0eval[1]=IKsign(((((18.0)*x1288))+(((18.0)*x1289))));\nj0eval[2]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nCheckValue<IkReal> x1290=IKPowWithIntegerCheck(IKsign(((((18.0)*(py*py)))+(((18.0)*(px*px))))),-1);\nif(!x1290.valid){\ncontinue;\n}\nCheckValue<IkReal> x1291 = IKatan2WithCheck(IkReal(((187.0)*px)),((-187.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x1291.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1290.value)))+(x1291.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1292=IKcos(j0);\nIkReal x1293=IKsin(j0);\nIkReal x1294=(px*x1293);\nIkReal x1295=((1.0)*x1292);\nevalcond[0]=(x1294+(((-1.0)*py*x1295)));\nevalcond[1]=((((-1.0)*py*x1293))+(((-1.0)*px*x1295)));\nevalcond[2]=((-0.935)+(((-0.09)*py*x1292))+(((0.09)*x1294)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1296=((17.0)*sj1);\nCheckValue<IkReal> x1297 = IKatan2WithCheck(IkReal((py*x1296)),(px*x1296),IKFAST_ATAN2_MAGTHRESH);\nif(!x1297.valid){\ncontinue;\n}\nCheckValue<IkReal> x1298=IKPowWithIntegerCheck(IKsign(((((20.0)*(px*px)))+(((20.0)*(py*py))))),-1);\nif(!x1298.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1297.value)+(((1.5707963267949)*(x1298.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x1299=IKcos(j0);\nIkReal x1300=IKsin(j0);\nIkReal x1301=((1.0)*py);\nIkReal x1302=((1.1)*sj1);\nIkReal x1303=(px*x1300);\nIkReal x1304=(px*x1299);\nIkReal x1305=(py*x1300);\nevalcond[0]=(x1303+(((-1.0)*x1299*x1301)));\nevalcond[1]=((-0.85)+((sj1*x1305))+((sj1*x1304)));\nevalcond[2]=((((-1.0)*x1304))+(((-1.0)*x1300*x1301))+(((0.85)*sj1)));\nevalcond[3]=((-0.935)+(((0.09)*x1303))+(((-0.09)*py*x1299))+((x1302*x1305))+((x1302*x1304)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1306=((20.0)*sj1);\nCheckValue<IkReal> x1307 = IKatan2WithCheck(IkReal(((17.0)*py)),((17.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x1307.valid){\ncontinue;\n}\nCheckValue<IkReal> x1308=IKPowWithIntegerCheck(IKsign((((x1306*(px*px)))+((x1306*(py*py))))),-1);\nif(!x1308.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1307.value)+(((1.5707963267949)*(x1308.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x1309=IKcos(j0);\nIkReal x1310=IKsin(j0);\nIkReal x1311=((1.0)*py);\nIkReal x1312=((1.1)*sj1);\nIkReal x1313=(px*x1310);\nIkReal x1314=(px*x1309);\nIkReal x1315=(py*x1310);\nevalcond[0]=(x1313+(((-1.0)*x1309*x1311)));\nevalcond[1]=((-0.85)+((sj1*x1314))+((sj1*x1315)));\nevalcond[2]=((((-1.0)*x1314))+(((0.85)*sj1))+(((-1.0)*x1310*x1311)));\nevalcond[3]=((-0.935)+(((0.09)*x1313))+(((-0.09)*py*x1309))+((x1312*x1315))+((x1312*x1314)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nj3=0;\nsj3=0;\ncj3=1.0;\nj1=0;\nsj1=0;\ncj1=1.0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nj3=0;\nsj3=0;\ncj3=1.0;\nj1=0;\nsj1=0;\ncj1=1.0;\nj0eval[0]=(pp+(((-1.0)*(pz*pz))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1317 = IKatan2WithCheck(IkReal(((-0.09)*py)),((0.09)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x1317.valid){\ncontinue;\n}\nIkReal x1316=x1317.value;\nj0array[0]=((-1.0)*x1316);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1316)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1318=IKcos(j0);\nIkReal x1319=IKsin(j0);\nIkReal x1320=((1.0)*x1318);\nevalcond[0]=(((px*x1319))+(((-1.0)*py*x1320)));\nevalcond[1]=((((-1.0)*py*x1319))+(((-1.0)*px*x1320)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1322 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x1322.valid){\ncontinue;\n}\nIkReal x1321=x1322.value;\nj0array[0]=((-1.0)*x1321);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1321)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1323=IKsin(j0);\nIkReal x1324=IKcos(j0);\nevalcond[0]=((((-1.0)*px*x1324))+(((-1.0)*py*x1323)));\nevalcond[1]=((((0.09)*px*x1323))+(((-0.09)*py*x1324)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+(((-1.0)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nj3=0;\nsj3=0;\ncj3=1.0;\nj1=3.14159265358979;\nsj1=0;\ncj1=-1.0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nj3=0;\nsj3=0;\ncj3=1.0;\nj1=3.14159265358979;\nsj1=0;\ncj1=-1.0;\nj0eval[0]=(pp+(((-1.0)*(pz*pz))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1326 = IKatan2WithCheck(IkReal(((-0.09)*py)),((0.09)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x1326.valid){\ncontinue;\n}\nIkReal x1325=x1326.value;\nj0array[0]=((-1.0)*x1325);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1325)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1327=IKsin(j0);\nIkReal x1328=IKcos(j0);\nevalcond[0]=(((py*x1327))+((px*x1328)));\nevalcond[1]=(((px*x1327))+(((-1.0)*py*x1328)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1330 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1330.valid){\ncontinue;\n}\nIkReal x1329=x1330.value;\nj0array[0]=((-1.0)*x1329);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1329)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1331=IKsin(j0);\nIkReal x1332=IKcos(j0);\nIkReal x1333=(px*x1331);\nIkReal x1334=(py*x1332);\nevalcond[0]=(x1333+(((-1.0)*x1334)));\nevalcond[1]=((((-0.09)*x1334))+(((0.09)*x1333)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1335=((0.3)*py);\nIkReal x1336=(cj3*sj1);\nIkReal x1337=((0.55)*sj1);\nIkReal x1338=((0.3)*px);\nIkReal x1339=((0.045)*py);\nIkReal x1340=(sj1*sj3);\nIkReal x1341=((0.045)*px);\nCheckValue<IkReal> x1342=IKPowWithIntegerCheck(IKsign((pp+(((-1.0)*(pz*pz))))),-1);\nif(!x1342.valid){\ncontinue;\n}\nCheckValue<IkReal> x1343 = IKatan2WithCheck(IkReal((x1341+((x1339*x1340))+((x1335*x1336))+((py*x1337))+(((-1.0)*cj3*x1341))+((sj3*x1338)))),(((px*x1337))+((x1336*x1338))+((x1340*x1341))+((cj3*x1339))+(((-1.0)*sj3*x1335))+(((-1.0)*x1339))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1343.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1342.value)))+(x1343.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x1344=IKsin(j0);\nIkReal x1345=IKcos(j0);\nIkReal x1346=((1.1)*sj1);\nIkReal x1347=((0.3)*cj3);\nIkReal x1348=((0.045)*sj3);\nIkReal x1349=((1.0)*cj1);\nIkReal x1350=(cj1*pz);\nIkReal x1351=(px*x1344);\nIkReal x1352=(px*x1345);\nIkReal x1353=(py*x1344);\nIkReal x1354=(py*x1345);\nevalcond[0]=(((pz*sj1))+(((-1.0)*x1349*x1353))+(((-1.0)*x1349*x1352)));\nevalcond[1]=((-0.045)+x1351+(((-1.0)*x1354))+(((0.045)*cj3))+(((-0.3)*sj3)));\nevalcond[2]=((-0.55)+x1350+((sj1*x1352))+((sj1*x1353))+(((-1.0)*x1348))+(((-1.0)*x1347)));\nevalcond[3]=((((-1.0)*x1353))+(((-1.0)*x1352))+((sj1*x1348))+((sj1*x1347))+(((0.55)*sj1)));\nevalcond[4]=((-0.2125)+(((-0.09)*x1354))+(((0.09)*x1351))+(((-1.0)*pp))+((x1346*x1353))+((x1346*x1352))+(((1.1)*x1350)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1355=((1.1)*pz);\nIkReal x1356=((0.2125)*cj1);\nIkReal x1357=((0.09)*cj1);\nIkReal x1358=(cj1*pp);\nIkReal x1359=((0.09)*pz*sj1);\nCheckValue<IkReal> x1360 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1358))+(((-1.0)*px*x1356))+((px*x1355))+(((-1.0)*py*x1359)))),((((-1.0)*px*x1359))+((py*x1358))+((py*x1356))+(((-1.0)*py*x1355))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1360.valid){\ncontinue;\n}\nCheckValue<IkReal> x1361=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp*x1357))+((x1357*(pz*pz))))),-1);\nif(!x1361.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1360.value)+(((1.5707963267949)*(x1361.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x1362=IKsin(j0);\nIkReal x1363=IKcos(j0);\nIkReal x1364=((1.1)*sj1);\nIkReal x1365=((0.3)*cj3);\nIkReal x1366=((0.045)*sj3);\nIkReal x1367=((1.0)*cj1);\nIkReal x1368=(cj1*pz);\nIkReal x1369=(px*x1362);\nIkReal x1370=(px*x1363);\nIkReal x1371=(py*x1362);\nIkReal x1372=(py*x1363);\nevalcond[0]=((((-1.0)*x1367*x1371))+(((-1.0)*x1367*x1370))+((pz*sj1)));\nevalcond[1]=((-0.045)+x1369+(((0.045)*cj3))+(((-1.0)*x1372))+(((-0.3)*sj3)));\nevalcond[2]=((-0.55)+x1368+((sj1*x1370))+((sj1*x1371))+(((-1.0)*x1366))+(((-1.0)*x1365)));\nevalcond[3]=((((-1.0)*x1371))+(((-1.0)*x1370))+((sj1*x1366))+((sj1*x1365))+(((0.55)*sj1)));\nevalcond[4]=((-0.2125)+(((1.1)*x1368))+(((0.09)*x1369))+(((-1.0)*pp))+(((-0.09)*x1372))+((x1364*x1371))+((x1364*x1370)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1373=((0.045)*cj1);\nIkReal x1374=(pz*sj1);\nIkReal x1375=((0.3)*cj1*sj3);\nCheckValue<IkReal> x1376=IKPowWithIntegerCheck(IKsign((((cj1*pp))+(((-1.0)*cj1*(pz*pz))))),-1);\nif(!x1376.valid){\ncontinue;\n}\nCheckValue<IkReal> x1377 = IKatan2WithCheck(IkReal((((px*x1375))+((px*x1373))+((py*x1374))+(((-1.0)*cj3*px*x1373)))),(((px*x1374))+((cj3*py*x1373))+(((-1.0)*py*x1375))+(((-1.0)*py*x1373))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1377.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1376.value)))+(x1377.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x1378=IKsin(j0);\nIkReal x1379=IKcos(j0);\nIkReal x1380=((1.1)*sj1);\nIkReal x1381=((0.3)*cj3);\nIkReal x1382=((0.045)*sj3);\nIkReal x1383=((1.0)*cj1);\nIkReal x1384=(cj1*pz);\nIkReal x1385=(px*x1378);\nIkReal x1386=(px*x1379);\nIkReal x1387=(py*x1378);\nIkReal x1388=(py*x1379);\nevalcond[0]=((((-1.0)*x1383*x1387))+(((-1.0)*x1383*x1386))+((pz*sj1)));\nevalcond[1]=((-0.045)+x1385+(((0.045)*cj3))+(((-1.0)*x1388))+(((-0.3)*sj3)));\nevalcond[2]=((-0.55)+(((-1.0)*x1382))+(((-1.0)*x1381))+x1384+((sj1*x1387))+((sj1*x1386)));\nevalcond[3]=(((sj1*x1382))+((sj1*x1381))+(((-1.0)*x1386))+(((-1.0)*x1387))+(((0.55)*sj1)));\nevalcond[4]=((-0.2125)+((x1380*x1386))+((x1380*x1387))+(((-0.09)*x1388))+(((1.1)*x1384))+(((-1.0)*pp))+(((0.09)*x1385)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1389=((-0.55)+(((-0.045)*sj3))+(((-0.3)*cj3))+pz);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=x1389;\nevalcond[3]=x1389;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nIkReal x1390=((0.3)*sj3);\nIkReal x1391=(px*sj2);\nIkReal x1392=((0.045)*py);\nIkReal x1393=(pp+(((-1.0)*(pz*pz))));\nIkReal x1394=(cj3*x1392);\nIkReal x1395=((0.045)*cj2*px);\nj0eval[0]=x1393;\nj0eval[1]=((IKabs((((cj2*x1392))+(((-1.0)*x1390*x1391))+(((0.045)*cj3*x1391))+(((-1.0)*cj2*x1394))+(((-0.045)*x1391))+((cj2*py*x1390)))))+(IKabs((x1395+((py*sj2*x1390))+((sj2*x1392))+(((-1.0)*cj3*x1395))+((cj2*px*x1390))+(((-1.0)*sj2*x1394))))));\nj0eval[2]=IKsign(x1393);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[2];\nsj1=0;\ncj1=1.0;\nj1=0;\nIkReal x1396=((((-1.0)*cj2*pp))+((cj2*(pz*pz))));\nj0eval[0]=x1396;\nj0eval[1]=IKsign(x1396);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[2];\nsj1=0;\ncj1=1.0;\nj1=0;\nIkReal x1397=((((-1.0)*pp*sj2))+((sj2*(pz*pz))));\nj0eval[0]=x1397;\nj0eval[1]=IKsign(x1397);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1398=x1389;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=x1398;\nevalcond[3]=x1398;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x1399=((20.0)*sj3);\nIkReal x1400=((3.0)*px);\nIkReal x1401=((3.0)*py);\nIkReal x1402=(pp+(((-1.0)*(pz*pz))));\nj0eval[0]=x1402;\nj0eval[1]=((IKabs(((((-1.0)*cj3*x1401))+((py*x1399))+x1401)))+(IKabs((((px*x1399))+(((-1.0)*cj3*x1400))+x1400))));\nj0eval[2]=IKsign(x1402);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x1403=pz*pz;\nIkReal x1404=((80.0)*pp);\nIkReal x1405=((88.0)*pz);\nj0eval[0]=((((-1.0)*pp))+x1403);\nj0eval[1]=IKsign(((((-9.0)*pp))+(((9.0)*x1403))));\nj0eval[2]=((IKabs((((py*x1405))+(((-17.0)*py))+(((-1.0)*py*x1404)))))+(IKabs((((px*x1405))+(((-1.0)*px*x1404))+(((-17.0)*px))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=1.0;\nj2=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=1.0;\nj2=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=(pp+(((-1.0)*(pz*pz))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1407 = IKatan2WithCheck(IkReal(((0.09)*px)),((0.09)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x1407.valid){\ncontinue;\n}\nIkReal x1406=x1407.value;\nj0array[0]=((-1.0)*x1406);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1406)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1408=IKcos(j0);\nIkReal x1409=IKsin(j0);\nIkReal x1410=((1.0)*x1408);\nevalcond[0]=(((px*x1409))+(((-1.0)*py*x1410)));\nevalcond[1]=((((-1.0)*py*x1409))+(((-1.0)*px*x1410)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1412 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x1412.valid){\ncontinue;\n}\nIkReal x1411=x1412.value;\nj0array[0]=((-1.0)*x1411);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1411)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1413=IKcos(j0);\nIkReal x1414=IKsin(j0);\nIkReal x1415=(py*x1414);\nIkReal x1416=(px*x1413);\nevalcond[0]=((((-1.0)*x1416))+(((-1.0)*x1415)));\nevalcond[1]=((((0.09)*x1416))+(((0.09)*x1415)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1417=((110.0)*pz);\nIkReal x1418=((100.0)*pp);\nCheckValue<IkReal> x1419=IKPowWithIntegerCheck(IKsign(((((-9.0)*pp))+(((9.0)*(pz*pz))))),-1);\nif(!x1419.valid){\ncontinue;\n}\nCheckValue<IkReal> x1420 = IKatan2WithCheck(IkReal((((py*x1417))+(((-21.25)*py))+(((-1.0)*py*x1418)))),(((px*x1417))+(((-21.25)*px))+(((-1.0)*px*x1418))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1420.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1419.value)))+(x1420.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1421=IKcos(j0);\nIkReal x1422=IKsin(j0);\nIkReal x1423=((1.0)*py);\nIkReal x1424=(px*x1421);\nevalcond[0]=((((-1.0)*x1421*x1423))+((px*x1422)));\nevalcond[1]=((0.045)+(((-0.045)*cj3))+(((-1.0)*x1424))+(((-1.0)*x1422*x1423))+(((0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((0.09)*py*x1422))+(((-1.0)*pp))+(((1.1)*pz))+(((0.09)*x1424)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1425=((0.3)*sj3);\nIkReal x1426=((0.045)*px);\nIkReal x1427=((0.045)*py);\nCheckValue<IkReal> x1428=IKPowWithIntegerCheck(IKsign((pp+(((-1.0)*(pz*pz))))),-1);\nif(!x1428.valid){\ncontinue;\n}\nCheckValue<IkReal> x1429 = IKatan2WithCheck(IkReal((x1427+(((-1.0)*cj3*x1427))+((py*x1425)))),(x1426+((px*x1425))+(((-1.0)*cj3*x1426))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1429.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1428.value)))+(x1429.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1430=IKcos(j0);\nIkReal x1431=IKsin(j0);\nIkReal x1432=((1.0)*py);\nIkReal x1433=(px*x1430);\nevalcond[0]=(((px*x1431))+(((-1.0)*x1430*x1432)));\nevalcond[1]=((0.045)+(((-1.0)*x1433))+(((-1.0)*x1431*x1432))+(((-0.045)*cj3))+(((0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((0.09)*x1433))+(((-1.0)*pp))+(((1.1)*pz))+(((0.09)*py*x1431)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1434=x1389;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=x1434;\nevalcond[3]=x1434;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x1435=((20.0)*sj3);\nIkReal x1436=((3.0)*px);\nIkReal x1437=((3.0)*py);\nIkReal x1438=((((-1.0)*pp))+(pz*pz));\nj0eval[0]=x1438;\nj0eval[1]=((IKabs(((((-1.0)*cj3*x1437))+((py*x1435))+x1437)))+(IKabs((((px*x1435))+(((-1.0)*cj3*x1436))+x1436))));\nj0eval[2]=IKsign(x1438);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x1439=pz*pz;\nIkReal x1440=((80.0)*pp);\nIkReal x1441=((88.0)*pz);\nj0eval[0]=((((-1.0)*x1439))+pp);\nj0eval[1]=IKsign(((((-9.0)*x1439))+(((9.0)*pp))));\nj0eval[2]=((IKabs(((((-1.0)*py*x1440))+((py*x1441))+(((-17.0)*py)))))+(IKabs(((((-1.0)*px*x1440))+((px*x1441))+(((-17.0)*px))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=(pp+(((-1.0)*(pz*pz))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1443 = IKatan2WithCheck(IkReal(((-0.09)*px)),((-0.09)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x1443.valid){\ncontinue;\n}\nIkReal x1442=x1443.value;\nj0array[0]=((-1.0)*x1442);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1442)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1444=IKsin(j0);\nIkReal x1445=IKcos(j0);\nevalcond[0]=(((py*x1444))+((px*x1445)));\nevalcond[1]=((((-1.0)*py*x1445))+((px*x1444)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1447 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1447.valid){\ncontinue;\n}\nIkReal x1446=x1447.value;\nj0array[0]=((-1.0)*x1446);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1446)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1448=IKcos(j0);\nIkReal x1449=IKsin(j0);\nevalcond[0]=((((-1.0)*py*x1448))+((px*x1449)));\nevalcond[1]=((((-0.09)*py*x1449))+(((-0.09)*px*x1448)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1450=((110.0)*pz);\nIkReal x1451=((100.0)*pp);\nCheckValue<IkReal> x1452 = IKatan2WithCheck(IkReal((((py*x1450))+(((-21.25)*py))+(((-1.0)*py*x1451)))),(((px*x1450))+(((-1.0)*px*x1451))+(((-21.25)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1452.valid){\ncontinue;\n}\nCheckValue<IkReal> x1453=IKPowWithIntegerCheck(IKsign(((((9.0)*pp))+(((-9.0)*(pz*pz))))),-1);\nif(!x1453.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1452.value)+(((1.5707963267949)*(x1453.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1454=IKsin(j0);\nIkReal x1455=IKcos(j0);\nIkReal x1456=(px*x1455);\nIkReal x1457=(py*x1454);\nevalcond[0]=(((px*x1454))+(((-1.0)*py*x1455)));\nevalcond[1]=((0.045)+(((-0.045)*cj3))+x1456+x1457+(((0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((-1.0)*pp))+(((-0.09)*x1457))+(((-0.09)*x1456))+(((1.1)*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1458=((0.3)*sj3);\nIkReal x1459=((0.045)*px);\nIkReal x1460=((0.045)*py);\nCheckValue<IkReal> x1461 = IKatan2WithCheck(IkReal((((py*x1458))+(((-1.0)*cj3*x1460))+x1460)),((((-1.0)*cj3*x1459))+((px*x1458))+x1459),IKFAST_ATAN2_MAGTHRESH);\nif(!x1461.valid){\ncontinue;\n}\nCheckValue<IkReal> x1462=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp))+(pz*pz))),-1);\nif(!x1462.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1461.value)+(((1.5707963267949)*(x1462.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1463=IKsin(j0);\nIkReal x1464=IKcos(j0);\nIkReal x1465=(px*x1464);\nIkReal x1466=(py*x1463);\nevalcond[0]=((((-1.0)*py*x1464))+((px*x1463)));\nevalcond[1]=((0.045)+(((-0.045)*cj3))+x1465+x1466+(((0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((-1.0)*pp))+(((1.1)*pz))+(((-0.09)*x1465))+(((-0.09)*x1466)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1467=x1389;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=x1467;\nevalcond[3]=x1467;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nIkReal x1468=((20.0)*sj3);\nIkReal x1469=((3.0)*px);\nIkReal x1470=((3.0)*py);\nIkReal x1471=((((-1.0)*pp))+(pz*pz));\nj0eval[0]=x1471;\nj0eval[1]=((IKabs(((((-1.0)*py*x1468))+((cj3*x1470))+(((-1.0)*x1470)))))+(IKabs(((((-1.0)*cj3*x1469))+((px*x1468))+x1469))));\nj0eval[2]=IKsign(x1471);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nIkReal x1472=pz*pz;\nIkReal x1473=((80.0)*pp);\nIkReal x1474=((88.0)*pz);\nj0eval[0]=((((-1.0)*x1472))+pp);\nj0eval[1]=IKsign(((((-9.0)*x1472))+(((9.0)*pp))));\nj0eval[2]=((IKabs(((((17.0)*py))+(((-1.0)*py*x1474))+((py*x1473)))))+(IKabs(((((-1.0)*px*x1473))+(((-17.0)*px))+((px*x1474))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=(pp+(((-1.0)*(pz*pz))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1476 = IKatan2WithCheck(IkReal(((0.09)*py)),((-0.09)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x1476.valid){\ncontinue;\n}\nIkReal x1475=x1476.value;\nj0array[0]=((-1.0)*x1475);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1475)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1477=IKsin(j0);\nIkReal x1478=IKcos(j0);\nevalcond[0]=(((py*x1477))+((px*x1478)));\nevalcond[1]=((((-1.0)*py*x1478))+((px*x1477)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1480 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1480.valid){\ncontinue;\n}\nIkReal x1479=x1480.value;\nj0array[0]=((-1.0)*x1479);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1479)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1481=IKcos(j0);\nIkReal x1482=IKsin(j0);\nIkReal x1483=(px*x1482);\nIkReal x1484=(py*x1481);\nevalcond[0]=((((-1.0)*x1484))+x1483);\nevalcond[1]=((((0.09)*x1484))+(((-0.09)*x1483)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1485=((110.0)*pz);\nIkReal x1486=((100.0)*pp);\nCheckValue<IkReal> x1487 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1486))+(((-21.25)*px))+((px*x1485)))),(((py*x1486))+(((21.25)*py))+(((-1.0)*py*x1485))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1487.valid){\ncontinue;\n}\nCheckValue<IkReal> x1488=IKPowWithIntegerCheck(IKsign(((((9.0)*pp))+(((-9.0)*(pz*pz))))),-1);\nif(!x1488.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1487.value)+(((1.5707963267949)*(x1488.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1489=IKsin(j0);\nIkReal x1490=IKcos(j0);\nIkReal x1491=(px*x1489);\nIkReal x1492=(py*x1490);\nevalcond[0]=(((py*x1489))+((px*x1490)));\nevalcond[1]=((0.045)+(((-1.0)*x1492))+(((-0.045)*cj3))+x1491+(((0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((0.09)*x1492))+(((-0.09)*x1491))+(((-1.0)*pp))+(((1.1)*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1493=((0.3)*sj3);\nIkReal x1494=((0.045)*px);\nIkReal x1495=((0.045)*py);\nCheckValue<IkReal> x1496 = IKatan2WithCheck(IkReal(((((-1.0)*cj3*x1494))+x1494+((px*x1493)))),(((cj3*x1495))+(((-1.0)*x1495))+(((-1.0)*py*x1493))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1496.valid){\ncontinue;\n}\nCheckValue<IkReal> x1497=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp))+(pz*pz))),-1);\nif(!x1497.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1496.value)+(((1.5707963267949)*(x1497.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1498=IKsin(j0);\nIkReal x1499=IKcos(j0);\nIkReal x1500=(px*x1498);\nIkReal x1501=(py*x1499);\nevalcond[0]=(((py*x1498))+((px*x1499)));\nevalcond[1]=((0.045)+(((-1.0)*x1501))+(((-0.045)*cj3))+x1500+(((0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((-0.09)*x1500))+(((0.09)*x1501))+(((-1.0)*pp))+(((1.1)*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1502=x1389;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=x1502;\nevalcond[3]=x1502;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nIkReal x1503=((20.0)*sj3);\nIkReal x1504=((3.0)*px);\nIkReal x1505=((3.0)*py);\nIkReal x1506=((((-1.0)*pp))+(pz*pz));\nj0eval[0]=x1506;\nj0eval[1]=((IKabs((x1505+(((-1.0)*cj3*x1505))+((py*x1503)))))+(IKabs(((((-1.0)*x1504))+((cj3*x1504))+(((-1.0)*px*x1503))))));\nj0eval[2]=IKsign(x1506);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nIkReal x1507=pz*pz;\nIkReal x1508=((80.0)*pp);\nIkReal x1509=((88.0)*pz);\nj0eval[0]=((((-1.0)*pp))+x1507);\nj0eval[1]=IKsign(((((-9.0)*pp))+(((9.0)*x1507))));\nj0eval[2]=((IKabs(((((17.0)*py))+((py*x1508))+(((-1.0)*py*x1509)))))+(IKabs(((((-1.0)*px*x1508))+((px*x1509))+(((-17.0)*px))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=(pp+(((-1.0)*(pz*pz))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1511 = IKatan2WithCheck(IkReal(((-0.09)*py)),((0.09)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x1511.valid){\ncontinue;\n}\nIkReal x1510=x1511.value;\nj0array[0]=((-1.0)*x1510);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1510)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1512=IKcos(j0);\nIkReal x1513=IKsin(j0);\nIkReal x1514=((1.0)*x1512);\nevalcond[0]=((((-1.0)*py*x1514))+((px*x1513)));\nevalcond[1]=((((-1.0)*py*x1513))+(((-1.0)*px*x1514)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1516 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x1516.valid){\ncontinue;\n}\nIkReal x1515=x1516.value;\nj0array[0]=((-1.0)*x1515);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1515)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1517=IKsin(j0);\nIkReal x1518=IKcos(j0);\nevalcond[0]=((((-1.0)*py*x1517))+(((-1.0)*px*x1518)));\nevalcond[1]=((((-0.09)*py*x1518))+(((0.09)*px*x1517)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1519=((110.0)*pz);\nIkReal x1520=((100.0)*pp);\nCheckValue<IkReal> x1521=IKPowWithIntegerCheck(IKsign(((((-9.0)*pp))+(((9.0)*(pz*pz))))),-1);\nif(!x1521.valid){\ncontinue;\n}\nCheckValue<IkReal> x1522 = IKatan2WithCheck(IkReal(((((-21.25)*px))+(((-1.0)*px*x1520))+((px*x1519)))),((((21.25)*py))+(((-1.0)*py*x1519))+((py*x1520))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1522.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1521.value)))+(x1522.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1523=IKsin(j0);\nIkReal x1524=IKcos(j0);\nIkReal x1525=(px*x1523);\nIkReal x1526=((1.0)*x1524);\nevalcond[0]=((((-1.0)*px*x1526))+(((-1.0)*py*x1523)));\nevalcond[1]=((-0.045)+(((0.045)*cj3))+x1525+(((-1.0)*py*x1526))+(((-0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((0.09)*x1525))+(((-1.0)*pp))+(((1.1)*pz))+(((-0.09)*py*x1524)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1527=((0.3)*sj3);\nIkReal x1528=((0.045)*px);\nIkReal x1529=((0.045)*py);\nCheckValue<IkReal> x1530=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp))+(pz*pz))),-1);\nif(!x1530.valid){\ncontinue;\n}\nCheckValue<IkReal> x1531 = IKatan2WithCheck(IkReal(((((-1.0)*x1528))+((cj3*x1528))+(((-1.0)*px*x1527)))),(x1529+(((-1.0)*cj3*x1529))+((py*x1527))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1531.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1530.value)))+(x1531.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1532=IKsin(j0);\nIkReal x1533=IKcos(j0);\nIkReal x1534=(px*x1532);\nIkReal x1535=((1.0)*x1533);\nevalcond[0]=((((-1.0)*px*x1535))+(((-1.0)*py*x1532)));\nevalcond[1]=((-0.045)+(((0.045)*cj3))+x1534+(((-1.0)*py*x1535))+(((-0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((0.09)*x1534))+(((-1.0)*pp))+(((1.1)*pz))+(((-0.09)*py*x1533)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(((((-1.0)*cj2*py))+((px*sj2)))))+(IKabs((((cj2*px))+((py*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nIkReal x1536=((1.0)*py);\nj0eval[0]=((IKabs(((((-1.0)*sj2*x1536))+(((-1.0)*cj2*px)))))+(IKabs((((px*sj2))+(((-1.0)*cj2*x1536))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x1537=((1.0)*cj2);\nCheckValue<IkReal> x1539 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1537))+(((-1.0)*py*sj2)))),(((px*sj2))+(((-1.0)*py*x1537))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1539.valid){\ncontinue;\n}\nIkReal x1538=x1539.value;\nj0array[0]=((-1.0)*x1538);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1538)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x1540=IKcos(j0);\nIkReal x1541=IKsin(j0);\nIkReal x1542=((0.09)*py);\nIkReal x1543=(px*x1541);\nIkReal x1544=((1.0)*x1540);\nIkReal x1545=(sj2*x1540);\nIkReal x1546=(py*x1541);\nevalcond[0]=((((-1.0)*py*x1544))+x1543);\nevalcond[1]=((((-1.0)*x1546))+(((-1.0)*px*x1544)));\nevalcond[2]=((((-1.0)*cj2*py*x1544))+((cj2*x1543))+((px*x1545))+((sj2*x1546)));\nevalcond[3]=(((cj2*x1541*x1542))+(((-0.09)*sj2*x1543))+(((0.09)*cj2*px*x1540))+((x1542*x1545)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1548 = IKatan2WithCheck(IkReal(((((-1.0)*cj2*py))+((px*sj2)))),(((cj2*px))+((py*sj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1548.valid){\ncontinue;\n}\nIkReal x1547=x1548.value;\nj0array[0]=((-1.0)*x1547);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1547)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x1549=IKcos(j0);\nIkReal x1550=IKsin(j0);\nIkReal x1551=((0.09)*sj2);\nIkReal x1552=(cj2*px);\nIkReal x1553=(px*x1550);\nIkReal x1554=((1.0)*x1549);\nIkReal x1555=(py*x1550);\nevalcond[0]=((((-1.0)*py*x1554))+x1553);\nevalcond[1]=((((-1.0)*x1555))+(((-1.0)*px*x1554)));\nevalcond[2]=((((-1.0)*x1552*x1554))+(((-1.0)*cj2*x1555))+(((-1.0)*py*sj2*x1554))+((sj2*x1553)));\nevalcond[3]=(((py*x1549*x1551))+(((0.09)*x1549*x1552))+(((0.09)*cj2*x1555))+(((-1.0)*x1551*x1553)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1557 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x1557.valid){\ncontinue;\n}\nIkReal x1556=x1557.value;\nj0array[0]=((-1.0)*x1556);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1556)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x1558=IKcos(j0);\nIkReal x1559=IKsin(j0);\nIkReal x1560=(py*sj2);\nIkReal x1561=(px*sj2);\nIkReal x1562=(cj2*px);\nIkReal x1563=((1.0)*x1558);\nIkReal x1564=((0.09)*x1558);\nIkReal x1565=(py*x1559);\nevalcond[0]=((((-1.0)*px*x1563))+(((-1.0)*x1565)));\nevalcond[1]=((((-1.0)*cj2*py*x1563))+((x1559*x1560))+((x1559*x1562))+((x1558*x1561)));\nevalcond[2]=((((-1.0)*x1560*x1563))+(((-1.0)*x1562*x1563))+(((-1.0)*cj2*x1565))+((x1559*x1561)));\nevalcond[3]=(((x1560*x1564))+(((-0.09)*x1559*x1561))+((x1562*x1564))+(((0.09)*cj2*x1565)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1566=cj2*cj2;\nIkReal x1567=((0.045)*px);\nIkReal x1568=(cj2*sj2);\nIkReal x1569=((0.3)*sj3);\nIkReal x1570=((0.045)*cj3);\nIkReal x1571=((0.045)*py);\nIkReal x1572=(py*x1566);\nCheckValue<IkReal> x1573=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp*sj2))+((sj2*(pz*pz))))),-1);\nif(!x1573.valid){\ncontinue;\n}\nCheckValue<IkReal> x1574 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1566*x1569))+(((-1.0)*x1566*x1567))+((cj3*x1566*x1567))+(((-1.0)*x1568*x1571))+x1567+((px*x1569))+((py*x1568*x1570))+(((-1.0)*cj3*x1567))+(((-1.0)*py*x1568*x1569)))),(((x1566*x1571))+((x1569*x1572))+(((-1.0)*x1570*x1572))+(((-1.0)*x1567*x1568))+(((-1.0)*py*x1569))+(((-1.0)*px*x1568*x1569))+((cj3*x1567*x1568))+((py*x1570))+(((-1.0)*x1571))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1574.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1573.value)))+(x1574.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x1575=IKcos(j0);\nIkReal x1576=IKsin(j0);\nIkReal x1577=((0.045)*cj2);\nIkReal x1578=((0.09)*sj2);\nIkReal x1579=((0.3)*sj3);\nIkReal x1580=((0.045)*cj3);\nIkReal x1581=((0.09)*cj2);\nIkReal x1582=((1.0)*cj2);\nIkReal x1583=(px*x1576);\nIkReal x1584=(px*x1575);\nIkReal x1585=(py*x1575);\nIkReal x1586=(py*x1576);\nevalcond[0]=((((0.045)*sj2))+x1583+(((-1.0)*x1585))+(((-1.0)*sj2*x1580))+((sj2*x1579)));\nevalcond[1]=(((cj2*x1579))+x1577+(((-1.0)*x1586))+(((-1.0)*x1584))+(((-1.0)*cj3*x1577)));\nevalcond[2]=(((sj2*x1586))+((sj2*x1584))+((cj2*x1583))+(((-1.0)*x1582*x1585)));\nevalcond[3]=((0.045)+(((-1.0)*x1580))+((sj2*x1583))+x1579+(((-1.0)*sj2*x1585))+(((-1.0)*x1582*x1586))+(((-1.0)*x1582*x1584)));\nevalcond[4]=((-0.2125)+(((-1.0)*x1578*x1583))+(((-1.0)*pp))+(((1.1)*pz))+((x1578*x1585))+((x1581*x1584))+((x1581*x1586)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1587=cj2*cj2;\nIkReal x1588=((0.045)*px);\nIkReal x1589=(cj2*sj2);\nIkReal x1590=((0.045)*cj3);\nIkReal x1591=((0.3)*sj3);\nIkReal x1592=(py*x1587);\nCheckValue<IkReal> x1593=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj2*pp))+((cj2*(pz*pz))))),-1);\nif(!x1593.valid){\ncontinue;\n}\nCheckValue<IkReal> x1594 = IKatan2WithCheck(IkReal((((px*x1589*x1591))+((x1590*x1592))+(((-1.0)*cj3*x1588*x1589))+(((-0.045)*x1592))+((x1588*x1589))+(((-1.0)*x1591*x1592)))),(((py*x1589*x1590))+(((-1.0)*px*x1587*x1591))+((cj3*x1587*x1588))+(((-1.0)*py*x1589*x1591))+(((-1.0)*x1587*x1588))+(((-0.045)*py*x1589))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1594.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1593.value)))+(x1594.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x1595=IKcos(j0);\nIkReal x1596=IKsin(j0);\nIkReal x1597=((0.045)*cj2);\nIkReal x1598=((0.09)*sj2);\nIkReal x1599=((0.3)*sj3);\nIkReal x1600=((0.045)*cj3);\nIkReal x1601=((0.09)*cj2);\nIkReal x1602=((1.0)*cj2);\nIkReal x1603=(px*x1596);\nIkReal x1604=(px*x1595);\nIkReal x1605=(py*x1595);\nIkReal x1606=(py*x1596);\nevalcond[0]=(((sj2*x1599))+(((-1.0)*x1605))+x1603+(((0.045)*sj2))+(((-1.0)*sj2*x1600)));\nevalcond[1]=((((-1.0)*cj3*x1597))+(((-1.0)*x1606))+(((-1.0)*x1604))+x1597+((cj2*x1599)));\nevalcond[2]=(((sj2*x1606))+((sj2*x1604))+((cj2*x1603))+(((-1.0)*x1602*x1605)));\nevalcond[3]=((0.045)+((sj2*x1603))+(((-1.0)*x1600))+x1599+(((-1.0)*sj2*x1605))+(((-1.0)*x1602*x1606))+(((-1.0)*x1602*x1604)));\nevalcond[4]=((-0.2125)+((x1601*x1606))+((x1601*x1604))+(((-1.0)*pp))+((x1598*x1605))+(((1.1)*pz))+(((-1.0)*x1598*x1603)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1607=(px*sj2);\nIkReal x1608=((0.3)*sj3);\nIkReal x1609=(cj2*py);\nIkReal x1610=(py*sj2);\nIkReal x1611=((0.045)*cj3*py);\nIkReal x1612=((0.045)*cj2*px);\nCheckValue<IkReal> x1613 = IKatan2WithCheck(IkReal(((((-1.0)*x1607*x1608))+(((-0.045)*x1607))+(((0.045)*cj3*x1607))+((x1608*x1609))+(((0.045)*x1609))+(((-0.045)*cj3*x1609)))),((((-0.045)*cj3*x1610))+(((-1.0)*cj3*x1612))+x1612+((cj2*px*x1608))+((x1608*x1610))+(((0.045)*x1610))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1613.valid){\ncontinue;\n}\nCheckValue<IkReal> x1614=IKPowWithIntegerCheck(IKsign((pp+(((-1.0)*(pz*pz))))),-1);\nif(!x1614.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1613.value)+(((1.5707963267949)*(x1614.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x1615=IKcos(j0);\nIkReal x1616=IKsin(j0);\nIkReal x1617=((0.045)*cj2);\nIkReal x1618=((0.09)*sj2);\nIkReal x1619=((0.3)*sj3);\nIkReal x1620=((0.045)*cj3);\nIkReal x1621=((0.09)*cj2);\nIkReal x1622=((1.0)*cj2);\nIkReal x1623=(px*x1616);\nIkReal x1624=(px*x1615);\nIkReal x1625=(py*x1615);\nIkReal x1626=(py*x1616);\nevalcond[0]=((((-1.0)*x1625))+((sj2*x1619))+x1623+(((0.045)*sj2))+(((-1.0)*sj2*x1620)));\nevalcond[1]=((((-1.0)*cj3*x1617))+(((-1.0)*x1624))+(((-1.0)*x1626))+x1617+((cj2*x1619)));\nevalcond[2]=(((sj2*x1624))+((sj2*x1626))+(((-1.0)*x1622*x1625))+((cj2*x1623)));\nevalcond[3]=((0.045)+((sj2*x1623))+x1619+(((-1.0)*x1620))+(((-1.0)*x1622*x1624))+(((-1.0)*x1622*x1626))+(((-1.0)*sj2*x1625)));\nevalcond[4]=((-0.2125)+(((-1.0)*pp))+(((1.1)*pz))+((x1618*x1625))+(((-1.0)*x1618*x1623))+((x1621*x1624))+((x1621*x1626)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1627=((0.045)*sj3);\nIkReal x1628=((0.3)*cj3);\nIkReal x1629=(x1627+x1628);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=((-0.55)+(((-1.0)*x1629))+(((-1.0)*pz)));\nevalcond[3]=((0.55)+x1629+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nIkReal x1630=((0.3)*sj3);\nIkReal x1631=(px*sj2);\nIkReal x1632=((0.045)*py);\nIkReal x1633=(pp+(((-1.0)*(pz*pz))));\nIkReal x1634=(cj3*x1632);\nIkReal x1635=((0.045)*cj2*px);\nj0eval[0]=x1633;\nj0eval[1]=((IKabs(((((0.045)*cj3*x1631))+((cj2*x1634))+(((-1.0)*cj2*x1632))+(((-0.045)*x1631))+(((-1.0)*x1630*x1631))+(((-1.0)*cj2*py*x1630)))))+(IKabs(((((-1.0)*sj2*x1634))+((cj3*x1635))+((sj2*x1632))+(((-1.0)*x1635))+((py*sj2*x1630))+(((-1.0)*cj2*px*x1630))))));\nj0eval[2]=IKsign(x1633);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[2];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nIkReal x1636=((((-1.0)*cj2*pp))+((cj2*(pz*pz))));\nj0eval[0]=x1636;\nj0eval[1]=IKsign(x1636);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[2];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nIkReal x1637=((((-1.0)*sj2*(pz*pz)))+((pp*sj2)));\nj0eval[0]=x1637;\nj0eval[1]=IKsign(x1637);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1638=((0.045)*sj3);\nIkReal x1639=((0.3)*cj3);\nIkReal x1640=(x1638+x1639);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=((-0.55)+(((-1.0)*x1640))+(((-1.0)*pz)));\nevalcond[3]=((0.55)+x1640+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x1641=((20.0)*sj3);\nIkReal x1642=((3.0)*px);\nIkReal x1643=((3.0)*py);\nIkReal x1644=((((-1.0)*pp))+(pz*pz));\nj0eval[0]=x1644;\nj0eval[1]=((IKabs((x1643+((py*x1641))+(((-1.0)*cj3*x1643)))))+(IKabs((x1642+((px*x1641))+(((-1.0)*cj3*x1642))))));\nj0eval[2]=IKsign(x1644);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x1645=pz*pz;\nIkReal x1646=((80.0)*pp);\nIkReal x1647=((88.0)*pz);\nj0eval[0]=((((-1.0)*x1645))+pp);\nj0eval[1]=IKsign(((((-9.0)*x1645))+(((9.0)*pp))));\nj0eval[2]=((IKabs(((((-1.0)*py*x1646))+(((-1.0)*py*x1647))+(((-17.0)*py)))))+(IKabs(((((-1.0)*px*x1647))+(((-1.0)*px*x1646))+(((-17.0)*px))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+(((-1.0)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=1.0;\nj2=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=1.0;\nj2=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=(pp+(((-1.0)*(pz*pz))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1649 = IKatan2WithCheck(IkReal(((-0.09)*px)),((-0.09)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x1649.valid){\ncontinue;\n}\nIkReal x1648=x1649.value;\nj0array[0]=((-1.0)*x1648);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1648)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1650=IKsin(j0);\nIkReal x1651=IKcos(j0);\nevalcond[0]=(((px*x1651))+((py*x1650)));\nevalcond[1]=((((-1.0)*py*x1651))+((px*x1650)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1653 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1653.valid){\ncontinue;\n}\nIkReal x1652=x1653.value;\nj0array[0]=((-1.0)*x1652);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1652)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1654=IKcos(j0);\nIkReal x1655=IKsin(j0);\nevalcond[0]=((((-1.0)*py*x1654))+((px*x1655)));\nevalcond[1]=((((-0.09)*px*x1654))+(((-0.09)*py*x1655)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1656=((110.0)*pz);\nIkReal x1657=((100.0)*pp);\nCheckValue<IkReal> x1658 = IKatan2WithCheck(IkReal(((((-1.0)*py*x1657))+(((-1.0)*py*x1656))+(((-21.25)*py)))),((((-1.0)*px*x1656))+(((-1.0)*px*x1657))+(((-21.25)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1658.valid){\ncontinue;\n}\nCheckValue<IkReal> x1659=IKPowWithIntegerCheck(IKsign(((((9.0)*pp))+(((-9.0)*(pz*pz))))),-1);\nif(!x1659.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1658.value)+(((1.5707963267949)*(x1659.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1660=IKsin(j0);\nIkReal x1661=IKcos(j0);\nIkReal x1662=(px*x1661);\nIkReal x1663=(py*x1660);\nevalcond[0]=((((-1.0)*py*x1661))+((px*x1660)));\nevalcond[1]=((0.045)+x1663+x1662+(((-0.045)*cj3))+(((0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((-0.09)*x1663))+(((-0.09)*x1662))+(((-1.0)*pp))+(((-1.1)*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1664=((0.3)*sj3);\nIkReal x1665=((0.045)*px);\nIkReal x1666=((0.045)*py);\nCheckValue<IkReal> x1667 = IKatan2WithCheck(IkReal((x1666+((py*x1664))+(((-1.0)*cj3*x1666)))),(x1665+((px*x1664))+(((-1.0)*cj3*x1665))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1667.valid){\ncontinue;\n}\nCheckValue<IkReal> x1668=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp))+(pz*pz))),-1);\nif(!x1668.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1667.value)+(((1.5707963267949)*(x1668.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1669=IKsin(j0);\nIkReal x1670=IKcos(j0);\nIkReal x1671=(px*x1670);\nIkReal x1672=(py*x1669);\nevalcond[0]=(((px*x1669))+(((-1.0)*py*x1670)));\nevalcond[1]=((0.045)+x1671+x1672+(((-0.045)*cj3))+(((0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((-0.09)*x1672))+(((-0.09)*x1671))+(((-1.0)*pp))+(((-1.1)*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1673=((0.045)*sj3);\nIkReal x1674=((0.3)*cj3);\nIkReal x1675=(x1674+x1673);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=((-0.55)+(((-1.0)*pz))+(((-1.0)*x1675)));\nevalcond[3]=((0.55)+x1675+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x1676=((20.0)*sj3);\nIkReal x1677=((3.0)*px);\nIkReal x1678=((3.0)*py);\nIkReal x1679=(pp+(((-1.0)*(pz*pz))));\nj0eval[0]=x1679;\nj0eval[1]=((IKabs((x1677+((px*x1676))+(((-1.0)*cj3*x1677)))))+(IKabs((x1678+((py*x1676))+(((-1.0)*cj3*x1678))))));\nj0eval[2]=IKsign(x1679);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x1680=pz*pz;\nIkReal x1681=((80.0)*pp);\nIkReal x1682=((88.0)*pz);\nj0eval[0]=(x1680+(((-1.0)*pp)));\nj0eval[1]=IKsign(((((-9.0)*pp))+(((9.0)*x1680))));\nj0eval[2]=((IKabs(((((-1.0)*py*x1681))+(((-1.0)*py*x1682))+(((-17.0)*py)))))+(IKabs(((((-17.0)*px))+(((-1.0)*px*x1682))+(((-1.0)*px*x1681))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+(((-1.0)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=(pp+(((-1.0)*(pz*pz))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1684 = IKatan2WithCheck(IkReal(((0.09)*px)),((0.09)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x1684.valid){\ncontinue;\n}\nIkReal x1683=x1684.value;\nj0array[0]=((-1.0)*x1683);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1683)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1685=IKcos(j0);\nIkReal x1686=IKsin(j0);\nIkReal x1687=((1.0)*x1685);\nevalcond[0]=((((-1.0)*py*x1687))+((px*x1686)));\nevalcond[1]=((((-1.0)*py*x1686))+(((-1.0)*px*x1687)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1689 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x1689.valid){\ncontinue;\n}\nIkReal x1688=x1689.value;\nj0array[0]=((-1.0)*x1688);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1688)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1690=IKcos(j0);\nIkReal x1691=IKsin(j0);\nIkReal x1692=(py*x1691);\nIkReal x1693=(px*x1690);\nevalcond[0]=((((-1.0)*x1692))+(((-1.0)*x1693)));\nevalcond[1]=((((0.09)*x1692))+(((0.09)*x1693)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1694=((110.0)*pz);\nIkReal x1695=((100.0)*pp);\nCheckValue<IkReal> x1696=IKPowWithIntegerCheck(IKsign(((((-9.0)*pp))+(((9.0)*(pz*pz))))),-1);\nif(!x1696.valid){\ncontinue;\n}\nCheckValue<IkReal> x1697 = IKatan2WithCheck(IkReal(((((-1.0)*py*x1694))+(((-1.0)*py*x1695))+(((-21.25)*py)))),((((-21.25)*px))+(((-1.0)*px*x1695))+(((-1.0)*px*x1694))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1697.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1696.value)))+(x1697.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1698=IKcos(j0);\nIkReal x1699=IKsin(j0);\nIkReal x1700=((1.0)*py);\nIkReal x1701=(px*x1698);\nevalcond[0]=((((-1.0)*x1698*x1700))+((px*x1699)));\nevalcond[1]=((0.045)+(((-1.0)*x1701))+(((-1.0)*x1699*x1700))+(((-0.045)*cj3))+(((0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((-1.0)*pp))+(((-1.1)*pz))+(((0.09)*x1701))+(((0.09)*py*x1699)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1702=((0.3)*sj3);\nIkReal x1703=((0.045)*px);\nIkReal x1704=((0.045)*py);\nCheckValue<IkReal> x1705 = IKatan2WithCheck(IkReal(((((-1.0)*cj3*x1704))+x1704+((py*x1702)))),((((-1.0)*cj3*x1703))+x1703+((px*x1702))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1705.valid){\ncontinue;\n}\nCheckValue<IkReal> x1706=IKPowWithIntegerCheck(IKsign((pp+(((-1.0)*(pz*pz))))),-1);\nif(!x1706.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1705.value)+(((1.5707963267949)*(x1706.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1707=IKcos(j0);\nIkReal x1708=IKsin(j0);\nIkReal x1709=((1.0)*py);\nIkReal x1710=(px*x1707);\nevalcond[0]=((((-1.0)*x1707*x1709))+((px*x1708)));\nevalcond[1]=((0.045)+(((-1.0)*x1708*x1709))+(((-1.0)*x1710))+(((-0.045)*cj3))+(((0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((-1.0)*pp))+(((-1.1)*pz))+(((0.09)*x1710))+(((0.09)*py*x1708)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1711=((0.045)*sj3);\nIkReal x1712=((0.3)*cj3);\nIkReal x1713=(x1712+x1711);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=((-0.55)+(((-1.0)*x1713))+(((-1.0)*pz)));\nevalcond[3]=((0.55)+x1713+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nIkReal x1714=((20.0)*sj3);\nIkReal x1715=((3.0)*px);\nIkReal x1716=((3.0)*py);\nIkReal x1717=((((-1.0)*pp))+(pz*pz));\nj0eval[0]=x1717;\nj0eval[1]=((IKabs(((((-1.0)*x1716))+((cj3*x1716))+(((-1.0)*py*x1714)))))+(IKabs(((((-1.0)*cj3*x1715))+x1715+((px*x1714))))));\nj0eval[2]=IKsign(x1717);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nIkReal x1718=pz*pz;\nIkReal x1719=((80.0)*pp);\nIkReal x1720=((88.0)*pz);\nj0eval[0]=((((-1.0)*x1718))+pp);\nj0eval[1]=((IKabs(((((-1.0)*px*x1719))+(((-1.0)*px*x1720))+(((-17.0)*px)))))+(IKabs((((py*x1720))+(((17.0)*py))+((py*x1719))))));\nj0eval[2]=IKsign(((((-9.0)*x1718))+(((9.0)*pp))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+(((-1.0)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=(pp+(((-1.0)*(pz*pz))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1722 = IKatan2WithCheck(IkReal(((0.09)*py)),((-0.09)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x1722.valid){\ncontinue;\n}\nIkReal x1721=x1722.value;\nj0array[0]=((-1.0)*x1721);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1721)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1723=IKcos(j0);\nIkReal x1724=IKsin(j0);\nIkReal x1725=((1.0)*x1723);\nevalcond[0]=(((px*x1724))+(((-1.0)*py*x1725)));\nevalcond[1]=((((-1.0)*py*x1724))+(((-1.0)*px*x1725)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1727 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x1727.valid){\ncontinue;\n}\nIkReal x1726=x1727.value;\nj0array[0]=((-1.0)*x1726);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1726)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1728=IKcos(j0);\nIkReal x1729=IKsin(j0);\nevalcond[0]=((((-1.0)*py*x1729))+(((-1.0)*px*x1728)));\nevalcond[1]=((((0.09)*py*x1728))+(((-0.09)*px*x1729)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1730=((110.0)*pz);\nIkReal x1731=((100.0)*pp);\nCheckValue<IkReal> x1732 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1730))+(((-1.0)*px*x1731))+(((-21.25)*px)))),(((py*x1730))+((py*x1731))+(((21.25)*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1732.valid){\ncontinue;\n}\nCheckValue<IkReal> x1733=IKPowWithIntegerCheck(IKsign(((((9.0)*pp))+(((-9.0)*(pz*pz))))),-1);\nif(!x1733.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1732.value)+(((1.5707963267949)*(x1733.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1734=IKsin(j0);\nIkReal x1735=IKcos(j0);\nIkReal x1736=(px*x1734);\nIkReal x1737=((1.0)*x1735);\nevalcond[0]=((((-1.0)*px*x1737))+(((-1.0)*py*x1734)));\nevalcond[1]=((0.045)+x1736+(((-1.0)*py*x1737))+(((-0.045)*cj3))+(((0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((0.09)*py*x1735))+(((-1.0)*pp))+(((-1.1)*pz))+(((-0.09)*x1736)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1738=((0.3)*sj3);\nIkReal x1739=((0.045)*px);\nIkReal x1740=((0.045)*py);\nCheckValue<IkReal> x1741=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp))+(pz*pz))),-1);\nif(!x1741.valid){\ncontinue;\n}\nCheckValue<IkReal> x1742 = IKatan2WithCheck(IkReal((((px*x1738))+x1739+(((-1.0)*cj3*x1739)))),((((-1.0)*py*x1738))+((cj3*x1740))+(((-1.0)*x1740))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1742.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1741.value)))+(x1742.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1743=IKsin(j0);\nIkReal x1744=IKcos(j0);\nIkReal x1745=(px*x1743);\nIkReal x1746=((1.0)*x1744);\nevalcond[0]=((((-1.0)*py*x1743))+(((-1.0)*px*x1746)));\nevalcond[1]=((0.045)+x1745+(((-0.045)*cj3))+(((-1.0)*py*x1746))+(((0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((0.09)*py*x1744))+(((-1.0)*pp))+(((-1.1)*pz))+(((-0.09)*x1745)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1747=((0.045)*sj3);\nIkReal x1748=((0.3)*cj3);\nIkReal x1749=(x1748+x1747);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=((-0.55)+(((-1.0)*pz))+(((-1.0)*x1749)));\nevalcond[3]=((0.55)+x1749+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nIkReal x1750=((20.0)*sj3);\nIkReal x1751=((3.0)*px);\nIkReal x1752=((3.0)*py);\nIkReal x1753=((((-1.0)*pp))+(pz*pz));\nj0eval[0]=x1753;\nj0eval[1]=((IKabs((x1752+(((-1.0)*cj3*x1752))+((py*x1750)))))+(IKabs((((cj3*x1751))+(((-1.0)*x1751))+(((-1.0)*px*x1750))))));\nj0eval[2]=IKsign(x1753);\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nIkReal x1754=pz*pz;\nIkReal x1755=((80.0)*pp);\nIkReal x1756=((88.0)*pz);\nj0eval[0]=(x1754+(((-1.0)*pp)));\nj0eval[1]=IKsign(((((-9.0)*pp))+(((9.0)*x1754))));\nj0eval[2]=((IKabs(((((-1.0)*px*x1755))+(((-1.0)*px*x1756))+(((-17.0)*px)))))+(IKabs(((((17.0)*py))+((py*x1755))+((py*x1756))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+(((-1.0)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=(pp+(((-1.0)*(pz*pz))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1758 = IKatan2WithCheck(IkReal(((-0.09)*py)),((0.09)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x1758.valid){\ncontinue;\n}\nIkReal x1757=x1758.value;\nj0array[0]=((-1.0)*x1757);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1757)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1759=IKsin(j0);\nIkReal x1760=IKcos(j0);\nevalcond[0]=(((px*x1760))+((py*x1759)));\nevalcond[1]=(((px*x1759))+(((-1.0)*py*x1760)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1762 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1762.valid){\ncontinue;\n}\nIkReal x1761=x1762.value;\nj0array[0]=((-1.0)*x1761);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1761)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1763=IKsin(j0);\nIkReal x1764=IKcos(j0);\nIkReal x1765=(px*x1763);\nIkReal x1766=(py*x1764);\nevalcond[0]=((((-1.0)*x1766))+x1765);\nevalcond[1]=((((-0.09)*x1766))+(((0.09)*x1765)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1767=((110.0)*pz);\nIkReal x1768=((100.0)*pp);\nCheckValue<IkReal> x1769=IKPowWithIntegerCheck(IKsign(((((-9.0)*pp))+(((9.0)*(pz*pz))))),-1);\nif(!x1769.valid){\ncontinue;\n}\nCheckValue<IkReal> x1770 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1768))+(((-1.0)*px*x1767))+(((-21.25)*px)))),((((21.25)*py))+((py*x1768))+((py*x1767))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1770.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1769.value)))+(x1770.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1771=IKsin(j0);\nIkReal x1772=IKcos(j0);\nIkReal x1773=(px*x1771);\nIkReal x1774=(py*x1772);\nevalcond[0]=(((px*x1772))+((py*x1771)));\nevalcond[1]=((-0.045)+(((0.045)*cj3))+(((-1.0)*x1774))+x1773+(((-0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((-0.09)*x1774))+(((-1.0)*pp))+(((-1.1)*pz))+(((0.09)*x1773)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1775=((0.3)*sj3);\nIkReal x1776=((0.045)*px);\nIkReal x1777=((0.045)*py);\nCheckValue<IkReal> x1778=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp))+(pz*pz))),-1);\nif(!x1778.valid){\ncontinue;\n}\nCheckValue<IkReal> x1779 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1775))+(((-1.0)*x1776))+((cj3*x1776)))),((((-1.0)*cj3*x1777))+x1777+((py*x1775))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1779.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1778.value)))+(x1779.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x1780=IKsin(j0);\nIkReal x1781=IKcos(j0);\nIkReal x1782=(px*x1780);\nIkReal x1783=(py*x1781);\nevalcond[0]=(((py*x1780))+((px*x1781)));\nevalcond[1]=((-0.045)+(((0.045)*cj3))+x1782+(((-1.0)*x1783))+(((-0.3)*sj3)));\nevalcond[2]=((-0.2125)+(((0.09)*x1782))+(((-1.0)*pp))+(((-1.1)*pz))+(((-0.09)*x1783)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=((-0.85)+(((-1.0)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs((((cj2*px))+(((-1.0)*py*sj2)))))+(IKabs((((cj2*py))+((px*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nIkReal x1784=((1.0)*sj2);\nj0eval[0]=((IKabs(((((-1.0)*py*x1784))+((cj2*px)))))+(IKabs(((((-1.0)*cj2*py))+(((-1.0)*px*x1784))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x1785=((1.0)*py);\nCheckValue<IkReal> x1787 = IKatan2WithCheck(IkReal(((((-1.0)*cj2*x1785))+(((-1.0)*px*sj2)))),(((cj2*px))+(((-1.0)*sj2*x1785))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1787.valid){\ncontinue;\n}\nIkReal x1786=x1787.value;\nj0array[0]=((-1.0)*x1786);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1786)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x1788=IKcos(j0);\nIkReal x1789=IKsin(j0);\nIkReal x1790=((0.09)*sj2);\nIkReal x1791=(px*x1789);\nIkReal x1792=((1.0)*x1788);\nIkReal x1793=(py*x1789);\nIkReal x1794=(cj2*px*x1788);\nevalcond[0]=(x1791+(((-1.0)*py*x1792)));\nevalcond[1]=((((-1.0)*x1793))+(((-1.0)*px*x1792)));\nevalcond[2]=(((sj2*x1791))+x1794+((cj2*x1793))+(((-1.0)*py*sj2*x1792)));\nevalcond[3]=((((-1.0)*x1790*x1791))+((py*x1788*x1790))+(((-0.09)*x1794))+(((-0.09)*cj2*x1793)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1796 = IKatan2WithCheck(IkReal((((cj2*px))+(((-1.0)*py*sj2)))),(((cj2*py))+((px*sj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1796.valid){\ncontinue;\n}\nIkReal x1795=x1796.value;\nj0array[0]=((-1.0)*x1795);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1795)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x1797=IKcos(j0);\nIkReal x1798=IKsin(j0);\nIkReal x1799=((0.09)*sj2);\nIkReal x1800=(cj2*py);\nIkReal x1801=(px*x1798);\nIkReal x1802=((1.0)*x1797);\nIkReal x1803=((1.0)*py*x1798);\nevalcond[0]=((((-1.0)*py*x1802))+x1801);\nevalcond[1]=((((-1.0)*x1803))+(((-1.0)*px*x1802)));\nevalcond[2]=(((cj2*x1801))+(((-1.0)*x1800*x1802))+(((-1.0)*px*sj2*x1802))+(((-1.0)*sj2*x1803)));\nevalcond[3]=((((-1.0)*x1799*x1801))+((py*x1797*x1799))+(((-0.09)*cj2*px*x1797))+(((-0.09)*x1798*x1800)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1805 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x1805.valid){\ncontinue;\n}\nIkReal x1804=x1805.value;\nj0array[0]=((-1.0)*x1804);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1804)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x1806=IKsin(j0);\nIkReal x1807=IKcos(j0);\nIkReal x1808=(py*sj2);\nIkReal x1809=(cj2*px);\nIkReal x1810=((1.0)*x1807);\nIkReal x1811=((0.09)*x1807);\nIkReal x1812=(py*x1806);\nIkReal x1813=(px*sj2*x1806);\nevalcond[0]=((((-1.0)*px*x1810))+(((-1.0)*x1812)));\nevalcond[1]=(((cj2*x1812))+(((-1.0)*x1808*x1810))+x1813+((x1807*x1809)));\nevalcond[2]=((((-1.0)*px*sj2*x1810))+((x1806*x1809))+(((-1.0)*x1806*x1808))+(((-1.0)*cj2*py*x1810)));\nevalcond[3]=((((-1.0)*x1809*x1811))+(((-0.09)*cj2*x1812))+((x1808*x1811))+(((-0.09)*x1813)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1814=cj2*cj2;\nIkReal x1815=((0.045)*px);\nIkReal x1816=(cj2*sj2);\nIkReal x1817=((0.3)*sj3);\nIkReal x1818=((0.045)*py);\nIkReal x1819=(cj3*x1818);\nIkReal x1820=(py*x1814);\nCheckValue<IkReal> x1821=IKPowWithIntegerCheck(IKsign(((((-1.0)*sj2*(pz*pz)))+((pp*sj2)))),-1);\nif(!x1821.valid){\ncontinue;\n}\nCheckValue<IkReal> x1822 = IKatan2WithCheck(IkReal(((((-1.0)*x1815))+(((-1.0)*py*x1816*x1817))+(((-1.0)*cj3*x1814*x1815))+((cj3*x1815))+((x1816*x1819))+(((-1.0)*x1816*x1818))+((x1814*x1815))+((px*x1814*x1817))+(((-1.0)*px*x1817)))),((((-1.0)*x1819))+(((-1.0)*x1817*x1820))+(((-1.0)*px*x1816*x1817))+((py*x1817))+((x1814*x1819))+(((-1.0)*x1814*x1818))+x1818+(((-1.0)*x1815*x1816))+((cj3*x1815*x1816))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1822.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1821.value)))+(x1822.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x1823=IKcos(j0);\nIkReal x1824=IKsin(j0);\nIkReal x1825=((0.045)*cj2);\nIkReal x1826=((0.09)*sj2);\nIkReal x1827=((0.3)*sj3);\nIkReal x1828=((0.045)*cj3);\nIkReal x1829=((1.0)*sj2);\nIkReal x1830=((0.09)*cj2);\nIkReal x1831=(px*x1824);\nIkReal x1832=(px*x1823);\nIkReal x1833=(py*x1823);\nIkReal x1834=(py*x1824);\nevalcond[0]=((((-1.0)*x1833))+(((0.045)*sj2))+x1831+((sj2*x1827))+(((-1.0)*sj2*x1828)));\nevalcond[1]=((((-1.0)*x1825))+(((-1.0)*x1834))+(((-1.0)*x1832))+(((-1.0)*cj2*x1827))+((cj3*x1825)));\nevalcond[2]=(((cj2*x1831))+(((-1.0)*x1829*x1832))+(((-1.0)*x1829*x1834))+(((-1.0)*cj2*x1833)));\nevalcond[3]=((0.045)+(((-1.0)*x1828))+((cj2*x1834))+((cj2*x1832))+((sj2*x1831))+x1827+(((-1.0)*x1829*x1833)));\nevalcond[4]=((-0.2125)+((x1826*x1833))+(((-1.0)*pp))+(((-1.1)*pz))+(((-1.0)*x1826*x1831))+(((-1.0)*x1830*x1832))+(((-1.0)*x1830*x1834)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1835=cj2*cj2;\nIkReal x1836=((0.045)*px);\nIkReal x1837=((0.045)*py);\nIkReal x1838=(cj2*sj2);\nIkReal x1839=(cj3*x1838);\nIkReal x1840=(cj3*x1835);\nIkReal x1841=((0.3)*py*sj3);\nIkReal x1842=((0.3)*px*sj3);\nCheckValue<IkReal> x1843=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj2*pp))+((cj2*(pz*pz))))),-1);\nif(!x1843.valid){\ncontinue;\n}\nCheckValue<IkReal> x1844 = IKatan2WithCheck(IkReal((((x1838*x1842))+(((-1.0)*x1836*x1839))+((x1835*x1837))+(((-1.0)*x1837*x1840))+((x1835*x1841))+((x1836*x1838)))),((((-1.0)*x1837*x1838))+((x1835*x1836))+(((-1.0)*x1836*x1840))+((x1837*x1839))+(((-1.0)*x1838*x1841))+((x1835*x1842))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1844.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1843.value)))+(x1844.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x1845=IKcos(j0);\nIkReal x1846=IKsin(j0);\nIkReal x1847=((0.045)*cj2);\nIkReal x1848=((0.09)*sj2);\nIkReal x1849=((0.3)*sj3);\nIkReal x1850=((0.045)*cj3);\nIkReal x1851=((1.0)*sj2);\nIkReal x1852=((0.09)*cj2);\nIkReal x1853=(px*x1846);\nIkReal x1854=(px*x1845);\nIkReal x1855=(py*x1845);\nIkReal x1856=(py*x1846);\nevalcond[0]=((((-1.0)*x1855))+((sj2*x1849))+(((0.045)*sj2))+x1853+(((-1.0)*sj2*x1850)));\nevalcond[1]=((((-1.0)*x1847))+(((-1.0)*x1856))+(((-1.0)*x1854))+((cj3*x1847))+(((-1.0)*cj2*x1849)));\nevalcond[2]=((((-1.0)*cj2*x1855))+(((-1.0)*x1851*x1854))+(((-1.0)*x1851*x1856))+((cj2*x1853)));\nevalcond[3]=((0.045)+(((-1.0)*x1851*x1855))+((cj2*x1854))+((cj2*x1856))+x1849+((sj2*x1853))+(((-1.0)*x1850)));\nevalcond[4]=((-0.2125)+(((-1.0)*x1848*x1853))+((x1848*x1855))+(((-1.0)*x1852*x1856))+(((-1.0)*x1852*x1854))+(((-1.0)*pp))+(((-1.1)*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1857=(px*sj2);\nIkReal x1858=((0.3)*sj3);\nIkReal x1859=(cj2*py);\nIkReal x1860=(py*sj2);\nIkReal x1861=((0.045)*cj3*py);\nIkReal x1862=((0.045)*cj2*px);\nCheckValue<IkReal> x1863=IKPowWithIntegerCheck(IKsign((pp+(((-1.0)*(pz*pz))))),-1);\nif(!x1863.valid){\ncontinue;\n}\nCheckValue<IkReal> x1864 = IKatan2WithCheck(IkReal(((((-1.0)*x1858*x1859))+(((-0.045)*x1859))+(((-0.045)*x1857))+(((-1.0)*x1857*x1858))+(((0.045)*cj3*x1859))+(((0.045)*cj3*x1857)))),(((cj3*x1862))+(((0.045)*x1860))+(((-1.0)*cj2*px*x1858))+((x1858*x1860))+(((-1.0)*x1862))+(((-0.045)*cj3*x1860))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1864.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1863.value)))+(x1864.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x1865=IKcos(j0);\nIkReal x1866=IKsin(j0);\nIkReal x1867=((0.045)*cj2);\nIkReal x1868=((0.09)*sj2);\nIkReal x1869=((0.3)*sj3);\nIkReal x1870=((0.045)*cj3);\nIkReal x1871=((1.0)*sj2);\nIkReal x1872=((0.09)*cj2);\nIkReal x1873=(px*x1866);\nIkReal x1874=(px*x1865);\nIkReal x1875=(py*x1865);\nIkReal x1876=(py*x1866);\nevalcond[0]=((((0.045)*sj2))+(((-1.0)*sj2*x1870))+x1873+((sj2*x1869))+(((-1.0)*x1875)));\nevalcond[1]=(((cj3*x1867))+(((-1.0)*cj2*x1869))+(((-1.0)*x1876))+(((-1.0)*x1874))+(((-1.0)*x1867)));\nevalcond[2]=(((cj2*x1873))+(((-1.0)*x1871*x1876))+(((-1.0)*x1871*x1874))+(((-1.0)*cj2*x1875)));\nevalcond[3]=((0.045)+(((-1.0)*x1870))+((sj2*x1873))+((cj2*x1876))+((cj2*x1874))+x1869+(((-1.0)*x1871*x1875)));\nevalcond[4]=((-0.2125)+(((-1.0)*x1872*x1874))+(((-1.0)*x1872*x1876))+(((-1.0)*x1868*x1873))+(((-1.0)*pp))+(((-1.1)*pz))+((x1868*x1875)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1877=(cj3*py);\nIkReal x1878=((0.3)*sj1);\nIkReal x1879=((0.045)*sj2);\nIkReal x1880=(cj3*px);\nIkReal x1881=(px*sj1);\nIkReal x1882=((0.3)*sj3);\nIkReal x1883=((0.045)*sj3);\nIkReal x1884=(py*sj1);\nIkReal x1885=(cj1*cj2);\nIkReal x1886=((0.045)*x1885);\nCheckValue<IkReal> x1887 = IKatan2WithCheck(IkReal(((((0.55)*x1884))+((x1879*x1880))+(((-1.0)*px*x1879))+((x1883*x1884))+((x1877*x1878))+((py*x1886))+(((-1.0)*px*sj2*x1882))+((py*x1882*x1885))+(((-1.0)*x1877*x1886)))),((((0.55)*x1881))+((x1881*x1883))+(((-1.0)*x1880*x1886))+((py*sj2*x1882))+((px*x1882*x1885))+(((-1.0)*x1877*x1879))+((x1878*x1880))+((px*x1886))+((py*x1879))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1887.valid){\ncontinue;\n}\nCheckValue<IkReal> x1888=IKPowWithIntegerCheck(IKsign((pp+(((-1.0)*(pz*pz))))),-1);\nif(!x1888.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1887.value)+(((1.5707963267949)*(x1888.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[6];\nIkReal x1889=IKsin(j0);\nIkReal x1890=IKcos(j0);\nIkReal x1891=(cj1*sj2);\nIkReal x1892=((0.09)*sj2);\nIkReal x1893=((0.3)*sj3);\nIkReal x1894=((0.045)*cj3);\nIkReal x1895=((1.1)*sj1);\nIkReal x1896=((0.3)*cj3);\nIkReal x1897=(cj1*cj2);\nIkReal x1898=((0.045)*sj3);\nIkReal x1899=((1.0)*sj2);\nIkReal x1900=(cj1*pz);\nIkReal x1901=(px*x1889);\nIkReal x1902=(px*x1890);\nIkReal x1903=(py*x1890);\nIkReal x1904=(py*x1889);\nIkReal x1905=(cj2*pz*sj1);\nevalcond[0]=((-0.55)+x1900+((sj1*x1902))+((sj1*x1904))+(((-1.0)*x1898))+(((-1.0)*x1896)));\nevalcond[1]=(((sj2*x1893))+(((-1.0)*sj2*x1894))+(((0.045)*sj2))+(((-1.0)*x1903))+x1901);\nevalcond[2]=((((-1.0)*pz*sj1*x1899))+(((-1.0)*cj2*x1903))+((cj2*x1901))+((x1891*x1902))+((x1891*x1904)));\nevalcond[3]=((((0.045)*x1897))+((x1893*x1897))+(((-1.0)*x1904))+(((-1.0)*x1902))+(((-1.0)*x1894*x1897))+((sj1*x1896))+((sj1*x1898))+(((0.55)*sj1)));\nevalcond[4]=((0.045)+(((-1.0)*x1899*x1903))+(((-1.0)*x1897*x1902))+(((-1.0)*x1897*x1904))+x1905+x1893+(((-1.0)*x1894))+((sj2*x1901)));\nevalcond[5]=((-0.2125)+((x1892*x1903))+(((1.1)*x1900))+(((-1.0)*x1892*x1901))+(((-1.0)*pp))+((x1895*x1902))+((x1895*x1904))+(((0.09)*x1897*x1904))+(((0.09)*x1897*x1902))+(((-0.09)*x1905)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1906=((0.55)*cj2);\nIkReal x1907=(cj2*sj1);\nIkReal x1908=(py*sj2);\nIkReal x1909=((0.045)*sj3);\nIkReal x1910=(px*pz);\nIkReal x1911=(cj2*px);\nIkReal x1912=(cj1*cj2);\nIkReal x1913=(cj2*py);\nIkReal x1914=((0.3)*cj3);\nIkReal x1915=((0.55)*cj1*sj2);\nIkReal x1916=(cj1*px*sj2);\nCheckValue<IkReal> x1917 = IKatan2WithCheck(IkReal(((((-1.0)*py*x1906))+((x1914*x1916))+(((-1.0)*sj2*x1910))+((px*x1915))+((x1909*x1916))+(((-1.0)*x1913*x1914))+(((-1.0)*x1909*x1913))+((py*pz*x1912)))),((((-1.0)*x1911*x1914))+(((-1.0)*cj1*x1908*x1909))+(((-1.0)*px*x1906))+((x1910*x1912))+(((-1.0)*cj1*x1908*x1914))+((pz*x1908))+(((-0.55)*cj1*x1908))+(((-1.0)*x1909*x1911))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1917.valid){\ncontinue;\n}\nCheckValue<IkReal> x1918=IKPowWithIntegerCheck(IKsign((((x1907*(pz*pz)))+(((-1.0)*pp*x1907)))),-1);\nif(!x1918.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1917.value)+(((1.5707963267949)*(x1918.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[6];\nIkReal x1919=IKsin(j0);\nIkReal x1920=IKcos(j0);\nIkReal x1921=(cj1*sj2);\nIkReal x1922=((0.09)*sj2);\nIkReal x1923=((0.3)*sj3);\nIkReal x1924=((0.045)*cj3);\nIkReal x1925=((1.1)*sj1);\nIkReal x1926=((0.3)*cj3);\nIkReal x1927=(cj1*cj2);\nIkReal x1928=((0.045)*sj3);\nIkReal x1929=((1.0)*sj2);\nIkReal x1930=(cj1*pz);\nIkReal x1931=(px*x1919);\nIkReal x1932=(px*x1920);\nIkReal x1933=(py*x1920);\nIkReal x1934=(py*x1919);\nIkReal x1935=(cj2*pz*sj1);\nevalcond[0]=((-0.55)+(((-1.0)*x1926))+(((-1.0)*x1928))+((sj1*x1934))+((sj1*x1932))+x1930);\nevalcond[1]=((((-1.0)*x1933))+(((0.045)*sj2))+((sj2*x1923))+x1931+(((-1.0)*sj2*x1924)));\nevalcond[2]=(((x1921*x1934))+((x1921*x1932))+(((-1.0)*cj2*x1933))+((cj2*x1931))+(((-1.0)*pz*sj1*x1929)));\nevalcond[3]=((((-1.0)*x1934))+(((-1.0)*x1932))+(((0.045)*x1927))+((x1923*x1927))+(((-1.0)*x1924*x1927))+(((0.55)*sj1))+((sj1*x1928))+((sj1*x1926)));\nevalcond[4]=((0.045)+((sj2*x1931))+(((-1.0)*x1927*x1934))+(((-1.0)*x1927*x1932))+(((-1.0)*x1924))+x1923+x1935+(((-1.0)*x1929*x1933)));\nevalcond[5]=((-0.2125)+(((1.1)*x1930))+((x1922*x1933))+((x1925*x1934))+((x1925*x1932))+(((-1.0)*pp))+(((0.09)*x1927*x1934))+(((0.09)*x1927*x1932))+(((-1.0)*x1922*x1931))+(((-0.09)*x1935)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1936=((0.045)*px);\nIkReal x1937=((0.3)*sj3);\nIkReal x1938=(sj1*sj2);\nIkReal x1939=((0.3)*cj3);\nIkReal x1940=(py*x1938);\nIkReal x1941=((1.0)*cj1*pz);\nCheckValue<IkReal> x1942 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1937*x1938))+(((0.045)*py*sj3))+((py*x1939))+(((-1.0)*py*x1941))+((cj3*x1936*x1938))+(((0.55)*py))+(((-1.0)*x1936*x1938)))),((((0.045)*x1940))+((x1937*x1940))+((px*x1939))+(((-1.0)*px*x1941))+(((-0.045)*cj3*x1940))+(((0.55)*px))+((sj3*x1936))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1942.valid){\ncontinue;\n}\nCheckValue<IkReal> x1943=IKPowWithIntegerCheck(IKsign((((pp*sj1))+(((-1.0)*sj1*(pz*pz))))),-1);\nif(!x1943.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1942.value)+(((1.5707963267949)*(x1943.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[6];\nIkReal x1944=IKsin(j0);\nIkReal x1945=IKcos(j0);\nIkReal x1946=(cj1*sj2);\nIkReal x1947=((0.09)*sj2);\nIkReal x1948=((0.3)*sj3);\nIkReal x1949=((0.045)*cj3);\nIkReal x1950=((1.1)*sj1);\nIkReal x1951=((0.3)*cj3);\nIkReal x1952=(cj1*cj2);\nIkReal x1953=((0.045)*sj3);\nIkReal x1954=((1.0)*sj2);\nIkReal x1955=(cj1*pz);\nIkReal x1956=(px*x1944);\nIkReal x1957=(px*x1945);\nIkReal x1958=(py*x1945);\nIkReal x1959=(py*x1944);\nIkReal x1960=(cj2*pz*sj1);\nevalcond[0]=((-0.55)+(((-1.0)*x1953))+(((-1.0)*x1951))+((sj1*x1957))+((sj1*x1959))+x1955);\nevalcond[1]=(((sj2*x1948))+(((-1.0)*sj2*x1949))+(((0.045)*sj2))+x1956+(((-1.0)*x1958)));\nevalcond[2]=(((cj2*x1956))+((x1946*x1957))+((x1946*x1959))+(((-1.0)*cj2*x1958))+(((-1.0)*pz*sj1*x1954)));\nevalcond[3]=((((-1.0)*x1949*x1952))+(((0.045)*x1952))+((sj1*x1953))+((sj1*x1951))+(((-1.0)*x1957))+(((-1.0)*x1959))+((x1948*x1952))+(((0.55)*sj1)));\nevalcond[4]=((0.045)+((sj2*x1956))+(((-1.0)*x1954*x1958))+(((-1.0)*x1949))+x1960+x1948+(((-1.0)*x1952*x1957))+(((-1.0)*x1952*x1959)));\nevalcond[5]=((-0.2125)+(((1.1)*x1955))+((x1950*x1957))+((x1950*x1959))+(((-1.0)*x1947*x1956))+(((0.09)*x1952*x1957))+(((0.09)*x1952*x1959))+(((-1.0)*pp))+(((-0.09)*x1960))+((x1947*x1958)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x1961=((0.045)*sj2);\nCheckValue<IkReal> x1964 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x1964.valid){\ncontinue;\n}\nIkReal x1962=((1.0)*(x1964.value));\nif((((px*px)+(py*py))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x1965=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);\nif(!x1965.valid){\ncontinue;\n}\nif( (((x1965.value)*(((((0.3)*sj2*sj3))+x1961+(((-1.0)*cj3*x1961)))))) < -1-IKFAST_SINCOS_THRESH || (((x1965.value)*(((((0.3)*sj2*sj3))+x1961+(((-1.0)*cj3*x1961)))))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x1963=IKasin(((x1965.value)*(((((0.3)*sj2*sj3))+x1961+(((-1.0)*cj3*x1961))))));\nj0array[0]=((((-1.0)*x1962))+(((-1.0)*x1963)));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x1962))+x1963);\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n\n{\nIkReal j1eval[2];\nIkReal x1966=(py*sj0);\nIkReal x1967=((0.3)*cj3);\nIkReal x1968=((0.045)*sj3);\nIkReal x1969=(cj2*pz);\nIkReal x1970=((6.66666666666667)*cj3);\nIkReal x1971=(cj0*px);\nIkReal x1972=((1.0)*sj3);\nj1eval[0]=(((cj3*x1969))+(((-1.0)*x1969))+(((-1.0)*x1966*x1972))+(((-1.0)*x1966*x1970))+(((-1.0)*x1971*x1972))+(((-1.0)*x1970*x1971))+(((-6.66666666666667)*sj3*x1969))+(((-12.2222222222222)*x1971))+(((-12.2222222222222)*x1966)));\nj1eval[1]=IKsign(((((0.045)*cj3*x1969))+(((-1.0)*x1966*x1967))+(((-1.0)*x1966*x1968))+(((-1.0)*x1968*x1971))+(((-0.3)*sj3*x1969))+(((-0.55)*x1971))+(((-0.55)*x1966))+(((-0.045)*x1969))+(((-1.0)*x1967*x1971))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nIkReal x1973=cj0*cj0;\nIkReal x1974=py*py;\nIkReal x1975=(sj2*x1973);\nIkReal x1976=(((sj2*x1974))+(((-1.0)*x1974*x1975))+((sj2*(pz*pz)))+((x1975*(px*px)))+(((2.0)*cj0*px*py*sj0*sj2)));\nj1eval[0]=x1976;\nj1eval[1]=IKsign(x1976);\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nIkReal x1977=(pz*sj2);\nIkReal x1978=(py*sj0);\nIkReal x1979=(cj0*px);\nIkReal x1980=(cj2*sj2);\nIkReal x1981=((1.0)*cj3);\nIkReal x1982=((0.045)*x1980);\nIkReal x1983=(sj3*x1980);\nIkReal x1984=(x1978*x1983);\nj1eval[0]=((((6.66666666666667)*x1984))+(((-6.66666666666667)*cj3*x1977))+((x1978*x1980))+((x1979*x1980))+(((-1.0)*x1978*x1980*x1981))+(((-1.0)*x1979*x1980*x1981))+(((-12.2222222222222)*x1977))+(((6.66666666666667)*x1979*x1983))+(((-1.0)*sj3*x1977)));\nj1eval[1]=IKsign(((((-1.0)*cj3*x1979*x1982))+(((-0.045)*sj3*x1977))+(((-1.0)*cj3*x1978*x1982))+(((-0.3)*cj3*x1977))+((x1978*x1982))+(((0.3)*x1979*x1983))+((x1979*x1982))+(((0.3)*x1984))+(((-0.55)*x1977))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1985=(((px*sj0))+(((-1.0)*cj0*py)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=x1985;\nevalcond[3]=x1985;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[2];\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x1986=(cj0*px);\nIkReal x1987=((0.310561435803037)*sj3);\nIkReal x1988=(pp*pz);\nIkReal x1989=(py*sj0);\nIkReal x1990=((0.138057984353428)*pp);\nIkReal x1991=((12.2222222222222)*sj3);\nIkReal x1992=((5.4333061668025)*pp);\nIkReal x1993=(pz*sj3);\nj1eval[0]=((((7.28153581454315)*pz))+(((-1.0)*x1986*x1991))+((x1986*x1992))+(((-1.0)*x1989*x1991))+(((-3.92556370551481)*x1989))+(((-3.92556370551481)*x1986))+((x1989*x1992))+(((-1.0)*x1993))+(((36.2220411120167)*x1988)));\nj1eval[1]=IKsign(((((-1.0)*x1986*x1987))+((x1986*x1990))+(((-1.0)*x1987*x1989))+(((0.185020708697653)*pz))+(((-0.0254095720202485)*x1993))+(((-0.099746893695352)*x1989))+(((-0.099746893695352)*x1986))+((x1989*x1990))+(((0.92038656235619)*x1988))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x1994=(cj0*px);\nIkReal x1995=(py*sj0);\nIkReal x1996=((0.3)*sj3);\nIkReal x1997=((0.045)*cj3);\nIkReal x1998=(pz*sj3);\nIkReal x1999=((6.66666666666667)*sj3);\nIkReal x2000=((1.0)*cj3);\nIkReal x2001=(cj3*pz);\nj1eval[0]=((((-1.0)*x1994*x2000))+(((-1.0)*x1995*x2000))+((x1995*x1999))+((x1994*x1999))+x1995+x1994+(((-6.66666666666667)*x2001))+(((-12.2222222222222)*pz))+(((-1.0)*x1998)));\nj1eval[1]=IKsign(((((-0.55)*pz))+(((-0.045)*x1998))+((x1995*x1996))+((x1994*x1996))+(((0.045)*x1994))+(((0.045)*x1995))+(((-1.0)*x1995*x1997))+(((-1.0)*x1994*x1997))+(((-0.3)*x2001))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x2002=(py*sj0);\nIkReal x2003=(cj0*px);\nIkReal x2004=(pp*pz);\nIkReal x2005=((0.92038656235619)*pp);\nIkReal x2006=(pz*sj3);\nIkReal x2007=((36.2220411120167)*pp);\nIkReal x2008=((0.0254095720202485)*sj3);\nj1eval[0]=((((-12.2222222222222)*x2006))+(((-1.0)*x2003*x2007))+((sj3*x2003))+((sj3*x2002))+(((-1.0)*x2002*x2007))+(((-3.92556370551481)*pz))+(((5.4333061668025)*x2004))+(((-7.28153581454315)*x2003))+(((-7.28153581454315)*x2002)));\nj1eval[1]=IKsign((((x2002*x2008))+(((-0.099746893695352)*pz))+(((-1.0)*x2003*x2005))+(((-0.310561435803037)*x2006))+(((-1.0)*x2002*x2005))+(((-0.185020708697653)*x2002))+(((-0.185020708697653)*x2003))+(((0.138057984353428)*x2004))+((x2003*x2008))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x2009=x1985;\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=x2009;\nevalcond[3]=x2009;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x2010=((-1.0)*py);\nsj2=0;\ncj2=1.0;\nj2=0;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x2010);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x2010);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x2010);\nrxp2_1=(px*r22);\nj1eval[0]=(((cj0*px))+((py*sj0)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(px))+(IKabs(py)));\nevalcond[1]=0.7225;\nevalcond[2]=-0.85;\nevalcond[3]=0;\nevalcond[4]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nsj2=0;\ncj2=1.0;\nj2=0;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=0;\nnpx=0;\nnpy=0;\nnpz=0;\nrxp0_0=0;\nrxp0_1=0;\nrxp1_0=0;\nrxp1_1=0;\nrxp2_0=0;\nrxp2_1=0;\npx=0;\npy=0;\nrxp0_2=0;\nrxp1_2=0;\nrxp2_2=0;\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));\nevalcond[1]=((0.7225)+(((-1.0)*(py*py))));\nevalcond[2]=-0.85;\nevalcond[3]=((-1.0)*py);\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x2011=((-1.0)*py);\nsj2=0;\ncj2=1.0;\nj2=0;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=py*py;\nnpx=(py*r10);\nnpy=(py*r11);\nnpz=(py*r12);\nrxp0_0=(r20*x2011);\nrxp0_1=0;\nrxp1_0=(r21*x2011);\nrxp1_1=0;\nrxp2_0=(r22*x2011);\nrxp2_1=0;\npx=0;\nj0=0;\nsj0=0;\ncj0=1.0;\nrxp0_2=(py*r00);\nrxp1_2=(py*r01);\nrxp2_2=(py*r02);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*(py*py))));\nevalcond[2]=-0.85;\nevalcond[3]=py;\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x2012=((-1.0)*py);\nsj2=0;\ncj2=1.0;\nj2=0;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=py*py;\nnpx=(py*r10);\nnpy=(py*r11);\nnpz=(py*r12);\nrxp0_0=(r20*x2012);\nrxp0_1=0;\nrxp1_0=(r21*x2012);\nrxp1_1=0;\nrxp2_0=(r22*x2012);\nrxp2_1=0;\npx=0;\nj0=3.14159265358979;\nsj0=0;\ncj0=-1.0;\nrxp0_2=(py*r00);\nrxp1_2=(py*r01);\nrxp2_2=(py*r02);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*(px*px))));\nevalcond[2]=-0.85;\nevalcond[3]=px;\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x2013=((-1.0)*px);\nsj2=0;\ncj2=1.0;\nj2=0;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=px*px;\nnpx=(px*r00);\nnpy=(px*r01);\nnpz=(px*r02);\nrxp0_0=0;\nrxp0_1=(px*r20);\nrxp1_0=0;\nrxp1_1=(px*r21);\nrxp2_0=0;\nrxp2_1=(px*r22);\npy=0;\nj0=1.5707963267949;\nsj0=1.0;\ncj0=0;\nrxp0_2=(r10*x2013);\nrxp1_2=(r11*x2013);\nrxp2_2=(r12*x2013);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*(px*px))));\nevalcond[2]=-0.85;\nevalcond[3]=((-1.0)*px);\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x2014=((-1.0)*px);\nsj2=0;\ncj2=1.0;\nj2=0;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=px*px;\nnpx=(px*r00);\nnpy=(px*r01);\nnpz=(px*r02);\nrxp0_0=0;\nrxp0_1=(px*r20);\nrxp1_0=0;\nrxp1_1=(px*r21);\nrxp2_0=0;\nrxp2_1=(px*r22);\npy=0;\nj0=-1.5707963267949;\nsj0=-1.0;\ncj0=0;\nrxp0_2=(r10*x2014);\nrxp1_2=(r11*x2014);\nrxp2_2=(r12*x2014);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x2015=py*py;\nIkReal x2016=cj0*cj0;\nIkReal x2017=(cj0*px);\nIkReal x2018=(py*sj0);\nIkReal x2019=((4400.0)*x2015);\nCheckValue<IkReal> x2020=IKPowWithIntegerCheck(((((306.0)*x2018))+(((306.0)*x2017))),-1);\nif(!x2020.valid){\ncontinue;\n}\nif( IKabs(((((1.17647058823529)*x2017))+(((1.17647058823529)*x2018)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x2020.value)*(((3179.0)+(((-1.0)*x2019))+((x2016*x2019))+(((-8800.0)*x2017*x2018))+(((-4400.0)*x2016*(px*px))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((1.17647058823529)*x2017))+(((1.17647058823529)*x2018))))+IKsqr(((x2020.value)*(((3179.0)+(((-1.0)*x2019))+((x2016*x2019))+(((-8800.0)*x2017*x2018))+(((-4400.0)*x2016*(px*px)))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj1array[0]=IKatan2(((((1.17647058823529)*x2017))+(((1.17647058823529)*x2018))), ((x2020.value)*(((3179.0)+(((-1.0)*x2019))+((x2016*x2019))+(((-8800.0)*x2017*x2018))+(((-4400.0)*x2016*(px*px)))))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x2021=IKsin(j1);\nIkReal x2022=IKcos(j1);\nIkReal x2023=(py*sj0);\nIkReal x2024=(cj0*px);\nIkReal x2025=((0.09)*x2022);\nIkReal x2026=((1.0)*x2022);\nIkReal x2027=((1.1)*x2021);\nevalcond[0]=((-0.85)*x2022);\nevalcond[1]=((-0.85)+((x2021*x2024))+((x2021*x2023)));\nevalcond[2]=((((0.85)*x2021))+(((-1.0)*x2023))+(((-1.0)*x2024)));\nevalcond[3]=((((-1.0)*x2023*x2026))+(((-1.0)*x2024*x2026)));\nevalcond[4]=((-0.935)+((x2024*x2025))+((x2024*x2027))+((x2023*x2025))+((x2023*x2027)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x2028=cj3*cj3;\nIkReal x2029=(cj3*sj3);\nIkReal x2030=(cj0*px);\nIkReal x2031=((0.92038656235619)*pp);\nIkReal x2032=((0.0254095720202485)*sj3);\nIkReal x2033=(py*sj0);\nIkReal x2034=(pp*sj3);\nIkReal x2035=((1.0)*pz);\nIkReal x2036=(cj3*pp);\nCheckValue<IkReal> x2037 = IKatan2WithCheck(IkReal(((-0.100617959042798)+(((-0.0414173953060285)*x2034))+(((-0.276115968706857)*x2036))+(((-0.00114343074091118)*x2028))+(pz*pz)+(((-0.506212609295904)*pp))+(((0.00564933271974229)*sj3))+(((-0.0555062126092959)*cj3))+(((0.00762287160607455)*x2029)))),((-0.0688360561435803)+(((0.0414173953060285)*x2036))+(((0.0139752646111367)*x2028))+(((-0.0299240681086056)*cj3))+(((0.0759318913943856)*pp))+(((-0.175297399907961)*sj3))+(((-0.0931684307409112)*x2029))+(((-1.0)*x2030*x2035))+(((0.00621260929590428)*x2034))+(((-1.0)*x2033*x2035))),IKFAST_ATAN2_MAGTHRESH);\nif(!x2037.valid){\ncontinue;\n}\nCheckValue<IkReal> x2038=IKPowWithIntegerCheck(IKsign(((((-0.099746893695352)*pz))+((x2030*x2032))+(((-0.185020708697653)*x2033))+(((-0.185020708697653)*x2030))+(((-0.310561435803037)*pz*sj3))+((x2032*x2033))+(((-1.0)*x2030*x2031))+(((0.138057984353428)*pp*pz))+(((-1.0)*x2031*x2033)))),-1);\nif(!x2038.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x2037.value)+(((1.5707963267949)*(x2038.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x2039=IKsin(j1);\nIkReal x2040=IKcos(j1);\nIkReal x2041=((0.045)*sj3);\nIkReal x2042=((0.3)*cj3);\nIkReal x2043=((0.045)*cj3);\nIkReal x2044=(cj0*px);\nIkReal x2045=(py*sj0);\nIkReal x2046=((1.0)*x2040);\nIkReal x2047=(sj3*x2040);\nIkReal x2048=(pz*x2039);\nIkReal x2049=(pz*x2040);\nIkReal x2050=((0.09)*x2040);\nIkReal x2051=((1.1)*x2039);\nevalcond[0]=((-0.55)+(((-1.0)*x2041))+(((-1.0)*x2042))+x2049+((x2039*x2044))+((x2039*x2045)));\nevalcond[1]=((0.045)+(((-1.0)*x2043))+x2048+(((-1.0)*x2045*x2046))+(((-1.0)*x2044*x2046))+(((0.3)*sj3)));\nevalcond[2]=((((-0.92038656235619)*pp*x2040))+pz+(((0.310561435803037)*sj3*x2039))+(((-0.185020708697653)*x2040))+(((0.0254095720202485)*x2047))+(((-0.138057984353428)*pp*x2039))+(((0.099746893695352)*x2039)));\nevalcond[3]=((((0.045)*x2040))+(((0.55)*x2039))+(((0.3)*x2047))+((x2039*x2041))+((x2039*x2042))+(((-1.0)*x2044))+(((-1.0)*x2045))+(((-1.0)*x2040*x2043)));\nevalcond[4]=((-0.2125)+(((1.1)*x2049))+((x2044*x2050))+((x2044*x2051))+(((-1.0)*pp))+((x2045*x2050))+((x2045*x2051))+(((-0.09)*x2048)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x2052=cj0*cj0;\nIkReal x2053=py*py;\nIkReal x2054=cj3*cj3;\nIkReal x2055=(py*sj0);\nIkReal x2056=((0.3)*sj3);\nIkReal x2057=((0.045)*cj3);\nIkReal x2058=(cj0*px);\nIkReal x2059=(cj3*sj3);\nIkReal x2060=((1.0)*pz);\nCheckValue<IkReal> x2061 = IKatan2WithCheck(IkReal(((0.03825)+(((-0.01125)*cj3))+(((-1.0)*x2058*x2060))+(((-0.027)*x2054))+(((-1.0)*x2055*x2060))+(((0.167025)*sj3))+(((0.087975)*x2059)))),((-0.304525)+(((-0.027)*x2059))+x2053+(((-0.0495)*sj3))+(((-1.0)*x2052*x2053))+(((2.0)*x2055*x2058))+(((-0.087975)*x2054))+((x2052*(px*px)))+(((-0.33)*cj3))),IKFAST_ATAN2_MAGTHRESH);\nif(!x2061.valid){\ncontinue;\n}\nCheckValue<IkReal> x2062=IKPowWithIntegerCheck(IKsign(((((-0.55)*pz))+(((-0.3)*cj3*pz))+((x2055*x2056))+(((-0.045)*pz*sj3))+(((-1.0)*x2057*x2058))+(((0.045)*x2055))+(((0.045)*x2058))+((x2056*x2058))+(((-1.0)*x2055*x2057)))),-1);\nif(!x2062.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x2061.value)+(((1.5707963267949)*(x2062.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x2063=IKsin(j1);\nIkReal x2064=IKcos(j1);\nIkReal x2065=((0.045)*sj3);\nIkReal x2066=((0.3)*cj3);\nIkReal x2067=((0.045)*cj3);\nIkReal x2068=(cj0*px);\nIkReal x2069=(py*sj0);\nIkReal x2070=((1.0)*x2064);\nIkReal x2071=(sj3*x2064);\nIkReal x2072=(pz*x2063);\nIkReal x2073=(pz*x2064);\nIkReal x2074=((0.09)*x2064);\nIkReal x2075=((1.1)*x2063);\nevalcond[0]=((-0.55)+x2073+(((-1.0)*x2066))+(((-1.0)*x2065))+((x2063*x2069))+((x2063*x2068)));\nevalcond[1]=((0.045)+x2072+(((-1.0)*x2067))+(((-1.0)*x2069*x2070))+(((0.3)*sj3))+(((-1.0)*x2068*x2070)));\nevalcond[2]=((((0.099746893695352)*x2063))+(((-0.138057984353428)*pp*x2063))+(((-0.92038656235619)*pp*x2064))+pz+(((0.0254095720202485)*x2071))+(((0.310561435803037)*sj3*x2063))+(((-0.185020708697653)*x2064)));\nevalcond[3]=((((-1.0)*x2064*x2067))+(((0.3)*x2071))+(((-1.0)*x2068))+(((-1.0)*x2069))+(((0.55)*x2063))+((x2063*x2065))+((x2063*x2066))+(((0.045)*x2064)));\nevalcond[4]=((-0.2125)+((x2069*x2074))+((x2069*x2075))+((x2068*x2075))+((x2068*x2074))+(((1.1)*x2073))+(((-1.0)*pp))+(((-0.09)*x2072)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x2076=cj3*cj3;\nIkReal x2077=(cj0*px);\nIkReal x2078=((0.00621260929590428)*pp);\nIkReal x2079=(cj3*sj3);\nIkReal x2080=(py*sj0);\nIkReal x2081=((0.138057984353428)*pp);\nIkReal x2082=((0.0414173953060285)*pp);\nIkReal x2083=((0.310561435803037)*sj3);\nCheckValue<IkReal> x2084=IKPowWithIntegerCheck(IKsign(((((-0.099746893695352)*x2080))+(((-0.0254095720202485)*pz*sj3))+(((-0.099746893695352)*x2077))+(((-1.0)*x2077*x2083))+(((0.185020708697653)*pz))+((x2077*x2081))+(((0.92038656235619)*pp*pz))+(((-1.0)*x2080*x2083))+((x2080*x2081)))),-1);\nif(!x2084.valid){\ncontinue;\n}\nCheckValue<IkReal> x2085 = IKatan2WithCheck(IkReal(((-0.000703060285319834)+(((-1.0)*x2082))+((pz*x2080))+(((-0.276115968706857)*pp*sj3))+(((-0.00762287160607455)*x2076))+(((-0.00114343074091118)*x2079))+((pz*x2077))+(((-0.0543627818683847)*sj3))+(((0.00832593189139439)*cj3))+((cj3*x2082)))),((-0.097657040957202)+x2078+(((-1.0)*cj3*x2078))+(((0.0139752646111367)*x2079))+(pz*pz)+(((0.0931684307409112)*x2076))+(((0.00448861021629084)*cj3))+((sj3*x2082))+(((-0.0438993327197423)*sj3))),IKFAST_ATAN2_MAGTHRESH);\nif(!x2085.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x2084.value)))+(x2085.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x2086=IKsin(j1);\nIkReal x2087=IKcos(j1);\nIkReal x2088=((0.045)*sj3);\nIkReal x2089=((0.3)*cj3);\nIkReal x2090=((0.045)*cj3);\nIkReal x2091=(cj0*px);\nIkReal x2092=(py*sj0);\nIkReal x2093=((1.0)*x2087);\nIkReal x2094=(sj3*x2087);\nIkReal x2095=(pz*x2086);\nIkReal x2096=(pz*x2087);\nIkReal x2097=((0.09)*x2087);\nIkReal x2098=((1.1)*x2086);\nevalcond[0]=((-0.55)+x2096+(((-1.0)*x2089))+(((-1.0)*x2088))+((x2086*x2091))+((x2086*x2092)));\nevalcond[1]=((0.045)+(((-1.0)*x2090))+(((-1.0)*x2091*x2093))+x2095+(((-1.0)*x2092*x2093))+(((0.3)*sj3)));\nevalcond[2]=((((-0.138057984353428)*pp*x2086))+(((-0.185020708697653)*x2087))+(((0.099746893695352)*x2086))+pz+(((0.310561435803037)*sj3*x2086))+(((-0.92038656235619)*pp*x2087))+(((0.0254095720202485)*x2094)));\nevalcond[3]=((((0.045)*x2087))+((x2086*x2088))+((x2086*x2089))+(((-1.0)*x2087*x2090))+(((-1.0)*x2092))+(((-1.0)*x2091))+(((0.55)*x2086))+(((0.3)*x2094)));\nevalcond[4]=((-0.2125)+(((-0.09)*x2095))+(((1.1)*x2096))+((x2091*x2098))+((x2091*x2097))+(((-1.0)*pp))+((x2092*x2098))+((x2092*x2097)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x2099=(px*sj0);\nIkReal x2100=(cj0*py);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.39655)+(((0.0765)*sj3))+(((-1.0)*pp))+(((0.32595)*cj3)));\nevalcond[2]=(x2099+(((-1.0)*x2100)));\nevalcond[3]=(x2100+(((-1.0)*x2099)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[2];\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x2101=cj0*cj0;\nIkReal x2102=py*py;\nIkReal x2103=(((x2101*(px*px)))+x2102+(pz*pz)+(((2.0)*cj0*px*py*sj0))+(((-1.0)*x2101*x2102)));\nj1eval[0]=x2103;\nj1eval[1]=IKsign(x2103);\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x2104=(py*sj0);\nIkReal x2105=((0.3)*sj3);\nIkReal x2106=(cj0*px);\nIkReal x2107=((6.66666666666667)*sj3);\nIkReal x2108=(pz*sj3);\nIkReal x2109=(cj3*pz);\nIkReal x2110=((0.045)*x2106);\nj1eval[0]=((((-1.0)*x2106*x2107))+((cj3*x2106))+((cj3*x2104))+(((-1.0)*x2104))+(((-1.0)*x2106))+(((-1.0)*x2108))+(((-12.2222222222222)*pz))+(((-1.0)*x2104*x2107))+(((-6.66666666666667)*x2109)));\nj1eval[1]=IKsign(((((-0.55)*pz))+(((0.045)*cj3*x2104))+(((-0.045)*x2104))+(((-0.045)*x2108))+(((-1.0)*x2105*x2106))+(((-0.3)*x2109))+(((-1.0)*x2110))+(((-1.0)*x2104*x2105))+((cj3*x2110))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x2111=(py*sj0);\nIkReal x2112=(cj0*px);\nIkReal x2113=(pp*pz);\nIkReal x2114=((0.92038656235619)*pp);\nIkReal x2115=(pz*sj3);\nIkReal x2116=((36.2220411120167)*pp);\nIkReal x2117=((0.0254095720202485)*sj3);\nj1eval[0]=((((-5.4333061668025)*x2113))+(((-1.0)*x2112*x2116))+(((12.2222222222222)*x2115))+((sj3*x2111))+((sj3*x2112))+(((-1.0)*x2111*x2116))+(((3.92556370551481)*pz))+(((-7.28153581454315)*x2111))+(((-7.28153581454315)*x2112)));\nj1eval[1]=IKsign(((((0.310561435803037)*x2115))+(((-1.0)*x2112*x2114))+((x2111*x2117))+(((-1.0)*x2111*x2114))+(((0.099746893695352)*pz))+(((-0.138057984353428)*x2113))+(((-0.185020708697653)*x2111))+(((-0.185020708697653)*x2112))+((x2112*x2117))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x2118=(px*sj0);\nIkReal x2119=(cj0*py);\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*pp)));\nevalcond[2]=(x2118+(((-1.0)*x2119)));\nevalcond[3]=(x2119+(((-1.0)*x2118)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x2120=((-1.0)*py);\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x2120);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x2120);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x2120);\nrxp2_1=(px*r22);\nj1eval[0]=((((-1.0)*py*sj0))+(((-1.0)*cj0*px)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(px))+(IKabs(py)));\nevalcond[1]=0.7225;\nevalcond[2]=-0.85;\nevalcond[3]=0;\nevalcond[4]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=0;\nnpx=0;\nnpy=0;\nnpz=0;\nrxp0_0=0;\nrxp0_1=0;\nrxp1_0=0;\nrxp1_1=0;\nrxp2_0=0;\nrxp2_1=0;\npx=0;\npy=0;\nrxp0_2=0;\nrxp1_2=0;\nrxp2_2=0;\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(px)));\nevalcond[1]=((0.7225)+(((-1.0)*(py*py))));\nevalcond[2]=-0.85;\nevalcond[3]=((-1.0)*py);\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x2121=((-1.0)*py);\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=py*py;\nnpx=(py*r10);\nnpy=(py*r11);\nnpz=(py*r12);\nrxp0_0=(r20*x2121);\nrxp0_1=0;\nrxp1_0=(r21*x2121);\nrxp1_1=0;\nrxp2_0=(r22*x2121);\nrxp2_1=0;\npx=0;\nj0=0;\nsj0=0;\ncj0=1.0;\nrxp0_2=(py*r00);\nrxp1_2=(py*r01);\nrxp2_2=(py*r02);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*(py*py))));\nevalcond[2]=-0.85;\nevalcond[3]=py;\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x2122=((-1.0)*py);\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=py*py;\nnpx=(py*r10);\nnpy=(py*r11);\nnpz=(py*r12);\nrxp0_0=(r20*x2122);\nrxp0_1=0;\nrxp1_0=(r21*x2122);\nrxp1_1=0;\nrxp2_0=(r22*x2122);\nrxp2_1=0;\npx=0;\nj0=3.14159265358979;\nsj0=0;\ncj0=-1.0;\nrxp0_2=(py*r00);\nrxp1_2=(py*r01);\nrxp2_2=(py*r02);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*(px*px))));\nevalcond[2]=-0.85;\nevalcond[3]=px;\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x2123=((-1.0)*px);\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=px*px;\nnpx=(px*r00);\nnpy=(px*r01);\nnpz=(px*r02);\nrxp0_0=0;\nrxp0_1=(px*r20);\nrxp1_0=0;\nrxp1_1=(px*r21);\nrxp2_0=0;\nrxp2_1=(px*r22);\npy=0;\nj0=1.5707963267949;\nsj0=1.0;\ncj0=0;\nrxp0_2=(r10*x2123);\nrxp1_2=(r11*x2123);\nrxp2_2=(r12*x2123);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));\nevalcond[1]=((0.7225)+(((-1.0)*(px*px))));\nevalcond[2]=-0.85;\nevalcond[3]=((-1.0)*px);\nevalcond[4]=0;\nevalcond[5]=-0.935;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x2124=((-1.0)*px);\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\npz=0;\nj3=0;\nsj3=0;\ncj3=1.0;\npp=px*px;\nnpx=(px*r00);\nnpy=(px*r01);\nnpz=(px*r02);\nrxp0_0=0;\nrxp0_1=(px*r20);\nrxp1_0=0;\nrxp1_1=(px*r21);\nrxp2_0=0;\nrxp2_1=(px*r22);\npy=0;\nj0=-1.5707963267949;\nsj0=-1.0;\ncj0=0;\nrxp0_2=(r10*x2124);\nrxp1_2=(r11*x2124);\nrxp2_2=(r12*x2124);\nj1eval[0]=1.0;\nif( IKabs(j1eval[0]) < 0.0000000100000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\nIkReal op[2+1], zeror[2];\nint numroots;\nop[0]=1.0;\nop[1]=0;\nop[2]=-1.0;\npolyroots2(op,zeror,numroots);\nIkReal j1array[2], cj1array[2], sj1array[2], tempj1array[1];\nint numsolutions = 0;\nfor(int ij1 = 0; ij1 < numroots; ++ij1)\n{\nIkReal htj1 = zeror[ij1];\ntempj1array[0]=((2.0)*(atan(htj1)));\nfor(int kj1 = 0; kj1 < 1; ++kj1)\n{\nj1array[numsolutions] = tempj1array[kj1];\nif( j1array[numsolutions] > IKPI )\n{\n    j1array[numsolutions]-=IK2PI;\n}\nelse if( j1array[numsolutions] < -IKPI )\n{\n    j1array[numsolutions]+=IK2PI;\n}\nsj1array[numsolutions] = IKsin(j1array[numsolutions]);\ncj1array[numsolutions] = IKcos(j1array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j1valid[2]={true,true};\n_nj1 = 2;\nfor(int ij1 = 0; ij1 < numsolutions; ++ij1)\n    {\nif( !j1valid[ij1] )\n{\n    continue;\n}\n    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\nhtj1 = IKtan(j1/2);\n\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nrotationfunction0(solutions);\n    }\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x2125=py*py;\nIkReal x2126=cj0*cj0;\nIkReal x2127=(cj0*px);\nIkReal x2128=(py*sj0);\nIkReal x2129=((4400.0)*x2125);\nCheckValue<IkReal> x2130=IKPowWithIntegerCheck(((((-306.0)*x2128))+(((-306.0)*x2127))),-1);\nif(!x2130.valid){\ncontinue;\n}\nif( IKabs(((((1.17647058823529)*x2128))+(((1.17647058823529)*x2127)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x2130.value)*(((3179.0)+(((-4400.0)*x2126*(px*px)))+(((-1.0)*x2129))+((x2126*x2129))+(((-8800.0)*x2127*x2128)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((1.17647058823529)*x2128))+(((1.17647058823529)*x2127))))+IKsqr(((x2130.value)*(((3179.0)+(((-4400.0)*x2126*(px*px)))+(((-1.0)*x2129))+((x2126*x2129))+(((-8800.0)*x2127*x2128))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj1array[0]=IKatan2(((((1.17647058823529)*x2128))+(((1.17647058823529)*x2127))), ((x2130.value)*(((3179.0)+(((-4400.0)*x2126*(px*px)))+(((-1.0)*x2129))+((x2126*x2129))+(((-8800.0)*x2127*x2128))))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x2131=IKcos(j1);\nIkReal x2132=IKsin(j1);\nIkReal x2133=(py*sj0);\nIkReal x2134=(cj0*px);\nIkReal x2135=((0.09)*x2131);\nIkReal x2136=(x2132*x2133);\nevalcond[0]=((-0.85)*x2131);\nevalcond[1]=(((x2131*x2134))+((x2131*x2133)));\nevalcond[2]=((-0.85)+x2136+((x2132*x2134)));\nevalcond[3]=((((0.85)*x2132))+(((-1.0)*x2134))+(((-1.0)*x2133)));\nevalcond[4]=((-0.935)+(((1.1)*x2136))+(((-1.0)*x2134*x2135))+(((1.1)*x2132*x2134))+(((-1.0)*x2133*x2135)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x2137=cj3*cj3;\nIkReal x2138=(cj3*sj3);\nIkReal x2139=(cj0*px);\nIkReal x2140=((0.92038656235619)*pp);\nIkReal x2141=((0.0254095720202485)*sj3);\nIkReal x2142=(py*sj0);\nIkReal x2143=((0.0414173953060285)*pp);\nIkReal x2144=((1.0)*pz);\nCheckValue<IkReal> x2145 = IKatan2WithCheck(IkReal(((-0.100617959042798)+(((0.00762287160607455)*x2138))+(((-0.276115968706857)*cj3*pp))+(((-0.00114343074091118)*x2137))+(((-1.0)*sj3*x2143))+(pz*pz)+(((-0.506212609295904)*pp))+(((0.00564933271974229)*sj3))+(((-0.0555062126092959)*cj3)))),((0.0688360561435803)+(((0.175297399907961)*sj3))+(((-1.0)*x2142*x2144))+(((0.0931684307409112)*x2138))+(((-0.00621260929590428)*pp*sj3))+(((-0.0139752646111367)*x2137))+(((-0.0759318913943856)*pp))+(((0.0299240681086056)*cj3))+(((-1.0)*cj3*x2143))+(((-1.0)*x2139*x2144))),IKFAST_ATAN2_MAGTHRESH);\nif(!x2145.valid){\ncontinue;\n}\nCheckValue<IkReal> x2146=IKPowWithIntegerCheck(IKsign(((((-0.185020708697653)*x2139))+(((-0.138057984353428)*pp*pz))+(((0.310561435803037)*pz*sj3))+(((-1.0)*x2140*x2142))+((x2141*x2142))+(((0.099746893695352)*pz))+(((-0.185020708697653)*x2142))+(((-1.0)*x2139*x2140))+((x2139*x2141)))),-1);\nif(!x2146.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x2145.value)+(((1.5707963267949)*(x2146.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x2147=IKsin(j1);\nIkReal x2148=IKcos(j1);\nIkReal x2149=((0.045)*sj3);\nIkReal x2150=((0.3)*cj3);\nIkReal x2151=((0.045)*cj3);\nIkReal x2152=(cj0*px);\nIkReal x2153=(py*sj0);\nIkReal x2154=(sj3*x2148);\nIkReal x2155=(pz*x2147);\nIkReal x2156=(pz*x2148);\nIkReal x2157=((0.09)*x2148);\nIkReal x2158=((1.1)*x2147);\nevalcond[0]=((-0.55)+((x2147*x2152))+((x2147*x2153))+x2156+(((-1.0)*x2149))+(((-1.0)*x2150)));\nevalcond[1]=((0.045)+(((-1.0)*x2151))+((x2148*x2153))+((x2148*x2152))+(((0.3)*sj3))+(((-1.0)*x2155)));\nevalcond[2]=((((-0.310561435803037)*sj3*x2147))+(((-0.099746893695352)*x2147))+pz+(((0.0254095720202485)*x2154))+(((0.138057984353428)*pp*x2147))+(((-0.185020708697653)*x2148))+(((-0.92038656235619)*pp*x2148)));\nevalcond[3]=(((x2147*x2150))+(((-0.3)*x2154))+(((-0.045)*x2148))+((x2148*x2151))+(((0.55)*x2147))+(((-1.0)*x2152))+(((-1.0)*x2153))+((x2147*x2149)));\nevalcond[4]=((-0.2125)+((x2152*x2158))+(((-1.0)*x2152*x2157))+(((-1.0)*x2153*x2157))+(((-1.0)*pp))+(((0.09)*x2155))+(((1.1)*x2156))+((x2153*x2158)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x2159=cj0*cj0;\nIkReal x2160=py*py;\nIkReal x2161=cj3*cj3;\nIkReal x2162=(py*sj0);\nIkReal x2163=((0.3)*sj3);\nIkReal x2164=((0.045)*cj3);\nIkReal x2165=(cj0*px);\nIkReal x2166=(cj3*sj3);\nIkReal x2167=((1.0)*pz);\nCheckValue<IkReal> x2168=IKPowWithIntegerCheck(IKsign(((((-0.55)*pz))+(((-0.3)*cj3*pz))+(((-1.0)*x2163*x2165))+((x2164*x2165))+(((-0.045)*pz*sj3))+(((-0.045)*x2165))+(((-0.045)*x2162))+((x2162*x2164))+(((-1.0)*x2162*x2163)))),-1);\nif(!x2168.valid){\ncontinue;\n}\nCheckValue<IkReal> x2169 = IKatan2WithCheck(IkReal(((-0.03825)+(((0.01125)*cj3))+(((-0.167025)*sj3))+(((0.027)*x2161))+(((-1.0)*x2165*x2167))+(((-0.087975)*x2166))+(((-1.0)*x2162*x2167)))),((-0.304525)+(((2.0)*x2162*x2165))+((x2159*(px*px)))+(((-0.0495)*sj3))+x2160+(((-0.027)*x2166))+(((-0.087975)*x2161))+(((-0.33)*cj3))+(((-1.0)*x2159*x2160))),IKFAST_ATAN2_MAGTHRESH);\nif(!x2169.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x2168.value)))+(x2169.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x2170=IKsin(j1);\nIkReal x2171=IKcos(j1);\nIkReal x2172=((0.045)*sj3);\nIkReal x2173=((0.3)*cj3);\nIkReal x2174=((0.045)*cj3);\nIkReal x2175=(cj0*px);\nIkReal x2176=(py*sj0);\nIkReal x2177=(sj3*x2171);\nIkReal x2178=(pz*x2170);\nIkReal x2179=(pz*x2171);\nIkReal x2180=((0.09)*x2171);\nIkReal x2181=((1.1)*x2170);\nevalcond[0]=((-0.55)+((x2170*x2176))+((x2170*x2175))+x2179+(((-1.0)*x2173))+(((-1.0)*x2172)));\nevalcond[1]=((0.045)+((x2171*x2176))+((x2171*x2175))+(((-1.0)*x2178))+(((0.3)*sj3))+(((-1.0)*x2174)));\nevalcond[2]=((((-0.310561435803037)*sj3*x2170))+(((0.138057984353428)*pp*x2170))+pz+(((-0.099746893695352)*x2170))+(((0.0254095720202485)*x2177))+(((-0.92038656235619)*pp*x2171))+(((-0.185020708697653)*x2171)));\nevalcond[3]=((((0.55)*x2170))+((x2170*x2172))+((x2170*x2173))+(((-0.3)*x2177))+((x2171*x2174))+(((-0.045)*x2171))+(((-1.0)*x2176))+(((-1.0)*x2175)));\nevalcond[4]=((-0.2125)+(((-1.0)*x2175*x2180))+(((-1.0)*pp))+((x2176*x2181))+(((1.1)*x2179))+(((-1.0)*x2176*x2180))+((x2175*x2181))+(((0.09)*x2178)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x2182=cj0*cj0;\nIkReal x2183=py*py;\nIkReal x2184=(pz*sj3);\nIkReal x2185=(py*sj0);\nIkReal x2186=((0.3)*cj3);\nIkReal x2187=((0.045)*sj3);\nIkReal x2188=((0.045)*cj3);\nIkReal x2189=(cj0*px);\nIkReal x2190=((0.3)*sj3);\nCheckValue<IkReal> x2191=IKPowWithIntegerCheck(IKsign(((((2.0)*x2185*x2189))+x2183+((x2182*(px*px)))+(pz*pz)+(((-1.0)*x2182*x2183)))),-1);\nif(!x2191.valid){\ncontinue;\n}\nCheckValue<IkReal> x2192 = IKatan2WithCheck(IkReal(((((0.3)*x2184))+(((0.045)*pz))+((x2186*x2189))+(((-1.0)*pz*x2188))+((x2187*x2189))+(((0.55)*x2185))+(((0.55)*x2189))+((x2185*x2186))+((x2185*x2187)))),(((pz*x2186))+(((-1.0)*x2189*x2190))+(((-1.0)*x2185*x2190))+(((-0.045)*x2189))+(((-0.045)*x2185))+((x2188*x2189))+(((0.045)*x2184))+(((0.55)*pz))+((x2185*x2188))),IKFAST_ATAN2_MAGTHRESH);\nif(!x2192.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x2191.value)))+(x2192.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x2193=IKsin(j1);\nIkReal x2194=IKcos(j1);\nIkReal x2195=((0.045)*sj3);\nIkReal x2196=((0.3)*cj3);\nIkReal x2197=((0.045)*cj3);\nIkReal x2198=(cj0*px);\nIkReal x2199=(py*sj0);\nIkReal x2200=(sj3*x2194);\nIkReal x2201=(pz*x2193);\nIkReal x2202=(pz*x2194);\nIkReal x2203=((0.09)*x2194);\nIkReal x2204=((1.1)*x2193);\nevalcond[0]=((-0.55)+x2202+((x2193*x2198))+((x2193*x2199))+(((-1.0)*x2196))+(((-1.0)*x2195)));\nevalcond[1]=((0.045)+(((-1.0)*x2201))+((x2194*x2198))+((x2194*x2199))+(((-1.0)*x2197))+(((0.3)*sj3)));\nevalcond[2]=((((-0.92038656235619)*pp*x2194))+(((0.0254095720202485)*x2200))+(((-0.310561435803037)*sj3*x2193))+(((-0.185020708697653)*x2194))+(((0.138057984353428)*pp*x2193))+pz+(((-0.099746893695352)*x2193)));\nevalcond[3]=((((-0.3)*x2200))+((x2193*x2195))+((x2193*x2196))+((x2194*x2197))+(((-1.0)*x2198))+(((-1.0)*x2199))+(((-0.045)*x2194))+(((0.55)*x2193)));\nevalcond[4]=((-0.2125)+((x2198*x2204))+(((0.09)*x2201))+(((-1.0)*pp))+(((-1.0)*x2198*x2203))+(((-1.0)*x2199*x2203))+((x2199*x2204))+(((1.1)*x2202)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x2205=cj2*cj2;\nIkReal x2206=((0.045)*px);\nIkReal x2207=(sj0*sj2);\nIkReal x2208=(pz*sj2);\nIkReal x2209=(cj0*cj3);\nIkReal x2210=((0.55)*cj2);\nIkReal x2211=(px*sj0);\nIkReal x2212=(cj0*py);\nIkReal x2213=((0.3)*cj3);\nIkReal x2214=((0.3)*sj3);\nIkReal x2215=((0.045)*sj3);\nIkReal x2216=(sj0*x2205);\nIkReal x2217=(cj0*cj2*sj2);\nIkReal x2218=((0.3)*cj2*py);\nIkReal x2219=((0.045)*x2205);\nIkReal x2220=((0.045)*cj2*py);\nCheckValue<IkReal> x2221=IKPowWithIntegerCheck(IKsign(((((-1.0)*x2208*x2213))+(((-1.0)*x2208*x2215))+(((-1.0)*cj2*sj2*x2206*x2209))+((x2206*x2217))+((px*x2214*x2217))+(((-1.0)*cj3*x2207*x2220))+(((-0.55)*x2208))+((x2207*x2220))+((cj2*py*x2207*x2214)))),-1);\nif(!x2221.valid){\ncontinue;\n}\nCheckValue<IkReal> x2222 = IKatan2WithCheck(IkReal(((((-1.0)*x2210*x2211))+((cj2*x2212*x2215))+((x2210*x2212))+(((-1.0)*py*pz*x2207))+(((-1.0)*cj0*px*x2208))+(((-1.0)*cj2*x2211*x2213))+(((-1.0)*cj2*sj0*sj3*x2206))+((x2209*x2218)))),(((cj3*x2206*x2216))+(((-1.0)*x2205*x2211*x2214))+(((-1.0)*pz*x2208))+((x2205*x2212*x2214))+((x2212*x2219))+(((-1.0)*py*x2209*x2219))+(((-1.0)*x2206*x2216))),IKFAST_ATAN2_MAGTHRESH);\nif(!x2222.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x2221.value)))+(x2222.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x2223=IKsin(j1);\nIkReal x2224=IKcos(j1);\nIkReal x2225=(px*sj2);\nIkReal x2226=((0.3)*sj3);\nIkReal x2227=((0.09)*sj0);\nIkReal x2228=(cj2*px);\nIkReal x2229=((0.045)*cj3);\nIkReal x2230=((0.045)*cj2);\nIkReal x2231=(py*sj0);\nIkReal x2232=((0.045)*sj3);\nIkReal x2233=((1.0)*cj0);\nIkReal x2234=((0.3)*cj3);\nIkReal x2235=(py*sj2);\nIkReal x2236=(cj0*x2224);\nIkReal x2237=(cj3*x2223);\nIkReal x2238=(cj2*x2224);\nIkReal x2239=(cj2*x2223);\nIkReal x2240=(pz*x2224);\nIkReal x2241=(cj0*px*x2223);\nevalcond[0]=((-0.55)+x2240+x2241+(((-1.0)*x2234))+(((-1.0)*x2232))+((x2223*x2231)));\nevalcond[1]=((((-1.0)*cj2*py*x2233))+((sj0*x2228))+((x2225*x2236))+((sj2*x2224*x2231))+(((-1.0)*pz*sj2*x2223)));\nevalcond[2]=((((-0.55)*x2224))+((x2226*x2239))+(((-1.0)*x2224*x2234))+(((-1.0)*x2224*x2232))+(((-1.0)*x2229*x2239))+pz+((x2223*x2230)));\nevalcond[3]=((0.045)+((pz*x2239))+x2226+(((-1.0)*x2231*x2238))+((sj0*x2225))+(((-1.0)*x2224*x2228*x2233))+(((-1.0)*x2229))+(((-1.0)*x2233*x2235)));\nevalcond[4]=(((x2226*x2238))+(((-1.0)*x2229*x2238))+((x2224*x2230))+(((-1.0)*x2231))+(((-1.0)*px*x2233))+((x2223*x2232))+((x2223*x2234))+(((0.55)*x2223)));\nevalcond[5]=((-0.2125)+(((-1.0)*x2225*x2227))+((py*x2227*x2238))+(((-1.0)*pp))+(((0.09)*cj0*x2235))+(((-0.09)*pz*x2239))+(((1.1)*x2240))+(((1.1)*x2241))+(((1.1)*x2223*x2231))+(((0.09)*x2228*x2236)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x2242=cj0*cj0;\nIkReal x2243=py*py;\nIkReal x2244=px*px;\nIkReal x2245=(px*py);\nIkReal x2246=((1.0)*cj2);\nIkReal x2247=(cj0*sj2);\nIkReal x2248=(cj2*sj0);\nIkReal x2249=((0.3)*cj3);\nIkReal x2250=(pz*sj2);\nIkReal x2251=((0.045)*sj3);\nIkReal x2252=(sj2*x2243);\nIkReal x2253=(py*sj0*sj2);\nCheckValue<IkReal> x2254 = IKatan2WithCheck(IkReal(((((0.55)*px*x2247))+((px*x2247*x2251))+((px*x2247*x2249))+((px*pz*x2248))+((x2249*x2253))+(((0.55)*x2253))+((x2251*x2253))+(((-1.0)*cj0*py*pz*x2246)))),(((x2249*x2250))+(((2.0)*cj2*x2242*x2245))+(((0.55)*x2250))+((cj0*x2243*x2248))+((x2250*x2251))+(((-1.0)*x2245*x2246))+(((-1.0)*cj0*sj0*x2244*x2246))),IKFAST_ATAN2_MAGTHRESH);\nif(!x2254.valid){\ncontinue;\n}\nCheckValue<IkReal> x2255=IKPowWithIntegerCheck(IKsign((x2252+((sj2*x2242*x2244))+(((-1.0)*x2242*x2252))+(((2.0)*sj0*x2245*x2247))+((pz*x2250)))),-1);\nif(!x2255.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x2254.value)+(((1.5707963267949)*(x2255.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x2256=IKsin(j1);\nIkReal x2257=IKcos(j1);\nIkReal x2258=(px*sj2);\nIkReal x2259=((0.3)*sj3);\nIkReal x2260=((0.09)*sj0);\nIkReal x2261=(cj2*px);\nIkReal x2262=((0.045)*cj3);\nIkReal x2263=((0.045)*cj2);\nIkReal x2264=(py*sj0);\nIkReal x2265=((0.045)*sj3);\nIkReal x2266=((1.0)*cj0);\nIkReal x2267=((0.3)*cj3);\nIkReal x2268=(py*sj2);\nIkReal x2269=(cj0*x2257);\nIkReal x2270=(cj3*x2256);\nIkReal x2271=(cj2*x2257);\nIkReal x2272=(cj2*x2256);\nIkReal x2273=(pz*x2257);\nIkReal x2274=(cj0*px*x2256);\nevalcond[0]=((-0.55)+((x2256*x2264))+x2274+x2273+(((-1.0)*x2267))+(((-1.0)*x2265)));\nevalcond[1]=((((-1.0)*pz*sj2*x2256))+((x2258*x2269))+((sj0*x2261))+(((-1.0)*cj2*py*x2266))+((sj2*x2257*x2264)));\nevalcond[2]=(((x2256*x2263))+((x2259*x2272))+(((-1.0)*x2257*x2267))+(((-1.0)*x2257*x2265))+pz+(((-0.55)*x2257))+(((-1.0)*x2262*x2272)));\nevalcond[3]=((0.045)+x2259+(((-1.0)*x2257*x2261*x2266))+((pz*x2272))+((sj0*x2258))+(((-1.0)*x2262))+(((-1.0)*x2264*x2271))+(((-1.0)*x2266*x2268)));\nevalcond[4]=(((x2256*x2265))+((x2256*x2267))+((x2257*x2263))+((x2259*x2271))+(((-1.0)*px*x2266))+(((0.55)*x2256))+(((-1.0)*x2262*x2271))+(((-1.0)*x2264)));\nevalcond[5]=((-0.2125)+(((1.1)*x2273))+(((1.1)*x2274))+(((1.1)*x2256*x2264))+(((-0.09)*pz*x2272))+(((0.09)*x2261*x2269))+(((-1.0)*x2258*x2260))+(((-1.0)*pp))+(((0.09)*cj0*x2268))+((py*x2260*x2271)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x2275=cj3*cj3;\nIkReal x2276=(cj2*sj3);\nIkReal x2277=(py*sj0);\nIkReal x2278=((0.3)*cj3);\nIkReal x2279=((0.045)*sj3);\nIkReal x2280=(cj0*px);\nIkReal x2281=(cj2*cj3);\nIkReal x2282=((0.045)*pz);\nIkReal x2283=((1.0)*pz);\nCheckValue<IkReal> x2284=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj2*x2282))+((x2281*x2282))+(((-0.55)*x2277))+(((-1.0)*x2278*x2280))+(((-1.0)*x2279*x2280))+(((-1.0)*x2277*x2279))+(((-1.0)*x2277*x2278))+(((-0.55)*x2280))+(((-0.3)*pz*x2276)))),-1);\nif(!x2284.valid){\ncontinue;\n}\nCheckValue<IkReal> x2285 = IKatan2WithCheck(IkReal(((-0.304525)+(((-0.0495)*sj3))+(((-0.027)*cj3*sj3))+(pz*pz)+(((-0.087975)*x2275))+(((-0.33)*cj3)))),((((-1.0)*x2280*x2283))+(((-1.0)*x2277*x2283))+(((0.01125)*x2281))+(((-0.087975)*cj3*x2276))+(((-0.167025)*x2276))+(((0.027)*cj2*x2275))+(((-0.03825)*cj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x2285.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x2284.value)))+(x2285.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x2286=IKsin(j1);\nIkReal x2287=IKcos(j1);\nIkReal x2288=(px*sj2);\nIkReal x2289=((0.3)*sj3);\nIkReal x2290=((0.09)*sj0);\nIkReal x2291=(cj2*px);\nIkReal x2292=((0.045)*cj3);\nIkReal x2293=((0.045)*cj2);\nIkReal x2294=(py*sj0);\nIkReal x2295=((0.045)*sj3);\nIkReal x2296=((1.0)*cj0);\nIkReal x2297=((0.3)*cj3);\nIkReal x2298=(py*sj2);\nIkReal x2299=(cj0*x2287);\nIkReal x2300=(cj3*x2286);\nIkReal x2301=(cj2*x2287);\nIkReal x2302=(cj2*x2286);\nIkReal x2303=(pz*x2287);\nIkReal x2304=(cj0*px*x2286);\nevalcond[0]=((-0.55)+x2303+x2304+((x2286*x2294))+(((-1.0)*x2297))+(((-1.0)*x2295)));\nevalcond[1]=(((sj0*x2291))+((sj2*x2287*x2294))+(((-1.0)*cj2*py*x2296))+(((-1.0)*pz*sj2*x2286))+((x2288*x2299)));\nevalcond[2]=((((-1.0)*x2292*x2302))+(((-1.0)*x2287*x2295))+(((-1.0)*x2287*x2297))+pz+((x2286*x2293))+(((-0.55)*x2287))+((x2289*x2302)));\nevalcond[3]=((0.045)+x2289+((pz*x2302))+((sj0*x2288))+(((-1.0)*x2296*x2298))+(((-1.0)*x2292))+(((-1.0)*x2294*x2301))+(((-1.0)*x2287*x2291*x2296)));\nevalcond[4]=((((-1.0)*x2292*x2301))+(((-1.0)*x2294))+((x2287*x2293))+(((0.55)*x2286))+((x2286*x2295))+((x2286*x2297))+(((-1.0)*px*x2296))+((x2289*x2301)));\nevalcond[5]=((-0.2125)+(((-0.09)*pz*x2302))+(((1.1)*x2304))+(((1.1)*x2303))+(((0.09)*cj0*x2298))+(((-1.0)*pp))+(((-1.0)*x2288*x2290))+(((0.09)*x2291*x2299))+((py*x2290*x2301))+(((1.1)*x2286*x2294)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\nreturn solutions.GetNumSolutions()>0;\n}\ninline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {\nfor(int rotationiter = 0; rotationiter < 1; ++rotationiter) {\nIkReal x159=((1.0)*cj3);\nIkReal x160=(sj0*sj2);\nIkReal x161=(cj2*sj1);\nIkReal x162=((1.0)*sj3);\nIkReal x163=(cj1*cj2);\nIkReal x164=(sj1*sj2);\nIkReal x165=(cj0*sj2);\nIkReal x166=((1.0)*cj1);\nIkReal x167=(((cj3*x163))+(((-1.0)*sj1*x162)));\nIkReal x168=((((-1.0)*x160*x166))+((cj0*cj2)));\nIkReal x169=(((sj3*x163))+((cj3*sj1)));\nIkReal x170=((((-1.0)*x161*x162))+((cj1*cj3)));\nIkReal x171=(cj0*x167);\nIkReal x172=((((-1.0)*x159*x161))+(((-1.0)*cj1*x162)));\nIkReal x173=((((-1.0)*cj2*sj0))+(((-1.0)*x165*x166)));\nIkReal x174=(((sj0*x167))+((cj3*x165)));\nIkReal x175=(((cj0*x169))+(((-1.0)*x160*x162)));\nIkReal x176=(((sj3*x165))+((sj0*x169)));\nIkReal x177=((((-1.0)*cj3*x160))+x171);\nnew_r00=(((r20*x172))+((r00*(((((-1.0)*x159*x160))+x171))))+((r10*x174)));\nnew_r01=(((r01*x177))+((r21*x172))+((r11*x174)));\nnew_r02=(((r22*x172))+((r12*x174))+((r02*x177)));\nnew_r10=(((r00*x173))+((r20*x164))+((r10*x168)));\nnew_r11=(((r01*x173))+((r21*x164))+((r11*x168)));\nnew_r12=(((r22*x164))+((r12*x168))+((r02*x173)));\nnew_r20=(((r00*x175))+((r20*x170))+((r10*x176)));\nnew_r21=(((r01*x175))+((r21*x170))+((r11*x176)));\nnew_r22=(((r22*x170))+((r12*x176))+((r02*x175)));\n{\nIkReal j5array[2], cj5array[2], sj5array[2];\nbool j5valid[2]={false};\n_nj5 = 2;\ncj5array[0]=new_r22;\nif( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j5valid[0] = j5valid[1] = true;\n    j5array[0] = IKacos(cj5array[0]);\n    sj5array[0] = IKsin(j5array[0]);\n    cj5array[1] = cj5array[0];\n    j5array[1] = -j5array[0];\n    sj5array[1] = -sj5array[0];\n}\nelse if( isnan(cj5array[0]) )\n{\n    // probably any value will work\n    j5valid[0] = true;\n    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;\n}\nfor(int ij5 = 0; ij5 < 2; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 2; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n\n{\nIkReal j4eval[2];\nIkReal x178=((1.0)*cj3);\nIkReal x179=(sj0*sj2);\nIkReal x180=(cj2*sj1);\nIkReal x181=((1.0)*sj3);\nIkReal x182=(cj1*cj2);\nIkReal x183=(sj1*sj2);\nIkReal x184=(cj0*sj2);\nIkReal x185=((1.0)*cj1);\nIkReal x186=x167;\nIkReal x187=x168;\nIkReal x188=x169;\nIkReal x189=x170;\nIkReal x190=(cj0*x186);\nIkReal x191=x172;\nIkReal x192=x173;\nIkReal x193=(((sj0*x186))+((cj3*x184)));\nIkReal x194=(((cj0*x188))+(((-1.0)*x179*x181)));\nIkReal x195=(((sj3*x184))+((sj0*x188)));\nIkReal x196=(x190+(((-1.0)*cj3*x179)));\nnew_r00=(((r20*x191))+((r10*x193))+((r00*((x190+(((-1.0)*x178*x179)))))));\nnew_r01=(((r01*x196))+((r21*x191))+((r11*x193)));\nnew_r02=(((r12*x193))+((r22*x191))+((r02*x196)));\nnew_r10=(((r00*x192))+((r20*x183))+((r10*x187)));\nnew_r11=(((r01*x192))+((r21*x183))+((r11*x187)));\nnew_r12=(((r12*x187))+((r02*x192))+((r22*x183)));\nnew_r20=(((r00*x194))+((r20*x189))+((r10*x195)));\nnew_r21=(((r01*x194))+((r21*x189))+((r11*x195)));\nnew_r22=(((r12*x195))+((r02*x194))+((r22*x189)));\nj4eval[0]=sj5;\nj4eval[1]=IKsign(sj5);\nif( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j4eval[1];\nIkReal x197=((1.0)*cj3);\nIkReal x198=(sj0*sj2);\nIkReal x199=(cj2*sj1);\nIkReal x200=((1.0)*sj3);\nIkReal x201=(cj1*cj2);\nIkReal x202=(sj1*sj2);\nIkReal x203=(cj0*sj2);\nIkReal x204=((1.0)*cj1);\nIkReal x205=x167;\nIkReal x206=x168;\nIkReal x207=x169;\nIkReal x208=x170;\nIkReal x209=(cj0*x205);\nIkReal x210=x172;\nIkReal x211=x173;\nIkReal x212=(((sj0*x205))+((cj3*x203)));\nIkReal x213=((((-1.0)*x198*x200))+((cj0*x207)));\nIkReal x214=(((sj3*x203))+((sj0*x207)));\nIkReal x215=((((-1.0)*cj3*x198))+x209);\nnew_r00=(((r00*(((((-1.0)*x197*x198))+x209))))+((r10*x212))+((r20*x210)));\nnew_r01=(((r21*x210))+((r11*x212))+((r01*x215)));\nnew_r02=(((r12*x212))+((r02*x215))+((r22*x210)));\nnew_r10=(((r10*x206))+((r20*x202))+((r00*x211)));\nnew_r11=(((r11*x206))+((r21*x202))+((r01*x211)));\nnew_r12=(((r22*x202))+((r02*x211))+((r12*x206)));\nnew_r20=(((r20*x208))+((r00*x213))+((r10*x214)));\nnew_r21=(((r11*x214))+((r21*x208))+((r01*x213)));\nnew_r22=(((r22*x208))+((r12*x214))+((r02*x213)));\nj4eval[0]=sj5;\nif( IKabs(j4eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j4array[2], cj4array[2], sj4array[2];\nbool j4valid[2]={false};\n_nj4 = 2;\nCheckValue<IkReal> x217 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x217.valid){\ncontinue;\n}\nIkReal x216=x217.value;\nj4array[0]=((-1.0)*x216);\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nj4array[1]=((3.14159265358979)+(((-1.0)*x216)));\nsj4array[1]=IKsin(j4array[1]);\ncj4array[1]=IKcos(j4array[1]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nif( j4array[1] > IKPI )\n{\n    j4array[1]-=IK2PI;\n}\nelse if( j4array[1] < -IKPI )\n{    j4array[1]+=IK2PI;\n}\nj4valid[1] = true;\nfor(int ij4 = 0; ij4 < 2; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 2; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[1];\nevalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x218=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj4*x218))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x218)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x218))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x218))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((((-1.0)*cj4*x218))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x218))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x219=IKsin(j6);\nIkReal x220=IKcos(j6);\nIkReal x221=((1.0)*sj4);\nIkReal x222=((1.0)*x220);\nIkReal x223=(sj4*x219);\nIkReal x224=(sj4*x220);\nIkReal x225=(cj4*x219);\nIkReal x226=(cj4*x222);\nevalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x219);\nevalcond[1]=(x225+x224+new_r01);\nevalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x222)));\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*x219))+(((-1.0)*new_r00*x221)));\nevalcond[4]=((((-1.0)*new_r01*x221))+((cj4*new_r11))+(((-1.0)*x222)));\nevalcond[5]=(x223+new_r00+(((-1.0)*x226)));\nevalcond[6]=(x223+new_r11+(((-1.0)*x226)));\nevalcond[7]=((((-1.0)*x220*x221))+new_r10+(((-1.0)*x225)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j4array[2], cj4array[2], sj4array[2];\nbool j4valid[2]={false};\n_nj4 = 2;\nCheckValue<IkReal> x228 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x228.valid){\ncontinue;\n}\nIkReal x227=x228.value;\nj4array[0]=((-1.0)*x227);\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nj4array[1]=((3.14159265358979)+(((-1.0)*x227)));\nsj4array[1]=IKsin(j4array[1]);\ncj4array[1]=IKcos(j4array[1]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nif( j4array[1] > IKPI )\n{\n    j4array[1]-=IK2PI;\n}\nelse if( j4array[1] < -IKPI )\n{    j4array[1]+=IK2PI;\n}\nj4valid[1] = true;\nfor(int ij4 = 0; ij4 < 2; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 2; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[1];\nevalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x229=((1.0)*new_r00);\nif( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x229)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*x229))+(((-1.0)*new_r01*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x229))))+IKsqr(((((-1.0)*cj4*x229))+(((-1.0)*new_r01*sj4))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x229))), ((((-1.0)*cj4*x229))+(((-1.0)*new_r01*sj4))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x230=IKcos(j6);\nIkReal x231=IKsin(j6);\nIkReal x232=((1.0)*sj4);\nIkReal x233=((1.0)*x231);\nIkReal x234=(sj4*x230);\nIkReal x235=((1.0)*x230);\nIkReal x236=(cj4*x233);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x230);\nevalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x233)));\nevalcond[2]=(((sj4*x231))+((cj4*x230))+new_r00);\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*x233))+(((-1.0)*new_r00*x232)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x235))+(((-1.0)*new_r01*x232)));\nevalcond[5]=((((-1.0)*x236))+x234+new_r01);\nevalcond[6]=((((-1.0)*x236))+x234+new_r10);\nevalcond[7]=((((-1.0)*cj4*x235))+(((-1.0)*x231*x232))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j4, j6]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j4array[1], cj4array[1], sj4array[1];\nbool j4valid[1]={false};\n_nj4 = 1;\nCheckValue<IkReal> x238=IKPowWithIntegerCheck(sj5,-1);\nif(!x238.valid){\ncontinue;\n}\nIkReal x237=x238.value;\nCheckValue<IkReal> x239=IKPowWithIntegerCheck(new_r12,-1);\nif(!x239.valid){\ncontinue;\n}\nif( IKabs((x237*(x239.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x237)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x237*(x239.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))))+IKsqr((new_r02*x237))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj4array[0]=IKatan2((x237*(x239.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))), (new_r02*x237));\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nfor(int ij4 = 0; ij4 < 1; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 1; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[8];\nIkReal x240=IKcos(j4);\nIkReal x241=IKsin(j4);\nIkReal x242=((1.0)*sj5);\nIkReal x243=((1.0)*cj5);\nIkReal x244=(new_r12*x241);\nIkReal x245=(new_r02*x240);\nevalcond[0]=((((-1.0)*x240*x242))+new_r02);\nevalcond[1]=((((-1.0)*x241*x242))+new_r12);\nevalcond[2]=(((new_r12*x240))+(((-1.0)*new_r02*x241)));\nevalcond[3]=(x245+x244+(((-1.0)*x242)));\nevalcond[4]=(((cj5*x244))+((cj5*x245))+(((-1.0)*new_r22*x242)));\nevalcond[5]=((((-1.0)*new_r10*x241*x242))+(((-1.0)*new_r00*x240*x242))+(((-1.0)*new_r20*x243)));\nevalcond[6]=((((-1.0)*new_r11*x241*x242))+(((-1.0)*new_r01*x240*x242))+(((-1.0)*new_r21*x243)));\nevalcond[7]=((1.0)+(((-1.0)*x242*x244))+(((-1.0)*x242*x245))+(((-1.0)*new_r22*x243)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6eval[2];\nIkReal x246=((1.0)*cj3);\nIkReal x247=(sj0*sj2);\nIkReal x248=(cj2*sj1);\nIkReal x249=((1.0)*sj3);\nIkReal x250=(cj1*cj2);\nIkReal x251=(sj1*sj2);\nIkReal x252=(cj0*sj2);\nIkReal x253=((1.0)*cj1);\nIkReal x254=x167;\nIkReal x255=x168;\nIkReal x256=x169;\nIkReal x257=x170;\nIkReal x258=(cj0*x254);\nIkReal x259=x172;\nIkReal x260=x173;\nIkReal x261=(((cj3*x252))+((sj0*x254)));\nIkReal x262=(((cj0*x256))+(((-1.0)*x247*x249)));\nIkReal x263=(((sj0*x256))+((sj3*x252)));\nIkReal x264=(x258+(((-1.0)*cj3*x247)));\nnew_r00=(((r20*x259))+((r10*x261))+((r00*((x258+(((-1.0)*x246*x247)))))));\nnew_r01=(((r21*x259))+((r11*x261))+((r01*x264)));\nnew_r02=(((r02*x264))+((r12*x261))+((r22*x259)));\nnew_r10=(((r20*x251))+((r10*x255))+((r00*x260)));\nnew_r11=(((r21*x251))+((r11*x255))+((r01*x260)));\nnew_r12=(((r02*x260))+((r12*x255))+((r22*x251)));\nnew_r20=(((r20*x257))+((r00*x262))+((r10*x263)));\nnew_r21=(((r21*x257))+((r11*x263))+((r01*x262)));\nnew_r22=(((r02*x262))+((r12*x263))+((r22*x257)));\nj6eval[0]=sj5;\nj6eval[1]=IKsign(sj5);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[2];\nIkReal x265=((1.0)*cj3);\nIkReal x266=(sj0*sj2);\nIkReal x267=(cj2*sj1);\nIkReal x268=((1.0)*sj3);\nIkReal x269=(cj1*cj2);\nIkReal x270=(sj1*sj2);\nIkReal x271=(cj0*sj2);\nIkReal x272=((1.0)*cj1);\nIkReal x273=x167;\nIkReal x274=x168;\nIkReal x275=x169;\nIkReal x276=x170;\nIkReal x277=(cj0*x273);\nIkReal x278=x172;\nIkReal x279=x173;\nIkReal x280=(((sj0*x273))+((cj3*x271)));\nIkReal x281=((((-1.0)*x266*x268))+((cj0*x275)));\nIkReal x282=(((sj3*x271))+((sj0*x275)));\nIkReal x283=((((-1.0)*cj3*x266))+x277);\nnew_r00=(((r00*((x277+(((-1.0)*x265*x266))))))+((r10*x280))+((r20*x278)));\nnew_r01=(((r01*x283))+((r11*x280))+((r21*x278)));\nnew_r02=(((r22*x278))+((r02*x283))+((r12*x280)));\nnew_r10=(((r00*x279))+((r10*x274))+((r20*x270)));\nnew_r11=(((r21*x270))+((r01*x279))+((r11*x274)));\nnew_r12=(((r02*x279))+((r22*x270))+((r12*x274)));\nnew_r20=(((r00*x281))+((r10*x282))+((r20*x276)));\nnew_r21=(((r01*x281))+((r11*x282))+((r21*x276)));\nnew_r22=(((r22*x276))+((r02*x281))+((r12*x282)));\nj6eval[0]=sj4;\nj6eval[1]=sj5;\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[3];\nIkReal x284=((1.0)*cj3);\nIkReal x285=(sj0*sj2);\nIkReal x286=(cj2*sj1);\nIkReal x287=((1.0)*sj3);\nIkReal x288=(cj1*cj2);\nIkReal x289=(sj1*sj2);\nIkReal x290=(cj0*sj2);\nIkReal x291=((1.0)*cj1);\nIkReal x292=x167;\nIkReal x293=x168;\nIkReal x294=x169;\nIkReal x295=x170;\nIkReal x296=(cj0*x292);\nIkReal x297=x172;\nIkReal x298=x173;\nIkReal x299=(((cj3*x290))+((sj0*x292)));\nIkReal x300=((((-1.0)*x285*x287))+((cj0*x294)));\nIkReal x301=(((sj0*x294))+((sj3*x290)));\nIkReal x302=((((-1.0)*cj3*x285))+x296);\nnew_r00=(((r20*x297))+((r10*x299))+((r00*((x296+(((-1.0)*x284*x285)))))));\nnew_r01=(((r01*x302))+((r21*x297))+((r11*x299)));\nnew_r02=(((r12*x299))+((r02*x302))+((r22*x297)));\nnew_r10=(((r00*x298))+((r10*x293))+((r20*x289)));\nnew_r11=(((r21*x289))+((r01*x298))+((r11*x293)));\nnew_r12=(((r12*x293))+((r22*x289))+((r02*x298)));\nnew_r20=(((r20*x295))+((r10*x301))+((r00*x300)));\nnew_r21=(((r11*x301))+((r01*x300))+((r21*x295)));\nnew_r22=(((r02*x300))+((r22*x295))+((r12*x301)));\nj6eval[0]=cj4;\nj6eval[1]=cj5;\nj6eval[2]=sj5;\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x303=(new_r22+(((-1.0)*cj5)));\nIkReal x304=((((-1.0)*sj5))+new_r12);\nIkReal x305=((1.0)*cj5);\nIkReal x306=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));\nevalcond[1]=x303;\nevalcond[2]=x303;\nevalcond[3]=new_r02;\nevalcond[4]=x304;\nevalcond[5]=x304;\nevalcond[6]=((((-1.0)*new_r22*x306))+((cj5*new_r12)));\nevalcond[7]=((((-1.0)*new_r20*x305))+(((-1.0)*new_r10*x306)));\nevalcond[8]=((((-1.0)*new_r21*x305))+(((-1.0)*new_r11*x306)));\nevalcond[9]=((1.0)+(((-1.0)*new_r22*x305))+(((-1.0)*new_r12*x306)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x307 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x307.valid){\ncontinue;\n}\nCheckValue<IkReal> x308=IKPowWithIntegerCheck(IKsign(new_r12),-1);\nif(!x308.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x307.value)+(((1.5707963267949)*(x308.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x309=IKsin(j6);\nIkReal x310=IKcos(j6);\nIkReal x311=((1.0)*new_r12);\nIkReal x312=((1.0)*x310);\nevalcond[0]=(((new_r12*x310))+new_r20);\nevalcond[1]=(((new_r22*x309))+new_r11);\nevalcond[2]=(new_r21+(((-1.0)*x309*x311)));\nevalcond[3]=((((-1.0)*new_r22*x312))+new_r10);\nevalcond[4]=((((-1.0)*x309))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*x312))+(((-1.0)*new_r01)));\nevalcond[6]=((((-1.0)*new_r21*x311))+x309+((new_r11*new_r22)));\nevalcond[7]=((((-1.0)*new_r20*x311))+(((-1.0)*x312))+((new_r10*new_r22)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x313=(new_r22+(((-1.0)*cj5)));\nIkReal x314=((1.0)*cj5);\nIkReal x315=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));\nevalcond[1]=x313;\nevalcond[2]=x313;\nevalcond[3]=new_r02;\nevalcond[4]=(sj5+new_r12);\nevalcond[5]=((((-1.0)*x315))+(((-1.0)*new_r12)));\nevalcond[6]=((((-1.0)*new_r22*x315))+(((-1.0)*new_r12*x314)));\nevalcond[7]=(((new_r10*sj5))+(((-1.0)*new_r20*x314)));\nevalcond[8]=((((-1.0)*new_r21*x314))+((new_r11*sj5)));\nevalcond[9]=((1.0)+((new_r12*sj5))+(((-1.0)*new_r22*x314)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r00, new_r01);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x316=IKsin(j6);\nIkReal x317=IKcos(j6);\nIkReal x318=((1.0)*new_r22);\nIkReal x319=((1.0)*x317);\nevalcond[0]=(((new_r12*x316))+new_r21);\nevalcond[1]=((((-1.0)*x316))+new_r00);\nevalcond[2]=((((-1.0)*x319))+new_r01);\nevalcond[3]=((((-1.0)*new_r12*x319))+new_r20);\nevalcond[4]=((((-1.0)*new_r11))+((new_r22*x316)));\nevalcond[5]=((((-1.0)*new_r10))+(((-1.0)*x317*x318)));\nevalcond[6]=((((-1.0)*new_r11*x318))+x316+((new_r12*new_r21)));\nevalcond[7]=(((new_r12*new_r20))+(((-1.0)*new_r10*x318))+(((-1.0)*x319)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x320=((1.0)*cj4);\nIkReal x321=((1.0)*sj4);\nIkReal x322=(((cj4*new_r12))+(((-1.0)*new_r02*x321)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*x320))+new_r02);\nevalcond[3]=((((-1.0)*x321))+new_r12);\nevalcond[4]=x322;\nevalcond[5]=x322;\nevalcond[6]=((-1.0)+((new_r12*sj4))+((cj4*new_r02)));\nevalcond[7]=(((cj4*new_r01))+((new_r11*sj4)));\nevalcond[8]=(((cj4*new_r00))+((new_r10*sj4)));\nevalcond[9]=((((-1.0)*new_r00*x320))+(((-1.0)*new_r10*x321)));\nevalcond[10]=((((-1.0)*new_r01*x320))+(((-1.0)*new_r11*x321)));\nevalcond[11]=((1.0)+(((-1.0)*new_r12*x321))+(((-1.0)*new_r02*x320)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x323=IKcos(j6);\nIkReal x324=IKsin(j6);\nIkReal x325=((1.0)*new_r12);\nIkReal x326=((1.0)*x324);\nIkReal x327=((1.0)*x323);\nevalcond[0]=(x323+new_r20);\nevalcond[1]=((((-1.0)*x326))+new_r21);\nevalcond[2]=(((new_r12*x323))+new_r01);\nevalcond[3]=(((new_r12*x324))+new_r00);\nevalcond[4]=((((-1.0)*new_r02*x327))+new_r11);\nevalcond[5]=((((-1.0)*new_r02*x326))+new_r10);\nevalcond[6]=((((-1.0)*x326))+(((-1.0)*new_r00*x325))+((new_r02*new_r10)));\nevalcond[7]=((((-1.0)*x327))+(((-1.0)*new_r01*x325))+((new_r02*new_r11)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x328=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nIkReal x329=(((cj4*new_r00))+((new_r10*sj4)));\nIkReal x330=(((cj4*new_r01))+((new_r11*sj4)));\nIkReal x331=((1.0)+((new_r12*sj4))+((cj4*new_r02)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(cj4+new_r02);\nevalcond[3]=(sj4+new_r12);\nevalcond[4]=x328;\nevalcond[5]=x328;\nevalcond[6]=x331;\nevalcond[7]=x330;\nevalcond[8]=x329;\nevalcond[9]=x329;\nevalcond[10]=x330;\nevalcond[11]=x331;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r21), new_r20);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x332=IKcos(j6);\nIkReal x333=IKsin(j6);\nIkReal x334=((1.0)*new_r02);\nIkReal x335=((1.0)*new_r12);\nIkReal x336=((1.0)*x332);\nevalcond[0]=(x333+new_r21);\nevalcond[1]=((((-1.0)*x336))+new_r20);\nevalcond[2]=(((new_r02*x332))+new_r11);\nevalcond[3]=(((new_r02*x333))+new_r10);\nevalcond[4]=((((-1.0)*x332*x335))+new_r01);\nevalcond[5]=((((-1.0)*x333*x335))+new_r00);\nevalcond[6]=((((-1.0)*new_r10*x334))+((new_r00*new_r12))+(((-1.0)*x333)));\nevalcond[7]=((((-1.0)*new_r11*x334))+((new_r01*new_r12))+(((-1.0)*x336)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x337=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nIkReal x338=(((new_r12*sj4))+((cj4*new_r02)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x337;\nevalcond[7]=x337;\nevalcond[8]=x338;\nevalcond[9]=x338;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x339=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj4*x339))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj4*x339))+((cj4*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x339))+(((-1.0)*new_r00*sj4))))+IKsqr(((((-1.0)*sj4*x339))+((cj4*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((((-1.0)*cj4*x339))+(((-1.0)*new_r00*sj4))), ((((-1.0)*sj4*x339))+((cj4*new_r00))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x340=IKsin(j6);\nIkReal x341=IKcos(j6);\nIkReal x342=((1.0)*sj4);\nIkReal x343=((1.0)*x341);\nIkReal x344=(sj4*x340);\nIkReal x345=(sj4*x341);\nIkReal x346=(cj4*x340);\nIkReal x347=(cj4*x343);\nevalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x340);\nevalcond[1]=(x346+x345+new_r01);\nevalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x343)));\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x342))+(((-1.0)*x340)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x342))+(((-1.0)*x343)));\nevalcond[5]=(x344+new_r00+(((-1.0)*x347)));\nevalcond[6]=(x344+new_r11+(((-1.0)*x347)));\nevalcond[7]=((((-1.0)*x341*x342))+new_r10+(((-1.0)*x346)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x348=(cj4*new_r02);\nIkReal x349=(new_r12*sj4);\nIkReal x350=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x350;\nevalcond[7]=x350;\nevalcond[8]=(x348+x349);\nevalcond[9]=((((-1.0)*x348))+(((-1.0)*x349)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x351=((1.0)*new_r00);\nif( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x351)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x351)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x351))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x351))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x351))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x351))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x352=IKcos(j6);\nIkReal x353=IKsin(j6);\nIkReal x354=((1.0)*sj4);\nIkReal x355=((1.0)*x353);\nIkReal x356=(sj4*x352);\nIkReal x357=((1.0)*x352);\nIkReal x358=(cj4*x355);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x352);\nevalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x355)));\nevalcond[2]=(((sj4*x353))+((cj4*x352))+new_r00);\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*x355))+(((-1.0)*new_r00*x354)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x357))+(((-1.0)*new_r01*x354)));\nevalcond[5]=((((-1.0)*x358))+x356+new_r01);\nevalcond[6]=((((-1.0)*x358))+x356+new_r10);\nevalcond[7]=((((-1.0)*cj4*x357))+(((-1.0)*x353*x354))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x359=(new_r22+(((-1.0)*cj5)));\nIkReal x360=((((-1.0)*sj5))+new_r02);\nIkReal x361=((1.0)*cj5);\nIkReal x362=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));\nevalcond[1]=x359;\nevalcond[2]=x359;\nevalcond[3]=x360;\nevalcond[4]=new_r12;\nevalcond[5]=x360;\nevalcond[6]=(((cj5*new_r02))+(((-1.0)*new_r22*x362)));\nevalcond[7]=((((-1.0)*new_r00*x362))+(((-1.0)*new_r20*x361)));\nevalcond[8]=((((-1.0)*new_r01*x362))+(((-1.0)*new_r21*x361)));\nevalcond[9]=((1.0)+(((-1.0)*new_r22*x361))+(((-1.0)*new_r02*x362)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r10, new_r11);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x363=IKcos(j6);\nIkReal x364=IKsin(j6);\nIkReal x365=((1.0)*new_r02);\nIkReal x366=((1.0)*x363);\nevalcond[0]=(new_r20+((new_r02*x363)));\nevalcond[1]=((((-1.0)*x364))+new_r10);\nevalcond[2]=((((-1.0)*x366))+new_r11);\nevalcond[3]=(((new_r22*x364))+new_r01);\nevalcond[4]=((((-1.0)*x364*x365))+new_r21);\nevalcond[5]=((((-1.0)*new_r22*x366))+new_r00);\nevalcond[6]=(((new_r01*new_r22))+x364+(((-1.0)*new_r21*x365)));\nevalcond[7]=((((-1.0)*new_r20*x365))+((new_r00*new_r22))+(((-1.0)*x366)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x367=(new_r22+(((-1.0)*cj5)));\nIkReal x368=((1.0)*cj5);\nIkReal x369=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));\nevalcond[1]=x367;\nevalcond[2]=x367;\nevalcond[3]=(sj5+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x369))+(((-1.0)*new_r02)));\nevalcond[6]=((((-1.0)*new_r22*x369))+(((-1.0)*new_r02*x368)));\nevalcond[7]=((((-1.0)*new_r20*x368))+((new_r00*sj5)));\nevalcond[8]=(((new_r01*sj5))+(((-1.0)*new_r21*x368)));\nevalcond[9]=((1.0)+((new_r02*sj5))+(((-1.0)*new_r22*x368)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x370 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x370.valid){\ncontinue;\n}\nCheckValue<IkReal> x371=IKPowWithIntegerCheck(IKsign(new_r02),-1);\nif(!x371.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x370.value)+(((1.5707963267949)*(x371.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x372=IKsin(j6);\nIkReal x373=IKcos(j6);\nIkReal x374=((1.0)*new_r01);\nIkReal x375=((1.0)*new_r00);\nIkReal x376=((1.0)*x373);\nevalcond[0]=(new_r21+((new_r02*x372)));\nevalcond[1]=(new_r20+(((-1.0)*new_r02*x376)));\nevalcond[2]=((((-1.0)*x372))+(((-1.0)*new_r10)));\nevalcond[3]=((((-1.0)*x376))+(((-1.0)*new_r11)));\nevalcond[4]=((((-1.0)*x374))+((new_r22*x372)));\nevalcond[5]=((((-1.0)*x375))+(((-1.0)*new_r22*x376)));\nevalcond[6]=((((-1.0)*new_r22*x374))+x372+((new_r02*new_r21)));\nevalcond[7]=((((-1.0)*x376))+(((-1.0)*new_r22*x375))+((new_r02*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j6]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x378=IKPowWithIntegerCheck(sj5,-1);\nif(!x378.valid){\ncontinue;\n}\nIkReal x377=x378.value;\nCheckValue<IkReal> x379=IKPowWithIntegerCheck(cj4,-1);\nif(!x379.valid){\ncontinue;\n}\nCheckValue<IkReal> x380=IKPowWithIntegerCheck(cj5,-1);\nif(!x380.valid){\ncontinue;\n}\nif( IKabs((x377*(x379.value)*(x380.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x377)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x377*(x379.value)*(x380.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x377))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((x377*(x379.value)*(x380.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x377));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x381=IKsin(j6);\nIkReal x382=IKcos(j6);\nIkReal x383=((1.0)*sj5);\nIkReal x384=((1.0)*sj4);\nIkReal x385=(cj5*sj4);\nIkReal x386=(cj4*new_r01);\nIkReal x387=(cj4*new_r00);\nIkReal x388=((1.0)*x382);\nIkReal x389=(cj5*x381);\nIkReal x390=((1.0)*x381);\nevalcond[0]=(((sj5*x382))+new_r20);\nevalcond[1]=((((-1.0)*x381*x383))+new_r21);\nevalcond[2]=(((new_r11*sj4))+x386+x389);\nevalcond[3]=((((-1.0)*x390))+((cj4*new_r10))+(((-1.0)*new_r00*x384)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x384))+(((-1.0)*x388)));\nevalcond[5]=(((sj4*x382))+new_r01+((cj4*x389)));\nevalcond[6]=(((new_r10*sj4))+x387+(((-1.0)*cj5*x388)));\nevalcond[7]=((((-1.0)*cj4*cj5*x388))+((sj4*x381))+new_r00);\nevalcond[8]=((((-1.0)*cj4*x388))+new_r11+((x381*x385)));\nevalcond[9]=((((-1.0)*cj4*x390))+(((-1.0)*cj5*x382*x384))+new_r10);\nevalcond[10]=(x381+((new_r11*x385))+(((-1.0)*new_r21*x383))+((cj5*x386)));\nevalcond[11]=((((-1.0)*new_r20*x383))+((new_r10*x385))+(((-1.0)*x388))+((cj5*x387)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x392=IKPowWithIntegerCheck(sj5,-1);\nif(!x392.valid){\ncontinue;\n}\nIkReal x391=x392.value;\nCheckValue<IkReal> x393=IKPowWithIntegerCheck(sj4,-1);\nif(!x393.valid){\ncontinue;\n}\nif( IKabs((x391*(x393.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x391)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x391*(x393.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x391))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((x391*(x393.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x391));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x394=IKsin(j6);\nIkReal x395=IKcos(j6);\nIkReal x396=((1.0)*sj5);\nIkReal x397=((1.0)*sj4);\nIkReal x398=(cj5*sj4);\nIkReal x399=(cj4*new_r01);\nIkReal x400=(cj4*new_r00);\nIkReal x401=((1.0)*x395);\nIkReal x402=(cj5*x394);\nIkReal x403=((1.0)*x394);\nevalcond[0]=(((sj5*x395))+new_r20);\nevalcond[1]=((((-1.0)*x394*x396))+new_r21);\nevalcond[2]=(((new_r11*sj4))+x399+x402);\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x397))+(((-1.0)*x403)));\nevalcond[4]=((((-1.0)*new_r01*x397))+((cj4*new_r11))+(((-1.0)*x401)));\nevalcond[5]=(((cj4*x402))+new_r01+((sj4*x395)));\nevalcond[6]=(((new_r10*sj4))+x400+(((-1.0)*cj5*x401)));\nevalcond[7]=(new_r00+(((-1.0)*cj4*cj5*x401))+((sj4*x394)));\nevalcond[8]=(((x394*x398))+new_r11+(((-1.0)*cj4*x401)));\nevalcond[9]=(new_r10+(((-1.0)*cj4*x403))+(((-1.0)*cj5*x395*x397)));\nevalcond[10]=(((new_r11*x398))+(((-1.0)*new_r21*x396))+((cj5*x399))+x394);\nevalcond[11]=(((cj5*x400))+(((-1.0)*x401))+(((-1.0)*new_r20*x396))+((new_r10*x398)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x404=IKPowWithIntegerCheck(IKsign(sj5),-1);\nif(!x404.valid){\ncontinue;\n}\nCheckValue<IkReal> x405 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x405.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x404.value)))+(x405.value));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x406=IKsin(j6);\nIkReal x407=IKcos(j6);\nIkReal x408=((1.0)*sj5);\nIkReal x409=((1.0)*sj4);\nIkReal x410=(cj5*sj4);\nIkReal x411=(cj4*new_r01);\nIkReal x412=(cj4*new_r00);\nIkReal x413=((1.0)*x407);\nIkReal x414=(cj5*x406);\nIkReal x415=((1.0)*x406);\nevalcond[0]=(((sj5*x407))+new_r20);\nevalcond[1]=((((-1.0)*x406*x408))+new_r21);\nevalcond[2]=(((new_r11*sj4))+x411+x414);\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x409))+(((-1.0)*x415)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x413))+(((-1.0)*new_r01*x409)));\nevalcond[5]=(((cj4*x414))+new_r01+((sj4*x407)));\nevalcond[6]=(((new_r10*sj4))+x412+(((-1.0)*cj5*x413)));\nevalcond[7]=((((-1.0)*cj4*cj5*x413))+new_r00+((sj4*x406)));\nevalcond[8]=(((x406*x410))+(((-1.0)*cj4*x413))+new_r11);\nevalcond[9]=((((-1.0)*cj5*x407*x409))+(((-1.0)*cj4*x415))+new_r10);\nevalcond[10]=(((cj5*x411))+x406+(((-1.0)*new_r21*x408))+((new_r11*x410)));\nevalcond[11]=((((-1.0)*new_r20*x408))+((cj5*x412))+((new_r10*x410))+(((-1.0)*x413)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j4array[1], cj4array[1], sj4array[1];\nbool j4valid[1]={false};\n_nj4 = 1;\nCheckValue<IkReal> x416=IKPowWithIntegerCheck(IKsign(sj5),-1);\nif(!x416.valid){\ncontinue;\n}\nCheckValue<IkReal> x417 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);\nif(!x417.valid){\ncontinue;\n}\nj4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x416.value)))+(x417.value));\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nfor(int ij4 = 0; ij4 < 1; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 1; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[8];\nIkReal x418=IKcos(j4);\nIkReal x419=IKsin(j4);\nIkReal x420=((1.0)*sj5);\nIkReal x421=((1.0)*cj5);\nIkReal x422=(new_r12*x419);\nIkReal x423=(new_r02*x418);\nevalcond[0]=((((-1.0)*x418*x420))+new_r02);\nevalcond[1]=((((-1.0)*x419*x420))+new_r12);\nevalcond[2]=((((-1.0)*new_r02*x419))+((new_r12*x418)));\nevalcond[3]=((((-1.0)*x420))+x423+x422);\nevalcond[4]=((((-1.0)*new_r22*x420))+((cj5*x422))+((cj5*x423)));\nevalcond[5]=((((-1.0)*new_r10*x419*x420))+(((-1.0)*new_r00*x418*x420))+(((-1.0)*new_r20*x421)));\nevalcond[6]=((((-1.0)*new_r01*x418*x420))+(((-1.0)*new_r11*x419*x420))+(((-1.0)*new_r21*x421)));\nevalcond[7]=((1.0)+(((-1.0)*x420*x422))+(((-1.0)*x420*x423))+(((-1.0)*new_r22*x421)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6eval[2];\nIkReal x424=((1.0)*cj3);\nIkReal x425=(sj0*sj2);\nIkReal x426=(cj2*sj1);\nIkReal x427=((1.0)*sj3);\nIkReal x428=(cj1*cj2);\nIkReal x429=(sj1*sj2);\nIkReal x430=(cj0*sj2);\nIkReal x431=((1.0)*cj1);\nIkReal x432=x167;\nIkReal x433=x168;\nIkReal x434=x169;\nIkReal x435=x170;\nIkReal x436=(cj0*x432);\nIkReal x437=x172;\nIkReal x438=x173;\nIkReal x439=(((sj0*x432))+((cj3*x430)));\nIkReal x440=(((cj0*x434))+(((-1.0)*x425*x427)));\nIkReal x441=(((sj0*x434))+((sj3*x430)));\nIkReal x442=((((-1.0)*cj3*x425))+x436);\nnew_r00=(((r10*x439))+((r00*((x436+(((-1.0)*x424*x425))))))+((r20*x437)));\nnew_r01=(((r21*x437))+((r01*x442))+((r11*x439)));\nnew_r02=(((r12*x439))+((r02*x442))+((r22*x437)));\nnew_r10=(((r20*x429))+((r00*x438))+((r10*x433)));\nnew_r11=(((r21*x429))+((r01*x438))+((r11*x433)));\nnew_r12=(((r12*x433))+((r02*x438))+((r22*x429)));\nnew_r20=(((r00*x440))+((r10*x441))+((r20*x435)));\nnew_r21=(((r21*x435))+((r01*x440))+((r11*x441)));\nnew_r22=(((r02*x440))+((r22*x435))+((r12*x441)));\nj6eval[0]=sj5;\nj6eval[1]=IKsign(sj5);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[2];\nIkReal x443=((1.0)*cj3);\nIkReal x444=(sj0*sj2);\nIkReal x445=(cj2*sj1);\nIkReal x446=((1.0)*sj3);\nIkReal x447=(cj1*cj2);\nIkReal x448=(sj1*sj2);\nIkReal x449=(cj0*sj2);\nIkReal x450=((1.0)*cj1);\nIkReal x451=x167;\nIkReal x452=x168;\nIkReal x453=x169;\nIkReal x454=x170;\nIkReal x455=(cj0*x451);\nIkReal x456=x172;\nIkReal x457=x173;\nIkReal x458=(((sj0*x451))+((cj3*x449)));\nIkReal x459=((((-1.0)*x444*x446))+((cj0*x453)));\nIkReal x460=(((sj0*x453))+((sj3*x449)));\nIkReal x461=((((-1.0)*cj3*x444))+x455);\nnew_r00=(((r20*x456))+((r00*(((((-1.0)*x443*x444))+x455))))+((r10*x458)));\nnew_r01=(((r11*x458))+((r01*x461))+((r21*x456)));\nnew_r02=(((r02*x461))+((r12*x458))+((r22*x456)));\nnew_r10=(((r00*x457))+((r20*x448))+((r10*x452)));\nnew_r11=(((r21*x448))+((r11*x452))+((r01*x457)));\nnew_r12=(((r22*x448))+((r12*x452))+((r02*x457)));\nnew_r20=(((r20*x454))+((r00*x459))+((r10*x460)));\nnew_r21=(((r11*x460))+((r01*x459))+((r21*x454)));\nnew_r22=(((r12*x460))+((r02*x459))+((r22*x454)));\nj6eval[0]=sj4;\nj6eval[1]=sj5;\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[3];\nIkReal x462=((1.0)*cj3);\nIkReal x463=(sj0*sj2);\nIkReal x464=(cj2*sj1);\nIkReal x465=((1.0)*sj3);\nIkReal x466=(cj1*cj2);\nIkReal x467=(sj1*sj2);\nIkReal x468=(cj0*sj2);\nIkReal x469=((1.0)*cj1);\nIkReal x470=x167;\nIkReal x471=x168;\nIkReal x472=x169;\nIkReal x473=x170;\nIkReal x474=(cj0*x470);\nIkReal x475=x172;\nIkReal x476=x173;\nIkReal x477=(((cj3*x468))+((sj0*x470)));\nIkReal x478=((((-1.0)*x463*x465))+((cj0*x472)));\nIkReal x479=(((sj3*x468))+((sj0*x472)));\nIkReal x480=(x474+(((-1.0)*cj3*x463)));\nnew_r00=(((r10*x477))+((r20*x475))+((r00*(((((-1.0)*x462*x463))+x474)))));\nnew_r01=(((r21*x475))+((r11*x477))+((r01*x480)));\nnew_r02=(((r02*x480))+((r12*x477))+((r22*x475)));\nnew_r10=(((r10*x471))+((r20*x467))+((r00*x476)));\nnew_r11=(((r11*x471))+((r21*x467))+((r01*x476)));\nnew_r12=(((r22*x467))+((r02*x476))+((r12*x471)));\nnew_r20=(((r10*x479))+((r20*x473))+((r00*x478)));\nnew_r21=(((r21*x473))+((r11*x479))+((r01*x478)));\nnew_r22=(((r02*x478))+((r12*x479))+((r22*x473)));\nj6eval[0]=cj4;\nj6eval[1]=cj5;\nj6eval[2]=sj5;\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x481=(new_r22+(((-1.0)*cj5)));\nIkReal x482=((((-1.0)*sj5))+new_r12);\nIkReal x483=((1.0)*cj5);\nIkReal x484=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));\nevalcond[1]=x481;\nevalcond[2]=x481;\nevalcond[3]=new_r02;\nevalcond[4]=x482;\nevalcond[5]=x482;\nevalcond[6]=(((cj5*new_r12))+(((-1.0)*new_r22*x484)));\nevalcond[7]=((((-1.0)*new_r10*x484))+(((-1.0)*new_r20*x483)));\nevalcond[8]=((((-1.0)*new_r21*x483))+(((-1.0)*new_r11*x484)));\nevalcond[9]=((1.0)+(((-1.0)*new_r22*x483))+(((-1.0)*new_r12*x484)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x485 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x485.valid){\ncontinue;\n}\nCheckValue<IkReal> x486=IKPowWithIntegerCheck(IKsign(new_r12),-1);\nif(!x486.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x485.value)+(((1.5707963267949)*(x486.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x487=IKsin(j6);\nIkReal x488=IKcos(j6);\nIkReal x489=((1.0)*new_r12);\nIkReal x490=((1.0)*x488);\nevalcond[0]=(((new_r12*x488))+new_r20);\nevalcond[1]=(new_r11+((new_r22*x487)));\nevalcond[2]=((((-1.0)*x487*x489))+new_r21);\nevalcond[3]=((((-1.0)*new_r22*x490))+new_r10);\nevalcond[4]=((((-1.0)*x487))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*x490))+(((-1.0)*new_r01)));\nevalcond[6]=((((-1.0)*new_r21*x489))+x487+((new_r11*new_r22)));\nevalcond[7]=((((-1.0)*x490))+(((-1.0)*new_r20*x489))+((new_r10*new_r22)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x491=(new_r22+(((-1.0)*cj5)));\nIkReal x492=((1.0)*cj5);\nIkReal x493=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));\nevalcond[1]=x491;\nevalcond[2]=x491;\nevalcond[3]=new_r02;\nevalcond[4]=(sj5+new_r12);\nevalcond[5]=((((-1.0)*x493))+(((-1.0)*new_r12)));\nevalcond[6]=((((-1.0)*new_r22*x493))+(((-1.0)*new_r12*x492)));\nevalcond[7]=((((-1.0)*new_r20*x492))+((new_r10*sj5)));\nevalcond[8]=(((new_r11*sj5))+(((-1.0)*new_r21*x492)));\nevalcond[9]=((1.0)+((new_r12*sj5))+(((-1.0)*new_r22*x492)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r00, new_r01);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x494=IKsin(j6);\nIkReal x495=IKcos(j6);\nIkReal x496=((1.0)*new_r22);\nIkReal x497=((1.0)*x495);\nevalcond[0]=(((new_r12*x494))+new_r21);\nevalcond[1]=((((-1.0)*x494))+new_r00);\nevalcond[2]=((((-1.0)*x497))+new_r01);\nevalcond[3]=(new_r20+(((-1.0)*new_r12*x497)));\nevalcond[4]=((((-1.0)*new_r11))+((new_r22*x494)));\nevalcond[5]=((((-1.0)*x495*x496))+(((-1.0)*new_r10)));\nevalcond[6]=((((-1.0)*new_r11*x496))+((new_r12*new_r21))+x494);\nevalcond[7]=((((-1.0)*x497))+(((-1.0)*new_r10*x496))+((new_r12*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x498=((1.0)*cj4);\nIkReal x499=((1.0)*sj4);\nIkReal x500=(((cj4*new_r12))+(((-1.0)*new_r02*x499)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*x498))+new_r02);\nevalcond[3]=((((-1.0)*x499))+new_r12);\nevalcond[4]=x500;\nevalcond[5]=x500;\nevalcond[6]=((-1.0)+((new_r12*sj4))+((cj4*new_r02)));\nevalcond[7]=(((cj4*new_r01))+((new_r11*sj4)));\nevalcond[8]=(((cj4*new_r00))+((new_r10*sj4)));\nevalcond[9]=((((-1.0)*new_r00*x498))+(((-1.0)*new_r10*x499)));\nevalcond[10]=((((-1.0)*new_r01*x498))+(((-1.0)*new_r11*x499)));\nevalcond[11]=((1.0)+(((-1.0)*new_r02*x498))+(((-1.0)*new_r12*x499)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x501=IKcos(j6);\nIkReal x502=IKsin(j6);\nIkReal x503=((1.0)*new_r12);\nIkReal x504=((1.0)*x502);\nIkReal x505=((1.0)*x501);\nevalcond[0]=(x501+new_r20);\nevalcond[1]=((((-1.0)*x504))+new_r21);\nevalcond[2]=(((new_r12*x501))+new_r01);\nevalcond[3]=(((new_r12*x502))+new_r00);\nevalcond[4]=((((-1.0)*new_r02*x505))+new_r11);\nevalcond[5]=((((-1.0)*new_r02*x504))+new_r10);\nevalcond[6]=((((-1.0)*new_r00*x503))+(((-1.0)*x504))+((new_r02*new_r10)));\nevalcond[7]=((((-1.0)*new_r01*x503))+(((-1.0)*x505))+((new_r02*new_r11)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x506=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nIkReal x507=(((cj4*new_r00))+((new_r10*sj4)));\nIkReal x508=(((cj4*new_r01))+((new_r11*sj4)));\nIkReal x509=((1.0)+((new_r12*sj4))+((cj4*new_r02)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(cj4+new_r02);\nevalcond[3]=(sj4+new_r12);\nevalcond[4]=x506;\nevalcond[5]=x506;\nevalcond[6]=x509;\nevalcond[7]=x508;\nevalcond[8]=x507;\nevalcond[9]=x507;\nevalcond[10]=x508;\nevalcond[11]=x509;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r21), new_r20);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x510=IKcos(j6);\nIkReal x511=IKsin(j6);\nIkReal x512=((1.0)*new_r02);\nIkReal x513=((1.0)*new_r12);\nIkReal x514=((1.0)*x510);\nevalcond[0]=(x511+new_r21);\nevalcond[1]=(new_r20+(((-1.0)*x514)));\nevalcond[2]=(((new_r02*x510))+new_r11);\nevalcond[3]=(((new_r02*x511))+new_r10);\nevalcond[4]=(new_r01+(((-1.0)*x510*x513)));\nevalcond[5]=((((-1.0)*x511*x513))+new_r00);\nevalcond[6]=((((-1.0)*new_r10*x512))+(((-1.0)*x511))+((new_r00*new_r12)));\nevalcond[7]=((((-1.0)*new_r11*x512))+((new_r01*new_r12))+(((-1.0)*x514)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x515=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nIkReal x516=(((new_r12*sj4))+((cj4*new_r02)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x515;\nevalcond[7]=x515;\nevalcond[8]=x516;\nevalcond[9]=x516;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x517=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj4*x517))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x517)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x517))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x517))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((((-1.0)*cj4*x517))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x517))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x518=IKsin(j6);\nIkReal x519=IKcos(j6);\nIkReal x520=((1.0)*sj4);\nIkReal x521=((1.0)*x519);\nIkReal x522=(sj4*x518);\nIkReal x523=(sj4*x519);\nIkReal x524=(cj4*x518);\nIkReal x525=(cj4*x521);\nevalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x518);\nevalcond[1]=(x523+x524+new_r01);\nevalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x521)));\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*x518))+(((-1.0)*new_r00*x520)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x521))+(((-1.0)*new_r01*x520)));\nevalcond[5]=((((-1.0)*x525))+x522+new_r00);\nevalcond[6]=((((-1.0)*x525))+x522+new_r11);\nevalcond[7]=((((-1.0)*x524))+new_r10+(((-1.0)*x519*x520)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x526=(cj4*new_r02);\nIkReal x527=(new_r12*sj4);\nIkReal x528=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x528;\nevalcond[7]=x528;\nevalcond[8]=(x526+x527);\nevalcond[9]=((((-1.0)*x527))+(((-1.0)*x526)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x529=((1.0)*new_r00);\nif( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x529)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x529)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x529))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x529))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x529))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x529))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x530=IKcos(j6);\nIkReal x531=IKsin(j6);\nIkReal x532=((1.0)*sj4);\nIkReal x533=((1.0)*x531);\nIkReal x534=(sj4*x530);\nIkReal x535=((1.0)*x530);\nIkReal x536=(cj4*x533);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x530);\nevalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x533)));\nevalcond[2]=(((cj4*x530))+new_r00+((sj4*x531)));\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x532))+(((-1.0)*x533)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x535))+(((-1.0)*new_r01*x532)));\nevalcond[5]=((((-1.0)*x536))+x534+new_r01);\nevalcond[6]=((((-1.0)*x536))+x534+new_r10);\nevalcond[7]=((((-1.0)*x531*x532))+new_r11+(((-1.0)*cj4*x535)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x537=(new_r22+(((-1.0)*cj5)));\nIkReal x538=((((-1.0)*sj5))+new_r02);\nIkReal x539=((1.0)*cj5);\nIkReal x540=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));\nevalcond[1]=x537;\nevalcond[2]=x537;\nevalcond[3]=x538;\nevalcond[4]=new_r12;\nevalcond[5]=x538;\nevalcond[6]=((((-1.0)*new_r22*x540))+((cj5*new_r02)));\nevalcond[7]=((((-1.0)*new_r00*x540))+(((-1.0)*new_r20*x539)));\nevalcond[8]=((((-1.0)*new_r21*x539))+(((-1.0)*new_r01*x540)));\nevalcond[9]=((1.0)+(((-1.0)*new_r22*x539))+(((-1.0)*new_r02*x540)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r10, new_r11);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x541=IKcos(j6);\nIkReal x542=IKsin(j6);\nIkReal x543=((1.0)*new_r02);\nIkReal x544=((1.0)*x541);\nevalcond[0]=(((new_r02*x541))+new_r20);\nevalcond[1]=((((-1.0)*x542))+new_r10);\nevalcond[2]=((((-1.0)*x544))+new_r11);\nevalcond[3]=(((new_r22*x542))+new_r01);\nevalcond[4]=((((-1.0)*x542*x543))+new_r21);\nevalcond[5]=((((-1.0)*new_r22*x544))+new_r00);\nevalcond[6]=(((new_r01*new_r22))+(((-1.0)*new_r21*x543))+x542);\nevalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x543))+(((-1.0)*x544)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x545=(new_r22+(((-1.0)*cj5)));\nIkReal x546=((1.0)*cj5);\nIkReal x547=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));\nevalcond[1]=x545;\nevalcond[2]=x545;\nevalcond[3]=(sj5+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x547))+(((-1.0)*new_r02)));\nevalcond[6]=((((-1.0)*new_r22*x547))+(((-1.0)*new_r02*x546)));\nevalcond[7]=((((-1.0)*new_r20*x546))+((new_r00*sj5)));\nevalcond[8]=(((new_r01*sj5))+(((-1.0)*new_r21*x546)));\nevalcond[9]=((1.0)+((new_r02*sj5))+(((-1.0)*new_r22*x546)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x548 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x548.valid){\ncontinue;\n}\nCheckValue<IkReal> x549=IKPowWithIntegerCheck(IKsign(new_r02),-1);\nif(!x549.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x548.value)+(((1.5707963267949)*(x549.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x550=IKsin(j6);\nIkReal x551=IKcos(j6);\nIkReal x552=((1.0)*new_r01);\nIkReal x553=((1.0)*new_r00);\nIkReal x554=((1.0)*x551);\nevalcond[0]=(((new_r02*x550))+new_r21);\nevalcond[1]=(new_r20+(((-1.0)*new_r02*x554)));\nevalcond[2]=((((-1.0)*x550))+(((-1.0)*new_r10)));\nevalcond[3]=((((-1.0)*x554))+(((-1.0)*new_r11)));\nevalcond[4]=((((-1.0)*x552))+((new_r22*x550)));\nevalcond[5]=((((-1.0)*new_r22*x554))+(((-1.0)*x553)));\nevalcond[6]=((((-1.0)*new_r22*x552))+x550+((new_r02*new_r21)));\nevalcond[7]=((((-1.0)*new_r22*x553))+(((-1.0)*x554))+((new_r02*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j6]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x556=IKPowWithIntegerCheck(sj5,-1);\nif(!x556.valid){\ncontinue;\n}\nIkReal x555=x556.value;\nCheckValue<IkReal> x557=IKPowWithIntegerCheck(cj4,-1);\nif(!x557.valid){\ncontinue;\n}\nCheckValue<IkReal> x558=IKPowWithIntegerCheck(cj5,-1);\nif(!x558.valid){\ncontinue;\n}\nif( IKabs((x555*(x557.value)*(x558.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x555)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x555*(x557.value)*(x558.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x555))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((x555*(x557.value)*(x558.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x555));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x559=IKsin(j6);\nIkReal x560=IKcos(j6);\nIkReal x561=((1.0)*sj5);\nIkReal x562=((1.0)*sj4);\nIkReal x563=(cj5*sj4);\nIkReal x564=(cj4*new_r01);\nIkReal x565=(cj4*new_r00);\nIkReal x566=((1.0)*x560);\nIkReal x567=(cj5*x559);\nIkReal x568=((1.0)*x559);\nevalcond[0]=(new_r20+((sj5*x560)));\nevalcond[1]=((((-1.0)*x559*x561))+new_r21);\nevalcond[2]=(((new_r11*sj4))+x567+x564);\nevalcond[3]=((((-1.0)*new_r00*x562))+((cj4*new_r10))+(((-1.0)*x568)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x566))+(((-1.0)*new_r01*x562)));\nevalcond[5]=(((sj4*x560))+new_r01+((cj4*x567)));\nevalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x566))+x565);\nevalcond[7]=(((sj4*x559))+(((-1.0)*cj4*cj5*x566))+new_r00);\nevalcond[8]=((((-1.0)*cj4*x566))+new_r11+((x559*x563)));\nevalcond[9]=((((-1.0)*cj5*x560*x562))+(((-1.0)*cj4*x568))+new_r10);\nevalcond[10]=(x559+((new_r11*x563))+((cj5*x564))+(((-1.0)*new_r21*x561)));\nevalcond[11]=((((-1.0)*new_r20*x561))+((new_r10*x563))+((cj5*x565))+(((-1.0)*x566)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x570=IKPowWithIntegerCheck(sj5,-1);\nif(!x570.valid){\ncontinue;\n}\nIkReal x569=x570.value;\nCheckValue<IkReal> x571=IKPowWithIntegerCheck(sj4,-1);\nif(!x571.valid){\ncontinue;\n}\nif( IKabs((x569*(x571.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x569)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x569*(x571.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x569))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((x569*(x571.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x569));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x572=IKsin(j6);\nIkReal x573=IKcos(j6);\nIkReal x574=((1.0)*sj5);\nIkReal x575=((1.0)*sj4);\nIkReal x576=(cj5*sj4);\nIkReal x577=(cj4*new_r01);\nIkReal x578=(cj4*new_r00);\nIkReal x579=((1.0)*x573);\nIkReal x580=(cj5*x572);\nIkReal x581=((1.0)*x572);\nevalcond[0]=(((sj5*x573))+new_r20);\nevalcond[1]=(new_r21+(((-1.0)*x572*x574)));\nevalcond[2]=(((new_r11*sj4))+x577+x580);\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x575))+(((-1.0)*x581)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x579))+(((-1.0)*new_r01*x575)));\nevalcond[5]=(((sj4*x573))+((cj4*x580))+new_r01);\nevalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x579))+x578);\nevalcond[7]=(((sj4*x572))+(((-1.0)*cj4*cj5*x579))+new_r00);\nevalcond[8]=((((-1.0)*cj4*x579))+new_r11+((x572*x576)));\nevalcond[9]=((((-1.0)*cj5*x573*x575))+(((-1.0)*cj4*x581))+new_r10);\nevalcond[10]=(((cj5*x577))+((new_r11*x576))+x572+(((-1.0)*new_r21*x574)));\nevalcond[11]=(((cj5*x578))+((new_r10*x576))+(((-1.0)*x579))+(((-1.0)*new_r20*x574)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x582=IKPowWithIntegerCheck(IKsign(sj5),-1);\nif(!x582.valid){\ncontinue;\n}\nCheckValue<IkReal> x583 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x583.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x582.value)))+(x583.value));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x584=IKsin(j6);\nIkReal x585=IKcos(j6);\nIkReal x586=((1.0)*sj5);\nIkReal x587=((1.0)*sj4);\nIkReal x588=(cj5*sj4);\nIkReal x589=(cj4*new_r01);\nIkReal x590=(cj4*new_r00);\nIkReal x591=((1.0)*x585);\nIkReal x592=(cj5*x584);\nIkReal x593=((1.0)*x584);\nevalcond[0]=(((sj5*x585))+new_r20);\nevalcond[1]=((((-1.0)*x584*x586))+new_r21);\nevalcond[2]=(((new_r11*sj4))+x589+x592);\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*x593))+(((-1.0)*new_r00*x587)));\nevalcond[4]=((((-1.0)*new_r01*x587))+((cj4*new_r11))+(((-1.0)*x591)));\nevalcond[5]=(((sj4*x585))+new_r01+((cj4*x592)));\nevalcond[6]=((((-1.0)*cj5*x591))+((new_r10*sj4))+x590);\nevalcond[7]=((((-1.0)*cj4*cj5*x591))+((sj4*x584))+new_r00);\nevalcond[8]=(((x584*x588))+(((-1.0)*cj4*x591))+new_r11);\nevalcond[9]=((((-1.0)*cj4*x593))+(((-1.0)*cj5*x585*x587))+new_r10);\nevalcond[10]=((((-1.0)*new_r21*x586))+((cj5*x589))+x584+((new_r11*x588)));\nevalcond[11]=((((-1.0)*new_r20*x586))+(((-1.0)*x591))+((cj5*x590))+((new_r10*x588)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\n}static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {\n    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];\n    if( det < 0 ) {\n        numroots=0;\n    }\n    else if( det == 0 ) {\n        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];\n        numroots = 1;\n    }\n    else {\n        det = IKsqrt(det);\n        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);\n        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);\n        numroots = 2;\n    }\n}\n};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"e9a051e4825529aa31892beb41684ca4\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\nchar* ComputeFkWrapper(const IkReal* j) {\n    IkReal eetrans[3] = {0};\n    IkReal eerot[9] = {0};\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n\nstd::vector<IkReal> TrueComputeIk(int argc, char** argv)\n{\n    std::vector<IkReal> solvalues(GetNumJoints());\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return solvalues;\n}\n"]}