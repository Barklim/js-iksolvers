{"version":3,"file":"./solvers/man1_leftarm.html","sources":["./solvers/man1_leftarm.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AApMA;AAAA;AAAA;;;;;;;;AAFA;AAAA;AAAA;;;;;AA0MA;;;;;;;;;;;;;;;AAqzRA;AACA;AACA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-05-22 07:12:06.403968\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53;\nx0=IKcos(j[1]);\nx1=IKcos(j[2]);\nx2=IKsin(j[4]);\nx3=IKcos(j[4]);\nx4=IKsin(j[2]);\nx5=IKsin(j[3]);\nx6=IKcos(j[3]);\nx7=IKsin(j[1]);\nx8=IKcos(j[6]);\nx9=IKsin(j[5]);\nx10=IKsin(j[6]);\nx11=IKcos(j[5]);\nx12=IKcos(j[0]);\nx13=IKsin(j[0]);\nx14=((1.0)*x1);\nx15=((1.0)*x5);\nx16=((1.0)*x4);\nx17=((0.2617)*x1);\nx18=((0.2617)*x13);\nx19=((0.3102)*x0);\nx20=(x6*x7);\nx21=((-1.0)*x2);\nx22=((-1.0)*x0);\nx23=(x1*x3);\nx24=((-1.0)*x3);\nx25=(x0*x6);\nx26=(x12*x4);\nx27=(x0*x5);\nx28=(x13*x7);\nx29=(x12*x7);\nx30=(x0*x14*x2);\nx31=(x14*x29);\nx32=((1.0)*x13*x25);\nx33=((((-1.0)*x15*x7))+((x25*x4)));\nx34=(((x27*x4))+x20);\nx35=((((-1.0)*x31))+((x13*x4)));\nx36=(((x1*x28))+x26);\nx37=((((-1.0)*x13*x16))+x31);\nx38=((((-1.0)*x12*x14))+((x16*x28)));\nx39=(x11*x34);\nx40=((((-1.0)*x13*x14))+(((-1.0)*x16*x29)));\nx41=(x3*x35);\nx42=(x3*x33);\nx43=(x38*x5);\nx44=(x40*x6);\nx45=(x21*x37);\nx46=(((x38*x6))+((x13*x27)));\nx47=(x44+(((-1.0)*x0*x12*x15)));\nx48=(((x40*x5))+((x12*x25)));\nx49=(((x12*x22*x5))+x44);\nx50=(x11*x48);\nx51=(x3*x47);\nx52=(((x21*(((((-1.0)*x12*x16))+(((-1.0)*x14*x28))))))+((x24*x46)));\nx53=(x52*x9);\neerot[0]=(((x8*((((x0*x23))+((x2*x33))))))+((x10*((((x9*((x30+((x24*x33))))))+x39)))));\neerot[1]=(((x8*((((x9*(((((-1.0)*x42))+x30))))+x39))))+((x10*((((x22*x23))+((x21*x33)))))));\neerot[2]=(((x34*x9))+((x11*(((((-1.0)*x30))+x42)))));\neetrans[0]=((0.1744)+(((-0.2617)*x20))+(((-0.3102)*x7))+(((-0.2617)*x27*x4)));\neerot[3]=(((x8*((((x2*x47))+x41))))+((x10*((((x9*((x45+((x24*x47))))))+x50)))));\neerot[4]=(((x8*((((x9*((x45+((x24*x49))))))+x50))))+((x10*((((x21*x49))+((x24*x35)))))));\neerot[5]=(((x48*x9))+((x11*((((x2*x37))+x51)))));\neetrans[1]=((((-0.2617)*x12*x25))+(((-1.0)*x12*x19))+((x5*(((((0.2617)*x26*x7))+((x13*x17)))))));\neerot[6]=(((x8*((((x21*x46))+((x24*x36))))))+(((-1.0)*x10*(((((1.0)*x11*(((((-1.0)*x32))+x43))))+(((1.0)*x53)))))));\neerot[7]=(((x10*((((x3*x36))+((x2*x46))))))+((x8*(((((-1.0)*x11*((((x13*x22*x6))+x43))))+(((-1.0)*x53)))))));\neerot[8]=(((x9*((x32+(((-1.0)*x15*x38))))))+((x11*x52)));\neetrans[2]=((((-1.0)*x13*x19))+((x5*((((x18*x4*x7))+(((-1.0)*x12*x17))))))+(((-1.0)*x18*x25)));\n}\n\nIKFAST_API int GetNumFreeParameters() { return 1; }\nIKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }\nIKFAST_API int GetNumJoints() { return 7; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j10,cj10,sj10,htj10,j10mul,j11,cj11,sj11,htj11,j11mul,j13,cj13,sj13,htj13,j13mul,j14,cj14,sj14,htj14,j14mul,j15,cj15,sj15,htj15,j15mul,j16,cj16,sj16,htj16,j16mul,j12,cj12,sj12,htj12,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij10[2], _nj10,_ij11[2], _nj11,_ij13[2], _nj13,_ij14[2], _nj14,_ij15[2], _nj15,_ij16[2], _nj16,_ij12[2], _nj12;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj10=numeric_limits<IkReal>::quiet_NaN(); _ij10[0] = -1; _ij10[1] = -1; _nj10 = -1; j11=numeric_limits<IkReal>::quiet_NaN(); _ij11[0] = -1; _ij11[1] = -1; _nj11 = -1; j13=numeric_limits<IkReal>::quiet_NaN(); _ij13[0] = -1; _ij13[1] = -1; _nj13 = -1; j14=numeric_limits<IkReal>::quiet_NaN(); _ij14[0] = -1; _ij14[1] = -1; _nj14 = -1; j15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1; j16=numeric_limits<IkReal>::quiet_NaN(); _ij16[0] = -1; _ij16[1] = -1; _nj16 = -1;  _ij12[0] = -1; _ij12[1] = -1; _nj12 = 0; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nj12=pfree[0]; cj12=cos(pfree[0]); sj12=sin(pfree[0]), htj12=tan(pfree[0]*0.5);\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=((-1.0)*r20);\nnew_r01=((-1.0)*r21);\nnew_r02=((-1.0)*r22);\nnew_px=((-1.0)*pz);\nnew_r10=r10;\nnew_r11=r11;\nnew_r12=r12;\nnew_py=py;\nnew_r20=r00;\nnew_r21=r01;\nnew_r22=r02;\nnew_pz=((-0.1744)+px);\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x54=((1.0)*px);\nIkReal x55=((1.0)*pz);\nIkReal x56=((1.0)*py);\npp=((px*px)+(py*py)+(pz*pz));\nnpx=(((px*r00))+((py*r10))+((pz*r20)));\nnpy=(((px*r01))+((py*r11))+((pz*r21)));\nnpz=(((px*r02))+((py*r12))+((pz*r22)));\nrxp0_0=((((-1.0)*r20*x56))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x55)));\nrxp0_2=((((-1.0)*r10*x54))+((py*r00)));\nrxp1_0=((((-1.0)*r21*x56))+((pz*r11)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x55)));\nrxp1_2=((((-1.0)*r11*x54))+((py*r01)));\nrxp2_0=(((pz*r12))+(((-1.0)*r22*x56)));\nrxp2_1=(((px*r22))+(((-1.0)*r02*x55)));\nrxp2_2=((((-1.0)*r12*x54))+((py*r02)));\n{\nIkReal j13array[2], cj13array[2], sj13array[2];\nbool j13valid[2]={false};\n_nj13 = 2;\ncj13array[0]=((-1.01448798425806)+(((6.1592025754336)*pp)));\nif( cj13array[0] >= -1-IKFAST_SINCOS_THRESH && cj13array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j13valid[0] = j13valid[1] = true;\n    j13array[0] = IKacos(cj13array[0]);\n    sj13array[0] = IKsin(j13array[0]);\n    cj13array[1] = cj13array[0];\n    j13array[1] = -j13array[0];\n    sj13array[1] = -sj13array[0];\n}\nelse if( isnan(cj13array[0]) )\n{\n    // probably any value will work\n    j13valid[0] = true;\n    cj13array[0] = 1; sj13array[0] = 0; j13array[0] = 0;\n}\nfor(int ij13 = 0; ij13 < 2; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 2; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n\n{\nIkReal j10eval[2];\nj10eval[0]=((px*px)+(py*py));\nj10eval[1]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j11eval[2];\nj11eval[0]=((1.40499940937601)+(((sj12*sj12)*(sj13*sj13)))+(cj13*cj13)+(((2.3706534199465)*cj13)));\nj11eval[1]=((IKabs((sj12*sj13)))+(((3.82116927779901)*(IKabs(((-0.3102)+(((-0.2617)*cj13))))))));\nif( IKabs(j11eval[0]) < 0.0000010000000000  || IKabs(j11eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[2];\nIkReal x57=px*px;\nIkReal x58=py*py;\nIkReal x59=cj12*cj12;\nIkReal x60=py*py*py*py;\nIkReal x61=sj12*sj12;\nIkReal x62=sj12*sj12*sj12*sj12;\nIkReal x63=cj12*cj12*cj12*cj12;\nIkReal x64=(px*py);\nIkReal x65=(x57*x58);\nIkReal x66=((2.0)*x59*x61);\nj10eval[0]=(((x60*x66))+((x60*x62))+((x60*x63))+((x62*x65))+((x63*x65))+((x65*x66)));\nj10eval[1]=((IKabs((((x58*x59))+((x58*x61)))))+(IKabs((((x59*x64))+((x61*x64))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j10, j11]\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nIkReal x67=py*py;\nIkReal x68=cj12*cj12;\nIkReal x69=sj12*sj12;\nIkReal x70=(px*py);\nIkReal x71=(((x69*x70))+((x68*x70)));\nIkReal x72=(((x67*x68))+((x67*x69)));\nCheckValue<IkReal> x75 = IKatan2WithCheck(IkReal(x71),x72,IKFAST_ATAN2_MAGTHRESH);\nif(!x75.valid){\ncontinue;\n}\nIkReal x73=((1.0)*(x75.value));\nif((((x71*x71)+(x72*x72))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x76=IKPowWithIntegerCheck(IKabs(IKsqrt(((x71*x71)+(x72*x72)))),-1);\nif(!x76.valid){\ncontinue;\n}\nif( (((0.2617)*cj12*py*sj13*(x76.value))) < -1-IKFAST_SINCOS_THRESH || (((0.2617)*cj12*py*sj13*(x76.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x74=IKasin(((0.2617)*cj12*py*sj13*(x76.value)));\nj10array[0]=((((-1.0)*x73))+x74);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x73))+(((-1.0)*x74)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[2];\nIkReal x77=sj12*sj12;\nIkReal x78=cj12*cj12;\nIkReal x79=px*px;\nIkReal x80=IKsin(j10);\nIkReal x81=IKcos(j10);\nIkReal x82=((1.0)*px);\nIkReal x83=((1.0)*x79);\nIkReal x84=((0.2617)*cj12*sj13);\nevalcond[0]=(((x80*(((((-1.0)*py*x78*x82))+(((-1.0)*py*x77*x82))))))+((px*x84))+((x81*(((((-1.0)*x77*x83))+(((-1.0)*x78*x83)))))));\nevalcond[1]=((((-1.0)*x81*x82))+(((-1.0)*py*x80))+x84);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j11eval[3];\nIkReal x85=(px*sj10);\nIkReal x86=(sj12*sj13);\nIkReal x87=(cj10*py);\nIkReal x88=((10000.0)*pz);\nIkReal x89=((2617.0)*cj13);\nj11eval[0]=((((-1.0)*pz*x86))+(((-1.0)*cj13*x85))+(((-1.18532670997325)*x85))+((cj13*x87))+(((1.18532670997325)*x87)));\nj11eval[1]=((IKabs((((x85*x88))+(((-1.0)*x87*x88))+(((684.8689)*cj13*x86))+(((811.7934)*x86)))))+(IKabs(((-962.2404)+((pz*x88))+(((-1623.5868)*cj13))+(((-684.8689)*(cj13*cj13)))))));\nj11eval[2]=IKsign(((((3102.0)*x87))+(((-3102.0)*x85))+(((-2617.0)*pz*x86))+(((-1.0)*x85*x89))+((x87*x89))));\nif( IKabs(j11eval[0]) < 0.0000010000000000  || IKabs(j11eval[1]) < 0.0000010000000000  || IKabs(j11eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j11eval[3];\nIkReal x90=(px*sj10);\nIkReal x91=(cj10*py);\nIkReal x92=((15510000.0)*pz);\nIkReal x93=(sj12*sj13);\nIkReal x94=((4058967.0)*cj13);\nIkReal x95=((6542500.0)*pp);\nj11eval[0]=((((1.18532670997325)*x91))+(((-1.0)*pz*x93))+(((-1.0)*cj13*x90))+(((-1.18532670997325)*x90))+((cj13*x91)));\nj11eval[1]=((IKabs(((-215101.59825)+(((-7755000.0)*pp))+((pz*x92))+(((-181470.303875)*cj13))+(((-1.0)*cj13*x95)))))+(IKabs(((((181470.303875)*x93))+(((-1.0)*x91*x92))+((x90*x92))+((x93*x95))))));\nj11eval[2]=IKsign(((((-1.0)*x90*x94))+(((-4811202.0)*x90))+(((-4058967.0)*pz*x93))+(((4811202.0)*x91))+((x91*x94))));\nif( IKabs(j11eval[0]) < 0.0000010000000000  || IKabs(j11eval[1]) < 0.0000010000000000  || IKabs(j11eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j11eval[3];\nIkReal x96=cj12*cj12;\nIkReal x97=cj13*cj13;\nIkReal x98=(sj12*sj13);\nIkReal x99=(cj10*py);\nIkReal x100=((26170000.0)*pz);\nIkReal x101=((26170000.0)*px*sj10);\nIkReal x102=(x96*x97);\nj11eval[0]=((-2.40499940937601)+(((-2.3706534199465)*cj13))+x96+(((-1.0)*x102)));\nj11eval[1]=((IKabs(((((31020000.0)*x99))+((x100*x98))+(((-31020000.0)*px*sj10))+(((-1.0)*cj13*x101))+(((26170000.0)*cj13*x99)))))+(IKabs(((((31020000.0)*pz))+((x101*x98))+((cj13*x100))+(((-26170000.0)*x98*x99))))));\nj11eval[2]=IKsign(((-16471093.0)+(((-16235868.0)*cj13))+(((6848689.0)*x96))+(((-6848689.0)*x102))));\nif( IKabs(j11eval[0]) < 0.0000010000000000  || IKabs(j11eval[1]) < 0.0000010000000000  || IKabs(j11eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j11]\n\n} else\n{\n{\nIkReal j11array[1], cj11array[1], sj11array[1];\nbool j11valid[1]={false};\n_nj11 = 1;\nIkReal x103=cj12*cj12;\nIkReal x104=(px*sj10);\nIkReal x105=(cj10*py);\nIkReal x106=((26170000.0)*cj13);\nIkReal x107=((26170000.0)*sj12*sj13);\nIkReal x108=((6848689.0)*x103);\nCheckValue<IkReal> x109 = IKatan2WithCheck(IkReal(((((31020000.0)*pz))+((pz*x106))+((x104*x107))+(((-1.0)*x105*x107)))),((((-1.0)*x104*x106))+(((31020000.0)*x105))+((pz*x107))+((x105*x106))+(((-31020000.0)*x104))),IKFAST_ATAN2_MAGTHRESH);\nif(!x109.valid){\ncontinue;\n}\nCheckValue<IkReal> x110=IKPowWithIntegerCheck(IKsign(((-16471093.0)+(((-16235868.0)*cj13))+x108+(((-1.0)*x108*(cj13*cj13))))),-1);\nif(!x110.valid){\ncontinue;\n}\nj11array[0]=((-1.5707963267949)+(x109.value)+(((1.5707963267949)*(x110.value))));\nsj11array[0]=IKsin(j11array[0]);\ncj11array[0]=IKcos(j11array[0]);\nif( j11array[0] > IKPI )\n{\n    j11array[0]-=IK2PI;\n}\nelse if( j11array[0] < -IKPI )\n{    j11array[0]+=IK2PI;\n}\nj11valid[0] = true;\nfor(int ij11 = 0; ij11 < 1; ++ij11)\n{\nif( !j11valid[ij11] )\n{\n    continue;\n}\n_ij11[0] = ij11; _ij11[1] = -1;\nfor(int iij11 = ij11+1; iij11 < 1; ++iij11)\n{\nif( j11valid[iij11] && IKabs(cj11array[ij11]-cj11array[iij11]) < IKFAST_SOLUTION_THRESH && IKabs(sj11array[ij11]-sj11array[iij11]) < IKFAST_SOLUTION_THRESH )\n{\n    j11valid[iij11]=false; _ij11[1] = iij11; break; \n}\n}\nj11 = j11array[ij11]; cj11 = cj11array[ij11]; sj11 = sj11array[ij11];\n{\nIkReal evalcond[6];\nIkReal x111=IKsin(j11);\nIkReal x112=IKcos(j11);\nIkReal x113=(sj12*sj13);\nIkReal x114=((0.2617)*cj13);\nIkReal x115=(cj10*py);\nIkReal x116=(px*sj10);\nIkReal x117=((1.0)*cj12);\nIkReal x118=(cj10*px);\nIkReal x119=((1.0)*pz);\nIkReal x120=((1.0)*sj12);\nIkReal x121=(py*sj10);\nIkReal x122=((0.2617)*x111);\nIkReal x123=((0.6204)*x112);\nIkReal x124=(pz*x112);\nevalcond[0]=((((-1.0)*x111*x114))+(((-0.2617)*x112*x113))+(((-0.3102)*x111))+(((-1.0)*x119)));\nevalcond[1]=((-0.3102)+(((-1.0)*x111*x119))+((x112*x116))+(((-1.0)*x114))+(((-1.0)*x112*x115)));\nevalcond[2]=((-0.02773715)+(((-1.0)*x115*x123))+(((-0.6204)*pz*x111))+(((-1.0)*pp))+((x116*x123)));\nevalcond[3]=((((-1.0)*x113*x122))+((x112*x114))+x115+(((0.3102)*x112))+(((-1.0)*x116)));\nevalcond[4]=((((-1.0)*x118*x120))+(((-1.0)*x120*x121))+((cj12*x111*x115))+(((-1.0)*x111*x116*x117))+(((-1.0)*x117*x124)));\nevalcond[5]=((((-1.0)*x111*x115*x120))+(((-1.0)*x117*x118))+(((0.2617)*sj13))+(((-1.0)*x117*x121))+((sj12*x124))+((sj12*x111*x116)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j11array[1], cj11array[1], sj11array[1];\nbool j11valid[1]={false};\n_nj11 = 1;\nIkReal x603=(sj12*sj13);\nIkReal x604=((6542500.0)*pp);\nIkReal x605=(cj10*py);\nIkReal x606=((15510000.0)*pz);\nIkReal x607=(px*sj10);\nIkReal x608=((4058967.0)*cj13);\nCheckValue<IkReal> x609=IKPowWithIntegerCheck(IKsign((((x605*x608))+(((-4058967.0)*pz*x603))+(((-4811202.0)*x607))+(((4811202.0)*x605))+(((-1.0)*x607*x608)))),-1);\nif(!x609.valid){\ncontinue;\n}\nCheckValue<IkReal> x610 = IKatan2WithCheck(IkReal(((((181470.303875)*x603))+(((-1.0)*x605*x606))+((x606*x607))+((x603*x604)))),((-215101.59825)+(((-7755000.0)*pp))+(((-1.0)*cj13*x604))+(((-181470.303875)*cj13))+((pz*x606))),IKFAST_ATAN2_MAGTHRESH);\nif(!x610.valid){\ncontinue;\n}\nj11array[0]=((-1.5707963267949)+(((1.5707963267949)*(x609.value)))+(x610.value));\nsj11array[0]=IKsin(j11array[0]);\ncj11array[0]=IKcos(j11array[0]);\nif( j11array[0] > IKPI )\n{\n    j11array[0]-=IK2PI;\n}\nelse if( j11array[0] < -IKPI )\n{    j11array[0]+=IK2PI;\n}\nj11valid[0] = true;\nfor(int ij11 = 0; ij11 < 1; ++ij11)\n{\nif( !j11valid[ij11] )\n{\n    continue;\n}\n_ij11[0] = ij11; _ij11[1] = -1;\nfor(int iij11 = ij11+1; iij11 < 1; ++iij11)\n{\nif( j11valid[iij11] && IKabs(cj11array[ij11]-cj11array[iij11]) < IKFAST_SOLUTION_THRESH && IKabs(sj11array[ij11]-sj11array[iij11]) < IKFAST_SOLUTION_THRESH )\n{\n    j11valid[iij11]=false; _ij11[1] = iij11; break; \n}\n}\nj11 = j11array[ij11]; cj11 = cj11array[ij11]; sj11 = sj11array[ij11];\n{\nIkReal evalcond[6];\nIkReal x611=IKsin(j11);\nIkReal x612=IKcos(j11);\nIkReal x613=(sj12*sj13);\nIkReal x614=((0.2617)*cj13);\nIkReal x615=(cj10*py);\nIkReal x616=(px*sj10);\nIkReal x617=((1.0)*cj12);\nIkReal x618=(cj10*px);\nIkReal x619=((1.0)*pz);\nIkReal x620=((1.0)*sj12);\nIkReal x621=(py*sj10);\nIkReal x622=((0.2617)*x611);\nIkReal x623=((0.6204)*x612);\nIkReal x624=(pz*x612);\nevalcond[0]=((((-0.3102)*x611))+(((-1.0)*x611*x614))+(((-1.0)*x619))+(((-0.2617)*x612*x613)));\nevalcond[1]=((-0.3102)+(((-1.0)*x612*x615))+(((-1.0)*x611*x619))+((x612*x616))+(((-1.0)*x614)));\nevalcond[2]=((-0.02773715)+(((-0.6204)*pz*x611))+((x616*x623))+(((-1.0)*pp))+(((-1.0)*x615*x623)));\nevalcond[3]=(((x612*x614))+(((-1.0)*x616))+(((0.3102)*x612))+x615+(((-1.0)*x613*x622)));\nevalcond[4]=((((-1.0)*x611*x616*x617))+((cj12*x611*x615))+(((-1.0)*x620*x621))+(((-1.0)*x617*x624))+(((-1.0)*x618*x620)));\nevalcond[5]=((((-1.0)*x611*x615*x620))+((sj12*x611*x616))+(((0.2617)*sj13))+(((-1.0)*x617*x621))+(((-1.0)*x617*x618))+((sj12*x624)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j11array[1], cj11array[1], sj11array[1];\nbool j11valid[1]={false};\n_nj11 = 1;\nIkReal x625=(sj12*sj13);\nIkReal x626=((10000.0)*pz);\nIkReal x627=(px*sj10);\nIkReal x628=(cj10*py);\nIkReal x629=((2617.0)*cj13);\nCheckValue<IkReal> x630=IKPowWithIntegerCheck(IKsign((((x628*x629))+(((-1.0)*x627*x629))+(((3102.0)*x628))+(((-3102.0)*x627))+(((-2617.0)*pz*x625)))),-1);\nif(!x630.valid){\ncontinue;\n}\nCheckValue<IkReal> x631 = IKatan2WithCheck(IkReal(((((811.7934)*x625))+(((684.8689)*cj13*x625))+(((-1.0)*x626*x628))+((x626*x627)))),((-962.2404)+((pz*x626))+(((-1623.5868)*cj13))+(((-684.8689)*(cj13*cj13)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x631.valid){\ncontinue;\n}\nj11array[0]=((-1.5707963267949)+(((1.5707963267949)*(x630.value)))+(x631.value));\nsj11array[0]=IKsin(j11array[0]);\ncj11array[0]=IKcos(j11array[0]);\nif( j11array[0] > IKPI )\n{\n    j11array[0]-=IK2PI;\n}\nelse if( j11array[0] < -IKPI )\n{    j11array[0]+=IK2PI;\n}\nj11valid[0] = true;\nfor(int ij11 = 0; ij11 < 1; ++ij11)\n{\nif( !j11valid[ij11] )\n{\n    continue;\n}\n_ij11[0] = ij11; _ij11[1] = -1;\nfor(int iij11 = ij11+1; iij11 < 1; ++iij11)\n{\nif( j11valid[iij11] && IKabs(cj11array[ij11]-cj11array[iij11]) < IKFAST_SOLUTION_THRESH && IKabs(sj11array[ij11]-sj11array[iij11]) < IKFAST_SOLUTION_THRESH )\n{\n    j11valid[iij11]=false; _ij11[1] = iij11; break; \n}\n}\nj11 = j11array[ij11]; cj11 = cj11array[ij11]; sj11 = sj11array[ij11];\n{\nIkReal evalcond[6];\nIkReal x632=IKsin(j11);\nIkReal x633=IKcos(j11);\nIkReal x634=(sj12*sj13);\nIkReal x635=((0.2617)*cj13);\nIkReal x636=(cj10*py);\nIkReal x637=(px*sj10);\nIkReal x638=((1.0)*cj12);\nIkReal x639=(cj10*px);\nIkReal x640=((1.0)*pz);\nIkReal x641=((1.0)*sj12);\nIkReal x642=(py*sj10);\nIkReal x643=((0.2617)*x632);\nIkReal x644=((0.6204)*x633);\nIkReal x645=(pz*x633);\nevalcond[0]=((((-0.2617)*x633*x634))+(((-1.0)*x640))+(((-0.3102)*x632))+(((-1.0)*x632*x635)));\nevalcond[1]=((-0.3102)+(((-1.0)*x635))+(((-1.0)*x633*x636))+(((-1.0)*x632*x640))+((x633*x637)));\nevalcond[2]=((-0.02773715)+((x637*x644))+(((-0.6204)*pz*x632))+(((-1.0)*pp))+(((-1.0)*x636*x644)));\nevalcond[3]=((((0.3102)*x633))+x636+(((-1.0)*x637))+(((-1.0)*x634*x643))+((x633*x635)));\nevalcond[4]=(((cj12*x632*x636))+(((-1.0)*x641*x642))+(((-1.0)*x639*x641))+(((-1.0)*x632*x637*x638))+(((-1.0)*x638*x645)));\nevalcond[5]=(((sj12*x645))+(((0.2617)*sj13))+(((-1.0)*x638*x639))+((sj12*x632*x637))+(((-1.0)*x632*x636*x641))+(((-1.0)*x638*x642)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j11array[2], cj11array[2], sj11array[2];\nbool j11valid[2]={false};\n_nj11 = 2;\nIkReal x646=((-0.3102)+(((-0.2617)*cj13)));\nCheckValue<IkReal> x649 = IKatan2WithCheck(IkReal(((-0.2617)*sj12*sj13)),x646,IKFAST_ATAN2_MAGTHRESH);\nif(!x649.valid){\ncontinue;\n}\nIkReal x647=((1.0)*(x649.value));\nif((((x646*x646)+(((0.06848689)*(sj12*sj12)*(sj13*sj13))))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x650=IKPowWithIntegerCheck(IKabs(IKsqrt(((x646*x646)+(((0.06848689)*(sj12*sj12)*(sj13*sj13)))))),-1);\nif(!x650.valid){\ncontinue;\n}\nif( ((pz*(x650.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x650.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x648=IKasin((pz*(x650.value)));\nj11array[0]=((((-1.0)*x647))+x648);\nsj11array[0]=IKsin(j11array[0]);\ncj11array[0]=IKcos(j11array[0]);\nj11array[1]=((3.14159265358979)+(((-1.0)*x648))+(((-1.0)*x647)));\nsj11array[1]=IKsin(j11array[1]);\ncj11array[1]=IKcos(j11array[1]);\nif( j11array[0] > IKPI )\n{\n    j11array[0]-=IK2PI;\n}\nelse if( j11array[0] < -IKPI )\n{    j11array[0]+=IK2PI;\n}\nj11valid[0] = true;\nif( j11array[1] > IKPI )\n{\n    j11array[1]-=IK2PI;\n}\nelse if( j11array[1] < -IKPI )\n{    j11array[1]+=IK2PI;\n}\nj11valid[1] = true;\nfor(int ij11 = 0; ij11 < 2; ++ij11)\n{\nif( !j11valid[ij11] )\n{\n    continue;\n}\n_ij11[0] = ij11; _ij11[1] = -1;\nfor(int iij11 = ij11+1; iij11 < 2; ++iij11)\n{\nif( j11valid[iij11] && IKabs(cj11array[ij11]-cj11array[iij11]) < IKFAST_SOLUTION_THRESH && IKabs(sj11array[ij11]-sj11array[iij11]) < IKFAST_SOLUTION_THRESH )\n{\n    j11valid[iij11]=false; _ij11[1] = iij11; break; \n}\n}\nj11 = j11array[ij11]; cj11 = cj11array[ij11]; sj11 = sj11array[ij11];\n\n{\nIkReal j10eval[3];\nIkReal x651=pz*pz;\nIkReal x652=(cj11*pp);\nIkReal x653=((2617.0)*cj13);\nIkReal x654=((10000.0)*pz*sj11);\nIkReal x655=(cj11*x651);\nIkReal x656=((2617.0)*cj11*cj12*sj13);\nj10eval[0]=((((-1.0)*x655))+x652);\nj10eval[1]=((IKabs(((((3102.0)*px))+((py*x656))+((px*x654))+((px*x653)))))+(IKabs((((px*x656))+(((-3102.0)*py))+(((-1.0)*py*x653))+(((-1.0)*py*x654))))));\nj10eval[2]=IKsign(((((-10000.0)*x655))+(((10000.0)*x652))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[3];\nIkReal x657=pz*pz;\nIkReal x658=((25000000.0)*pp);\nIkReal x659=(cj11*pp);\nIkReal x660=((15510000.0)*pz*sj11);\nIkReal x661=(cj11*x657);\nIkReal x662=((4058967.0)*cj11*cj12*sj13);\nj10eval[0]=((((-1.0)*x661))+x659);\nj10eval[1]=((IKabs((((px*x660))+(((693428.75)*px))+((py*x662))+((px*x658)))))+(IKabs((((px*x662))+(((-693428.75)*py))+(((-1.0)*py*x660))+(((-1.0)*py*x658))))));\nj10eval[2]=IKsign(((((15510000.0)*x659))+(((-15510000.0)*x661))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[3];\nIkReal x663=pz*pz;\nIkReal x664=(cj11*py);\nIkReal x665=((2617.0)*cj13);\nIkReal x666=((2617.0)*sj13);\nIkReal x667=(sj11*sj12);\nIkReal x668=(cj11*px);\nj10eval[0]=((((-1.0)*x663))+pp);\nj10eval[1]=IKsign(((((-10000.0)*x663))+(((10000.0)*pp))));\nj10eval[2]=((IKabs((((cj12*py*x666))+(((-1.0)*px*x666*x667))+((x665*x668))+(((3102.0)*x668)))))+(IKabs(((((-3102.0)*x664))+((cj12*px*x666))+((py*x666*x667))+(((-1.0)*x664*x665))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x669=((1.0)*pp);\nIkReal x670=((-0.3102)+(((-0.2617)*cj13))+(((-1.0)*pz)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j11)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((-1.0)*x669))+(((0.16235868)*cj13)));\nevalcond[2]=x670;\nevalcond[3]=((-0.02773715)+(((-1.0)*x669))+(((-0.6204)*pz)));\nevalcond[4]=x670;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[3];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x671=pz*pz;\nIkReal x672=(sj12*sj13);\nIkReal x673=(cj12*sj13);\nj10eval[0]=(pp+(((-1.0)*x671)));\nj10eval[1]=((IKabs((((py*x673))+(((-1.0)*px*x672)))))+(IKabs((((py*x672))+((px*x673))))));\nj10eval[2]=IKsign(((((-10000.0)*x671))+(((10000.0)*pp))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[3];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x674=pz*pz;\nIkReal x675=cj12*cj12;\nIkReal x676=(py*sj13);\nIkReal x677=(cj12*sj12);\nIkReal x678=(px*sj13);\nIkReal x679=(cj12*pp);\nIkReal x680=(cj12*x674);\nj10eval[0]=(x679+(((-1.0)*x680)));\nj10eval[1]=IKsign(((((10000.0)*x679))+(((-10000.0)*x680))));\nj10eval[2]=((IKabs((((x676*x677))+((x675*x678)))))+(IKabs(((((-1.0)*x677*x678))+((x675*x676))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[3];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x681=cj12*cj12;\nIkReal x682=pz*pz;\nIkReal x683=(py*sj13);\nIkReal x684=(cj12*sj12);\nIkReal x685=(pp*sj12);\nIkReal x686=(px*sj13);\nIkReal x687=(sj12*x682);\nj10eval[0]=(x685+(((-1.0)*x687)));\nj10eval[1]=((IKabs((((x683*x684))+((x681*x686))+(((-1.0)*x686)))))+(IKabs(((((-1.0)*x681*x683))+x683+((x684*x686))))));\nj10eval[2]=IKsign(((((10000.0)*x685))+(((-10000.0)*x687))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x688=((1.0)*pp);\nIkReal x689=x670;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j12))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((-1.0)*x688))+(((0.16235868)*cj13)));\nevalcond[2]=x689;\nevalcond[3]=((-0.02773715)+(((-1.0)*x688))+(((-0.6204)*pz)));\nevalcond[4]=x689;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[4];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj12=0;\ncj12=1.0;\nj12=0;\nIkReal x690=pz*pz;\nj10eval[0]=(pp+(((-1.0)*x690)));\nj10eval[1]=IKsign(((((-10000.0)*x690))+(((10000.0)*pp))));\nj10eval[2]=6848689.0;\nj10eval[3]=sj13;\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  || IKabs(j10eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x691=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x691)));\nevalcond[2]=((-0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x691))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj12=0;\ncj12=1.0;\nj12=0;\nsj13=0;\ncj13=1.0;\nj13=0;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x693 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x693.valid){\ncontinue;\n}\nIkReal x692=x693.value;\nj10array[0]=((-1.0)*x692);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x692)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x694=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x694)));\nevalcond[2]=((-0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x694))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj12=0;\ncj12=1.0;\nj12=0;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x696 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x696.valid){\ncontinue;\n}\nIkReal x695=x696.value;\nj10array[0]=((-1.0)*x695);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x695)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j10]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nIkReal x697=((2617.0)*sj13);\nCheckValue<IkReal> x698 = IKatan2WithCheck(IkReal((py*x697)),(px*x697),IKFAST_ATAN2_MAGTHRESH);\nif(!x698.valid){\ncontinue;\n}\nCheckValue<IkReal> x699=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x699.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(x698.value)+(((1.5707963267949)*(x699.value))));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[2];\nIkReal x700=IKsin(j10);\nIkReal x701=IKcos(j10);\nIkReal x702=((1.0)*x700);\nevalcond[0]=((((-1.0)*px*x702))+((py*x701)));\nevalcond[1]=((((-1.0)*py*x702))+(((-1.0)*px*x701))+(((0.2617)*sj13)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x703=((1.0)*pp);\nIkReal x704=x670;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j12)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((-1.0)*x703))+(((0.16235868)*cj13)));\nevalcond[2]=x704;\nevalcond[3]=((-0.02773715)+(((-1.0)*x703))+(((-0.6204)*pz)));\nevalcond[4]=x704;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[4];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj12=0;\ncj12=-1.0;\nj12=3.14159265358979;\nIkReal x705=pz*pz;\nj10eval[0]=((((-1.0)*pp))+x705);\nj10eval[1]=6848689.0;\nj10eval[2]=sj13;\nj10eval[3]=IKsign(((((-10000.0)*pp))+(((10000.0)*x705))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  || IKabs(j10eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x706=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x706)));\nevalcond[2]=((-0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x706))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj12=0;\ncj12=-1.0;\nj12=3.14159265358979;\nsj13=0;\ncj13=1.0;\nj13=0;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x708 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x708.valid){\ncontinue;\n}\nIkReal x707=x708.value;\nj10array[0]=((-1.0)*x707);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x707)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x709=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x709)));\nevalcond[2]=((-0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x709))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj12=0;\ncj12=-1.0;\nj12=3.14159265358979;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x711 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x711.valid){\ncontinue;\n}\nIkReal x710=x711.value;\nj10array[0]=((-1.0)*x710);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x710)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j10]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nIkReal x712=((2617.0)*sj13);\nCheckValue<IkReal> x713 = IKatan2WithCheck(IkReal((py*x712)),(px*x712),IKFAST_ATAN2_MAGTHRESH);\nif(!x713.valid){\ncontinue;\n}\nCheckValue<IkReal> x714=IKPowWithIntegerCheck(IKsign(((((10000.0)*(pz*pz)))+(((-10000.0)*pp)))),-1);\nif(!x714.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(x713.value)+(((1.5707963267949)*(x714.value))));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[2];\nIkReal x715=IKsin(j10);\nIkReal x716=IKcos(j10);\nIkReal x717=((1.0)*x715);\nevalcond[0]=((((-1.0)*px*x717))+((py*x716)));\nevalcond[1]=((((-1.0)*px*x716))+(((-0.2617)*sj13))+(((-1.0)*py*x717)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x718=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x718)));\nevalcond[2]=((-0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x718))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj13=0;\ncj13=1.0;\nj13=0;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj13=0;\ncj13=1.0;\nj13=0;\nIkReal x719=((1.0)*px);\nj10eval[0]=((IKabs(((((-1.0)*cj12*x719))+(((-1.0)*py*sj12)))))+(IKabs(((((-1.0)*sj12*x719))+((cj12*py))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj13=0;\ncj13=1.0;\nj13=0;\nIkReal x720=((1.0)*cj12);\nj10eval[0]=((IKabs((((px*sj12))+(((-1.0)*py*x720)))))+(IKabs(((((-1.0)*px*x720))+(((-1.0)*py*sj12))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j10]\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nIkReal x721=((1.0)*py);\nCheckValue<IkReal> x723 = IKatan2WithCheck(IkReal(((((-1.0)*sj12*x721))+(((-1.0)*cj12*px)))),(((px*sj12))+(((-1.0)*cj12*x721))),IKFAST_ATAN2_MAGTHRESH);\nif(!x723.valid){\ncontinue;\n}\nIkReal x722=x723.value;\nj10array[0]=((-1.0)*x722);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x722)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[3];\nIkReal x724=IKsin(j10);\nIkReal x725=IKcos(j10);\nIkReal x726=(py*x725);\nIkReal x727=((1.0)*x724);\nIkReal x728=((1.0)*px*x725);\nevalcond[0]=((((-1.0)*px*x727))+x726);\nevalcond[1]=((((-1.0)*x728))+(((-1.0)*py*x727)));\nevalcond[2]=((((-1.0)*sj12*x728))+(((-1.0)*py*sj12*x727))+(((-1.0)*cj12*px*x727))+((cj12*x726)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nIkReal x729=((1.0)*sj12);\nCheckValue<IkReal> x731 = IKatan2WithCheck(IkReal((((cj12*py))+(((-1.0)*px*x729)))),((((-1.0)*py*x729))+(((-1.0)*cj12*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x731.valid){\ncontinue;\n}\nIkReal x730=x731.value;\nj10array[0]=((-1.0)*x730);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x730)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[3];\nIkReal x732=IKsin(j10);\nIkReal x733=IKcos(j10);\nIkReal x734=(py*x733);\nIkReal x735=((1.0)*x732);\nIkReal x736=((1.0)*px*x733);\nevalcond[0]=((((-1.0)*px*x735))+x734);\nevalcond[1]=((((-1.0)*x736))+(((-1.0)*py*x735)));\nevalcond[2]=((((-1.0)*cj12*py*x735))+((px*sj12*x732))+(((-1.0)*cj12*x736))+(((-1.0)*sj12*x734)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x738 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x738.valid){\ncontinue;\n}\nIkReal x737=x738.value;\nj10array[0]=((-1.0)*x737);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x737)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[3];\nIkReal x739=IKcos(j10);\nIkReal x740=IKsin(j10);\nIkReal x741=((1.0)*px);\nIkReal x742=((1.0)*py);\nIkReal x743=(cj12*x739);\nIkReal x744=(sj12*x742);\nIkReal x745=(cj12*x740);\nevalcond[0]=((((-1.0)*x740*x742))+(((-1.0)*x739*x741)));\nevalcond[1]=(((py*x743))+(((-1.0)*sj12*x739*x741))+(((-1.0)*x740*x744))+(((-1.0)*x741*x745)));\nevalcond[2]=((((-1.0)*x742*x745))+((px*sj12*x740))+(((-1.0)*x741*x743))+(((-1.0)*x739*x744)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x746=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x746)));\nevalcond[2]=((-0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x746))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nIkReal x747=((1.0)*px);\nj10eval[0]=((IKabs(((((-1.0)*cj12*x747))+(((-1.0)*py*sj12)))))+(IKabs((((cj12*py))+(((-1.0)*sj12*x747))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nIkReal x748=((1.0)*cj12);\nj10eval[0]=((IKabs(((((-1.0)*px*x748))+(((-1.0)*py*sj12)))))+(IKabs((((px*sj12))+(((-1.0)*py*x748))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j10]\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nIkReal x749=((1.0)*py);\nCheckValue<IkReal> x751 = IKatan2WithCheck(IkReal(((((-1.0)*cj12*px))+(((-1.0)*sj12*x749)))),((((-1.0)*cj12*x749))+((px*sj12))),IKFAST_ATAN2_MAGTHRESH);\nif(!x751.valid){\ncontinue;\n}\nIkReal x750=x751.value;\nj10array[0]=((-1.0)*x750);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x750)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[3];\nIkReal x752=IKsin(j10);\nIkReal x753=IKcos(j10);\nIkReal x754=(py*x753);\nIkReal x755=((1.0)*x752);\nIkReal x756=((1.0)*px*x753);\nevalcond[0]=((((-1.0)*px*x755))+x754);\nevalcond[1]=((((-1.0)*py*x755))+(((-1.0)*x756)));\nevalcond[2]=((((-1.0)*cj12*px*x755))+((cj12*x754))+(((-1.0)*py*sj12*x755))+(((-1.0)*sj12*x756)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nIkReal x757=((1.0)*sj12);\nCheckValue<IkReal> x759 = IKatan2WithCheck(IkReal((((cj12*py))+(((-1.0)*px*x757)))),((((-1.0)*py*x757))+(((-1.0)*cj12*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x759.valid){\ncontinue;\n}\nIkReal x758=x759.value;\nj10array[0]=((-1.0)*x758);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x758)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[3];\nIkReal x760=IKsin(j10);\nIkReal x761=IKcos(j10);\nIkReal x762=(py*x761);\nIkReal x763=((1.0)*x760);\nIkReal x764=((1.0)*px*x761);\nevalcond[0]=((((-1.0)*px*x763))+x762);\nevalcond[1]=((((-1.0)*py*x763))+(((-1.0)*x764)));\nevalcond[2]=((((-1.0)*cj12*x764))+(((-1.0)*sj12*x762))+(((-1.0)*cj12*py*x763))+((px*sj12*x760)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x766 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x766.valid){\ncontinue;\n}\nIkReal x765=x766.value;\nj10array[0]=((-1.0)*x765);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x765)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[3];\nIkReal x767=IKcos(j10);\nIkReal x768=IKsin(j10);\nIkReal x769=((1.0)*px);\nIkReal x770=((1.0)*py);\nIkReal x771=(cj12*x767);\nIkReal x772=(sj12*x770);\nIkReal x773=(cj12*x768);\nevalcond[0]=((((-1.0)*x768*x770))+(((-1.0)*x767*x769)));\nevalcond[1]=((((-1.0)*x768*x772))+(((-1.0)*sj12*x767*x769))+(((-1.0)*x769*x773))+((py*x771)));\nevalcond[2]=(((px*sj12*x768))+(((-1.0)*x767*x772))+(((-1.0)*x769*x771))+(((-1.0)*x770*x773)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x774=((1.0)*pp);\nIkReal x775=x670;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j12)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((0.16235868)*cj13))+(((-1.0)*x774)));\nevalcond[2]=x775;\nevalcond[3]=((-0.02773715)+(((-1.0)*x774))+(((-0.6204)*pz)));\nevalcond[4]=x775;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[4];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj12=1.0;\ncj12=0;\nj12=1.5707963267949;\nIkReal x776=pz*pz;\nj10eval[0]=((((-1.0)*pp))+x776);\nj10eval[1]=IKsign(((((-10000.0)*pp))+(((10000.0)*x776))));\nj10eval[2]=6848689.0;\nj10eval[3]=sj13;\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  || IKabs(j10eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x777=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x777)));\nevalcond[2]=((-0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x777))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj12=1.0;\ncj12=0;\nj12=1.5707963267949;\nsj13=0;\ncj13=1.0;\nj13=0;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x779 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x779.valid){\ncontinue;\n}\nIkReal x778=x779.value;\nj10array[0]=((-1.0)*x778);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x778)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x780=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x780)));\nevalcond[2]=((-0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x780))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj12=1.0;\ncj12=0;\nj12=1.5707963267949;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x782 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x782.valid){\ncontinue;\n}\nIkReal x781=x782.value;\nj10array[0]=((-1.0)*x781);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x781)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j10]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nCheckValue<IkReal> x783=IKPowWithIntegerCheck(IKsign(((((10000.0)*(pz*pz)))+(((-10000.0)*pp)))),-1);\nif(!x783.valid){\ncontinue;\n}\nCheckValue<IkReal> x784 = IKatan2WithCheck(IkReal(((2617.0)*px*sj13)),((-2617.0)*py*sj13),IKFAST_ATAN2_MAGTHRESH);\nif(!x784.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(((1.5707963267949)*(x783.value)))+(x784.value));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[2];\nIkReal x785=IKcos(j10);\nIkReal x786=IKsin(j10);\nIkReal x787=((1.0)*x786);\nevalcond[0]=((((-1.0)*px*x785))+(((-1.0)*py*x787)));\nevalcond[1]=((((-1.0)*px*x787))+((py*x785))+(((-0.2617)*sj13)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x788=((1.0)*pp);\nIkReal x789=x670;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j12)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((-1.0)*x788))+(((0.16235868)*cj13)));\nevalcond[2]=x789;\nevalcond[3]=((-0.02773715)+(((-1.0)*x788))+(((-0.6204)*pz)));\nevalcond[4]=x789;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[4];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj12=-1.0;\ncj12=0;\nj12=-1.5707963267949;\nIkReal x790=pz*pz;\nj10eval[0]=(pp+(((-1.0)*x790)));\nj10eval[1]=IKsign(((((-10000.0)*x790))+(((10000.0)*pp))));\nj10eval[2]=6848689.0;\nj10eval[3]=sj13;\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  || IKabs(j10eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x791=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x791)));\nevalcond[2]=((-0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x791))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj12=-1.0;\ncj12=0;\nj12=-1.5707963267949;\nsj13=0;\ncj13=1.0;\nj13=0;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x793 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x793.valid){\ncontinue;\n}\nIkReal x792=x793.value;\nj10array[0]=((-1.0)*x792);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x792)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x794=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x794)));\nevalcond[2]=((-0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x794))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nsj12=-1.0;\ncj12=0;\nj12=-1.5707963267949;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x796 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x796.valid){\ncontinue;\n}\nIkReal x795=x796.value;\nj10array[0]=((-1.0)*x795);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x795)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j10]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nCheckValue<IkReal> x797 = IKatan2WithCheck(IkReal(((2617.0)*px*sj13)),((-2617.0)*py*sj13),IKFAST_ATAN2_MAGTHRESH);\nif(!x797.valid){\ncontinue;\n}\nCheckValue<IkReal> x798=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x798.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(x797.value)+(((1.5707963267949)*(x798.value))));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[2];\nIkReal x799=IKcos(j10);\nIkReal x800=IKsin(j10);\nIkReal x801=((1.0)*x800);\nevalcond[0]=((((-1.0)*py*x801))+(((-1.0)*px*x799)));\nevalcond[1]=((((-1.0)*px*x801))+(((0.2617)*sj13))+((py*x799)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j10]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nIkReal x802=cj12*cj12;\nIkReal x803=((2617.0)*sj13);\nIkReal x804=(cj12*sj12);\nIkReal x805=((10000.0)*sj12);\nCheckValue<IkReal> x806=IKPowWithIntegerCheck(IKsign(((((-1.0)*x805*(pz*pz)))+((pp*x805)))),-1);\nif(!x806.valid){\ncontinue;\n}\nCheckValue<IkReal> x807 = IKatan2WithCheck(IkReal(((((-1.0)*px*x803))+((py*x803*x804))+((px*x802*x803)))),((((-1.0)*py*x802*x803))+((py*x803))+((px*x803*x804))),IKFAST_ATAN2_MAGTHRESH);\nif(!x807.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(((1.5707963267949)*(x806.value)))+(x807.value));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[4];\nIkReal x808=IKsin(j10);\nIkReal x809=IKcos(j10);\nIkReal x810=((0.2617)*sj13);\nIkReal x811=((1.0)*sj12);\nIkReal x812=((1.0)*px);\nIkReal x813=(py*x809);\nIkReal x814=(cj12*x812);\nIkReal x815=(py*x808);\nevalcond[0]=((((-1.0)*x808*x812))+(((-1.0)*sj12*x810))+x813);\nevalcond[1]=((((-1.0)*x809*x812))+(((-1.0)*x815))+((cj12*x810)));\nevalcond[2]=((((-1.0)*x808*x814))+(((-1.0)*x811*x815))+((cj12*x813))+(((-1.0)*px*x809*x811)));\nevalcond[3]=((((-1.0)*x809*x814))+(((-1.0)*x811*x813))+(((-1.0)*cj12*x815))+x810+((px*sj12*x808)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nIkReal x816=cj12*cj12;\nIkReal x817=((10000.0)*cj12);\nIkReal x818=((2617.0)*sj13*x816);\nIkReal x819=((2617.0)*cj12*sj12*sj13);\nCheckValue<IkReal> x820 = IKatan2WithCheck(IkReal((((py*x818))+(((-1.0)*px*x819)))),(((py*x819))+((px*x818))),IKFAST_ATAN2_MAGTHRESH);\nif(!x820.valid){\ncontinue;\n}\nCheckValue<IkReal> x821=IKPowWithIntegerCheck(IKsign(((((-1.0)*x817*(pz*pz)))+((pp*x817)))),-1);\nif(!x821.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(x820.value)+(((1.5707963267949)*(x821.value))));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[4];\nIkReal x822=IKsin(j10);\nIkReal x823=IKcos(j10);\nIkReal x824=((0.2617)*sj13);\nIkReal x825=((1.0)*sj12);\nIkReal x826=((1.0)*px);\nIkReal x827=(py*x823);\nIkReal x828=(cj12*x826);\nIkReal x829=(py*x822);\nevalcond[0]=((((-1.0)*x822*x826))+x827+(((-1.0)*sj12*x824)));\nevalcond[1]=((((-1.0)*x823*x826))+(((-1.0)*x829))+((cj12*x824)));\nevalcond[2]=((((-1.0)*x822*x828))+(((-1.0)*px*x823*x825))+((cj12*x827))+(((-1.0)*x825*x829)));\nevalcond[3]=(((px*sj12*x822))+(((-1.0)*x823*x828))+(((-1.0)*cj12*x829))+x824+(((-1.0)*x825*x827)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nIkReal x830=((2617.0)*sj12*sj13);\nIkReal x831=((2617.0)*cj12*sj13);\nCheckValue<IkReal> x832=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x832.valid){\ncontinue;\n}\nCheckValue<IkReal> x833 = IKatan2WithCheck(IkReal(((((-1.0)*px*x830))+((py*x831)))),(((py*x830))+((px*x831))),IKFAST_ATAN2_MAGTHRESH);\nif(!x833.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(((1.5707963267949)*(x832.value)))+(x833.value));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[4];\nIkReal x834=IKsin(j10);\nIkReal x835=IKcos(j10);\nIkReal x836=((0.2617)*sj13);\nIkReal x837=((1.0)*sj12);\nIkReal x838=((1.0)*px);\nIkReal x839=(py*x835);\nIkReal x840=(cj12*x838);\nIkReal x841=(py*x834);\nevalcond[0]=((((-1.0)*x834*x838))+(((-1.0)*sj12*x836))+x839);\nevalcond[1]=((((-1.0)*x835*x838))+(((-1.0)*x841))+((cj12*x836)));\nevalcond[2]=((((-1.0)*x837*x841))+(((-1.0)*x834*x840))+(((-1.0)*px*x835*x837))+((cj12*x839)));\nevalcond[3]=(((px*sj12*x834))+(((-1.0)*x835*x840))+(((-1.0)*cj12*x841))+(((-1.0)*x837*x839))+x836);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x842=((1.0)*pp);\nIkReal x843=((0.2617)*cj13);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j11)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((-1.0)*x842))+(((0.16235868)*cj13)));\nevalcond[2]=((0.3102)+(((-1.0)*pz))+x843);\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x842)));\nevalcond[4]=((-0.3102)+(((-1.0)*x843))+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[3];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x844=pz*pz;\nIkReal x845=(sj12*sj13);\nIkReal x846=(cj12*sj13);\nj10eval[0]=(pp+(((-1.0)*x844)));\nj10eval[1]=IKsign(((((-10000.0)*x844))+(((10000.0)*pp))));\nj10eval[2]=((IKabs((((py*x846))+((px*x845)))))+(IKabs(((((-1.0)*py*x845))+((px*x846))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[3];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x847=pz*pz;\nIkReal x848=cj12*cj12;\nIkReal x849=((1.0)*px);\nIkReal x850=(cj12*pp);\nIkReal x851=(cj12*x847);\nIkReal x852=(cj12*sj12*sj13);\nIkReal x853=(sj13*x848);\nj10eval[0]=((((-1.0)*x850))+x851);\nj10eval[1]=IKsign(((((10000.0)*x851))+(((-10000.0)*x850))));\nj10eval[2]=((IKabs(((((-1.0)*x849*x853))+((py*x852)))))+(IKabs(((((-1.0)*x849*x852))+(((-1.0)*py*x853))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[3];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x854=pz*pz;\nIkReal x855=cj12*cj12;\nIkReal x856=(cj12*sj12);\nIkReal x857=(py*sj13);\nIkReal x858=(pp*sj12);\nIkReal x859=((1.0)*px*sj13);\nIkReal x860=(sj12*x854);\nj10eval[0]=((((-1.0)*x858))+x860);\nj10eval[1]=IKsign(((((-10000.0)*x858))+(((10000.0)*x860))));\nj10eval[2]=((IKabs(((((-1.0)*x856*x859))+x857+(((-1.0)*x855*x857)))))+(IKabs(((((-1.0)*x859))+((px*sj13*x855))+(((-1.0)*x856*x857))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x861=((1.0)*pp);\nIkReal x862=((0.2617)*cj13);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j12))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((-1.0)*x861))+(((0.16235868)*cj13)));\nevalcond[2]=((0.3102)+(((-1.0)*pz))+x862);\nevalcond[3]=((-0.02773715)+(((-1.0)*x861))+(((0.6204)*pz)));\nevalcond[4]=((-0.3102)+(((-1.0)*x862))+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[4];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj12=0;\ncj12=1.0;\nj12=0;\nIkReal x863=pz*pz;\nj10eval[0]=((((-1.0)*x863))+pp);\nj10eval[1]=IKsign(((((-10000.0)*x863))+(((10000.0)*pp))));\nj10eval[2]=6848689.0;\nj10eval[3]=sj13;\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  || IKabs(j10eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x864=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x864)));\nevalcond[2]=((0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x864))+(((0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj12=0;\ncj12=1.0;\nj12=0;\nsj13=0;\ncj13=1.0;\nj13=0;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x866 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x866.valid){\ncontinue;\n}\nIkReal x865=x866.value;\nj10array[0]=((-1.0)*x865);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x865)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x867=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x867)));\nevalcond[2]=((0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x867))+(((0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj12=0;\ncj12=1.0;\nj12=0;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x869 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x869.valid){\ncontinue;\n}\nIkReal x868=x869.value;\nj10array[0]=((-1.0)*x868);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x868)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j10]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nIkReal x870=((2617.0)*sj13);\nCheckValue<IkReal> x871 = IKatan2WithCheck(IkReal((py*x870)),(px*x870),IKFAST_ATAN2_MAGTHRESH);\nif(!x871.valid){\ncontinue;\n}\nCheckValue<IkReal> x872=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x872.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(x871.value)+(((1.5707963267949)*(x872.value))));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[2];\nIkReal x873=IKsin(j10);\nIkReal x874=IKcos(j10);\nIkReal x875=((1.0)*x873);\nevalcond[0]=(((py*x874))+(((-1.0)*px*x875)));\nevalcond[1]=((((0.2617)*sj13))+(((-1.0)*py*x875))+(((-1.0)*px*x874)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x876=((1.0)*pp);\nIkReal x877=((0.2617)*cj13);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j12)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((0.16235868)*cj13))+(((-1.0)*x876)));\nevalcond[2]=((0.3102)+(((-1.0)*pz))+x877);\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x876)));\nevalcond[4]=((-0.3102)+pz+(((-1.0)*x877)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[4];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj12=0;\ncj12=-1.0;\nj12=3.14159265358979;\nIkReal x878=pz*pz;\nj10eval[0]=((((-1.0)*pp))+x878);\nj10eval[1]=6848689.0;\nj10eval[2]=sj13;\nj10eval[3]=IKsign(((((-10000.0)*pp))+(((10000.0)*x878))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  || IKabs(j10eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x879=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x879)));\nevalcond[2]=((0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x879)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj12=0;\ncj12=-1.0;\nj12=3.14159265358979;\nsj13=0;\ncj13=1.0;\nj13=0;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x881 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x881.valid){\ncontinue;\n}\nIkReal x880=x881.value;\nj10array[0]=((-1.0)*x880);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x880)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x882=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x882)));\nevalcond[2]=((0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x882)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj12=0;\ncj12=-1.0;\nj12=3.14159265358979;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x884 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x884.valid){\ncontinue;\n}\nIkReal x883=x884.value;\nj10array[0]=((-1.0)*x883);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x883)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j10]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nIkReal x885=((2617.0)*sj13);\nCheckValue<IkReal> x886 = IKatan2WithCheck(IkReal((py*x885)),(px*x885),IKFAST_ATAN2_MAGTHRESH);\nif(!x886.valid){\ncontinue;\n}\nCheckValue<IkReal> x887=IKPowWithIntegerCheck(IKsign(((((10000.0)*(pz*pz)))+(((-10000.0)*pp)))),-1);\nif(!x887.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(x886.value)+(((1.5707963267949)*(x887.value))));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[2];\nIkReal x888=IKsin(j10);\nIkReal x889=IKcos(j10);\nIkReal x890=((1.0)*x888);\nevalcond[0]=(((py*x889))+(((-1.0)*px*x890)));\nevalcond[1]=((((-1.0)*py*x890))+(((-1.0)*px*x889))+(((-0.2617)*sj13)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x891=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x891)));\nevalcond[2]=((0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x891))+(((0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj13=0;\ncj13=1.0;\nj13=0;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj13=0;\ncj13=1.0;\nj13=0;\nIkReal x892=((1.0)*py);\nj10eval[0]=((IKabs((((cj12*px))+(((-1.0)*sj12*x892)))))+(IKabs(((((-1.0)*cj12*x892))+(((-1.0)*px*sj12))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj13=0;\ncj13=1.0;\nj13=0;\nIkReal x893=((1.0)*cj12);\nj10eval[0]=((IKabs(((((-1.0)*py*x893))+(((-1.0)*px*sj12)))))+(IKabs((((py*sj12))+(((-1.0)*px*x893))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j10]\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nIkReal x894=((1.0)*cj12);\nCheckValue<IkReal> x896 = IKatan2WithCheck(IkReal((((py*sj12))+(((-1.0)*px*x894)))),((((-1.0)*py*x894))+(((-1.0)*px*sj12))),IKFAST_ATAN2_MAGTHRESH);\nif(!x896.valid){\ncontinue;\n}\nIkReal x895=x896.value;\nj10array[0]=((-1.0)*x895);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x895)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[3];\nIkReal x897=IKsin(j10);\nIkReal x898=IKcos(j10);\nIkReal x899=(py*x898);\nIkReal x900=(px*x897);\nIkReal x901=((1.0)*py*x897);\nIkReal x902=((1.0)*px*x898);\nevalcond[0]=((((-1.0)*x900))+x899);\nevalcond[1]=((((-1.0)*x902))+(((-1.0)*x901)));\nevalcond[2]=((((-1.0)*cj12*x899))+(((-1.0)*sj12*x901))+(((-1.0)*sj12*x902))+((cj12*x900)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nIkReal x903=((1.0)*py);\nCheckValue<IkReal> x905 = IKatan2WithCheck(IkReal(((((-1.0)*cj12*x903))+(((-1.0)*px*sj12)))),(((cj12*px))+(((-1.0)*sj12*x903))),IKFAST_ATAN2_MAGTHRESH);\nif(!x905.valid){\ncontinue;\n}\nIkReal x904=x905.value;\nj10array[0]=((-1.0)*x904);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x904)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[3];\nIkReal x906=IKsin(j10);\nIkReal x907=IKcos(j10);\nIkReal x908=(py*x907);\nIkReal x909=((1.0)*x906);\nIkReal x910=((1.0)*px*x907);\nevalcond[0]=((((-1.0)*px*x909))+x908);\nevalcond[1]=((((-1.0)*py*x909))+(((-1.0)*x910)));\nevalcond[2]=((((-1.0)*px*sj12*x909))+(((-1.0)*cj12*x910))+((sj12*x908))+(((-1.0)*cj12*py*x909)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x912 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x912.valid){\ncontinue;\n}\nIkReal x911=x912.value;\nj10array[0]=((-1.0)*x911);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x911)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[3];\nIkReal x913=IKsin(j10);\nIkReal x914=IKcos(j10);\nIkReal x915=(cj12*x913);\nIkReal x916=((1.0)*cj12*x914);\nIkReal x917=((1.0)*py*x913);\nIkReal x918=((1.0)*px*x914);\nevalcond[0]=((((-1.0)*x918))+(((-1.0)*x917)));\nevalcond[1]=(((px*x915))+(((-1.0)*py*x916))+(((-1.0)*sj12*x918))+(((-1.0)*sj12*x917)));\nevalcond[2]=((((-1.0)*px*sj12*x913))+(((-1.0)*px*x916))+(((-1.0)*py*x915))+((py*sj12*x914)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x919=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x919)));\nevalcond[2]=((0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x919))+(((0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nIkReal x920=((1.0)*py);\nj10eval[0]=((IKabs(((((-1.0)*sj12*x920))+((cj12*px)))))+(IKabs(((((-1.0)*cj12*x920))+(((-1.0)*px*sj12))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nIkReal x921=((1.0)*cj12);\nj10eval[0]=((IKabs(((((-1.0)*py*x921))+(((-1.0)*px*sj12)))))+(IKabs(((((-1.0)*px*x921))+((py*sj12))))));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j10]\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nIkReal x922=((1.0)*cj12);\nCheckValue<IkReal> x924 = IKatan2WithCheck(IkReal(((((-1.0)*px*x922))+((py*sj12)))),((((-1.0)*py*x922))+(((-1.0)*px*sj12))),IKFAST_ATAN2_MAGTHRESH);\nif(!x924.valid){\ncontinue;\n}\nIkReal x923=x924.value;\nj10array[0]=((-1.0)*x923);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x923)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[3];\nIkReal x925=IKsin(j10);\nIkReal x926=IKcos(j10);\nIkReal x927=(py*x926);\nIkReal x928=(px*x925);\nIkReal x929=((1.0)*py*x925);\nIkReal x930=((1.0)*px*x926);\nevalcond[0]=((((-1.0)*x928))+x927);\nevalcond[1]=((((-1.0)*x929))+(((-1.0)*x930)));\nevalcond[2]=((((-1.0)*sj12*x929))+(((-1.0)*sj12*x930))+(((-1.0)*cj12*x927))+((cj12*x928)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nIkReal x931=((1.0)*py);\nCheckValue<IkReal> x933 = IKatan2WithCheck(IkReal(((((-1.0)*cj12*x931))+(((-1.0)*px*sj12)))),((((-1.0)*sj12*x931))+((cj12*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x933.valid){\ncontinue;\n}\nIkReal x932=x933.value;\nj10array[0]=((-1.0)*x932);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x932)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[3];\nIkReal x934=IKsin(j10);\nIkReal x935=IKcos(j10);\nIkReal x936=(py*x935);\nIkReal x937=((1.0)*x934);\nIkReal x938=((1.0)*px*x935);\nevalcond[0]=((((-1.0)*px*x937))+x936);\nevalcond[1]=((((-1.0)*py*x937))+(((-1.0)*x938)));\nevalcond[2]=((((-1.0)*px*sj12*x937))+(((-1.0)*cj12*x938))+((sj12*x936))+(((-1.0)*cj12*py*x937)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x940 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x940.valid){\ncontinue;\n}\nIkReal x939=x940.value;\nj10array[0]=((-1.0)*x939);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x939)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[3];\nIkReal x941=IKsin(j10);\nIkReal x942=IKcos(j10);\nIkReal x943=(cj12*x941);\nIkReal x944=((1.0)*cj12*x942);\nIkReal x945=((1.0)*py*x941);\nIkReal x946=((1.0)*px*x942);\nevalcond[0]=((((-1.0)*x946))+(((-1.0)*x945)));\nevalcond[1]=((((-1.0)*py*x944))+((px*x943))+(((-1.0)*sj12*x945))+(((-1.0)*sj12*x946)));\nevalcond[2]=(((py*sj12*x942))+(((-1.0)*py*x943))+(((-1.0)*px*x944))+(((-1.0)*px*sj12*x941)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x947=((1.0)*pp);\nIkReal x948=((0.2617)*cj13);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j12)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((-1.0)*x947))+(((0.16235868)*cj13)));\nevalcond[2]=((0.3102)+(((-1.0)*pz))+x948);\nevalcond[3]=((-0.02773715)+(((-1.0)*x947))+(((0.6204)*pz)));\nevalcond[4]=((-0.3102)+(((-1.0)*x948))+pz);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[4];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj12=1.0;\ncj12=0;\nj12=1.5707963267949;\nIkReal x949=pz*pz;\nj10eval[0]=((((-1.0)*x949))+pp);\nj10eval[1]=IKsign(((((-10000.0)*x949))+(((10000.0)*pp))));\nj10eval[2]=6848689.0;\nj10eval[3]=sj13;\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  || IKabs(j10eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x950=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x950)));\nevalcond[2]=((0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x950)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj12=1.0;\ncj12=0;\nj12=1.5707963267949;\nsj13=0;\ncj13=1.0;\nj13=0;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x952 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x952.valid){\ncontinue;\n}\nIkReal x951=x952.value;\nj10array[0]=((-1.0)*x951);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x951)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x953=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x953)));\nevalcond[2]=((0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x953)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj12=1.0;\ncj12=0;\nj12=1.5707963267949;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x955 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x955.valid){\ncontinue;\n}\nIkReal x954=x955.value;\nj10array[0]=((-1.0)*x954);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x954)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j10]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nCheckValue<IkReal> x956 = IKatan2WithCheck(IkReal(((2617.0)*px*sj13)),((-2617.0)*py*sj13),IKFAST_ATAN2_MAGTHRESH);\nif(!x956.valid){\ncontinue;\n}\nCheckValue<IkReal> x957=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x957.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(x956.value)+(((1.5707963267949)*(x957.value))));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[2];\nIkReal x958=IKcos(j10);\nIkReal x959=IKsin(j10);\nIkReal x960=((1.0)*x959);\nevalcond[0]=((((-1.0)*py*x960))+(((-1.0)*px*x958)));\nevalcond[1]=((((0.2617)*sj13))+((py*x958))+(((-1.0)*px*x960)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x961=((1.0)*pp);\nIkReal x962=((0.2617)*cj13);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j12)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((0.16235868)*cj13))+(((-1.0)*x961)));\nevalcond[2]=((0.3102)+(((-1.0)*pz))+x962);\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x961)));\nevalcond[4]=((-0.3102)+pz+(((-1.0)*x962)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[4];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj12=-1.0;\ncj12=0;\nj12=-1.5707963267949;\nIkReal x963=pz*pz;\nj10eval[0]=((((-1.0)*pp))+x963);\nj10eval[1]=IKsign(((((10000.0)*x963))+(((-10000.0)*pp))));\nj10eval[2]=6848689.0;\nj10eval[3]=sj13;\nif( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  || IKabs(j10eval[2]) < 0.0000010000000000  || IKabs(j10eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x964=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x964)));\nevalcond[2]=((0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x964)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj12=-1.0;\ncj12=0;\nj12=-1.5707963267949;\nsj13=0;\ncj13=1.0;\nj13=0;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x966 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x966.valid){\ncontinue;\n}\nIkReal x965=x966.value;\nj10array[0]=((-1.0)*x965);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x965)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x967=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x967)));\nevalcond[2]=((0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x967)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j10eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nsj12=-1.0;\ncj12=0;\nj12=-1.5707963267949;\nsj13=0;\ncj13=-1.0;\nj13=3.14159265358979;\nj10eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j10eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x969 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x969.valid){\ncontinue;\n}\nIkReal x968=x969.value;\nj10array[0]=((-1.0)*x968);\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+(((-1.0)*x968)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*px*(IKcos(j10))))+(((-1.0)*py*(IKsin(j10)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j10]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nCheckValue<IkReal> x970=IKPowWithIntegerCheck(IKsign(((((10000.0)*(pz*pz)))+(((-10000.0)*pp)))),-1);\nif(!x970.valid){\ncontinue;\n}\nCheckValue<IkReal> x971 = IKatan2WithCheck(IkReal(((2617.0)*px*sj13)),((-2617.0)*py*sj13),IKFAST_ATAN2_MAGTHRESH);\nif(!x971.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(((1.5707963267949)*(x970.value)))+(x971.value));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[2];\nIkReal x972=IKcos(j10);\nIkReal x973=IKsin(j10);\nIkReal x974=((1.0)*x973);\nevalcond[0]=((((-1.0)*py*x974))+(((-1.0)*px*x972)));\nevalcond[1]=((((-1.0)*px*x974))+((py*x972))+(((-0.2617)*sj13)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j10]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nIkReal x975=cj12*cj12;\nIkReal x976=((2617.0)*sj13);\nIkReal x977=(cj12*sj12);\nIkReal x978=((10000.0)*sj12);\nCheckValue<IkReal> x979=IKPowWithIntegerCheck(IKsign((((x978*(pz*pz)))+(((-1.0)*pp*x978)))),-1);\nif(!x979.valid){\ncontinue;\n}\nCheckValue<IkReal> x980 = IKatan2WithCheck(IkReal(((((-1.0)*px*x976))+(((-1.0)*py*x976*x977))+((px*x975*x976)))),((((-1.0)*py*x975*x976))+((py*x976))+(((-1.0)*px*x976*x977))),IKFAST_ATAN2_MAGTHRESH);\nif(!x980.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(((1.5707963267949)*(x979.value)))+(x980.value));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[4];\nIkReal x981=IKsin(j10);\nIkReal x982=IKcos(j10);\nIkReal x983=((0.2617)*sj13);\nIkReal x984=(cj12*px);\nIkReal x985=(py*x982);\nIkReal x986=((1.0)*x982);\nIkReal x987=((1.0)*py*x981);\nIkReal x988=((1.0)*px*x981);\nevalcond[0]=((((-1.0)*x988))+((sj12*x983))+x985);\nevalcond[1]=((((-1.0)*px*x986))+(((-1.0)*x987))+((cj12*x983)));\nevalcond[2]=(((x981*x984))+(((-1.0)*px*sj12*x986))+(((-1.0)*cj12*x985))+(((-1.0)*sj12*x987)));\nevalcond[3]=((((-1.0)*cj12*x987))+((sj12*x985))+(((-1.0)*x984*x986))+x983+(((-1.0)*sj12*x988)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nIkReal x989=cj12*cj12;\nIkReal x990=((10000.0)*cj12);\nIkReal x991=((2617.0)*sj13*x989);\nIkReal x992=((2617.0)*cj12*sj12*sj13);\nCheckValue<IkReal> x993=IKPowWithIntegerCheck(IKsign((((x990*(pz*pz)))+(((-1.0)*pp*x990)))),-1);\nif(!x993.valid){\ncontinue;\n}\nCheckValue<IkReal> x994 = IKatan2WithCheck(IkReal(((((-1.0)*px*x992))+(((-1.0)*py*x991)))),((((-1.0)*px*x991))+((py*x992))),IKFAST_ATAN2_MAGTHRESH);\nif(!x994.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(((1.5707963267949)*(x993.value)))+(x994.value));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[4];\nIkReal x995=IKsin(j10);\nIkReal x996=IKcos(j10);\nIkReal x997=((0.2617)*sj13);\nIkReal x998=(cj12*px);\nIkReal x999=(py*x996);\nIkReal x1000=((1.0)*x996);\nIkReal x1001=((1.0)*py*x995);\nIkReal x1002=((1.0)*px*x995);\nevalcond[0]=((((-1.0)*x1002))+x999+((sj12*x997)));\nevalcond[1]=(((cj12*x997))+(((-1.0)*x1001))+(((-1.0)*px*x1000)));\nevalcond[2]=((((-1.0)*sj12*x1001))+(((-1.0)*px*sj12*x1000))+((x995*x998))+(((-1.0)*cj12*x999)));\nevalcond[3]=((((-1.0)*sj12*x1002))+(((-1.0)*x1000*x998))+(((-1.0)*cj12*x1001))+x997+((sj12*x999)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nIkReal x1003=((2617.0)*sj12*sj13);\nIkReal x1004=((2617.0)*cj12*sj13);\nCheckValue<IkReal> x1005 = IKatan2WithCheck(IkReal((((px*x1003))+((py*x1004)))),(((px*x1004))+(((-1.0)*py*x1003))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1005.valid){\ncontinue;\n}\nCheckValue<IkReal> x1006=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x1006.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(x1005.value)+(((1.5707963267949)*(x1006.value))));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[4];\nIkReal x1007=IKsin(j10);\nIkReal x1008=IKcos(j10);\nIkReal x1009=((0.2617)*sj13);\nIkReal x1010=(cj12*px);\nIkReal x1011=(py*x1008);\nIkReal x1012=((1.0)*x1008);\nIkReal x1013=((1.0)*py*x1007);\nIkReal x1014=((1.0)*px*x1007);\nevalcond[0]=(x1011+(((-1.0)*x1014))+((sj12*x1009)));\nevalcond[1]=(((cj12*x1009))+(((-1.0)*px*x1012))+(((-1.0)*x1013)));\nevalcond[2]=((((-1.0)*cj12*x1011))+(((-1.0)*px*sj12*x1012))+((x1007*x1010))+(((-1.0)*sj12*x1013)));\nevalcond[3]=((((-1.0)*x1010*x1012))+x1009+(((-1.0)*cj12*x1013))+(((-1.0)*sj12*x1014))+((sj12*x1011)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j10]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nIkReal x1015=((3102.0)*cj11);\nIkReal x1016=((2617.0)*cj11*cj13);\nIkReal x1017=((2617.0)*cj12*sj13);\nIkReal x1018=((2617.0)*sj11*sj12*sj13);\nCheckValue<IkReal> x1019=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x1019.valid){\ncontinue;\n}\nCheckValue<IkReal> x1020 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1018))+((py*x1017))+((px*x1015))+((px*x1016)))),((((-1.0)*py*x1015))+(((-1.0)*py*x1016))+((py*x1018))+((px*x1017))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1020.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1019.value)))+(x1020.value));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[6];\nIkReal x1021=IKsin(j10);\nIkReal x1022=IKcos(j10);\nIkReal x1023=(cj12*sj11);\nIkReal x1024=((0.2617)*cj13);\nIkReal x1025=((0.6204)*cj11);\nIkReal x1026=((1.0)*px);\nIkReal x1027=(pz*sj11);\nIkReal x1028=(sj11*sj12);\nIkReal x1029=((0.2617)*sj13);\nIkReal x1030=(cj11*pz);\nIkReal x1031=((1.0)*cj12);\nIkReal x1032=(py*x1022);\nIkReal x1033=(px*x1021);\nIkReal x1034=(py*x1021);\nevalcond[0]=((((-1.0)*x1034))+(((-1.0)*x1022*x1026))+((cj12*x1029)));\nevalcond[1]=((-0.3102)+(((-1.0)*cj11*x1032))+(((-1.0)*x1027))+(((-1.0)*x1024))+((cj11*x1033)));\nevalcond[2]=((-0.02773715)+(((-1.0)*x1025*x1032))+(((-0.6204)*x1027))+(((-1.0)*pp))+((x1025*x1033)));\nevalcond[3]=((((-1.0)*x1028*x1029))+(((0.3102)*cj11))+x1032+(((-1.0)*x1021*x1026))+((cj11*x1024)));\nevalcond[4]=((((-1.0)*sj12*x1034))+(((-1.0)*x1021*x1023*x1026))+((x1023*x1032))+(((-1.0)*x1030*x1031))+(((-1.0)*sj12*x1022*x1026)));\nevalcond[5]=(x1029+((x1028*x1033))+(((-1.0)*x1031*x1034))+(((-1.0)*cj12*x1022*x1026))+((sj12*x1030))+(((-1.0)*x1028*x1032)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nIkReal x1035=((25000000.0)*pp);\nIkReal x1036=((15510000.0)*cj11);\nIkReal x1037=((15510000.0)*pz*sj11);\nIkReal x1038=((4058967.0)*cj11*cj12*sj13);\nCheckValue<IkReal> x1039 = IKatan2WithCheck(IkReal((((px*x1035))+((px*x1037))+(((693428.75)*px))+((py*x1038)))),((((-1.0)*py*x1035))+(((-1.0)*py*x1037))+((px*x1038))+(((-693428.75)*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1039.valid){\ncontinue;\n}\nCheckValue<IkReal> x1040=IKPowWithIntegerCheck(IKsign((((pp*x1036))+(((-1.0)*x1036*(pz*pz))))),-1);\nif(!x1040.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(x1039.value)+(((1.5707963267949)*(x1040.value))));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[6];\nIkReal x1041=IKsin(j10);\nIkReal x1042=IKcos(j10);\nIkReal x1043=(cj12*sj11);\nIkReal x1044=((0.2617)*cj13);\nIkReal x1045=((0.6204)*cj11);\nIkReal x1046=((1.0)*px);\nIkReal x1047=(pz*sj11);\nIkReal x1048=(sj11*sj12);\nIkReal x1049=((0.2617)*sj13);\nIkReal x1050=(cj11*pz);\nIkReal x1051=((1.0)*cj12);\nIkReal x1052=(py*x1042);\nIkReal x1053=(px*x1041);\nIkReal x1054=(py*x1041);\nevalcond[0]=((((-1.0)*x1042*x1046))+(((-1.0)*x1054))+((cj12*x1049)));\nevalcond[1]=((-0.3102)+(((-1.0)*cj11*x1052))+((cj11*x1053))+(((-1.0)*x1047))+(((-1.0)*x1044)));\nevalcond[2]=((-0.02773715)+(((-1.0)*x1045*x1052))+(((-1.0)*pp))+((x1045*x1053))+(((-0.6204)*x1047)));\nevalcond[3]=((((0.3102)*cj11))+x1052+((cj11*x1044))+(((-1.0)*x1041*x1046))+(((-1.0)*x1048*x1049)));\nevalcond[4]=(((x1043*x1052))+(((-1.0)*sj12*x1042*x1046))+(((-1.0)*x1050*x1051))+(((-1.0)*x1041*x1043*x1046))+(((-1.0)*sj12*x1054)));\nevalcond[5]=(x1049+(((-1.0)*cj12*x1042*x1046))+((x1048*x1053))+(((-1.0)*x1048*x1052))+((sj12*x1050))+(((-1.0)*x1051*x1054)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[1], cj10array[1], sj10array[1];\nbool j10valid[1]={false};\n_nj10 = 1;\nIkReal x1055=((10000.0)*cj11);\nIkReal x1056=((2617.0)*cj13);\nIkReal x1057=((10000.0)*pz*sj11);\nIkReal x1058=((2617.0)*cj11*cj12*sj13);\nCheckValue<IkReal> x1059 = IKatan2WithCheck(IkReal(((((3102.0)*px))+((px*x1057))+((px*x1056))+((py*x1058)))),(((px*x1058))+(((-1.0)*py*x1056))+(((-1.0)*py*x1057))+(((-3102.0)*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1059.valid){\ncontinue;\n}\nCheckValue<IkReal> x1060=IKPowWithIntegerCheck(IKsign((((pp*x1055))+(((-1.0)*x1055*(pz*pz))))),-1);\nif(!x1060.valid){\ncontinue;\n}\nj10array[0]=((-1.5707963267949)+(x1059.value)+(((1.5707963267949)*(x1060.value))));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nfor(int ij10 = 0; ij10 < 1; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 1; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n{\nIkReal evalcond[6];\nIkReal x1061=IKsin(j10);\nIkReal x1062=IKcos(j10);\nIkReal x1063=(cj12*sj11);\nIkReal x1064=((0.2617)*cj13);\nIkReal x1065=((0.6204)*cj11);\nIkReal x1066=((1.0)*px);\nIkReal x1067=(pz*sj11);\nIkReal x1068=(sj11*sj12);\nIkReal x1069=((0.2617)*sj13);\nIkReal x1070=(cj11*pz);\nIkReal x1071=((1.0)*cj12);\nIkReal x1072=(py*x1062);\nIkReal x1073=(px*x1061);\nIkReal x1074=(py*x1061);\nevalcond[0]=((((-1.0)*x1062*x1066))+((cj12*x1069))+(((-1.0)*x1074)));\nevalcond[1]=((-0.3102)+((cj11*x1073))+(((-1.0)*cj11*x1072))+(((-1.0)*x1064))+(((-1.0)*x1067)));\nevalcond[2]=((-0.02773715)+(((-1.0)*pp))+(((-0.6204)*x1067))+(((-1.0)*x1065*x1072))+((x1065*x1073)));\nevalcond[3]=((((0.3102)*cj11))+x1072+(((-1.0)*x1061*x1066))+(((-1.0)*x1068*x1069))+((cj11*x1064)));\nevalcond[4]=((((-1.0)*sj12*x1062*x1066))+(((-1.0)*x1070*x1071))+(((-1.0)*x1061*x1063*x1066))+((x1063*x1072))+(((-1.0)*sj12*x1074)));\nevalcond[5]=(((x1068*x1073))+(((-1.0)*cj12*x1062*x1066))+x1069+(((-1.0)*x1071*x1074))+((sj12*x1070))+(((-1.0)*x1068*x1072)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j10array[2], cj10array[2], sj10array[2];\nbool j10valid[2]={false};\n_nj10 = 2;\nCheckValue<IkReal> x1077 = IKatan2WithCheck(IkReal(((-1.0)*px)),((-1.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x1077.valid){\ncontinue;\n}\nIkReal x1075=((1.0)*(x1077.value));\nif((((px*px)+(py*py))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x1078=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);\nif(!x1078.valid){\ncontinue;\n}\nif( (((0.2617)*cj12*sj13*(x1078.value))) < -1-IKFAST_SINCOS_THRESH || (((0.2617)*cj12*sj13*(x1078.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x1076=IKasin(((0.2617)*cj12*sj13*(x1078.value)));\nj10array[0]=((((-1.0)*x1076))+(((-1.0)*x1075)));\nsj10array[0]=IKsin(j10array[0]);\ncj10array[0]=IKcos(j10array[0]);\nj10array[1]=((3.14159265358979)+x1076+(((-1.0)*x1075)));\nsj10array[1]=IKsin(j10array[1]);\ncj10array[1]=IKcos(j10array[1]);\nif( j10array[0] > IKPI )\n{\n    j10array[0]-=IK2PI;\n}\nelse if( j10array[0] < -IKPI )\n{    j10array[0]+=IK2PI;\n}\nj10valid[0] = true;\nif( j10array[1] > IKPI )\n{\n    j10array[1]-=IK2PI;\n}\nelse if( j10array[1] < -IKPI )\n{    j10array[1]+=IK2PI;\n}\nj10valid[1] = true;\nfor(int ij10 = 0; ij10 < 2; ++ij10)\n{\nif( !j10valid[ij10] )\n{\n    continue;\n}\n_ij10[0] = ij10; _ij10[1] = -1;\nfor(int iij10 = ij10+1; iij10 < 2; ++iij10)\n{\nif( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )\n{\n    j10valid[iij10]=false; _ij10[1] = iij10; break; \n}\n}\nj10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];\n\n{\nIkReal j11eval[3];\nIkReal x1079=(px*sj10);\nIkReal x1080=(sj12*sj13);\nIkReal x1081=(cj10*py);\nIkReal x1082=((10000.0)*pz);\nIkReal x1083=((2617.0)*cj13);\nj11eval[0]=((((-1.0)*pz*x1080))+(((-1.0)*cj13*x1079))+((cj13*x1081))+(((-1.18532670997325)*x1079))+(((1.18532670997325)*x1081)));\nj11eval[1]=((IKabs(((-962.2404)+((pz*x1082))+(((-1623.5868)*cj13))+(((-684.8689)*(cj13*cj13))))))+(IKabs((((x1079*x1082))+(((684.8689)*cj13*x1080))+(((811.7934)*x1080))+(((-1.0)*x1081*x1082))))));\nj11eval[2]=IKsign((((x1081*x1083))+(((-2617.0)*pz*x1080))+(((-3102.0)*x1079))+(((-1.0)*x1079*x1083))+(((3102.0)*x1081))));\nif( IKabs(j11eval[0]) < 0.0000010000000000  || IKabs(j11eval[1]) < 0.0000010000000000  || IKabs(j11eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j11eval[3];\nIkReal x1084=(px*sj10);\nIkReal x1085=(cj10*py);\nIkReal x1086=((15510000.0)*pz);\nIkReal x1087=(sj12*sj13);\nIkReal x1088=((4058967.0)*cj13);\nIkReal x1089=((6542500.0)*pp);\nj11eval[0]=((((-1.0)*pz*x1087))+((cj13*x1085))+(((-1.0)*cj13*x1084))+(((1.18532670997325)*x1085))+(((-1.18532670997325)*x1084)));\nj11eval[1]=((IKabs(((-215101.59825)+((pz*x1086))+(((-7755000.0)*pp))+(((-1.0)*cj13*x1089))+(((-181470.303875)*cj13)))))+(IKabs(((((181470.303875)*x1087))+((x1087*x1089))+(((-1.0)*x1085*x1086))+((x1084*x1086))))));\nj11eval[2]=IKsign(((((-4811202.0)*x1084))+(((4811202.0)*x1085))+(((-1.0)*x1084*x1088))+((x1085*x1088))+(((-4058967.0)*pz*x1087))));\nif( IKabs(j11eval[0]) < 0.0000010000000000  || IKabs(j11eval[1]) < 0.0000010000000000  || IKabs(j11eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j11eval[3];\nIkReal x1090=cj12*cj12;\nIkReal x1091=cj13*cj13;\nIkReal x1092=(sj12*sj13);\nIkReal x1093=(cj10*py);\nIkReal x1094=((26170000.0)*pz);\nIkReal x1095=((26170000.0)*px*sj10);\nIkReal x1096=(x1090*x1091);\nj11eval[0]=((-2.40499940937601)+x1090+(((-1.0)*x1096))+(((-2.3706534199465)*cj13)));\nj11eval[1]=((IKabs(((((-26170000.0)*x1092*x1093))+(((31020000.0)*pz))+((cj13*x1094))+((x1092*x1095)))))+(IKabs(((((-1.0)*cj13*x1095))+(((-31020000.0)*px*sj10))+(((26170000.0)*cj13*x1093))+(((31020000.0)*x1093))+((x1092*x1094))))));\nj11eval[2]=IKsign(((-16471093.0)+(((-16235868.0)*cj13))+(((-6848689.0)*x1096))+(((6848689.0)*x1090))));\nif( IKabs(j11eval[0]) < 0.0000010000000000  || IKabs(j11eval[1]) < 0.0000010000000000  || IKabs(j11eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j11]\n\n} else\n{\n{\nIkReal j11array[1], cj11array[1], sj11array[1];\nbool j11valid[1]={false};\n_nj11 = 1;\nIkReal x1097=cj12*cj12;\nIkReal x1098=(px*sj10);\nIkReal x1099=(cj10*py);\nIkReal x1100=((26170000.0)*cj13);\nIkReal x1101=((26170000.0)*sj12*sj13);\nIkReal x1102=((6848689.0)*x1097);\nCheckValue<IkReal> x1103 = IKatan2WithCheck(IkReal(((((31020000.0)*pz))+((x1098*x1101))+(((-1.0)*x1099*x1101))+((pz*x1100)))),((((-1.0)*x1098*x1100))+((x1099*x1100))+(((31020000.0)*x1099))+((pz*x1101))+(((-31020000.0)*x1098))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1103.valid){\ncontinue;\n}\nCheckValue<IkReal> x1104=IKPowWithIntegerCheck(IKsign(((-16471093.0)+x1102+(((-16235868.0)*cj13))+(((-1.0)*x1102*(cj13*cj13))))),-1);\nif(!x1104.valid){\ncontinue;\n}\nj11array[0]=((-1.5707963267949)+(x1103.value)+(((1.5707963267949)*(x1104.value))));\nsj11array[0]=IKsin(j11array[0]);\ncj11array[0]=IKcos(j11array[0]);\nif( j11array[0] > IKPI )\n{\n    j11array[0]-=IK2PI;\n}\nelse if( j11array[0] < -IKPI )\n{    j11array[0]+=IK2PI;\n}\nj11valid[0] = true;\nfor(int ij11 = 0; ij11 < 1; ++ij11)\n{\nif( !j11valid[ij11] )\n{\n    continue;\n}\n_ij11[0] = ij11; _ij11[1] = -1;\nfor(int iij11 = ij11+1; iij11 < 1; ++iij11)\n{\nif( j11valid[iij11] && IKabs(cj11array[ij11]-cj11array[iij11]) < IKFAST_SOLUTION_THRESH && IKabs(sj11array[ij11]-sj11array[iij11]) < IKFAST_SOLUTION_THRESH )\n{\n    j11valid[iij11]=false; _ij11[1] = iij11; break; \n}\n}\nj11 = j11array[ij11]; cj11 = cj11array[ij11]; sj11 = sj11array[ij11];\n{\nIkReal evalcond[6];\nIkReal x1105=IKsin(j11);\nIkReal x1106=IKcos(j11);\nIkReal x1107=(sj12*sj13);\nIkReal x1108=((0.2617)*cj13);\nIkReal x1109=(cj10*py);\nIkReal x1110=(px*sj10);\nIkReal x1111=((1.0)*cj12);\nIkReal x1112=(cj10*px);\nIkReal x1113=((1.0)*pz);\nIkReal x1114=((1.0)*sj12);\nIkReal x1115=(py*sj10);\nIkReal x1116=((0.2617)*x1105);\nIkReal x1117=((0.6204)*x1106);\nIkReal x1118=(pz*x1106);\nevalcond[0]=((((-0.3102)*x1105))+(((-0.2617)*x1106*x1107))+(((-1.0)*x1113))+(((-1.0)*x1105*x1108)));\nevalcond[1]=((-0.3102)+(((-1.0)*x1108))+(((-1.0)*x1105*x1113))+((x1106*x1110))+(((-1.0)*x1106*x1109)));\nevalcond[2]=((-0.02773715)+(((-1.0)*x1109*x1117))+((x1110*x1117))+(((-0.6204)*pz*x1105))+(((-1.0)*pp)));\nevalcond[3]=(x1109+(((-1.0)*x1110))+(((-1.0)*x1107*x1116))+(((0.3102)*x1106))+((x1106*x1108)));\nevalcond[4]=((((-1.0)*x1114*x1115))+(((-1.0)*x1112*x1114))+((cj12*x1105*x1109))+(((-1.0)*x1105*x1110*x1111))+(((-1.0)*x1111*x1118)));\nevalcond[5]=(((sj12*x1118))+(((-1.0)*x1105*x1109*x1114))+(((0.2617)*sj13))+((sj12*x1105*x1110))+(((-1.0)*x1111*x1115))+(((-1.0)*x1111*x1112)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j11array[1], cj11array[1], sj11array[1];\nbool j11valid[1]={false};\n_nj11 = 1;\nIkReal x1119=(sj12*sj13);\nIkReal x1120=((6542500.0)*pp);\nIkReal x1121=(cj10*py);\nIkReal x1122=((15510000.0)*pz);\nIkReal x1123=(px*sj10);\nIkReal x1124=((4058967.0)*cj13);\nCheckValue<IkReal> x1125=IKPowWithIntegerCheck(IKsign((((x1121*x1124))+(((-1.0)*x1123*x1124))+(((-4058967.0)*pz*x1119))+(((-4811202.0)*x1123))+(((4811202.0)*x1121)))),-1);\nif(!x1125.valid){\ncontinue;\n}\nCheckValue<IkReal> x1126 = IKatan2WithCheck(IkReal(((((-1.0)*x1121*x1122))+((x1119*x1120))+((x1122*x1123))+(((181470.303875)*x1119)))),((-215101.59825)+(((-1.0)*cj13*x1120))+(((-7755000.0)*pp))+((pz*x1122))+(((-181470.303875)*cj13))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1126.valid){\ncontinue;\n}\nj11array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1125.value)))+(x1126.value));\nsj11array[0]=IKsin(j11array[0]);\ncj11array[0]=IKcos(j11array[0]);\nif( j11array[0] > IKPI )\n{\n    j11array[0]-=IK2PI;\n}\nelse if( j11array[0] < -IKPI )\n{    j11array[0]+=IK2PI;\n}\nj11valid[0] = true;\nfor(int ij11 = 0; ij11 < 1; ++ij11)\n{\nif( !j11valid[ij11] )\n{\n    continue;\n}\n_ij11[0] = ij11; _ij11[1] = -1;\nfor(int iij11 = ij11+1; iij11 < 1; ++iij11)\n{\nif( j11valid[iij11] && IKabs(cj11array[ij11]-cj11array[iij11]) < IKFAST_SOLUTION_THRESH && IKabs(sj11array[ij11]-sj11array[iij11]) < IKFAST_SOLUTION_THRESH )\n{\n    j11valid[iij11]=false; _ij11[1] = iij11; break; \n}\n}\nj11 = j11array[ij11]; cj11 = cj11array[ij11]; sj11 = sj11array[ij11];\n{\nIkReal evalcond[6];\nIkReal x1127=IKsin(j11);\nIkReal x1128=IKcos(j11);\nIkReal x1129=(sj12*sj13);\nIkReal x1130=((0.2617)*cj13);\nIkReal x1131=(cj10*py);\nIkReal x1132=(px*sj10);\nIkReal x1133=((1.0)*cj12);\nIkReal x1134=(cj10*px);\nIkReal x1135=((1.0)*pz);\nIkReal x1136=((1.0)*sj12);\nIkReal x1137=(py*sj10);\nIkReal x1138=((0.2617)*x1127);\nIkReal x1139=((0.6204)*x1128);\nIkReal x1140=(pz*x1128);\nevalcond[0]=((((-1.0)*x1127*x1130))+(((-0.3102)*x1127))+(((-1.0)*x1135))+(((-0.2617)*x1128*x1129)));\nevalcond[1]=((-0.3102)+(((-1.0)*x1128*x1131))+(((-1.0)*x1127*x1135))+(((-1.0)*x1130))+((x1128*x1132)));\nevalcond[2]=((-0.02773715)+(((-1.0)*x1131*x1139))+(((-1.0)*pp))+(((-0.6204)*pz*x1127))+((x1132*x1139)));\nevalcond[3]=(x1131+(((0.3102)*x1128))+((x1128*x1130))+(((-1.0)*x1132))+(((-1.0)*x1129*x1138)));\nevalcond[4]=((((-1.0)*x1134*x1136))+(((-1.0)*x1133*x1140))+(((-1.0)*x1136*x1137))+(((-1.0)*x1127*x1132*x1133))+((cj12*x1127*x1131)));\nevalcond[5]=((((0.2617)*sj13))+((sj12*x1140))+(((-1.0)*x1127*x1131*x1136))+((sj12*x1127*x1132))+(((-1.0)*x1133*x1137))+(((-1.0)*x1133*x1134)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j11array[1], cj11array[1], sj11array[1];\nbool j11valid[1]={false};\n_nj11 = 1;\nIkReal x1141=(sj12*sj13);\nIkReal x1142=((10000.0)*pz);\nIkReal x1143=(px*sj10);\nIkReal x1144=(cj10*py);\nIkReal x1145=((2617.0)*cj13);\nCheckValue<IkReal> x1146 = IKatan2WithCheck(IkReal(((((811.7934)*x1141))+((x1142*x1143))+(((-1.0)*x1142*x1144))+(((684.8689)*cj13*x1141)))),((-962.2404)+((pz*x1142))+(((-1623.5868)*cj13))+(((-684.8689)*(cj13*cj13)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1146.valid){\ncontinue;\n}\nCheckValue<IkReal> x1147=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1143*x1145))+(((-3102.0)*x1143))+(((3102.0)*x1144))+((x1144*x1145))+(((-2617.0)*pz*x1141)))),-1);\nif(!x1147.valid){\ncontinue;\n}\nj11array[0]=((-1.5707963267949)+(x1146.value)+(((1.5707963267949)*(x1147.value))));\nsj11array[0]=IKsin(j11array[0]);\ncj11array[0]=IKcos(j11array[0]);\nif( j11array[0] > IKPI )\n{\n    j11array[0]-=IK2PI;\n}\nelse if( j11array[0] < -IKPI )\n{    j11array[0]+=IK2PI;\n}\nj11valid[0] = true;\nfor(int ij11 = 0; ij11 < 1; ++ij11)\n{\nif( !j11valid[ij11] )\n{\n    continue;\n}\n_ij11[0] = ij11; _ij11[1] = -1;\nfor(int iij11 = ij11+1; iij11 < 1; ++iij11)\n{\nif( j11valid[iij11] && IKabs(cj11array[ij11]-cj11array[iij11]) < IKFAST_SOLUTION_THRESH && IKabs(sj11array[ij11]-sj11array[iij11]) < IKFAST_SOLUTION_THRESH )\n{\n    j11valid[iij11]=false; _ij11[1] = iij11; break; \n}\n}\nj11 = j11array[ij11]; cj11 = cj11array[ij11]; sj11 = sj11array[ij11];\n{\nIkReal evalcond[6];\nIkReal x1148=IKsin(j11);\nIkReal x1149=IKcos(j11);\nIkReal x1150=(sj12*sj13);\nIkReal x1151=((0.2617)*cj13);\nIkReal x1152=(cj10*py);\nIkReal x1153=(px*sj10);\nIkReal x1154=((1.0)*cj12);\nIkReal x1155=(cj10*px);\nIkReal x1156=((1.0)*pz);\nIkReal x1157=((1.0)*sj12);\nIkReal x1158=(py*sj10);\nIkReal x1159=((0.2617)*x1148);\nIkReal x1160=((0.6204)*x1149);\nIkReal x1161=(pz*x1149);\nevalcond[0]=((((-1.0)*x1156))+(((-0.3102)*x1148))+(((-0.2617)*x1149*x1150))+(((-1.0)*x1148*x1151)));\nevalcond[1]=((-0.3102)+((x1149*x1153))+(((-1.0)*x1151))+(((-1.0)*x1149*x1152))+(((-1.0)*x1148*x1156)));\nevalcond[2]=((-0.02773715)+((x1153*x1160))+(((-1.0)*x1152*x1160))+(((-0.6204)*pz*x1148))+(((-1.0)*pp)));\nevalcond[3]=(x1152+((x1149*x1151))+(((0.3102)*x1149))+(((-1.0)*x1153))+(((-1.0)*x1150*x1159)));\nevalcond[4]=((((-1.0)*x1157*x1158))+(((-1.0)*x1155*x1157))+((cj12*x1148*x1152))+(((-1.0)*x1148*x1153*x1154))+(((-1.0)*x1154*x1161)));\nevalcond[5]=((((-1.0)*x1154*x1155))+(((-1.0)*x1154*x1158))+((sj12*x1161))+((sj12*x1148*x1153))+(((0.2617)*sj13))+(((-1.0)*x1148*x1152*x1157)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\nreturn solutions.GetNumSolutions()>0;\n}\ninline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {\nfor(int rotationiter = 0; rotationiter < 1; ++rotationiter) {\nIkReal x125=(cj12*cj13);\nIkReal x126=((1.0)*sj10);\nIkReal x127=(cj11*cj12);\nIkReal x128=(cj11*cj13);\nIkReal x129=(sj11*sj13);\nIkReal x130=((1.0)*cj10);\nIkReal x131=(cj12*sj11);\nIkReal x132=(cj12*sj13);\nIkReal x133=(cj10*x132);\nIkReal x134=((1.0)*cj13*sj11);\nIkReal x135=((-1.0)*sj10);\nIkReal x136=((1.0)*cj11*sj13);\nIkReal x137=(((cj10*sj12))+((sj10*x131)));\nIkReal x138=(((sj10*sj12))+(((-1.0)*x130*x131)));\nIkReal x139=((((-1.0)*x129))+((sj12*x128)));\nIkReal x140=((((-1.0)*x128))+((sj12*x129)));\nIkReal x141=((((-1.0)*sj12*x134))+(((-1.0)*x136)));\nIkReal x142=((((-1.0)*sj12*x136))+(((-1.0)*x134)));\nIkReal x143=(cj10*x141);\nIkReal x144=(((cj10*x140))+((sj10*x132)));\nIkReal x145=(x133+(((-1.0)*x126*x140)));\nIkReal x146=(x143+((x125*x135)));\nIkReal x147=((((-1.0)*x126*x141))+(((-1.0)*x125*x130)));\nnew_r00=(((r00*x137))+((r20*x127))+((r10*x138)));\nnew_r01=(((r21*x127))+((r01*x137))+((r11*x138)));\nnew_r02=(((r02*x137))+((r22*x127))+((r12*x138)));\nnew_r10=(((r10*((x143+(((-1.0)*x125*x126))))))+((r00*((((x135*x141))+(((-1.0)*cj10*x125))))))+((r20*x139)));\nnew_r11=(((r01*x147))+((r21*x139))+((r11*x146)));\nnew_r12=(((r22*x139))+((r02*x147))+((r12*x146)));\nnew_r20=(((r20*x142))+((r00*x145))+((r10*x144)));\nnew_r21=(((r01*x145))+((r21*x142))+((r11*x144)));\nnew_r22=(((r02*((((x135*x140))+x133))))+((r22*x142))+((r12*x144)));\n{\nIkReal j15array[2], cj15array[2], sj15array[2];\nbool j15valid[2]={false};\n_nj15 = 2;\nsj15array[0]=((-1.0)*new_r22);\nif( sj15array[0] >= -1-IKFAST_SINCOS_THRESH && sj15array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j15valid[0] = j15valid[1] = true;\n    j15array[0] = IKasin(sj15array[0]);\n    cj15array[0] = IKcos(j15array[0]);\n    sj15array[1] = sj15array[0];\n    j15array[1] = j15array[0] > 0 ? (IKPI-j15array[0]) : (-IKPI-j15array[0]);\n    cj15array[1] = -cj15array[0];\n}\nelse if( isnan(sj15array[0]) )\n{\n    // probably any value will work\n    j15valid[0] = true;\n    cj15array[0] = 1; sj15array[0] = 0; j15array[0] = 0;\n}\nfor(int ij15 = 0; ij15 < 2; ++ij15)\n{\nif( !j15valid[ij15] )\n{\n    continue;\n}\n_ij15[0] = ij15; _ij15[1] = -1;\nfor(int iij15 = ij15+1; iij15 < 2; ++iij15)\n{\nif( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )\n{\n    j15valid[iij15]=false; _ij15[1] = iij15; break; \n}\n}\nj15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];\n\n{\nIkReal j14eval[2];\nIkReal x148=(cj12*cj13);\nIkReal x149=((1.0)*sj10);\nIkReal x150=(cj11*cj12);\nIkReal x151=(cj11*cj13);\nIkReal x152=(sj11*sj13);\nIkReal x153=((1.0)*cj10);\nIkReal x154=(cj12*sj11);\nIkReal x155=(cj12*sj13);\nIkReal x156=(cj10*x155);\nIkReal x157=((1.0)*cj13*sj11);\nIkReal x158=((-1.0)*sj10);\nIkReal x159=((1.0)*cj11*sj13);\nIkReal x160=x137;\nIkReal x161=x138;\nIkReal x162=x139;\nIkReal x163=x140;\nIkReal x164=x141;\nIkReal x165=x142;\nIkReal x166=(cj10*x164);\nIkReal x167=(((cj10*x163))+((sj10*x155)));\nIkReal x168=(x156+(((-1.0)*x149*x163)));\nIkReal x169=(x166+((x148*x158)));\nIkReal x170=((((-1.0)*x148*x153))+(((-1.0)*x149*x164)));\nnew_r00=(((r00*x160))+((r20*x150))+((r10*x161)));\nnew_r01=(((r01*x160))+((r21*x150))+((r11*x161)));\nnew_r02=(((r12*x161))+((r22*x150))+((r02*x160)));\nnew_r10=(((r10*((x166+(((-1.0)*x148*x149))))))+((r20*x162))+((r00*(((((-1.0)*cj10*x148))+((x158*x164)))))));\nnew_r11=(((r01*x170))+((r21*x162))+((r11*x169)));\nnew_r12=(((r22*x162))+((r12*x169))+((r02*x170)));\nnew_r20=(((r00*x168))+((r20*x165))+((r10*x167)));\nnew_r21=(((r01*x168))+((r21*x165))+((r11*x167)));\nnew_r22=(((r22*x165))+((r02*((x156+((x158*x163))))))+((r12*x167)));\nj14eval[0]=cj15;\nj14eval[1]=IKsign(cj15);\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[1];\nIkReal x171=(cj12*cj13);\nIkReal x172=((1.0)*sj10);\nIkReal x173=(cj11*cj12);\nIkReal x174=(cj11*cj13);\nIkReal x175=(sj11*sj13);\nIkReal x176=((1.0)*cj10);\nIkReal x177=(cj12*sj11);\nIkReal x178=(cj12*sj13);\nIkReal x179=(cj10*x178);\nIkReal x180=((1.0)*cj13*sj11);\nIkReal x181=((-1.0)*sj10);\nIkReal x182=((1.0)*cj11*sj13);\nIkReal x183=x137;\nIkReal x184=x138;\nIkReal x185=x139;\nIkReal x186=x140;\nIkReal x187=x141;\nIkReal x188=x142;\nIkReal x189=(cj10*x187);\nIkReal x190=(((sj10*x178))+((cj10*x186)));\nIkReal x191=(x179+(((-1.0)*x172*x186)));\nIkReal x192=(x189+((x171*x181)));\nIkReal x193=((((-1.0)*x171*x176))+(((-1.0)*x172*x187)));\nnew_r00=(((r00*x183))+((r20*x173))+((r10*x184)));\nnew_r01=(((r01*x183))+((r21*x173))+((r11*x184)));\nnew_r02=(((r22*x173))+((r12*x184))+((r02*x183)));\nnew_r10=(((r00*(((((-1.0)*cj10*x171))+((x181*x187))))))+((r10*((x189+(((-1.0)*x171*x172))))))+((r20*x185)));\nnew_r11=(((r01*x193))+((r21*x185))+((r11*x192)));\nnew_r12=(((r12*x192))+((r02*x193))+((r22*x185)));\nnew_r20=(((r00*x191))+((r20*x188))+((r10*x190)));\nnew_r21=(((r01*x191))+((r21*x188))+((r11*x190)));\nnew_r22=(((r12*x190))+((r02*((x179+((x181*x186))))))+((r22*x188)));\nj14eval[0]=cj15;\nif( IKabs(j14eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j15)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r20;\nevalcond[4]=new_r21;\nevalcond[5]=new_r12;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j14array[2], cj14array[2], sj14array[2];\nbool j14valid[2]={false};\n_nj14 = 2;\nCheckValue<IkReal> x195 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x195.valid){\ncontinue;\n}\nIkReal x194=x195.value;\nj14array[0]=((-1.0)*x194);\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nj14array[1]=((3.14159265358979)+(((-1.0)*x194)));\nsj14array[1]=IKsin(j14array[1]);\ncj14array[1]=IKcos(j14array[1]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nif( j14array[1] > IKPI )\n{\n    j14array[1]-=IK2PI;\n}\nelse if( j14array[1] < -IKPI )\n{    j14array[1]+=IK2PI;\n}\nj14valid[1] = true;\nfor(int ij14 = 0; ij14 < 2; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 2; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*new_r02*(IKsin(j14))))+((new_r12*(IKcos(j14)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x196=((1.0)*cj14);\nif( IKabs(((((-1.0)*new_r01*x196))+(((-1.0)*new_r11*sj14)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x196))+((new_r01*sj14)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x196))+(((-1.0)*new_r11*sj14))))+IKsqr(((((-1.0)*new_r11*x196))+((new_r01*sj14))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((((-1.0)*new_r01*x196))+(((-1.0)*new_r11*sj14))), ((((-1.0)*new_r11*x196))+((new_r01*sj14))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x197=IKsin(j16);\nIkReal x198=IKcos(j16);\nIkReal x199=((1.0)*sj14);\nIkReal x200=(cj14*x197);\nIkReal x201=((1.0)*x198);\nIkReal x202=(x198*x199);\nevalcond[0]=(((cj14*new_r01))+x197+((new_r11*sj14)));\nevalcond[1]=(((cj14*new_r10))+x197+(((-1.0)*new_r00*x199)));\nevalcond[2]=(((cj14*new_r11))+x198+(((-1.0)*new_r01*x199)));\nevalcond[3]=(((cj14*new_r00))+(((-1.0)*x201))+((new_r10*sj14)));\nevalcond[4]=(((sj14*x197))+new_r11+((cj14*x198)));\nevalcond[5]=((((-1.0)*x202))+x200+new_r01);\nevalcond[6]=((((-1.0)*x202))+x200+new_r10);\nevalcond[7]=((((-1.0)*x197*x199))+new_r00+(((-1.0)*cj14*x201)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j15)))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r20;\nevalcond[4]=new_r21;\nevalcond[5]=new_r12;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j14array[2], cj14array[2], sj14array[2];\nbool j14valid[2]={false};\n_nj14 = 2;\nCheckValue<IkReal> x204 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x204.valid){\ncontinue;\n}\nIkReal x203=x204.value;\nj14array[0]=((-1.0)*x203);\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nj14array[1]=((3.14159265358979)+(((-1.0)*x203)));\nsj14array[1]=IKsin(j14array[1]);\ncj14array[1]=IKcos(j14array[1]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nif( j14array[1] > IKPI )\n{\n    j14array[1]-=IK2PI;\n}\nelse if( j14array[1] < -IKPI )\n{    j14array[1]+=IK2PI;\n}\nj14valid[1] = true;\nfor(int ij14 = 0; ij14 < 2; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 2; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*new_r02*(IKsin(j14))))+((new_r12*(IKcos(j14)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x205=((1.0)*new_r01);\nif( IKabs(((((-1.0)*new_r11*sj14))+(((-1.0)*cj14*x205)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj14*new_r11))+(((-1.0)*sj14*x205)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj14))+(((-1.0)*cj14*x205))))+IKsqr((((cj14*new_r11))+(((-1.0)*sj14*x205))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((((-1.0)*new_r11*sj14))+(((-1.0)*cj14*x205))), (((cj14*new_r11))+(((-1.0)*sj14*x205))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x206=IKsin(j16);\nIkReal x207=IKcos(j16);\nIkReal x208=((1.0)*sj14);\nIkReal x209=((1.0)*x207);\nIkReal x210=(sj14*x206);\nIkReal x211=((1.0)*x206);\nIkReal x212=(cj14*x209);\nevalcond[0]=(((cj14*new_r01))+x206+((new_r11*sj14)));\nevalcond[1]=(((cj14*new_r00))+(((-1.0)*x209))+((new_r10*sj14)));\nevalcond[2]=(((cj14*x206))+((sj14*x207))+new_r01);\nevalcond[3]=(x210+new_r11+(((-1.0)*x212)));\nevalcond[4]=((((-1.0)*new_r00*x208))+((cj14*new_r10))+(((-1.0)*x211)));\nevalcond[5]=(((cj14*new_r11))+(((-1.0)*x209))+(((-1.0)*new_r01*x208)));\nevalcond[6]=(x210+new_r00+(((-1.0)*x212)));\nevalcond[7]=((((-1.0)*x207*x208))+(((-1.0)*cj14*x211))+new_r10);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j14, j16]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nCheckValue<IkReal> x214=IKPowWithIntegerCheck(cj15,-1);\nif(!x214.valid){\ncontinue;\n}\nIkReal x213=x214.value;\nCheckValue<IkReal> x215=IKPowWithIntegerCheck(new_r12,-1);\nif(!x215.valid){\ncontinue;\n}\nCheckValue<IkReal> x216=IKPowWithIntegerCheck(x213,-2);\nif(!x216.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r02*x213)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x213*(x215.value)*(((((-1.0)*(new_r02*new_r02)))+(x216.value))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r02*x213))+IKsqr((x213*(x215.value)*(((((-1.0)*(new_r02*new_r02)))+(x216.value)))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj14array[0]=IKatan2(((-1.0)*new_r02*x213), (x213*(x215.value)*(((((-1.0)*(new_r02*new_r02)))+(x216.value)))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[8];\nIkReal x217=IKsin(j14);\nIkReal x218=IKcos(j14);\nIkReal x219=((1.0)*sj15);\nIkReal x220=((1.0)*cj15);\nIkReal x221=(cj15*x217);\nIkReal x222=(cj15*x218);\nIkReal x223=(new_r02*x217);\nIkReal x224=(new_r12*x218);\nevalcond[0]=(x221+new_r02);\nevalcond[1]=((((-1.0)*x218*x220))+new_r12);\nevalcond[2]=(((new_r02*x218))+((new_r12*x217)));\nevalcond[3]=(x224+(((-1.0)*x220))+(((-1.0)*x223)));\nevalcond[4]=((((-1.0)*new_r20*x219))+((new_r10*x222))+(((-1.0)*new_r00*x217*x220)));\nevalcond[5]=((((-1.0)*new_r21*x219))+((new_r11*x222))+(((-1.0)*new_r01*x217*x220)));\nevalcond[6]=((((-1.0)*x219*x224))+((sj15*x223))+(((-1.0)*new_r22*x220)));\nevalcond[7]=((-1.0)+((new_r12*x222))+(((-1.0)*x220*x223))+(((-1.0)*new_r22*x219)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j16eval[2];\nIkReal x225=(cj12*cj13);\nIkReal x226=((1.0)*sj10);\nIkReal x227=(cj11*cj12);\nIkReal x228=(cj11*cj13);\nIkReal x229=(sj11*sj13);\nIkReal x230=((1.0)*cj10);\nIkReal x231=(cj12*sj11);\nIkReal x232=(cj12*sj13);\nIkReal x233=(cj10*x232);\nIkReal x234=((1.0)*cj13*sj11);\nIkReal x235=((-1.0)*sj10);\nIkReal x236=((1.0)*cj11*sj13);\nIkReal x237=x137;\nIkReal x238=x138;\nIkReal x239=x139;\nIkReal x240=x140;\nIkReal x241=x141;\nIkReal x242=x142;\nIkReal x243=(cj10*x241);\nIkReal x244=(((sj10*x232))+((cj10*x240)));\nIkReal x245=((((-1.0)*x226*x240))+x233);\nIkReal x246=(x243+((x225*x235)));\nIkReal x247=((((-1.0)*x225*x230))+(((-1.0)*x226*x241)));\nnew_r00=(((r20*x227))+((r10*x238))+((r00*x237)));\nnew_r01=(((r11*x238))+((r01*x237))+((r21*x227)));\nnew_r02=(((r02*x237))+((r22*x227))+((r12*x238)));\nnew_r10=(((r20*x239))+((r00*(((((-1.0)*cj10*x225))+((x235*x241))))))+((r10*(((((-1.0)*x225*x226))+x243)))));\nnew_r11=(((r01*x247))+((r11*x246))+((r21*x239)));\nnew_r12=(((r02*x247))+((r12*x246))+((r22*x239)));\nnew_r20=(((r00*x245))+((r10*x244))+((r20*x242)));\nnew_r21=(((r21*x242))+((r01*x245))+((r11*x244)));\nnew_r22=(((r22*x242))+((r02*((x233+((x235*x240))))))+((r12*x244)));\nj16eval[0]=cj15;\nj16eval[1]=IKsign(cj15);\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[2];\nIkReal x248=(cj12*cj13);\nIkReal x249=((1.0)*sj10);\nIkReal x250=(cj11*cj12);\nIkReal x251=(cj11*cj13);\nIkReal x252=(sj11*sj13);\nIkReal x253=((1.0)*cj10);\nIkReal x254=(cj12*sj11);\nIkReal x255=(cj12*sj13);\nIkReal x256=(cj10*x255);\nIkReal x257=((1.0)*cj13*sj11);\nIkReal x258=((-1.0)*sj10);\nIkReal x259=((1.0)*cj11*sj13);\nIkReal x260=x137;\nIkReal x261=x138;\nIkReal x262=x139;\nIkReal x263=x140;\nIkReal x264=x141;\nIkReal x265=x142;\nIkReal x266=(cj10*x264);\nIkReal x267=(((sj10*x255))+((cj10*x263)));\nIkReal x268=((((-1.0)*x249*x263))+x256);\nIkReal x269=(((x248*x258))+x266);\nIkReal x270=((((-1.0)*x249*x264))+(((-1.0)*x248*x253)));\nnew_r00=(((r20*x250))+((r00*x260))+((r10*x261)));\nnew_r01=(((r21*x250))+((r11*x261))+((r01*x260)));\nnew_r02=(((r02*x260))+((r12*x261))+((r22*x250)));\nnew_r10=(((r00*(((((-1.0)*cj10*x248))+((x258*x264))))))+((r10*(((((-1.0)*x248*x249))+x266))))+((r20*x262)));\nnew_r11=(((r21*x262))+((r01*x270))+((r11*x269)));\nnew_r12=(((r02*x270))+((r22*x262))+((r12*x269)));\nnew_r20=(((r00*x268))+((r10*x267))+((r20*x265)));\nnew_r21=(((r21*x265))+((r11*x267))+((r01*x268)));\nnew_r22=(((r22*x265))+((r12*x267))+((r02*((((x258*x263))+x256)))));\nj16eval[0]=cj15;\nj16eval[1]=sj14;\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[3];\nIkReal x271=(cj12*cj13);\nIkReal x272=((1.0)*sj10);\nIkReal x273=(cj11*cj12);\nIkReal x274=(cj11*cj13);\nIkReal x275=(sj11*sj13);\nIkReal x276=((1.0)*cj10);\nIkReal x277=(cj12*sj11);\nIkReal x278=(cj12*sj13);\nIkReal x279=(cj10*x278);\nIkReal x280=((1.0)*cj13*sj11);\nIkReal x281=((-1.0)*sj10);\nIkReal x282=((1.0)*cj11*sj13);\nIkReal x283=x137;\nIkReal x284=x138;\nIkReal x285=x139;\nIkReal x286=x140;\nIkReal x287=x141;\nIkReal x288=x142;\nIkReal x289=(cj10*x287);\nIkReal x290=(((cj10*x286))+((sj10*x278)));\nIkReal x291=(x279+(((-1.0)*x272*x286)));\nIkReal x292=(((x271*x281))+x289);\nIkReal x293=((((-1.0)*x271*x276))+(((-1.0)*x272*x287)));\nnew_r00=(((r00*x283))+((r10*x284))+((r20*x273)));\nnew_r01=(((r01*x283))+((r11*x284))+((r21*x273)));\nnew_r02=(((r22*x273))+((r02*x283))+((r12*x284)));\nnew_r10=(((r00*(((((-1.0)*cj10*x271))+((x281*x287))))))+((r10*(((((-1.0)*x271*x272))+x289))))+((r20*x285)));\nnew_r11=(((r21*x285))+((r01*x293))+((r11*x292)));\nnew_r12=(((r12*x292))+((r22*x285))+((r02*x293)));\nnew_r20=(((r00*x291))+((r10*x290))+((r20*x288)));\nnew_r21=(((r21*x288))+((r01*x291))+((r11*x290)));\nnew_r22=(((r12*x290))+((r22*x288))+((r02*((x279+((x281*x286)))))));\nj16eval[0]=cj15;\nj16eval[1]=cj14;\nj16eval[2]=sj15;\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x294=(new_r12*sj14);\nIkReal x295=(new_r02*sj14);\nIkReal x296=(cj14*new_r12);\nIkReal x297=(cj14*new_r02);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j15)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r20;\nevalcond[4]=new_r21;\nevalcond[5]=new_r12;\nevalcond[6]=(x294+x297);\nevalcond[7]=((((-1.0)*x297))+(((-1.0)*x294)));\nevalcond[8]=((((-1.0)*x295))+x296);\nevalcond[9]=((((-1.0)*x296))+x295);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x298=((1.0)*cj14);\nif( IKabs(((((-1.0)*new_r01*x298))+(((-1.0)*new_r11*sj14)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x298))+((new_r01*sj14)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x298))+(((-1.0)*new_r11*sj14))))+IKsqr(((((-1.0)*new_r11*x298))+((new_r01*sj14))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((((-1.0)*new_r01*x298))+(((-1.0)*new_r11*sj14))), ((((-1.0)*new_r11*x298))+((new_r01*sj14))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x299=IKsin(j16);\nIkReal x300=IKcos(j16);\nIkReal x301=((1.0)*sj14);\nIkReal x302=(cj14*x299);\nIkReal x303=((1.0)*x300);\nIkReal x304=(x300*x301);\nevalcond[0]=(((cj14*new_r01))+x299+((new_r11*sj14)));\nevalcond[1]=(((cj14*new_r10))+x299+(((-1.0)*new_r00*x301)));\nevalcond[2]=(((cj14*new_r11))+x300+(((-1.0)*new_r01*x301)));\nevalcond[3]=(((cj14*new_r00))+((new_r10*sj14))+(((-1.0)*x303)));\nevalcond[4]=(((cj14*x300))+((sj14*x299))+new_r11);\nevalcond[5]=(x302+new_r01+(((-1.0)*x304)));\nevalcond[6]=(x302+new_r10+(((-1.0)*x304)));\nevalcond[7]=((((-1.0)*cj14*x303))+(((-1.0)*x299*x301))+new_r00);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x305=(new_r12*sj14);\nIkReal x306=(cj14*new_r02);\nIkReal x307=(((cj14*new_r12))+(((-1.0)*new_r02*sj14)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j15)))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r20;\nevalcond[4]=new_r21;\nevalcond[5]=new_r12;\nevalcond[6]=(x306+x305);\nevalcond[7]=((((-1.0)*x306))+(((-1.0)*x305)));\nevalcond[8]=x307;\nevalcond[9]=x307;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x308=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj14*x308))+(((-1.0)*new_r11*sj14)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj14*new_r11))+(((-1.0)*sj14*x308)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj14*x308))+(((-1.0)*new_r11*sj14))))+IKsqr((((cj14*new_r11))+(((-1.0)*sj14*x308))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((((-1.0)*cj14*x308))+(((-1.0)*new_r11*sj14))), (((cj14*new_r11))+(((-1.0)*sj14*x308))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x309=IKsin(j16);\nIkReal x310=IKcos(j16);\nIkReal x311=((1.0)*sj14);\nIkReal x312=((1.0)*x310);\nIkReal x313=(sj14*x309);\nIkReal x314=((1.0)*x309);\nIkReal x315=(cj14*x312);\nevalcond[0]=(((cj14*new_r01))+x309+((new_r11*sj14)));\nevalcond[1]=(((cj14*new_r00))+(((-1.0)*x312))+((new_r10*sj14)));\nevalcond[2]=(((sj14*x310))+((cj14*x309))+new_r01);\nevalcond[3]=(x313+(((-1.0)*x315))+new_r11);\nevalcond[4]=((((-1.0)*new_r00*x311))+((cj14*new_r10))+(((-1.0)*x314)));\nevalcond[5]=(((cj14*new_r11))+(((-1.0)*x312))+(((-1.0)*new_r01*x311)));\nevalcond[6]=(x313+(((-1.0)*x315))+new_r00);\nevalcond[7]=((((-1.0)*x310*x311))+(((-1.0)*cj14*x314))+new_r10);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x316=(sj15+new_r22);\nIkReal x317=((1.0)*sj15);\nIkReal x318=((1.0)*cj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j14)))), 6.28318530717959)));\nevalcond[1]=x316;\nevalcond[2]=x316;\nevalcond[3]=(cj15+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x318))+(((-1.0)*new_r02)));\nevalcond[6]=((((-1.0)*new_r00*x318))+(((-1.0)*new_r20*x317)));\nevalcond[7]=((((-1.0)*new_r21*x317))+(((-1.0)*new_r01*x318)));\nevalcond[8]=((((-1.0)*new_r22*x318))+((new_r02*sj15)));\nevalcond[9]=((-1.0)+(((-1.0)*new_r02*x318))+(((-1.0)*new_r22*x317)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nif( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((-1.0)*new_r11), new_r10);\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x319=IKsin(j16);\nIkReal x320=IKcos(j16);\nIkReal x321=((1.0)*new_r22);\nIkReal x322=((1.0)*x320);\nIkReal x323=((1.0)*x319);\nevalcond[0]=(x319+new_r11);\nevalcond[1]=((((-1.0)*x322))+new_r10);\nevalcond[2]=((((-1.0)*new_r02*x323))+new_r20);\nevalcond[3]=((((-1.0)*new_r02*x322))+new_r21);\nevalcond[4]=((((-1.0)*x319*x321))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*x320*x321))+(((-1.0)*new_r01)));\nevalcond[6]=((((-1.0)*x323))+(((-1.0)*new_r00*x321))+((new_r02*new_r20)));\nevalcond[7]=((((-1.0)*x322))+(((-1.0)*new_r01*x321))+((new_r02*new_r21)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x324=(sj15+new_r22);\nIkReal x325=((((-1.0)*cj15))+new_r02);\nIkReal x326=((1.0)*sj15);\nIkReal x327=((1.0)*cj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j14)))), 6.28318530717959)));\nevalcond[1]=x324;\nevalcond[2]=x324;\nevalcond[3]=x325;\nevalcond[4]=new_r12;\nevalcond[5]=x325;\nevalcond[6]=(((cj15*new_r00))+(((-1.0)*new_r20*x326)));\nevalcond[7]=(((cj15*new_r01))+(((-1.0)*new_r21*x326)));\nevalcond[8]=((((-1.0)*new_r22*x327))+(((-1.0)*new_r02*x326)));\nevalcond[9]=((-1.0)+(((-1.0)*new_r22*x326))+((cj15*new_r02)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nCheckValue<IkReal> x328=IKPowWithIntegerCheck(IKsign(new_r02),-1);\nif(!x328.valid){\ncontinue;\n}\nCheckValue<IkReal> x329 = IKatan2WithCheck(IkReal(((-1.0)*new_r20)),((-1.0)*new_r21),IKFAST_ATAN2_MAGTHRESH);\nif(!x329.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x328.value)))+(x329.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x330=IKsin(j16);\nIkReal x331=IKcos(j16);\nIkReal x332=((1.0)*new_r02);\nIkReal x333=((1.0)*x331);\nIkReal x334=((1.0)*x330);\nevalcond[0]=(((new_r02*x330))+new_r20);\nevalcond[1]=(((new_r02*x331))+new_r21);\nevalcond[2]=(x330+(((-1.0)*new_r11)));\nevalcond[3]=((((-1.0)*new_r22*x334))+new_r00);\nevalcond[4]=((((-1.0)*new_r22*x333))+new_r01);\nevalcond[5]=((((-1.0)*new_r10))+(((-1.0)*x333)));\nevalcond[6]=(((new_r00*new_r22))+(((-1.0)*new_r20*x332))+(((-1.0)*x334)));\nevalcond[7]=(((new_r01*new_r22))+(((-1.0)*new_r21*x332))+(((-1.0)*x333)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x335=((1.0)*sj14);\nIkReal x336=(cj14*new_r02);\nIkReal x337=(((cj14*new_r10))+(((-1.0)*new_r00*x335)));\nIkReal x338=(((cj14*new_r11))+(((-1.0)*new_r01*x335)));\nIkReal x339=((-1.0)+((cj14*new_r12))+(((-1.0)*new_r02*x335)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j15))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(sj14+new_r02);\nevalcond[3]=((((-1.0)*cj14))+new_r12);\nevalcond[4]=(x336+((new_r12*sj14)));\nevalcond[5]=((((-1.0)*x336))+(((-1.0)*new_r12*x335)));\nevalcond[6]=x339;\nevalcond[7]=x337;\nevalcond[8]=x338;\nevalcond[9]=x337;\nevalcond[10]=x338;\nevalcond[11]=x339;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nif( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x340=IKsin(j16);\nIkReal x341=IKcos(j16);\nIkReal x342=((1.0)*new_r02);\nIkReal x343=((1.0)*x341);\nevalcond[0]=(x340+new_r20);\nevalcond[1]=(x341+new_r21);\nevalcond[2]=(((new_r12*x340))+new_r01);\nevalcond[3]=(((new_r02*x341))+new_r10);\nevalcond[4]=((((-1.0)*x340*x342))+new_r11);\nevalcond[5]=((((-1.0)*new_r12*x343))+new_r00);\nevalcond[6]=((((-1.0)*new_r11*x342))+((new_r01*new_r12))+x340);\nevalcond[7]=((((-1.0)*new_r10*x342))+((new_r00*new_r12))+(((-1.0)*x343)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x344=((1.0)*sj14);\nIkReal x345=(cj14*new_r10);\nIkReal x346=(cj14*new_r12);\nIkReal x347=((1.0)*cj14);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j15)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(new_r02+(((-1.0)*x344)));\nevalcond[3]=(cj14+new_r12);\nevalcond[4]=(((cj14*new_r02))+((new_r12*sj14)));\nevalcond[5]=((((-1.0)*new_r02*x347))+(((-1.0)*new_r12*x344)));\nevalcond[6]=((1.0)+(((-1.0)*new_r02*x344))+x346);\nevalcond[7]=(x345+(((-1.0)*new_r00*x344)));\nevalcond[8]=(((cj14*new_r11))+(((-1.0)*new_r01*x344)));\nevalcond[9]=(((new_r00*sj14))+(((-1.0)*x345)));\nevalcond[10]=((((-1.0)*new_r11*x347))+((new_r01*sj14)));\nevalcond[11]=((-1.0)+((new_r02*sj14))+(((-1.0)*x346)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nif( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(new_r20, new_r21);\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x348=IKsin(j16);\nIkReal x349=IKcos(j16);\nIkReal x350=((1.0)*new_r12);\nIkReal x351=((1.0)*x349);\nIkReal x352=((1.0)*x348);\nevalcond[0]=((((-1.0)*x352))+new_r20);\nevalcond[1]=((((-1.0)*x351))+new_r21);\nevalcond[2]=(((new_r02*x348))+new_r11);\nevalcond[3]=(((new_r12*x349))+new_r00);\nevalcond[4]=((((-1.0)*x348*x350))+new_r01);\nevalcond[5]=((((-1.0)*new_r02*x351))+new_r10);\nevalcond[6]=(x348+(((-1.0)*new_r01*x350))+((new_r02*new_r11)));\nevalcond[7]=((((-1.0)*x351))+((new_r02*new_r10))+(((-1.0)*new_r00*x350)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x353=(sj15+new_r22);\nIkReal x354=((((-1.0)*cj15))+new_r12);\nIkReal x355=((1.0)*sj15);\nIkReal x356=((1.0)*cj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));\nevalcond[1]=x353;\nevalcond[2]=x353;\nevalcond[3]=new_r02;\nevalcond[4]=x354;\nevalcond[5]=x354;\nevalcond[6]=(((cj15*new_r10))+(((-1.0)*new_r20*x355)));\nevalcond[7]=(((cj15*new_r11))+(((-1.0)*new_r21*x355)));\nevalcond[8]=((((-1.0)*new_r22*x356))+(((-1.0)*new_r12*x355)));\nevalcond[9]=((-1.0)+(((-1.0)*new_r22*x355))+((cj15*new_r12)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nif( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((-1.0)*new_r01), new_r00);\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x357=IKsin(j16);\nIkReal x358=IKcos(j16);\nIkReal x359=((1.0)*new_r12);\nIkReal x360=((1.0)*x358);\nIkReal x361=((1.0)*x357);\nevalcond[0]=(x357+new_r01);\nevalcond[1]=(new_r20+((new_r12*x357)));\nevalcond[2]=(new_r21+((new_r12*x358)));\nevalcond[3]=((((-1.0)*x360))+new_r00);\nevalcond[4]=((((-1.0)*new_r22*x360))+new_r11);\nevalcond[5]=((((-1.0)*new_r22*x361))+new_r10);\nevalcond[6]=((((-1.0)*x361))+((new_r10*new_r22))+(((-1.0)*new_r20*x359)));\nevalcond[7]=((((-1.0)*x360))+((new_r11*new_r22))+(((-1.0)*new_r21*x359)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x362=(sj15+new_r22);\nIkReal x363=((1.0)*cj15);\nIkReal x364=((1.0)*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));\nevalcond[1]=x362;\nevalcond[2]=x362;\nevalcond[3]=new_r02;\nevalcond[4]=(cj15+new_r12);\nevalcond[5]=((((-1.0)*x363))+(((-1.0)*new_r12)));\nevalcond[6]=((((-1.0)*new_r20*x364))+(((-1.0)*new_r10*x363)));\nevalcond[7]=((((-1.0)*new_r11*x363))+(((-1.0)*new_r21*x364)));\nevalcond[8]=((((-1.0)*new_r22*x363))+((new_r12*sj15)));\nevalcond[9]=((-1.0)+(((-1.0)*new_r22*x364))+(((-1.0)*new_r12*x363)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nif( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(new_r01, ((-1.0)*new_r00));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x365=IKsin(j16);\nIkReal x366=IKcos(j16);\nIkReal x367=((1.0)*new_r10);\nIkReal x368=((1.0)*x366);\nIkReal x369=((1.0)*x365);\nevalcond[0]=(x365+(((-1.0)*new_r01)));\nevalcond[1]=(((new_r22*x366))+new_r11);\nevalcond[2]=((((-1.0)*new_r12*x369))+new_r20);\nevalcond[3]=((((-1.0)*new_r12*x368))+new_r21);\nevalcond[4]=((((-1.0)*x368))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*x367))+(((-1.0)*new_r22*x369)));\nevalcond[6]=((((-1.0)*x369))+(((-1.0)*new_r22*x367))+((new_r12*new_r20)));\nevalcond[7]=((((-1.0)*new_r11*new_r22))+(((-1.0)*x368))+((new_r12*new_r21)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j16]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nCheckValue<IkReal> x371=IKPowWithIntegerCheck(cj15,-1);\nif(!x371.valid){\ncontinue;\n}\nIkReal x370=x371.value;\nCheckValue<IkReal> x372=IKPowWithIntegerCheck(cj14,-1);\nif(!x372.valid){\ncontinue;\n}\nCheckValue<IkReal> x373=IKPowWithIntegerCheck(sj15,-1);\nif(!x373.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r20*x370)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x370*(x372.value)*(x373.value)*(((((-1.0)*cj15*new_r11))+((new_r20*sj14)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20*x370))+IKsqr((x370*(x372.value)*(x373.value)*(((((-1.0)*cj15*new_r11))+((new_r20*sj14))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((-1.0)*new_r20*x370), (x370*(x372.value)*(x373.value)*(((((-1.0)*cj15*new_r11))+((new_r20*sj14))))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[12];\nIkReal x374=IKsin(j16);\nIkReal x375=IKcos(j16);\nIkReal x376=((1.0)*cj14);\nIkReal x377=((1.0)*sj14);\nIkReal x378=(sj14*sj15);\nIkReal x379=((1.0)*cj15);\nIkReal x380=((1.0)*x375);\nIkReal x381=((1.0)*x374);\nIkReal x382=(sj15*x375);\nIkReal x383=(cj14*x374);\nevalcond[0]=(((cj15*x374))+new_r20);\nevalcond[1]=(((cj15*x375))+new_r21);\nevalcond[2]=(((cj14*new_r01))+x374+((new_r11*sj14)));\nevalcond[3]=(((cj14*new_r00))+(((-1.0)*x380))+((new_r10*sj14)));\nevalcond[4]=(((sj14*x374))+((cj14*x382))+new_r11);\nevalcond[5]=((((-1.0)*new_r00*x377))+((sj15*x374))+((cj14*new_r10)));\nevalcond[6]=(((cj14*new_r11))+x382+(((-1.0)*new_r01*x377)));\nevalcond[7]=(x383+new_r01+(((-1.0)*x377*x382)));\nevalcond[8]=(((sj15*x383))+new_r10+(((-1.0)*x375*x377)));\nevalcond[9]=((((-1.0)*sj15*x374*x377))+new_r00+(((-1.0)*x375*x376)));\nevalcond[10]=((((-1.0)*new_r10*sj15*x376))+(((-1.0)*new_r20*x379))+((new_r00*x378))+(((-1.0)*x381)));\nevalcond[11]=((((-1.0)*new_r21*x379))+((new_r01*x378))+(((-1.0)*new_r11*sj15*x376))+(((-1.0)*x380)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nCheckValue<IkReal> x385=IKPowWithIntegerCheck(cj15,-1);\nif(!x385.valid){\ncontinue;\n}\nIkReal x384=x385.value;\nCheckValue<IkReal> x386=IKPowWithIntegerCheck(sj14,-1);\nif(!x386.valid){\ncontinue;\n}\nif( IKabs((x384*(x386.value)*(((((-1.0)*cj15*new_r11))+((cj14*new_r21*sj15)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21*x384)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x384*(x386.value)*(((((-1.0)*cj15*new_r11))+((cj14*new_r21*sj15))))))+IKsqr(((-1.0)*new_r21*x384))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2((x384*(x386.value)*(((((-1.0)*cj15*new_r11))+((cj14*new_r21*sj15))))), ((-1.0)*new_r21*x384));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[12];\nIkReal x387=IKsin(j16);\nIkReal x388=IKcos(j16);\nIkReal x389=((1.0)*cj14);\nIkReal x390=((1.0)*sj14);\nIkReal x391=(sj14*sj15);\nIkReal x392=((1.0)*cj15);\nIkReal x393=((1.0)*x388);\nIkReal x394=((1.0)*x387);\nIkReal x395=(sj15*x388);\nIkReal x396=(cj14*x387);\nevalcond[0]=(((cj15*x387))+new_r20);\nevalcond[1]=(((cj15*x388))+new_r21);\nevalcond[2]=(((cj14*new_r01))+x387+((new_r11*sj14)));\nevalcond[3]=((((-1.0)*x393))+((cj14*new_r00))+((new_r10*sj14)));\nevalcond[4]=(((sj14*x387))+new_r11+((cj14*x395)));\nevalcond[5]=(((cj14*new_r10))+((sj15*x387))+(((-1.0)*new_r00*x390)));\nevalcond[6]=((((-1.0)*new_r01*x390))+((cj14*new_r11))+x395);\nevalcond[7]=(x396+(((-1.0)*x390*x395))+new_r01);\nevalcond[8]=((((-1.0)*x388*x390))+new_r10+((sj15*x396)));\nevalcond[9]=((((-1.0)*sj15*x387*x390))+new_r00+(((-1.0)*x388*x389)));\nevalcond[10]=((((-1.0)*x394))+(((-1.0)*new_r10*sj15*x389))+((new_r00*x391))+(((-1.0)*new_r20*x392)));\nevalcond[11]=((((-1.0)*x393))+(((-1.0)*new_r21*x392))+(((-1.0)*new_r11*sj15*x389))+((new_r01*x391)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nCheckValue<IkReal> x397=IKPowWithIntegerCheck(IKsign(cj15),-1);\nif(!x397.valid){\ncontinue;\n}\nCheckValue<IkReal> x398 = IKatan2WithCheck(IkReal(((-1.0)*new_r20)),((-1.0)*new_r21),IKFAST_ATAN2_MAGTHRESH);\nif(!x398.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x397.value)))+(x398.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[12];\nIkReal x399=IKsin(j16);\nIkReal x400=IKcos(j16);\nIkReal x401=((1.0)*cj14);\nIkReal x402=((1.0)*sj14);\nIkReal x403=(sj14*sj15);\nIkReal x404=((1.0)*cj15);\nIkReal x405=((1.0)*x400);\nIkReal x406=((1.0)*x399);\nIkReal x407=(sj15*x400);\nIkReal x408=(cj14*x399);\nevalcond[0]=(((cj15*x399))+new_r20);\nevalcond[1]=(((cj15*x400))+new_r21);\nevalcond[2]=(((cj14*new_r01))+x399+((new_r11*sj14)));\nevalcond[3]=(((cj14*new_r00))+((new_r10*sj14))+(((-1.0)*x405)));\nevalcond[4]=(((sj14*x399))+((cj14*x407))+new_r11);\nevalcond[5]=(((cj14*new_r10))+(((-1.0)*new_r00*x402))+((sj15*x399)));\nevalcond[6]=(((cj14*new_r11))+x407+(((-1.0)*new_r01*x402)));\nevalcond[7]=((((-1.0)*x402*x407))+x408+new_r01);\nevalcond[8]=((((-1.0)*x400*x402))+((sj15*x408))+new_r10);\nevalcond[9]=((((-1.0)*x400*x401))+new_r00+(((-1.0)*sj15*x399*x402)));\nevalcond[10]=((((-1.0)*new_r10*sj15*x401))+(((-1.0)*new_r20*x404))+(((-1.0)*x406))+((new_r00*x403)));\nevalcond[11]=((((-1.0)*new_r21*x404))+(((-1.0)*new_r11*sj15*x401))+((new_r01*x403))+(((-1.0)*x405)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nCheckValue<IkReal> x409=IKPowWithIntegerCheck(IKsign(cj15),-1);\nif(!x409.valid){\ncontinue;\n}\nCheckValue<IkReal> x410 = IKatan2WithCheck(IkReal(((-1.0)*new_r02)),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x410.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x409.value)))+(x410.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[8];\nIkReal x411=IKsin(j14);\nIkReal x412=IKcos(j14);\nIkReal x413=((1.0)*sj15);\nIkReal x414=((1.0)*cj15);\nIkReal x415=(cj15*x411);\nIkReal x416=(cj15*x412);\nIkReal x417=(new_r02*x411);\nIkReal x418=(new_r12*x412);\nevalcond[0]=(x415+new_r02);\nevalcond[1]=((((-1.0)*x412*x414))+new_r12);\nevalcond[2]=(((new_r12*x411))+((new_r02*x412)));\nevalcond[3]=(x418+(((-1.0)*x414))+(((-1.0)*x417)));\nevalcond[4]=((((-1.0)*new_r00*x411*x414))+(((-1.0)*new_r20*x413))+((new_r10*x416)));\nevalcond[5]=((((-1.0)*new_r21*x413))+(((-1.0)*new_r01*x411*x414))+((new_r11*x416)));\nevalcond[6]=(((sj15*x417))+(((-1.0)*x413*x418))+(((-1.0)*new_r22*x414)));\nevalcond[7]=((-1.0)+((new_r12*x416))+(((-1.0)*x414*x417))+(((-1.0)*new_r22*x413)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j16eval[2];\nIkReal x419=(cj12*cj13);\nIkReal x420=((1.0)*sj10);\nIkReal x421=(cj11*cj12);\nIkReal x422=(cj11*cj13);\nIkReal x423=(sj11*sj13);\nIkReal x424=((1.0)*cj10);\nIkReal x425=(cj12*sj11);\nIkReal x426=(cj12*sj13);\nIkReal x427=(cj10*x426);\nIkReal x428=((1.0)*cj13*sj11);\nIkReal x429=((-1.0)*sj10);\nIkReal x430=((1.0)*cj11*sj13);\nIkReal x431=x137;\nIkReal x432=x138;\nIkReal x433=x139;\nIkReal x434=x140;\nIkReal x435=x141;\nIkReal x436=x142;\nIkReal x437=(cj10*x435);\nIkReal x438=(((cj10*x434))+((sj10*x426)));\nIkReal x439=((((-1.0)*x420*x434))+x427);\nIkReal x440=(((x419*x429))+x437);\nIkReal x441=((((-1.0)*x420*x435))+(((-1.0)*x419*x424)));\nnew_r00=(((r20*x421))+((r00*x431))+((r10*x432)));\nnew_r01=(((r21*x421))+((r01*x431))+((r11*x432)));\nnew_r02=(((r12*x432))+((r02*x431))+((r22*x421)));\nnew_r10=(((r00*((((x429*x435))+(((-1.0)*cj10*x419))))))+((r10*((x437+(((-1.0)*x419*x420))))))+((r20*x433)));\nnew_r11=(((r21*x433))+((r01*x441))+((r11*x440)));\nnew_r12=(((r02*x441))+((r22*x433))+((r12*x440)));\nnew_r20=(((r00*x439))+((r10*x438))+((r20*x436)));\nnew_r21=(((r21*x436))+((r01*x439))+((r11*x438)));\nnew_r22=(((r12*x438))+((r22*x436))+((r02*((((x429*x434))+x427)))));\nj16eval[0]=cj15;\nj16eval[1]=IKsign(cj15);\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[2];\nIkReal x442=(cj12*cj13);\nIkReal x443=((1.0)*sj10);\nIkReal x444=(cj11*cj12);\nIkReal x445=(cj11*cj13);\nIkReal x446=(sj11*sj13);\nIkReal x447=((1.0)*cj10);\nIkReal x448=(cj12*sj11);\nIkReal x449=(cj12*sj13);\nIkReal x450=(cj10*x449);\nIkReal x451=((1.0)*cj13*sj11);\nIkReal x452=((-1.0)*sj10);\nIkReal x453=((1.0)*cj11*sj13);\nIkReal x454=x137;\nIkReal x455=x138;\nIkReal x456=x139;\nIkReal x457=x140;\nIkReal x458=x141;\nIkReal x459=x142;\nIkReal x460=(cj10*x458);\nIkReal x461=(((cj10*x457))+((sj10*x449)));\nIkReal x462=((((-1.0)*x443*x457))+x450);\nIkReal x463=(x460+((x442*x452)));\nIkReal x464=((((-1.0)*x443*x458))+(((-1.0)*x442*x447)));\nnew_r00=(((r00*x454))+((r20*x444))+((r10*x455)));\nnew_r01=(((r21*x444))+((r11*x455))+((r01*x454)));\nnew_r02=(((r22*x444))+((r12*x455))+((r02*x454)));\nnew_r10=(((r10*((x460+(((-1.0)*x442*x443))))))+((r00*(((((-1.0)*cj10*x442))+((x452*x458))))))+((r20*x456)));\nnew_r11=(((r11*x463))+((r01*x464))+((r21*x456)));\nnew_r12=(((r12*x463))+((r02*x464))+((r22*x456)));\nnew_r20=(((r20*x459))+((r00*x462))+((r10*x461)));\nnew_r21=(((r11*x461))+((r01*x462))+((r21*x459)));\nnew_r22=(((r02*((((x452*x457))+x450))))+((r12*x461))+((r22*x459)));\nj16eval[0]=cj15;\nj16eval[1]=sj14;\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[3];\nIkReal x465=(cj12*cj13);\nIkReal x466=((1.0)*sj10);\nIkReal x467=(cj11*cj12);\nIkReal x468=(cj11*cj13);\nIkReal x469=(sj11*sj13);\nIkReal x470=((1.0)*cj10);\nIkReal x471=(cj12*sj11);\nIkReal x472=(cj12*sj13);\nIkReal x473=(cj10*x472);\nIkReal x474=((1.0)*cj13*sj11);\nIkReal x475=((-1.0)*sj10);\nIkReal x476=((1.0)*cj11*sj13);\nIkReal x477=x137;\nIkReal x478=x138;\nIkReal x479=x139;\nIkReal x480=x140;\nIkReal x481=x141;\nIkReal x482=x142;\nIkReal x483=(cj10*x481);\nIkReal x484=(((sj10*x472))+((cj10*x480)));\nIkReal x485=((((-1.0)*x466*x480))+x473);\nIkReal x486=(((x465*x475))+x483);\nIkReal x487=((((-1.0)*x466*x481))+(((-1.0)*x465*x470)));\nnew_r00=(((r10*x478))+((r20*x467))+((r00*x477)));\nnew_r01=(((r11*x478))+((r21*x467))+((r01*x477)));\nnew_r02=(((r22*x467))+((r02*x477))+((r12*x478)));\nnew_r10=(((r00*(((((-1.0)*cj10*x465))+((x475*x481))))))+((r20*x479))+((r10*(((((-1.0)*x465*x466))+x483)))));\nnew_r11=(((r21*x479))+((r11*x486))+((r01*x487)));\nnew_r12=(((r02*x487))+((r12*x486))+((r22*x479)));\nnew_r20=(((r20*x482))+((r10*x484))+((r00*x485)));\nnew_r21=(((r11*x484))+((r21*x482))+((r01*x485)));\nnew_r22=(((r12*x484))+((r22*x482))+((r02*((((x475*x480))+x473)))));\nj16eval[0]=cj15;\nj16eval[1]=cj14;\nj16eval[2]=sj15;\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x488=(new_r12*sj14);\nIkReal x489=(new_r02*sj14);\nIkReal x490=(cj14*new_r12);\nIkReal x491=(cj14*new_r02);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j15)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r20;\nevalcond[4]=new_r21;\nevalcond[5]=new_r12;\nevalcond[6]=(x488+x491);\nevalcond[7]=((((-1.0)*x488))+(((-1.0)*x491)));\nevalcond[8]=((((-1.0)*x489))+x490);\nevalcond[9]=((((-1.0)*x490))+x489);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x492=((1.0)*cj14);\nif( IKabs(((((-1.0)*new_r01*x492))+(((-1.0)*new_r11*sj14)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x492))+((new_r01*sj14)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x492))+(((-1.0)*new_r11*sj14))))+IKsqr(((((-1.0)*new_r11*x492))+((new_r01*sj14))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((((-1.0)*new_r01*x492))+(((-1.0)*new_r11*sj14))), ((((-1.0)*new_r11*x492))+((new_r01*sj14))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x493=IKsin(j16);\nIkReal x494=IKcos(j16);\nIkReal x495=((1.0)*sj14);\nIkReal x496=(cj14*x493);\nIkReal x497=((1.0)*x494);\nIkReal x498=(x494*x495);\nevalcond[0]=(((cj14*new_r01))+x493+((new_r11*sj14)));\nevalcond[1]=((((-1.0)*new_r00*x495))+((cj14*new_r10))+x493);\nevalcond[2]=(((cj14*new_r11))+(((-1.0)*new_r01*x495))+x494);\nevalcond[3]=((((-1.0)*x497))+((cj14*new_r00))+((new_r10*sj14)));\nevalcond[4]=(new_r11+((sj14*x493))+((cj14*x494)));\nevalcond[5]=((((-1.0)*x498))+x496+new_r01);\nevalcond[6]=((((-1.0)*x498))+x496+new_r10);\nevalcond[7]=((((-1.0)*cj14*x497))+(((-1.0)*x493*x495))+new_r00);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x499=(new_r12*sj14);\nIkReal x500=(cj14*new_r02);\nIkReal x501=(((cj14*new_r12))+(((-1.0)*new_r02*sj14)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j15)))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r20;\nevalcond[4]=new_r21;\nevalcond[5]=new_r12;\nevalcond[6]=(x499+x500);\nevalcond[7]=((((-1.0)*x499))+(((-1.0)*x500)));\nevalcond[8]=x501;\nevalcond[9]=x501;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x502=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj14*x502))+(((-1.0)*new_r11*sj14)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj14*new_r11))+(((-1.0)*sj14*x502)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj14*x502))+(((-1.0)*new_r11*sj14))))+IKsqr((((cj14*new_r11))+(((-1.0)*sj14*x502))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((((-1.0)*cj14*x502))+(((-1.0)*new_r11*sj14))), (((cj14*new_r11))+(((-1.0)*sj14*x502))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x503=IKsin(j16);\nIkReal x504=IKcos(j16);\nIkReal x505=((1.0)*sj14);\nIkReal x506=((1.0)*x504);\nIkReal x507=(sj14*x503);\nIkReal x508=((1.0)*x503);\nIkReal x509=(cj14*x506);\nevalcond[0]=(((cj14*new_r01))+x503+((new_r11*sj14)));\nevalcond[1]=(((cj14*new_r00))+(((-1.0)*x506))+((new_r10*sj14)));\nevalcond[2]=(((cj14*x503))+new_r01+((sj14*x504)));\nevalcond[3]=((((-1.0)*x509))+x507+new_r11);\nevalcond[4]=(((cj14*new_r10))+(((-1.0)*new_r00*x505))+(((-1.0)*x508)));\nevalcond[5]=(((cj14*new_r11))+(((-1.0)*new_r01*x505))+(((-1.0)*x506)));\nevalcond[6]=((((-1.0)*x509))+x507+new_r00);\nevalcond[7]=((((-1.0)*cj14*x508))+(((-1.0)*x504*x505))+new_r10);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x510=(sj15+new_r22);\nIkReal x511=((1.0)*sj15);\nIkReal x512=((1.0)*cj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j14)))), 6.28318530717959)));\nevalcond[1]=x510;\nevalcond[2]=x510;\nevalcond[3]=(cj15+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*new_r02))+(((-1.0)*x512)));\nevalcond[6]=((((-1.0)*new_r20*x511))+(((-1.0)*new_r00*x512)));\nevalcond[7]=((((-1.0)*new_r01*x512))+(((-1.0)*new_r21*x511)));\nevalcond[8]=((((-1.0)*new_r22*x512))+((new_r02*sj15)));\nevalcond[9]=((-1.0)+(((-1.0)*new_r22*x511))+(((-1.0)*new_r02*x512)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nif( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((-1.0)*new_r11), new_r10);\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x513=IKsin(j16);\nIkReal x514=IKcos(j16);\nIkReal x515=((1.0)*new_r22);\nIkReal x516=((1.0)*x514);\nIkReal x517=((1.0)*x513);\nevalcond[0]=(x513+new_r11);\nevalcond[1]=(new_r10+(((-1.0)*x516)));\nevalcond[2]=((((-1.0)*new_r02*x517))+new_r20);\nevalcond[3]=((((-1.0)*new_r02*x516))+new_r21);\nevalcond[4]=((((-1.0)*x513*x515))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*x514*x515))+(((-1.0)*new_r01)));\nevalcond[6]=((((-1.0)*new_r00*x515))+((new_r02*new_r20))+(((-1.0)*x517)));\nevalcond[7]=((((-1.0)*new_r01*x515))+((new_r02*new_r21))+(((-1.0)*x516)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x518=(sj15+new_r22);\nIkReal x519=((((-1.0)*cj15))+new_r02);\nIkReal x520=((1.0)*sj15);\nIkReal x521=((1.0)*cj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j14)))), 6.28318530717959)));\nevalcond[1]=x518;\nevalcond[2]=x518;\nevalcond[3]=x519;\nevalcond[4]=new_r12;\nevalcond[5]=x519;\nevalcond[6]=((((-1.0)*new_r20*x520))+((cj15*new_r00)));\nevalcond[7]=((((-1.0)*new_r21*x520))+((cj15*new_r01)));\nevalcond[8]=((((-1.0)*new_r22*x521))+(((-1.0)*new_r02*x520)));\nevalcond[9]=((-1.0)+(((-1.0)*new_r22*x520))+((cj15*new_r02)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nCheckValue<IkReal> x522=IKPowWithIntegerCheck(IKsign(new_r02),-1);\nif(!x522.valid){\ncontinue;\n}\nCheckValue<IkReal> x523 = IKatan2WithCheck(IkReal(((-1.0)*new_r20)),((-1.0)*new_r21),IKFAST_ATAN2_MAGTHRESH);\nif(!x523.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x522.value)))+(x523.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x524=IKsin(j16);\nIkReal x525=IKcos(j16);\nIkReal x526=((1.0)*new_r02);\nIkReal x527=((1.0)*x525);\nIkReal x528=((1.0)*x524);\nevalcond[0]=(((new_r02*x524))+new_r20);\nevalcond[1]=(((new_r02*x525))+new_r21);\nevalcond[2]=(x524+(((-1.0)*new_r11)));\nevalcond[3]=((((-1.0)*new_r22*x528))+new_r00);\nevalcond[4]=((((-1.0)*new_r22*x527))+new_r01);\nevalcond[5]=((((-1.0)*x527))+(((-1.0)*new_r10)));\nevalcond[6]=(((new_r00*new_r22))+(((-1.0)*new_r20*x526))+(((-1.0)*x528)));\nevalcond[7]=(((new_r01*new_r22))+(((-1.0)*x527))+(((-1.0)*new_r21*x526)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x529=((1.0)*sj14);\nIkReal x530=(cj14*new_r02);\nIkReal x531=(((cj14*new_r10))+(((-1.0)*new_r00*x529)));\nIkReal x532=(((cj14*new_r11))+(((-1.0)*new_r01*x529)));\nIkReal x533=((-1.0)+((cj14*new_r12))+(((-1.0)*new_r02*x529)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j15))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(sj14+new_r02);\nevalcond[3]=((((-1.0)*cj14))+new_r12);\nevalcond[4]=(x530+((new_r12*sj14)));\nevalcond[5]=((((-1.0)*x530))+(((-1.0)*new_r12*x529)));\nevalcond[6]=x533;\nevalcond[7]=x531;\nevalcond[8]=x532;\nevalcond[9]=x531;\nevalcond[10]=x532;\nevalcond[11]=x533;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nif( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x534=IKsin(j16);\nIkReal x535=IKcos(j16);\nIkReal x536=((1.0)*new_r02);\nIkReal x537=((1.0)*x535);\nevalcond[0]=(x534+new_r20);\nevalcond[1]=(x535+new_r21);\nevalcond[2]=(((new_r12*x534))+new_r01);\nevalcond[3]=(((new_r02*x535))+new_r10);\nevalcond[4]=((((-1.0)*x534*x536))+new_r11);\nevalcond[5]=((((-1.0)*new_r12*x537))+new_r00);\nevalcond[6]=(((new_r01*new_r12))+(((-1.0)*new_r11*x536))+x534);\nevalcond[7]=((((-1.0)*x537))+((new_r00*new_r12))+(((-1.0)*new_r10*x536)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x538=((1.0)*sj14);\nIkReal x539=(cj14*new_r10);\nIkReal x540=(cj14*new_r12);\nIkReal x541=((1.0)*cj14);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j15)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*x538))+new_r02);\nevalcond[3]=(cj14+new_r12);\nevalcond[4]=(((cj14*new_r02))+((new_r12*sj14)));\nevalcond[5]=((((-1.0)*new_r12*x538))+(((-1.0)*new_r02*x541)));\nevalcond[6]=((1.0)+x540+(((-1.0)*new_r02*x538)));\nevalcond[7]=((((-1.0)*new_r00*x538))+x539);\nevalcond[8]=(((cj14*new_r11))+(((-1.0)*new_r01*x538)));\nevalcond[9]=((((-1.0)*x539))+((new_r00*sj14)));\nevalcond[10]=((((-1.0)*new_r11*x541))+((new_r01*sj14)));\nevalcond[11]=((-1.0)+(((-1.0)*x540))+((new_r02*sj14)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nif( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(new_r20, new_r21);\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x542=IKsin(j16);\nIkReal x543=IKcos(j16);\nIkReal x544=((1.0)*new_r12);\nIkReal x545=((1.0)*x543);\nIkReal x546=((1.0)*x542);\nevalcond[0]=((((-1.0)*x546))+new_r20);\nevalcond[1]=((((-1.0)*x545))+new_r21);\nevalcond[2]=(((new_r02*x542))+new_r11);\nevalcond[3]=(((new_r12*x543))+new_r00);\nevalcond[4]=((((-1.0)*x542*x544))+new_r01);\nevalcond[5]=(new_r10+(((-1.0)*new_r02*x545)));\nevalcond[6]=((((-1.0)*new_r01*x544))+x542+((new_r02*new_r11)));\nevalcond[7]=((((-1.0)*new_r00*x544))+(((-1.0)*x545))+((new_r02*new_r10)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x547=(sj15+new_r22);\nIkReal x548=((((-1.0)*cj15))+new_r12);\nIkReal x549=((1.0)*sj15);\nIkReal x550=((1.0)*cj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));\nevalcond[1]=x547;\nevalcond[2]=x547;\nevalcond[3]=new_r02;\nevalcond[4]=x548;\nevalcond[5]=x548;\nevalcond[6]=((((-1.0)*new_r20*x549))+((cj15*new_r10)));\nevalcond[7]=(((cj15*new_r11))+(((-1.0)*new_r21*x549)));\nevalcond[8]=((((-1.0)*new_r22*x550))+(((-1.0)*new_r12*x549)));\nevalcond[9]=((-1.0)+(((-1.0)*new_r22*x549))+((cj15*new_r12)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nif( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((-1.0)*new_r01), new_r00);\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x551=IKsin(j16);\nIkReal x552=IKcos(j16);\nIkReal x553=((1.0)*new_r12);\nIkReal x554=((1.0)*x552);\nIkReal x555=((1.0)*x551);\nevalcond[0]=(x551+new_r01);\nevalcond[1]=(((new_r12*x551))+new_r20);\nevalcond[2]=(((new_r12*x552))+new_r21);\nevalcond[3]=((((-1.0)*x554))+new_r00);\nevalcond[4]=((((-1.0)*new_r22*x554))+new_r11);\nevalcond[5]=((((-1.0)*new_r22*x555))+new_r10);\nevalcond[6]=((((-1.0)*x555))+(((-1.0)*new_r20*x553))+((new_r10*new_r22)));\nevalcond[7]=((((-1.0)*new_r21*x553))+(((-1.0)*x554))+((new_r11*new_r22)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x556=(sj15+new_r22);\nIkReal x557=((1.0)*cj15);\nIkReal x558=((1.0)*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));\nevalcond[1]=x556;\nevalcond[2]=x556;\nevalcond[3]=new_r02;\nevalcond[4]=(cj15+new_r12);\nevalcond[5]=((((-1.0)*x557))+(((-1.0)*new_r12)));\nevalcond[6]=((((-1.0)*new_r10*x557))+(((-1.0)*new_r20*x558)));\nevalcond[7]=((((-1.0)*new_r21*x558))+(((-1.0)*new_r11*x557)));\nevalcond[8]=((((-1.0)*new_r22*x557))+((new_r12*sj15)));\nevalcond[9]=((-1.0)+(((-1.0)*new_r22*x558))+(((-1.0)*new_r12*x557)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nif( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(new_r01, ((-1.0)*new_r00));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[8];\nIkReal x559=IKsin(j16);\nIkReal x560=IKcos(j16);\nIkReal x561=((1.0)*new_r10);\nIkReal x562=((1.0)*x560);\nIkReal x563=((1.0)*x559);\nevalcond[0]=(x559+(((-1.0)*new_r01)));\nevalcond[1]=(((new_r22*x560))+new_r11);\nevalcond[2]=((((-1.0)*new_r12*x563))+new_r20);\nevalcond[3]=((((-1.0)*new_r12*x562))+new_r21);\nevalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x562)));\nevalcond[5]=((((-1.0)*new_r22*x563))+(((-1.0)*x561)));\nevalcond[6]=(((new_r12*new_r20))+(((-1.0)*new_r22*x561))+(((-1.0)*x563)));\nevalcond[7]=((((-1.0)*new_r11*new_r22))+((new_r12*new_r21))+(((-1.0)*x562)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j16]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nCheckValue<IkReal> x565=IKPowWithIntegerCheck(cj15,-1);\nif(!x565.valid){\ncontinue;\n}\nIkReal x564=x565.value;\nCheckValue<IkReal> x566=IKPowWithIntegerCheck(cj14,-1);\nif(!x566.valid){\ncontinue;\n}\nCheckValue<IkReal> x567=IKPowWithIntegerCheck(sj15,-1);\nif(!x567.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r20*x564)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x564*(x566.value)*(x567.value)*(((((-1.0)*cj15*new_r11))+((new_r20*sj14)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20*x564))+IKsqr((x564*(x566.value)*(x567.value)*(((((-1.0)*cj15*new_r11))+((new_r20*sj14))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2(((-1.0)*new_r20*x564), (x564*(x566.value)*(x567.value)*(((((-1.0)*cj15*new_r11))+((new_r20*sj14))))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[12];\nIkReal x568=IKsin(j16);\nIkReal x569=IKcos(j16);\nIkReal x570=((1.0)*cj14);\nIkReal x571=((1.0)*sj14);\nIkReal x572=(sj14*sj15);\nIkReal x573=((1.0)*cj15);\nIkReal x574=((1.0)*x569);\nIkReal x575=((1.0)*x568);\nIkReal x576=(sj15*x569);\nIkReal x577=(cj14*x568);\nevalcond[0]=(((cj15*x568))+new_r20);\nevalcond[1]=(((cj15*x569))+new_r21);\nevalcond[2]=(((cj14*new_r01))+x568+((new_r11*sj14)));\nevalcond[3]=(((cj14*new_r00))+(((-1.0)*x574))+((new_r10*sj14)));\nevalcond[4]=(((sj14*x568))+((cj14*x576))+new_r11);\nevalcond[5]=(((sj15*x568))+((cj14*new_r10))+(((-1.0)*new_r00*x571)));\nevalcond[6]=(((cj14*new_r11))+x576+(((-1.0)*new_r01*x571)));\nevalcond[7]=((((-1.0)*x571*x576))+x577+new_r01);\nevalcond[8]=((((-1.0)*x569*x571))+((sj15*x577))+new_r10);\nevalcond[9]=((((-1.0)*x569*x570))+(((-1.0)*sj15*x568*x571))+new_r00);\nevalcond[10]=(((new_r00*x572))+(((-1.0)*x575))+(((-1.0)*new_r20*x573))+(((-1.0)*new_r10*sj15*x570)));\nevalcond[11]=(((new_r01*x572))+(((-1.0)*new_r11*sj15*x570))+(((-1.0)*x574))+(((-1.0)*new_r21*x573)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nCheckValue<IkReal> x579=IKPowWithIntegerCheck(cj15,-1);\nif(!x579.valid){\ncontinue;\n}\nIkReal x578=x579.value;\nCheckValue<IkReal> x580=IKPowWithIntegerCheck(sj14,-1);\nif(!x580.valid){\ncontinue;\n}\nif( IKabs((x578*(x580.value)*(((((-1.0)*cj15*new_r11))+((cj14*new_r21*sj15)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21*x578)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x578*(x580.value)*(((((-1.0)*cj15*new_r11))+((cj14*new_r21*sj15))))))+IKsqr(((-1.0)*new_r21*x578))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj16array[0]=IKatan2((x578*(x580.value)*(((((-1.0)*cj15*new_r11))+((cj14*new_r21*sj15))))), ((-1.0)*new_r21*x578));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[12];\nIkReal x581=IKsin(j16);\nIkReal x582=IKcos(j16);\nIkReal x583=((1.0)*cj14);\nIkReal x584=((1.0)*sj14);\nIkReal x585=(sj14*sj15);\nIkReal x586=((1.0)*cj15);\nIkReal x587=((1.0)*x582);\nIkReal x588=((1.0)*x581);\nIkReal x589=(sj15*x582);\nIkReal x590=(cj14*x581);\nevalcond[0]=(((cj15*x581))+new_r20);\nevalcond[1]=(((cj15*x582))+new_r21);\nevalcond[2]=(((cj14*new_r01))+x581+((new_r11*sj14)));\nevalcond[3]=(((cj14*new_r00))+((new_r10*sj14))+(((-1.0)*x587)));\nevalcond[4]=(((sj14*x581))+new_r11+((cj14*x589)));\nevalcond[5]=(((cj14*new_r10))+((sj15*x581))+(((-1.0)*new_r00*x584)));\nevalcond[6]=(((cj14*new_r11))+(((-1.0)*new_r01*x584))+x589);\nevalcond[7]=((((-1.0)*x584*x589))+x590+new_r01);\nevalcond[8]=((((-1.0)*x582*x584))+((sj15*x590))+new_r10);\nevalcond[9]=((((-1.0)*x582*x583))+(((-1.0)*sj15*x581*x584))+new_r00);\nevalcond[10]=((((-1.0)*new_r20*x586))+((new_r00*x585))+(((-1.0)*new_r10*sj15*x583))+(((-1.0)*x588)));\nevalcond[11]=((((-1.0)*new_r21*x586))+((new_r01*x585))+(((-1.0)*x587))+(((-1.0)*new_r11*sj15*x583)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nCheckValue<IkReal> x591=IKPowWithIntegerCheck(IKsign(cj15),-1);\nif(!x591.valid){\ncontinue;\n}\nCheckValue<IkReal> x592 = IKatan2WithCheck(IkReal(((-1.0)*new_r20)),((-1.0)*new_r21),IKFAST_ATAN2_MAGTHRESH);\nif(!x592.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x591.value)))+(x592.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[12];\nIkReal x593=IKsin(j16);\nIkReal x594=IKcos(j16);\nIkReal x595=((1.0)*cj14);\nIkReal x596=((1.0)*sj14);\nIkReal x597=(sj14*sj15);\nIkReal x598=((1.0)*cj15);\nIkReal x599=((1.0)*x594);\nIkReal x600=((1.0)*x593);\nIkReal x601=(sj15*x594);\nIkReal x602=(cj14*x593);\nevalcond[0]=(((cj15*x593))+new_r20);\nevalcond[1]=(((cj15*x594))+new_r21);\nevalcond[2]=(((cj14*new_r01))+x593+((new_r11*sj14)));\nevalcond[3]=(((cj14*new_r00))+(((-1.0)*x599))+((new_r10*sj14)));\nevalcond[4]=(((cj14*x601))+new_r11+((sj14*x593)));\nevalcond[5]=(((cj14*new_r10))+(((-1.0)*new_r00*x596))+((sj15*x593)));\nevalcond[6]=(((cj14*new_r11))+(((-1.0)*new_r01*x596))+x601);\nevalcond[7]=((((-1.0)*x596*x601))+x602+new_r01);\nevalcond[8]=((((-1.0)*x594*x596))+new_r10+((sj15*x602)));\nevalcond[9]=((((-1.0)*x594*x595))+new_r00+(((-1.0)*sj15*x593*x596)));\nevalcond[10]=((((-1.0)*new_r20*x598))+((new_r00*x597))+(((-1.0)*new_r10*sj15*x595))+(((-1.0)*x600)));\nevalcond[11]=((((-1.0)*new_r21*x598))+(((-1.0)*new_r11*sj15*x595))+((new_r01*x597))+(((-1.0)*x599)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j10;\nvinfos[0].indices[0] = _ij10[0];\nvinfos[0].indices[1] = _ij10[1];\nvinfos[0].maxsolutions = _nj10;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\n}};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"eebdaab6fb12dcef053ad06f8aa171e1\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\nchar* ComputeFkWrapper(const IkReal* j) {\n    IkReal eetrans[3] = {0};\n    IkReal eerot[9] = {0};\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n\nstd::vector<IkReal> TrueComputeIk(int argc, char** argv)\n{\n    std::vector<IkReal> solvalues(GetNumJoints());\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return solvalues;\n}\n"]}