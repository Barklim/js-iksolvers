/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2015-05-18 22:22:48.359872
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42;
x0=IKsin(j[0]);
x1=IKcos(j[0]);
x2=IKcos(j[3]);
x3=IKsin(j[3]);
x4=IKcos(j[1]);
x5=IKcos(j[2]);
x6=IKsin(j[1]);
x7=IKsin(j[2]);
x8=IKsin(j[4]);
x9=IKcos(j[4]);
x10=IKsin(j[5]);
x11=IKcos(j[5]);
x12=((0.331)*x5);
x13=((1.0)*x9);
x14=((1.0)*x7);
x15=((1.0)*x0);
x16=((1.0)*x8);
x17=((1.0)*x5);
x18=(x1*x3);
x19=(x0*x4);
x20=(x1*x4);
x21=(x5*x6);
x22=(x1*x6);
x23=(x4*x7);
x24=(x17*x4);
x25=((0.331)*x6*x7);
x26=(x0*x14*x6);
x27=(x17*x20);
x28=(x21+x23);
x29=((((-1.0)*x24))+((x6*x7)));
x30=((((-1.0)*x14*x6))+x24);
x31=(x2*x29);
x32=(((x19*x5))+(((-1.0)*x26)));
x33=(((x22*x7))+(((-1.0)*x27)));
x34=(x3*x30*x9);
x35=((((-1.0)*x15*x21))+(((-1.0)*x14*x19)));
x36=(((x14*x20))+((x17*x22)));
x37=(x32*x8);
x38=(x33*x8);
x39=(x2*x35);
x40=(((x1*x2))+((x3*x35)));
x41=(((x0*x2))+((x3*x36)));
x42=(((x2*x36))+(((-1.0)*x15*x3)));
eerot[0]=(((x11*((x37+((x40*x9))))))+((x10*(((((-1.0)*x18))+x39)))));
eerot[1]=(((x9*((x26+(((-1.0)*x15*x4*x5))))))+((x40*x8)));
eerot[2]=(((x11*(((((-1.0)*x18))+x39))))+((x10*(((((-1.0)*x16*x32))+(((-1.0)*x13*x40)))))));
eetrans[0]=((0.045416)+(((-0.10015)*x1))+((x0*x25))+(((-1.0)*x12*x19))+(((-0.405)*x19)));
eerot[3]=(((x10*x31))+((x11*(((((-1.0)*x16*x28))+(((-1.0)*x13*x3*x30)))))));
eerot[4]=(((x29*x3*x8))+((x28*x9)));
eerot[5]=(((x11*x31))+((x10*((x34+((x28*x8)))))));
eetrans[1]=((0.302408)+(((0.331)*x23))+(((0.405)*x6))+((x12*x6)));
eerot[6]=(((x11*((((x41*x9))+x38))))+((x10*x42)));
eerot[7]=(((x41*x8))+((x9*(((((-1.0)*x14*x22))+x27)))));
eerot[8]=(((x11*x42))+((x10*(((((-1.0)*x16*x33))+(((-1.0)*x13*x41)))))));
eetrans[2]=((0.467052)+(((-0.10015)*x0))+(((-0.331)*x22*x7))+(((0.405)*x20))+((x12*x20)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r02;
new_r02=((-1.0)*r01);
new_px=((-0.045416)+px);
new_r10=r20;
new_r11=r22;
new_r12=((-1.0)*r21);
new_py=((-0.467052)+pz);
new_r20=((-1.0)*r10);
new_r21=((-1.0)*r12);
new_r22=r11;
new_pz=((0.302408)+(((-1.0)*py)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x43=((1.0)*px);
IkReal x44=((1.0)*pz);
IkReal x45=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x45))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x44)));
rxp0_2=((((-1.0)*r10*x43))+((py*r00)));
rxp1_0=((((-1.0)*r21*x45))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x44)));
rxp1_2=((((-1.0)*r11*x43))+((py*r01)));
rxp2_0=((((-1.0)*r22*x45))+((pz*r12)));
rxp2_1=((((-1.0)*r02*x44))+((px*r22)));
rxp2_2=((((-1.0)*r12*x43))+((py*r02)));
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
cj2array[0]=((-1.05783455484689)+(((3.72981239043676)*pp)));
if( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKacos(cj2array[0]);
    sj2array[0] = IKsin(j2array[0]);
    cj2array[1] = cj2array[0];
    j2array[1] = -j2array[0];
    sj2array[1] = -sj2array[0];
}
else if( isnan(cj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j0eval[2];
j0eval[0]=((px*px)+(py*py));
j0eval[1]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
j1eval[0]=((1.49711119832787)+(sj2*sj2)+(cj2*cj2)+(((2.44712990936556)*cj2)));
j1eval[1]=((((3.02114803625378)*(IKabs(((0.405)+(((0.331)*cj2)))))))+(IKabs(sj2)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x46=((0.405)+(((0.331)*cj2)));
CheckValue<IkReal> x49 = IKatan2WithCheck(IkReal(((0.331)*sj2)),x46,IKFAST_ATAN2_MAGTHRESH);
if(!x49.valid){
continue;
}
IkReal x47=((1.0)*(x49.value));
if((((x46*x46)+(((0.109561)*(sj2*sj2))))) < -0.00001)
continue;
CheckValue<IkReal> x50=IKPowWithIntegerCheck(IKabs(IKsqrt(((x46*x46)+(((0.109561)*(sj2*sj2)))))),-1);
if(!x50.valid){
continue;
}
if( ((pz*(x50.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x50.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x48=IKasin((pz*(x50.value)));
j1array[0]=((((-1.0)*x48))+(((-1.0)*x47)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x47))+x48);
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j0eval[3];
IkReal x51=pz*pz;
IkReal x52=((6620.0)*sj2);
IkReal x53=(pp*sj1);
IkReal x54=((2003.0)*sj1);
IkReal x55=(sj1*x51);
IkReal x56=((20000.0)*cj1*pz);
j0eval[0]=(x53+(((-1.0)*x55)));
j0eval[1]=((IKabs((((px*x56))+((px*x52))+(((-1.0)*py*x54)))))+(IKabs(((((-1.0)*px*x54))+(((-1.0)*py*x56))+(((-1.0)*py*x52))))));
j0eval[2]=IKsign(((((20000.0)*x53))+(((-20000.0)*x55))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
IkReal x57=pz*pz;
IkReal x58=(cj1*pp);
IkReal x59=((2003.0)*cj1);
IkReal x60=((6620.0)*cj2);
IkReal x61=((20000.0)*pz*sj1);
IkReal x62=(cj1*x57);
j0eval[0]=(x58+(((-1.0)*x62)));
j0eval[1]=((IKabs(((((-1.0)*px*x59))+(((8100.0)*py))+((py*x61))+((py*x60)))))+(IKabs(((((-1.0)*px*x61))+(((-1.0)*px*x60))+(((-8100.0)*px))+(((-1.0)*py*x59))))));
j0eval[2]=IKsign(((((20000.0)*x58))+(((-20000.0)*x62))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
IkReal x63=pz*pz;
IkReal x64=((2000000.0)*pp);
IkReal x65=((162243.0)*cj1);
IkReal x66=(cj1*pp);
IkReal x67=((1620000.0)*pz*sj1);
IkReal x68=(cj1*x63);
j0eval[0]=(x66+(((-1.0)*x68)));
j0eval[1]=((IKabs(((((-88867.955)*px))+(((-1.0)*px*x67))+(((-1.0)*px*x64))+(((-1.0)*py*x65)))))+(IKabs(((((-1.0)*px*x65))+((py*x67))+((py*x64))+(((88867.955)*py))))));
j0eval[2]=IKsign(((((1620000.0)*x66))+(((-1620000.0)*x68))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
IkReal x69=((1.0)*pp);
IkReal x70=((0.405)+(((0.331)*cj2))+pz);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=((0.2836160225)+(((-1.0)*x69))+(((0.26811)*cj2)));
evalcond[2]=x70;
evalcond[3]=x70;
evalcond[4]=((-0.0444339775)+(((-0.81)*pz))+(((-1.0)*x69)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x71=pz*pz;
IkReal x72=((6620.0)*sj2);
j0eval[0]=(pp+(((-1.0)*x71)));
j0eval[1]=IKsign(((((-20000.0)*x71))+(((20000.0)*pp))));
j0eval[2]=((IKabs(((((-1.0)*py*x72))+(((-2003.0)*px)))))+(IKabs((((px*x72))+(((-2003.0)*py))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x73=((6620.0)*sj2);
CheckValue<IkReal> x74 = IKatan2WithCheck(IkReal((((px*x73))+(((-2003.0)*py)))),((((-1.0)*py*x73))+(((-2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x74.valid){
continue;
}
CheckValue<IkReal> x75=IKPowWithIntegerCheck(IKsign(((((-20000.0)*(pz*pz)))+(((20000.0)*pp)))),-1);
if(!x75.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x74.value)+(((1.5707963267949)*(x75.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x76=IKcos(j0);
IkReal x77=IKsin(j0);
evalcond[0]=((0.10015)+((py*x77))+((px*x76)));
evalcond[1]=(((py*x76))+(((-1.0)*px*x77))+(((0.331)*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x351=((0.331)*cj2);
IkReal x352=((1.0)*pp);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=((0.2836160225)+(((-1.0)*x352))+(((0.26811)*cj2)));
evalcond[2]=((-0.405)+(((-1.0)*x351))+pz);
evalcond[3]=((0.405)+x351+(((-1.0)*pz)));
evalcond[4]=((-0.0444339775)+(((-1.0)*x352))+(((0.81)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x353=pz*pz;
IkReal x354=((6620.0)*sj2);
j0eval[0]=(x353+(((-1.0)*pp)));
j0eval[1]=IKsign(((((-20000.0)*pp))+(((20000.0)*x353))));
j0eval[2]=((IKabs((((px*x354))+(((2003.0)*py)))))+(IKabs(((((-1.0)*py*x354))+(((2003.0)*px))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x355=((6620.0)*sj2);
CheckValue<IkReal> x356 = IKatan2WithCheck(IkReal((((px*x355))+(((2003.0)*py)))),((((-1.0)*py*x355))+(((2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x356.valid){
continue;
}
CheckValue<IkReal> x357=IKPowWithIntegerCheck(IKsign(((((-20000.0)*pp))+(((20000.0)*(pz*pz))))),-1);
if(!x357.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x356.value)+(((1.5707963267949)*(x357.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x358=IKsin(j0);
IkReal x359=IKcos(j0);
evalcond[0]=((0.10015)+((px*x359))+((py*x358)));
evalcond[1]=(((px*x358))+(((-1.0)*py*x359))+(((0.331)*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x360=(pz+(((0.331)*sj2)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=((0.2836160225)+(((-1.0)*pp))+(((0.26811)*cj2)));
evalcond[2]=x360;
evalcond[3]=x360;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x361=pz*pz;
IkReal x362=((24691.3580246914)*pp);
j0eval[0]=(x361+(((-1.0)*pp)));
j0eval[1]=IKsign(((((-20000.0)*pp))+(((20000.0)*x361))));
j0eval[2]=((IKabs(((((-1097.13524691358)*py))+(((-1.0)*py*x362))+(((2003.0)*px)))))+(IKabs(((((1097.13524691358)*px))+((px*x362))+(((2003.0)*py))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x363=pz*pz;
IkReal x364=((2000000.0)*pp);
j0eval[0]=((((-1.0)*x363))+pp);
j0eval[1]=IKsign(((((-1620000.0)*x363))+(((1620000.0)*pp))));
j0eval[2]=((IKabs(((((-88867.955)*px))+(((-162243.0)*py))+(((-1.0)*px*x364)))))+(IKabs((((py*x364))+(((-162243.0)*px))+(((88867.955)*py))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x365=((2000000.0)*pp);
CheckValue<IkReal> x366=IKPowWithIntegerCheck(IKsign(((((-1620000.0)*(pz*pz)))+(((1620000.0)*pp)))),-1);
if(!x366.valid){
continue;
}
CheckValue<IkReal> x367 = IKatan2WithCheck(IkReal(((((-88867.955)*px))+(((-162243.0)*py))+(((-1.0)*px*x365)))),(((py*x365))+(((-162243.0)*px))+(((88867.955)*py))),IKFAST_ATAN2_MAGTHRESH);
if(!x367.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x366.value)))+(x367.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x368=IKsin(j0);
IkReal x369=IKcos(j0);
IkReal x370=(px*x368);
IkReal x371=(py*x369);
evalcond[0]=((0.10015)+((py*x368))+((px*x369)));
evalcond[1]=((0.054856762345679)+(((-1.0)*x371))+x370+(((1.23456790123457)*pp)));
evalcond[2]=((-0.0444339775)+(((-0.81)*x370))+(((-1.0)*pp))+(((0.81)*x371)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x372=((24691.3580246914)*pp);
CheckValue<IkReal> x373 = IKatan2WithCheck(IkReal(((((1097.13524691358)*px))+((px*x372))+(((2003.0)*py)))),((((-1097.13524691358)*py))+(((-1.0)*py*x372))+(((2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x373.valid){
continue;
}
CheckValue<IkReal> x374=IKPowWithIntegerCheck(IKsign(((((-20000.0)*pp))+(((20000.0)*(pz*pz))))),-1);
if(!x374.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x373.value)+(((1.5707963267949)*(x374.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x375=IKsin(j0);
IkReal x376=IKcos(j0);
IkReal x377=(px*x375);
IkReal x378=(py*x376);
evalcond[0]=((0.10015)+((px*x376))+((py*x375)));
evalcond[1]=((0.054856762345679)+(((-1.0)*x378))+x377+(((1.23456790123457)*pp)));
evalcond[2]=((-0.0444339775)+(((-0.81)*x377))+(((-1.0)*pp))+(((0.81)*x378)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x379=((0.331)*sj2);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=((0.2836160225)+(((-1.0)*pp))+(((0.26811)*cj2)));
evalcond[2]=((((-1.0)*x379))+pz);
evalcond[3]=(x379+(((-1.0)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x380=pz*pz;
IkReal x381=((24691.3580246914)*pp);
j0eval[0]=((((-1.0)*x380))+pp);
j0eval[1]=IKsign(((((-20000.0)*x380))+(((20000.0)*pp))));
j0eval[2]=((IKabs(((((-1097.13524691358)*py))+(((-1.0)*py*x381))+(((-2003.0)*px)))))+(IKabs((((px*x381))+(((1097.13524691358)*px))+(((-2003.0)*py))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x382=pz*pz;
IkReal x383=((2000000.0)*pp);
j0eval[0]=(x382+(((-1.0)*pp)));
j0eval[1]=((IKabs(((((162243.0)*px))+((py*x383))+(((88867.955)*py)))))+(IKabs(((((-88867.955)*px))+(((162243.0)*py))+(((-1.0)*px*x383))))));
j0eval[2]=IKsign(((((-1620000.0)*pp))+(((1620000.0)*x382))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x384=((2000000.0)*pp);
CheckValue<IkReal> x385=IKPowWithIntegerCheck(IKsign(((((1620000.0)*(pz*pz)))+(((-1620000.0)*pp)))),-1);
if(!x385.valid){
continue;
}
CheckValue<IkReal> x386 = IKatan2WithCheck(IkReal(((((-88867.955)*px))+(((162243.0)*py))+(((-1.0)*px*x384)))),((((162243.0)*px))+((py*x384))+(((88867.955)*py))),IKFAST_ATAN2_MAGTHRESH);
if(!x386.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x385.value)))+(x386.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x387=IKcos(j0);
IkReal x388=IKsin(j0);
IkReal x389=(px*x388);
IkReal x390=(py*x387);
evalcond[0]=((0.10015)+((px*x387))+((py*x388)));
evalcond[1]=((0.054856762345679)+x390+(((-1.0)*x389))+(((1.23456790123457)*pp)));
evalcond[2]=((-0.0444339775)+(((-0.81)*x390))+(((0.81)*x389))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x391=((24691.3580246914)*pp);
CheckValue<IkReal> x392=IKPowWithIntegerCheck(IKsign(((((-20000.0)*(pz*pz)))+(((20000.0)*pp)))),-1);
if(!x392.valid){
continue;
}
CheckValue<IkReal> x393 = IKatan2WithCheck(IkReal(((((1097.13524691358)*px))+((px*x391))+(((-2003.0)*py)))),((((-1097.13524691358)*py))+(((-1.0)*py*x391))+(((-2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x393.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x392.value)))+(x393.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x394=IKcos(j0);
IkReal x395=IKsin(j0);
IkReal x396=(px*x395);
IkReal x397=(py*x394);
evalcond[0]=((0.10015)+((py*x395))+((px*x394)));
evalcond[1]=((0.054856762345679)+(((-1.0)*x396))+x397+(((1.23456790123457)*pp)));
evalcond[2]=((-0.0444339775)+(((-0.81)*x397))+(((-1.0)*pp))+(((0.81)*x396)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x398=((2000000.0)*pp);
IkReal x399=((1620000.0)*cj1);
IkReal x400=((162243.0)*cj1);
IkReal x401=((1620000.0)*pz*sj1);
CheckValue<IkReal> x402 = IKatan2WithCheck(IkReal(((((-88867.955)*px))+(((-1.0)*px*x401))+(((-1.0)*px*x398))+(((-1.0)*py*x400)))),(((py*x401))+(((-1.0)*px*x400))+((py*x398))+(((88867.955)*py))),IKFAST_ATAN2_MAGTHRESH);
if(!x402.valid){
continue;
}
CheckValue<IkReal> x403=IKPowWithIntegerCheck(IKsign(((((-1.0)*x399*(pz*pz)))+((pp*x399)))),-1);
if(!x403.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x402.value)+(((1.5707963267949)*(x403.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x404=IKcos(j0);
IkReal x405=IKsin(j0);
IkReal x406=((0.81)*cj1);
IkReal x407=((0.331)*sj2);
IkReal x408=(pz*sj1);
IkReal x409=((0.331)*cj2);
IkReal x410=(px*x405);
IkReal x411=(py*x404);
IkReal x412=((1.0)*x411);
evalcond[0]=((0.10015)+((py*x405))+((px*x404)));
evalcond[1]=((((-1.0)*sj1*x410))+((sj1*x411))+((cj1*pz))+x407);
evalcond[2]=((0.405)+(((-1.0)*cj1*x412))+x409+x408+((cj1*x410)));
evalcond[3]=((-0.0444339775)+(((-1.0)*x406*x410))+(((-0.81)*x408))+((x406*x411))+(((-1.0)*pp)));
evalcond[4]=((((0.405)*cj1))+x410+((cj1*x409))+(((-1.0)*x412))+(((-1.0)*sj1*x407)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x413=((2003.0)*cj1);
IkReal x414=((6620.0)*cj2);
IkReal x415=((20000.0)*cj1);
IkReal x416=((20000.0)*pz*sj1);
CheckValue<IkReal> x417 = IKatan2WithCheck(IkReal(((((-1.0)*px*x414))+(((-1.0)*px*x416))+(((-8100.0)*px))+(((-1.0)*py*x413)))),(((py*x414))+((py*x416))+(((-1.0)*px*x413))+(((8100.0)*py))),IKFAST_ATAN2_MAGTHRESH);
if(!x417.valid){
continue;
}
CheckValue<IkReal> x418=IKPowWithIntegerCheck(IKsign(((((-1.0)*x415*(pz*pz)))+((pp*x415)))),-1);
if(!x418.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x417.value)+(((1.5707963267949)*(x418.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x419=IKcos(j0);
IkReal x420=IKsin(j0);
IkReal x421=((0.81)*cj1);
IkReal x422=((0.331)*sj2);
IkReal x423=(pz*sj1);
IkReal x424=((0.331)*cj2);
IkReal x425=(px*x420);
IkReal x426=(py*x419);
IkReal x427=((1.0)*x426);
evalcond[0]=((0.10015)+((px*x419))+((py*x420)));
evalcond[1]=(((cj1*pz))+(((-1.0)*sj1*x425))+x422+((sj1*x426)));
evalcond[2]=((0.405)+(((-1.0)*cj1*x427))+x424+x423+((cj1*x425)));
evalcond[3]=((-0.0444339775)+(((-1.0)*x421*x425))+(((-1.0)*pp))+((x421*x426))+(((-0.81)*x423)));
evalcond[4]=((((-1.0)*sj1*x422))+(((0.405)*cj1))+(((-1.0)*x427))+x425+((cj1*x424)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x428=((6620.0)*sj2);
IkReal x429=((20000.0)*sj1);
IkReal x430=((2003.0)*sj1);
IkReal x431=((20000.0)*cj1*pz);
CheckValue<IkReal> x432=IKPowWithIntegerCheck(IKsign((((pp*x429))+(((-1.0)*x429*(pz*pz))))),-1);
if(!x432.valid){
continue;
}
CheckValue<IkReal> x433 = IKatan2WithCheck(IkReal((((px*x431))+(((-1.0)*py*x430))+((px*x428)))),((((-1.0)*py*x431))+(((-1.0)*py*x428))+(((-1.0)*px*x430))),IKFAST_ATAN2_MAGTHRESH);
if(!x433.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x432.value)))+(x433.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x434=IKcos(j0);
IkReal x435=IKsin(j0);
IkReal x436=((0.81)*cj1);
IkReal x437=((0.331)*sj2);
IkReal x438=(pz*sj1);
IkReal x439=((0.331)*cj2);
IkReal x440=(px*x435);
IkReal x441=(py*x434);
IkReal x442=((1.0)*x441);
evalcond[0]=((0.10015)+((px*x434))+((py*x435)));
evalcond[1]=(((sj1*x441))+(((-1.0)*sj1*x440))+((cj1*pz))+x437);
evalcond[2]=((0.405)+((cj1*x440))+(((-1.0)*cj1*x442))+x438+x439);
evalcond[3]=((-0.0444339775)+(((-0.81)*x438))+(((-1.0)*x436*x440))+(((-1.0)*pp))+((x436*x441)));
evalcond[4]=((((-1.0)*x442))+(((-1.0)*sj1*x437))+((cj1*x439))+(((0.405)*cj1))+x440);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x445 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);
if(!x445.valid){
continue;
}
IkReal x443=((1.0)*(x445.value));
if((((px*px)+(py*py))) < -0.00001)
continue;
CheckValue<IkReal> x446=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);
if(!x446.valid){
continue;
}
if( (((0.10015)*(x446.value))) < -1-IKFAST_SINCOS_THRESH || (((0.10015)*(x446.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x444=IKasin(((0.10015)*(x446.value)));
j0array[0]=((((-1.0)*x443))+(((-1.0)*x444)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x443))+x444);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j1eval[3];
IkReal x447=((331000.0)*cj2);
IkReal x448=(px*sj0);
IkReal x449=(cj0*py);
IkReal x450=((331000.0)*sj2);
j1eval[0]=((1.02042445265003)+cj2);
j1eval[1]=((IKabs((((x447*x449))+(((-405000.0)*x448))+(((405000.0)*x449))+(((-1.0)*pz*x450))+(((-1.0)*x447*x448)))))+(IKabs(((((-405000.0)*pz))+((x448*x450))+(((-1.0)*pz*x447))+(((-1.0)*x449*x450))))));
j1eval[2]=IKsign(((273586.0)+(((268110.0)*cj2))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
IkReal x451=(px*sj0);
IkReal x452=(cj0*py);
IkReal x453=((1000.0)*pz);
IkReal x454=(pz*sj2);
IkReal x455=((331.0)*cj2);
j1eval[0]=((((-1.0)*cj2*x452))+(((1.22356495468278)*x451))+(((-1.0)*x454))+((cj2*x451))+(((-1.22356495468278)*x452)));
j1eval[1]=IKsign(((((405.0)*x451))+(((-405.0)*x452))+(((-1.0)*x452*x455))+(((-331.0)*x454))+((x451*x455))));
j1eval[2]=((IKabs((((x452*x453))+(((134.055)*sj2))+(((-1.0)*x451*x453))+(((109.561)*cj2*sj2)))))+(IKabs(((-164.025)+(((-268.11)*cj2))+((pz*x453))+(((-109.561)*(cj2*cj2)))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
IkReal x456=(px*sj0);
IkReal x457=(cj0*py);
IkReal x458=((26811.0)*cj2);
IkReal x459=((33100.0)*pp);
IkReal x460=(pz*sj2);
IkReal x461=((81000.0)*pz);
j1eval[0]=((((-1.0)*cj2*x456))+(((1.22356495468278)*x457))+((cj2*x457))+x460+(((-1.22356495468278)*x456)));
j1eval[1]=((IKabs(((1799.57608875)+(((1470.76465525)*cj2))+((cj2*x459))+(((-1.0)*pz*x461))+(((40500.0)*pp)))))+(IKabs((((x456*x461))+(((-1470.76465525)*sj2))+(((-1.0)*sj2*x459))+(((-1.0)*x457*x461))))));
j1eval[2]=IKsign(((((-32805.0)*x456))+(((-1.0)*x456*x458))+(((32805.0)*x457))+(((26811.0)*x460))+((x457*x458))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x462=(cj0*py);
IkReal x463=((81000.0)*pz);
IkReal x464=((26811.0)*cj2);
IkReal x465=(px*sj0);
IkReal x466=((33100.0)*pp);
CheckValue<IkReal> x467 = IKatan2WithCheck(IkReal(((((-1470.76465525)*sj2))+(((-1.0)*x462*x463))+((x463*x465))+(((-1.0)*sj2*x466)))),((1799.57608875)+(((1470.76465525)*cj2))+((cj2*x466))+(((-1.0)*pz*x463))+(((40500.0)*pp))),IKFAST_ATAN2_MAGTHRESH);
if(!x467.valid){
continue;
}
CheckValue<IkReal> x468=IKPowWithIntegerCheck(IKsign(((((26811.0)*pz*sj2))+(((-32805.0)*x465))+(((-1.0)*x464*x465))+(((32805.0)*x462))+((x462*x464)))),-1);
if(!x468.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x467.value)+(((1.5707963267949)*(x468.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x469=IKsin(j1);
IkReal x470=IKcos(j1);
IkReal x471=((0.331)*sj2);
IkReal x472=(cj0*py);
IkReal x473=(px*sj0);
IkReal x474=((0.331)*cj2);
IkReal x475=((0.81)*x470);
IkReal x476=(pz*x469);
evalcond[0]=(((x469*x474))+((x470*x471))+(((0.405)*x469))+pz);
evalcond[1]=(((x469*x472))+(((-1.0)*x469*x473))+x471+((pz*x470)));
evalcond[2]=((0.405)+((x470*x473))+x474+x476+(((-1.0)*x470*x472)));
evalcond[3]=((-0.0444339775)+((x472*x475))+(((-1.0)*x473*x475))+(((-1.0)*pp))+(((-0.81)*x476)));
evalcond[4]=(((x470*x474))+(((-1.0)*x469*x471))+(((-1.0)*x472))+x473+(((0.405)*x470)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x477=(cj0*py);
IkReal x478=((1000.0)*pz);
IkReal x479=(px*sj0);
IkReal x480=((331.0)*cj2);
CheckValue<IkReal> x481 = IKatan2WithCheck(IkReal(((((-1.0)*x478*x479))+(((134.055)*sj2))+((x477*x478))+(((109.561)*cj2*sj2)))),((-164.025)+((pz*x478))+(((-268.11)*cj2))+(((-109.561)*(cj2*cj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x481.valid){
continue;
}
CheckValue<IkReal> x482=IKPowWithIntegerCheck(IKsign(((((-405.0)*x477))+(((-331.0)*pz*sj2))+(((405.0)*x479))+(((-1.0)*x477*x480))+((x479*x480)))),-1);
if(!x482.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x481.value)+(((1.5707963267949)*(x482.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x483=IKsin(j1);
IkReal x484=IKcos(j1);
IkReal x485=((0.331)*sj2);
IkReal x486=(cj0*py);
IkReal x487=(px*sj0);
IkReal x488=((0.331)*cj2);
IkReal x489=((0.81)*x484);
IkReal x490=(pz*x483);
evalcond[0]=(((x484*x485))+((x483*x488))+pz+(((0.405)*x483)));
evalcond[1]=(((pz*x484))+((x483*x486))+x485+(((-1.0)*x483*x487)));
evalcond[2]=((0.405)+((x484*x487))+(((-1.0)*x484*x486))+x488+x490);
evalcond[3]=((-0.0444339775)+(((-0.81)*x490))+(((-1.0)*pp))+(((-1.0)*x487*x489))+((x486*x489)));
evalcond[4]=(((x484*x488))+(((-1.0)*x483*x485))+(((-1.0)*x486))+x487+(((0.405)*x484)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x491=((331000.0)*cj2);
IkReal x492=(px*sj0);
IkReal x493=(cj0*py);
IkReal x494=((331000.0)*sj2);
CheckValue<IkReal> x495=IKPowWithIntegerCheck(IKsign(((273586.0)+(((268110.0)*cj2)))),-1);
if(!x495.valid){
continue;
}
CheckValue<IkReal> x496 = IKatan2WithCheck(IkReal(((((-1.0)*x493*x494))+(((-405000.0)*pz))+(((-1.0)*pz*x491))+((x492*x494)))),(((x491*x493))+(((-1.0)*x491*x492))+(((405000.0)*x493))+(((-405000.0)*x492))+(((-1.0)*pz*x494))),IKFAST_ATAN2_MAGTHRESH);
if(!x496.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x495.value)))+(x496.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x497=IKsin(j1);
IkReal x498=IKcos(j1);
IkReal x499=((0.331)*sj2);
IkReal x500=(cj0*py);
IkReal x501=(px*sj0);
IkReal x502=((0.331)*cj2);
IkReal x503=((0.81)*x498);
IkReal x504=(pz*x497);
evalcond[0]=((((0.405)*x497))+((x497*x502))+pz+((x498*x499)));
evalcond[1]=(((pz*x498))+((x497*x500))+x499+(((-1.0)*x497*x501)));
evalcond[2]=((0.405)+(((-1.0)*x498*x500))+((x498*x501))+x502+x504);
evalcond[3]=((-0.0444339775)+((x500*x503))+(((-1.0)*x501*x503))+(((-1.0)*pp))+(((-0.81)*x504)));
evalcond[4]=((((0.405)*x498))+(((-1.0)*x497*x499))+((x498*x502))+x501+(((-1.0)*x500)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
}
}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x78=(cj0*r10);
IkReal x79=((1.0)*sj0);
IkReal x80=(cj0*r11);
IkReal x81=((1.0)*cj2);
IkReal x82=(cj1*sj2);
IkReal x83=(cj0*r12);
IkReal x84=(((sj1*sj2))+(((-1.0)*cj1*x81)));
IkReal x85=(((cj2*sj1))+x82);
IkReal x86=(cj0*x84);
IkReal x87=((((-1.0)*sj1*x81))+(((-1.0)*x82)));
new_r00=((((-1.0)*r00*x79*x87))+((x78*x87))+((r20*x84)));
new_r01=(((r21*x84))+((x80*x87))+(((-1.0)*r01*x79*x87)));
new_r02=((((-1.0)*r02*x79*x87))+((x83*x87))+((r22*x84)));
new_r10=(((r10*sj0))+((cj0*r00)));
new_r11=(((r11*sj0))+((cj0*r01)));
new_r12=(((r12*sj0))+((cj0*r02)));
new_r20=((((-1.0)*r00*x79*x84))+((x78*x84))+((r20*x85)));
new_r21=(((r21*x85))+((x80*x84))+(((-1.0)*r01*x79*x84)));
new_r22=((((-1.0)*r02*x79*x84))+((x83*x84))+((r22*x85)));
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
cj4array[0]=new_r22;
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j3eval[2];
IkReal x88=(cj0*r10);
IkReal x89=((1.0)*sj0);
IkReal x90=(cj0*r11);
IkReal x91=((1.0)*cj2);
IkReal x92=(cj1*sj2);
IkReal x93=(cj0*r12);
IkReal x94=x84;
IkReal x95=(((cj2*sj1))+x92);
IkReal x96=(cj0*x94);
IkReal x97=x87;
new_r00=(((r20*x94))+((x88*x97))+(((-1.0)*r00*x89*x97)));
new_r01=(((r21*x94))+((x90*x97))+(((-1.0)*r01*x89*x97)));
new_r02=((((-1.0)*r02*x89*x97))+((x93*x97))+((r22*x94)));
new_r10=(((r10*sj0))+((cj0*r00)));
new_r11=(((r11*sj0))+((cj0*r01)));
new_r12=(((r12*sj0))+((cj0*r02)));
new_r20=(((r20*x95))+((x88*x94))+(((-1.0)*r00*x89*x94)));
new_r21=(((r21*x95))+((x90*x94))+(((-1.0)*r01*x89*x94)));
new_r22=((((-1.0)*r02*x89*x94))+((x93*x94))+((r22*x95)));
j3eval[0]=sj4;
j3eval[1]=IKsign(sj4);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
IkReal x98=(cj0*r10);
IkReal x99=((1.0)*sj0);
IkReal x100=(cj0*r11);
IkReal x101=((1.0)*cj2);
IkReal x102=(cj1*sj2);
IkReal x103=(cj0*r12);
IkReal x104=x84;
IkReal x105=(((cj2*sj1))+x102);
IkReal x106=(cj0*x104);
IkReal x107=x87;
new_r00=(((x107*x98))+((r20*x104))+(((-1.0)*r00*x107*x99)));
new_r01=((((-1.0)*r01*x107*x99))+((r21*x104))+((x100*x107)));
new_r02=(((r22*x104))+((x103*x107))+(((-1.0)*r02*x107*x99)));
new_r10=(((r10*sj0))+((cj0*r00)));
new_r11=(((r11*sj0))+((cj0*r01)));
new_r12=(((r12*sj0))+((cj0*r02)));
new_r20=((((-1.0)*r00*x104*x99))+((r20*x105))+((x104*x98)));
new_r21=((((-1.0)*r01*x104*x99))+((r21*x105))+((x100*x104)));
new_r22=(((r22*x105))+(((-1.0)*r02*x104*x99))+((x103*x104)));
j3eval[0]=sj4;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r21;
evalcond[4]=new_r02;
evalcond[5]=new_r20;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x109 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x109.valid){
continue;
}
IkReal x108=x109.value;
j3array[0]=((-1.0)*x108);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x108)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r02*(IKsin(j3))))+((new_r12*(IKcos(j3)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x110=((1.0)*cj3);
if( IKabs(((((-1.0)*new_r00*x110))+((new_r01*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x110))+(((-1.0)*new_r00*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x110))+((new_r01*sj3))))+IKsqr(((((-1.0)*new_r01*x110))+(((-1.0)*new_r00*sj3))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*new_r00*x110))+((new_r01*sj3))), ((((-1.0)*new_r01*x110))+(((-1.0)*new_r00*sj3))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x111=IKsin(j5);
IkReal x112=IKcos(j5);
IkReal x113=((1.0)*sj3);
IkReal x114=(cj3*x111);
IkReal x115=(sj3*x112);
IkReal x116=((1.0)*x112);
IkReal x117=(x115+x114);
evalcond[0]=(((new_r10*sj3))+x111+((cj3*new_r00)));
evalcond[1]=(((new_r11*sj3))+x112+((cj3*new_r01)));
evalcond[2]=((((-1.0)*new_r01*x113))+x111+((cj3*new_r11)));
evalcond[3]=(x117+new_r00);
evalcond[4]=(x117+new_r11);
evalcond[5]=((((-1.0)*x111*x113))+((cj3*x112))+new_r01);
evalcond[6]=(((sj3*x111))+(((-1.0)*cj3*x116))+new_r10);
evalcond[7]=((((-1.0)*new_r00*x113))+(((-1.0)*x116))+((cj3*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r21;
evalcond[4]=new_r02;
evalcond[5]=new_r20;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x119 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x119.valid){
continue;
}
IkReal x118=x119.value;
j3array[0]=((-1.0)*x118);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x118)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r02*(IKsin(j3))))+((new_r12*(IKcos(j3)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x120=((1.0)*new_r01);
if( IKabs(((((-1.0)*sj3*x120))+(((-1.0)*cj3*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r00*sj3))+(((-1.0)*cj3*x120)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj3*x120))+(((-1.0)*cj3*new_r00))))+IKsqr((((new_r00*sj3))+(((-1.0)*cj3*x120))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*sj3*x120))+(((-1.0)*cj3*new_r00))), (((new_r00*sj3))+(((-1.0)*cj3*x120))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x121=IKcos(j5);
IkReal x122=IKsin(j5);
IkReal x123=((1.0)*sj3);
IkReal x124=(sj3*x122);
IkReal x125=(cj3*x121);
IkReal x126=((1.0)*x122);
IkReal x127=(x124+x125);
evalcond[0]=(((new_r10*sj3))+x122+((cj3*new_r00)));
evalcond[1]=(((new_r11*sj3))+x121+((cj3*new_r01)));
evalcond[2]=((((-1.0)*new_r00*x123))+x121+((cj3*new_r10)));
evalcond[3]=(x127+new_r01);
evalcond[4]=(x127+new_r10);
evalcond[5]=(((cj3*x122))+(((-1.0)*x121*x123))+new_r00);
evalcond[6]=(((sj3*x121))+(((-1.0)*cj3*x126))+new_r11);
evalcond[7]=((((-1.0)*new_r01*x123))+(((-1.0)*x126))+((cj3*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x129=IKPowWithIntegerCheck(sj4,-1);
if(!x129.valid){
continue;
}
IkReal x128=x129.value;
CheckValue<IkReal> x130=IKPowWithIntegerCheck(new_r02,-1);
if(!x130.valid){
continue;
}
if( IKabs((x128*(x130.value)*(((1.0)+(((-1.0)*(cj4*cj4)))+(((-1.0)*(new_r12*new_r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x128)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x128*(x130.value)*(((1.0)+(((-1.0)*(cj4*cj4)))+(((-1.0)*(new_r12*new_r12)))))))+IKsqr(((-1.0)*new_r12*x128))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x128*(x130.value)*(((1.0)+(((-1.0)*(cj4*cj4)))+(((-1.0)*(new_r12*new_r12)))))), ((-1.0)*new_r12*x128));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x131=IKsin(j3);
IkReal x132=IKcos(j3);
IkReal x133=((1.0)*sj4);
IkReal x134=(new_r12*x132);
IkReal x135=(sj4*x131);
IkReal x136=((1.0)*new_r02*x131);
evalcond[0]=(((sj4*x132))+new_r12);
evalcond[1]=(new_r02+(((-1.0)*x131*x133)));
evalcond[2]=(((new_r12*x131))+((new_r02*x132)));
evalcond[3]=(sj4+x134+(((-1.0)*x136)));
evalcond[4]=(((new_r22*sj4))+(((-1.0)*cj4*x136))+((cj4*x134)));
evalcond[5]=(((cj4*new_r20))+((new_r00*x135))+(((-1.0)*new_r10*x132*x133)));
evalcond[6]=(((new_r01*x135))+(((-1.0)*new_r11*x132*x133))+((cj4*new_r21)));
evalcond[7]=((-1.0)+((cj4*new_r22))+(((-1.0)*x133*x134))+((new_r02*x135)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[2];
IkReal x137=(cj0*r10);
IkReal x138=((1.0)*sj0);
IkReal x139=(cj0*r11);
IkReal x140=((1.0)*cj2);
IkReal x141=(cj1*sj2);
IkReal x142=(cj0*r12);
IkReal x143=x84;
IkReal x144=(((cj2*sj1))+x141);
IkReal x145=(cj0*x143);
IkReal x146=x87;
new_r00=(((r20*x143))+((x137*x146))+(((-1.0)*r00*x138*x146)));
new_r01=(((r21*x143))+(((-1.0)*r01*x138*x146))+((x139*x146)));
new_r02=(((x142*x146))+((r22*x143))+(((-1.0)*r02*x138*x146)));
new_r10=(((r10*sj0))+((cj0*r00)));
new_r11=(((r11*sj0))+((cj0*r01)));
new_r12=(((r12*sj0))+((cj0*r02)));
new_r20=(((r20*x144))+((x137*x143))+(((-1.0)*r00*x138*x143)));
new_r21=(((r21*x144))+(((-1.0)*r01*x138*x143))+((x139*x143)));
new_r22=(((x142*x143))+((r22*x144))+(((-1.0)*r02*x138*x143)));
j5eval[0]=sj4;
j5eval[1]=IKsign(sj4);
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x147=(cj0*r10);
IkReal x148=((1.0)*sj0);
IkReal x149=(cj0*r11);
IkReal x150=((1.0)*cj2);
IkReal x151=(cj1*sj2);
IkReal x152=(cj0*r12);
IkReal x153=x84;
IkReal x154=(((cj2*sj1))+x151);
IkReal x155=(cj0*x153);
IkReal x156=x87;
new_r00=((((-1.0)*r00*x148*x156))+((r20*x153))+((x147*x156)));
new_r01=(((x149*x156))+(((-1.0)*r01*x148*x156))+((r21*x153)));
new_r02=((((-1.0)*r02*x148*x156))+((x152*x156))+((r22*x153)));
new_r10=(((r10*sj0))+((cj0*r00)));
new_r11=(((r11*sj0))+((cj0*r01)));
new_r12=(((r12*sj0))+((cj0*r02)));
new_r20=((((-1.0)*r00*x148*x153))+((r20*x154))+((x147*x153)));
new_r21=(((x149*x153))+(((-1.0)*r01*x148*x153))+((r21*x154)));
new_r22=((((-1.0)*r02*x148*x153))+((x152*x153))+((r22*x154)));
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x157=(cj0*r10);
IkReal x158=((1.0)*sj0);
IkReal x159=(cj0*r11);
IkReal x160=((1.0)*cj2);
IkReal x161=(cj1*sj2);
IkReal x162=(cj0*r12);
IkReal x163=x84;
IkReal x164=(((cj2*sj1))+x161);
IkReal x165=(cj0*x163);
IkReal x166=x87;
new_r00=(((x157*x166))+((r20*x163))+(((-1.0)*r00*x158*x166)));
new_r01=(((r21*x163))+(((-1.0)*r01*x158*x166))+((x159*x166)));
new_r02=(((r22*x163))+((x162*x166))+(((-1.0)*r02*x158*x166)));
new_r10=(((r10*sj0))+((cj0*r00)));
new_r11=(((r11*sj0))+((cj0*r01)));
new_r12=(((r12*sj0))+((cj0*r02)));
new_r20=(((x157*x163))+((r20*x164))+(((-1.0)*r00*x158*x163)));
new_r21=(((r21*x164))+(((-1.0)*r01*x158*x163))+((x159*x163)));
new_r22=(((r22*x164))+((x162*x163))+(((-1.0)*r02*x158*x163)));
j5eval[0]=sj4;
j5eval[1]=sj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[10];
bool bgotonextstatement = true;
do
{
IkReal x167=(((new_r12*sj3))+((cj3*new_r02)));
IkReal x168=((((-1.0)*new_r02*sj3))+((cj3*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r21;
evalcond[4]=new_r02;
evalcond[5]=new_r20;
evalcond[6]=x167;
evalcond[7]=x167;
evalcond[8]=x168;
evalcond[9]=x168;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x169=((1.0)*cj3);
if( IKabs(((((-1.0)*new_r00*x169))+((new_r01*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r00*sj3))+(((-1.0)*new_r01*x169)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x169))+((new_r01*sj3))))+IKsqr(((((-1.0)*new_r00*sj3))+(((-1.0)*new_r01*x169))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*new_r00*x169))+((new_r01*sj3))), ((((-1.0)*new_r00*sj3))+(((-1.0)*new_r01*x169))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x170=IKsin(j5);
IkReal x171=IKcos(j5);
IkReal x172=((1.0)*sj3);
IkReal x173=(cj3*x170);
IkReal x174=(sj3*x171);
IkReal x175=((1.0)*x171);
IkReal x176=(x173+x174);
evalcond[0]=(((new_r10*sj3))+x170+((cj3*new_r00)));
evalcond[1]=(((new_r11*sj3))+x171+((cj3*new_r01)));
evalcond[2]=(x170+((cj3*new_r11))+(((-1.0)*new_r01*x172)));
evalcond[3]=(x176+new_r00);
evalcond[4]=(x176+new_r11);
evalcond[5]=(((cj3*x171))+(((-1.0)*x170*x172))+new_r01);
evalcond[6]=((((-1.0)*cj3*x175))+new_r10+((sj3*x170)));
evalcond[7]=((((-1.0)*x175))+((cj3*new_r10))+(((-1.0)*new_r00*x172)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x177=(cj3*new_r12);
IkReal x178=(new_r02*sj3);
IkReal x179=(((new_r12*sj3))+((cj3*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r21;
evalcond[4]=new_r02;
evalcond[5]=new_r20;
evalcond[6]=x179;
evalcond[7]=x179;
evalcond[8]=((((-1.0)*x178))+x177);
evalcond[9]=((((-1.0)*x177))+x178);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x180=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj3*new_r00))+(((-1.0)*sj3*x180)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r00*sj3))+(((-1.0)*cj3*x180)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*new_r00))+(((-1.0)*sj3*x180))))+IKsqr((((new_r00*sj3))+(((-1.0)*cj3*x180))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*cj3*new_r00))+(((-1.0)*sj3*x180))), (((new_r00*sj3))+(((-1.0)*cj3*x180))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x181=IKcos(j5);
IkReal x182=IKsin(j5);
IkReal x183=((1.0)*sj3);
IkReal x184=(sj3*x182);
IkReal x185=(cj3*x181);
IkReal x186=((1.0)*x182);
IkReal x187=(x184+x185);
evalcond[0]=(((new_r10*sj3))+x182+((cj3*new_r00)));
evalcond[1]=(((new_r11*sj3))+x181+((cj3*new_r01)));
evalcond[2]=(x181+((cj3*new_r10))+(((-1.0)*new_r00*x183)));
evalcond[3]=(x187+new_r01);
evalcond[4]=(x187+new_r10);
evalcond[5]=(((cj3*x182))+new_r00+(((-1.0)*x181*x183)));
evalcond[6]=(((sj3*x181))+new_r11+(((-1.0)*cj3*x186)));
evalcond[7]=((((-1.0)*x186))+(((-1.0)*new_r01*x183))+((cj3*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x188=(new_r22+(((-1.0)*cj4)));
IkReal x189=(sj4+new_r12);
IkReal x190=((1.0)*sj4);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=x188;
evalcond[2]=x188;
evalcond[3]=x189;
evalcond[4]=new_r02;
evalcond[5]=x189;
evalcond[6]=(((cj4*new_r12))+((new_r22*sj4)));
evalcond[7]=(((cj4*new_r20))+(((-1.0)*new_r10*x190)));
evalcond[8]=(((cj4*new_r21))+(((-1.0)*new_r11*x190)));
evalcond[9]=((-1.0)+((cj4*new_r22))+(((-1.0)*new_r12*x190)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x191=IKcos(j5);
IkReal x192=IKsin(j5);
IkReal x193=((1.0)*new_r12);
IkReal x194=((1.0)*x191);
evalcond[0]=(x192+new_r00);
evalcond[1]=(x191+new_r01);
evalcond[2]=(((new_r12*x191))+new_r20);
evalcond[3]=(((new_r22*x192))+new_r11);
evalcond[4]=((((-1.0)*x192*x193))+new_r21);
evalcond[5]=((((-1.0)*new_r22*x194))+new_r10);
evalcond[6]=((((-1.0)*new_r21*x193))+x192+((new_r11*new_r22)));
evalcond[7]=((((-1.0)*x194))+(((-1.0)*new_r20*x193))+((new_r10*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x195=(new_r22+(((-1.0)*cj4)));
IkReal x196=((1.0)*cj4);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=x195;
evalcond[2]=x195;
evalcond[3]=((((-1.0)*sj4))+new_r12);
evalcond[4]=new_r02;
evalcond[5]=(sj4+(((-1.0)*new_r12)));
evalcond[6]=(((new_r22*sj4))+(((-1.0)*new_r12*x196)));
evalcond[7]=(((new_r10*sj4))+((cj4*new_r20)));
evalcond[8]=(((new_r11*sj4))+((cj4*new_r21)));
evalcond[9]=((-1.0)+((new_r12*sj4))+((cj4*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r00, new_r01);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x197=IKsin(j5);
IkReal x198=IKcos(j5);
IkReal x199=((1.0)*new_r22);
IkReal x200=((1.0)*x198);
evalcond[0]=(((new_r12*x197))+new_r21);
evalcond[1]=(x197+(((-1.0)*new_r00)));
evalcond[2]=(x198+(((-1.0)*new_r01)));
evalcond[3]=(((new_r22*x198))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x200))+new_r20);
evalcond[5]=((((-1.0)*x197*x199))+new_r11);
evalcond[6]=(x197+((new_r12*new_r21))+(((-1.0)*new_r11*x199)));
evalcond[7]=((((-1.0)*x200))+((new_r12*new_r20))+(((-1.0)*new_r10*x199)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x202=IKPowWithIntegerCheck(sj4,-1);
if(!x202.valid){
continue;
}
IkReal x201=x202.value;
CheckValue<IkReal> x203=IKPowWithIntegerCheck(sj3,-1);
if(!x203.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x201)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x201*(x203.value)*((((cj3*cj4*new_r21))+(((-1.0)*new_r11*sj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x201))+IKsqr((x201*(x203.value)*((((cj3*cj4*new_r21))+(((-1.0)*new_r11*sj4))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r21*x201), (x201*(x203.value)*((((cj3*cj4*new_r21))+(((-1.0)*new_r11*sj4))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x204=IKsin(j5);
IkReal x205=IKcos(j5);
IkReal x206=(cj4*sj3);
IkReal x207=(cj3*new_r10);
IkReal x208=((1.0)*new_r01);
IkReal x209=((1.0)*cj4);
IkReal x210=((1.0)*new_r00);
IkReal x211=(cj3*new_r11);
IkReal x212=(cj3*x205);
IkReal x213=(cj3*x204);
IkReal x214=((1.0)*x205);
evalcond[0]=(((sj4*x204))+new_r21);
evalcond[1]=((((-1.0)*sj4*x214))+new_r20);
evalcond[2]=(((new_r10*sj3))+x204+((cj3*new_r00)));
evalcond[3]=(((new_r11*sj3))+x205+((cj3*new_r01)));
evalcond[4]=(((x205*x206))+x213+new_r00);
evalcond[5]=(((sj3*x205))+((cj4*x213))+new_r11);
evalcond[6]=(((cj4*x204))+x211+(((-1.0)*sj3*x208)));
evalcond[7]=(x212+(((-1.0)*x204*x206))+new_r01);
evalcond[8]=(((sj3*x204))+new_r10+(((-1.0)*x209*x212)));
evalcond[9]=((((-1.0)*sj3*x210))+x207+(((-1.0)*x205*x209)));
evalcond[10]=(((cj4*x211))+(((-1.0)*x206*x208))+x204+((new_r21*sj4)));
evalcond[11]=(((new_r20*sj4))+(((-1.0)*x206*x210))+((cj4*x207))+(((-1.0)*x214)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x215=IKPowWithIntegerCheck(sj4,-1);
if(!x215.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*(x215.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj3*new_r01))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x215.value)))+IKsqr(((((-1.0)*cj3*new_r01))+(((-1.0)*new_r11*sj3))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r21*(x215.value)), ((((-1.0)*cj3*new_r01))+(((-1.0)*new_r11*sj3))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x216=IKsin(j5);
IkReal x217=IKcos(j5);
IkReal x218=(cj4*sj3);
IkReal x219=(cj3*new_r10);
IkReal x220=((1.0)*new_r01);
IkReal x221=((1.0)*cj4);
IkReal x222=((1.0)*new_r00);
IkReal x223=(cj3*new_r11);
IkReal x224=(cj3*x217);
IkReal x225=(cj3*x216);
IkReal x226=((1.0)*x217);
evalcond[0]=(new_r21+((sj4*x216)));
evalcond[1]=((((-1.0)*sj4*x226))+new_r20);
evalcond[2]=(((new_r10*sj3))+x216+((cj3*new_r00)));
evalcond[3]=(((new_r11*sj3))+x217+((cj3*new_r01)));
evalcond[4]=(x225+new_r00+((x217*x218)));
evalcond[5]=(((sj3*x217))+((cj4*x225))+new_r11);
evalcond[6]=(((cj4*x216))+x223+(((-1.0)*sj3*x220)));
evalcond[7]=((((-1.0)*x216*x218))+x224+new_r01);
evalcond[8]=(((sj3*x216))+(((-1.0)*x221*x224))+new_r10);
evalcond[9]=(x219+(((-1.0)*sj3*x222))+(((-1.0)*x217*x221)));
evalcond[10]=(x216+(((-1.0)*x218*x220))+((cj4*x223))+((new_r21*sj4)));
evalcond[11]=(((cj4*x219))+((new_r20*sj4))+(((-1.0)*x218*x222))+(((-1.0)*x226)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x227 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x227.valid){
continue;
}
CheckValue<IkReal> x228=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x228.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x227.value)+(((1.5707963267949)*(x228.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x229=IKsin(j5);
IkReal x230=IKcos(j5);
IkReal x231=(cj4*sj3);
IkReal x232=(cj3*new_r10);
IkReal x233=((1.0)*new_r01);
IkReal x234=((1.0)*cj4);
IkReal x235=((1.0)*new_r00);
IkReal x236=(cj3*new_r11);
IkReal x237=(cj3*x230);
IkReal x238=(cj3*x229);
IkReal x239=((1.0)*x230);
evalcond[0]=(((sj4*x229))+new_r21);
evalcond[1]=((((-1.0)*sj4*x239))+new_r20);
evalcond[2]=(((new_r10*sj3))+x229+((cj3*new_r00)));
evalcond[3]=(((new_r11*sj3))+x230+((cj3*new_r01)));
evalcond[4]=(((x230*x231))+x238+new_r00);
evalcond[5]=(((cj4*x238))+new_r11+((sj3*x230)));
evalcond[6]=(x236+((cj4*x229))+(((-1.0)*sj3*x233)));
evalcond[7]=(x237+(((-1.0)*x229*x231))+new_r01);
evalcond[8]=(((sj3*x229))+new_r10+(((-1.0)*x234*x237)));
evalcond[9]=((((-1.0)*x230*x234))+x232+(((-1.0)*sj3*x235)));
evalcond[10]=(x229+((cj4*x236))+(((-1.0)*x231*x233))+((new_r21*sj4)));
evalcond[11]=(((new_r20*sj4))+(((-1.0)*x239))+((cj4*x232))+(((-1.0)*x231*x235)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x240=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x240.valid){
continue;
}
CheckValue<IkReal> x241 = IKatan2WithCheck(IkReal(new_r02),((-1.0)*new_r12),IKFAST_ATAN2_MAGTHRESH);
if(!x241.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x240.value)))+(x241.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x242=IKsin(j3);
IkReal x243=IKcos(j3);
IkReal x244=((1.0)*sj4);
IkReal x245=(new_r12*x243);
IkReal x246=(sj4*x242);
IkReal x247=((1.0)*new_r02*x242);
evalcond[0]=(new_r12+((sj4*x243)));
evalcond[1]=((((-1.0)*x242*x244))+new_r02);
evalcond[2]=(((new_r12*x242))+((new_r02*x243)));
evalcond[3]=(sj4+x245+(((-1.0)*x247)));
evalcond[4]=((((-1.0)*cj4*x247))+((cj4*x245))+((new_r22*sj4)));
evalcond[5]=((((-1.0)*new_r10*x243*x244))+((cj4*new_r20))+((new_r00*x246)));
evalcond[6]=(((cj4*new_r21))+((new_r01*x246))+(((-1.0)*new_r11*x243*x244)));
evalcond[7]=((-1.0)+((cj4*new_r22))+((new_r02*x246))+(((-1.0)*x244*x245)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[2];
IkReal x248=(cj0*r10);
IkReal x249=((1.0)*sj0);
IkReal x250=(cj0*r11);
IkReal x251=((1.0)*cj2);
IkReal x252=(cj1*sj2);
IkReal x253=(cj0*r12);
IkReal x254=x84;
IkReal x255=(((cj2*sj1))+x252);
IkReal x256=(cj0*x254);
IkReal x257=x87;
new_r00=(((x248*x257))+(((-1.0)*r00*x249*x257))+((r20*x254)));
new_r01=(((r21*x254))+(((-1.0)*r01*x249*x257))+((x250*x257)));
new_r02=((((-1.0)*r02*x249*x257))+((x253*x257))+((r22*x254)));
new_r10=(((r10*sj0))+((cj0*r00)));
new_r11=(((r11*sj0))+((cj0*r01)));
new_r12=(((r12*sj0))+((cj0*r02)));
new_r20=(((x248*x254))+(((-1.0)*r00*x249*x254))+((r20*x255)));
new_r21=(((r21*x255))+(((-1.0)*r01*x249*x254))+((x250*x254)));
new_r22=((((-1.0)*r02*x249*x254))+((x253*x254))+((r22*x255)));
j5eval[0]=sj4;
j5eval[1]=IKsign(sj4);
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
IkReal x258=(cj0*r10);
IkReal x259=((1.0)*sj0);
IkReal x260=(cj0*r11);
IkReal x261=((1.0)*cj2);
IkReal x262=(cj1*sj2);
IkReal x263=(cj0*r12);
IkReal x264=x84;
IkReal x265=(((cj2*sj1))+x262);
IkReal x266=(cj0*x264);
IkReal x267=x87;
new_r00=((((-1.0)*r00*x259*x267))+((x258*x267))+((r20*x264)));
new_r01=((((-1.0)*r01*x259*x267))+((x260*x267))+((r21*x264)));
new_r02=((((-1.0)*r02*x259*x267))+((r22*x264))+((x263*x267)));
new_r10=(((r10*sj0))+((cj0*r00)));
new_r11=(((r11*sj0))+((cj0*r01)));
new_r12=(((r12*sj0))+((cj0*r02)));
new_r20=((((-1.0)*r00*x259*x264))+((x258*x264))+((r20*x265)));
new_r21=((((-1.0)*r01*x259*x264))+((x260*x264))+((r21*x265)));
new_r22=((((-1.0)*r02*x259*x264))+((r22*x265))+((x263*x264)));
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x268=(cj0*r10);
IkReal x269=((1.0)*sj0);
IkReal x270=(cj0*r11);
IkReal x271=((1.0)*cj2);
IkReal x272=(cj1*sj2);
IkReal x273=(cj0*r12);
IkReal x274=x84;
IkReal x275=(((cj2*sj1))+x272);
IkReal x276=(cj0*x274);
IkReal x277=x87;
new_r00=((((-1.0)*r00*x269*x277))+((r20*x274))+((x268*x277)));
new_r01=((((-1.0)*r01*x269*x277))+((r21*x274))+((x270*x277)));
new_r02=(((x273*x277))+(((-1.0)*r02*x269*x277))+((r22*x274)));
new_r10=(((r10*sj0))+((cj0*r00)));
new_r11=(((r11*sj0))+((cj0*r01)));
new_r12=(((r12*sj0))+((cj0*r02)));
new_r20=((((-1.0)*r00*x269*x274))+((r20*x275))+((x268*x274)));
new_r21=((((-1.0)*r01*x269*x274))+((r21*x275))+((x270*x274)));
new_r22=(((x273*x274))+(((-1.0)*r02*x269*x274))+((r22*x275)));
j5eval[0]=sj4;
j5eval[1]=sj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[10];
bool bgotonextstatement = true;
do
{
IkReal x278=(((new_r12*sj3))+((cj3*new_r02)));
IkReal x279=((((-1.0)*new_r02*sj3))+((cj3*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r21;
evalcond[4]=new_r02;
evalcond[5]=new_r20;
evalcond[6]=x278;
evalcond[7]=x278;
evalcond[8]=x279;
evalcond[9]=x279;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x280=((1.0)*cj3);
if( IKabs((((new_r01*sj3))+(((-1.0)*new_r00*x280)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x280))+(((-1.0)*new_r00*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r01*sj3))+(((-1.0)*new_r00*x280))))+IKsqr(((((-1.0)*new_r01*x280))+(((-1.0)*new_r00*sj3))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((new_r01*sj3))+(((-1.0)*new_r00*x280))), ((((-1.0)*new_r01*x280))+(((-1.0)*new_r00*sj3))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x281=IKsin(j5);
IkReal x282=IKcos(j5);
IkReal x283=((1.0)*sj3);
IkReal x284=(cj3*x281);
IkReal x285=(sj3*x282);
IkReal x286=((1.0)*x282);
IkReal x287=(x285+x284);
evalcond[0]=(((new_r10*sj3))+x281+((cj3*new_r00)));
evalcond[1]=(((new_r11*sj3))+x282+((cj3*new_r01)));
evalcond[2]=(x281+(((-1.0)*new_r01*x283))+((cj3*new_r11)));
evalcond[3]=(x287+new_r00);
evalcond[4]=(x287+new_r11);
evalcond[5]=((((-1.0)*x281*x283))+((cj3*x282))+new_r01);
evalcond[6]=((((-1.0)*cj3*x286))+((sj3*x281))+new_r10);
evalcond[7]=((((-1.0)*new_r00*x283))+((cj3*new_r10))+(((-1.0)*x286)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x288=(cj3*new_r12);
IkReal x289=(new_r02*sj3);
IkReal x290=(((new_r12*sj3))+((cj3*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r21;
evalcond[4]=new_r02;
evalcond[5]=new_r20;
evalcond[6]=x290;
evalcond[7]=x290;
evalcond[8]=(x288+(((-1.0)*x289)));
evalcond[9]=(x289+(((-1.0)*x288)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x291=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj3*new_r00))+(((-1.0)*sj3*x291)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r00*sj3))+(((-1.0)*cj3*x291)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*new_r00))+(((-1.0)*sj3*x291))))+IKsqr((((new_r00*sj3))+(((-1.0)*cj3*x291))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*cj3*new_r00))+(((-1.0)*sj3*x291))), (((new_r00*sj3))+(((-1.0)*cj3*x291))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x292=IKcos(j5);
IkReal x293=IKsin(j5);
IkReal x294=((1.0)*sj3);
IkReal x295=(sj3*x293);
IkReal x296=(cj3*x292);
IkReal x297=((1.0)*x293);
IkReal x298=(x295+x296);
evalcond[0]=(((new_r10*sj3))+x293+((cj3*new_r00)));
evalcond[1]=(((new_r11*sj3))+x292+((cj3*new_r01)));
evalcond[2]=(x292+((cj3*new_r10))+(((-1.0)*new_r00*x294)));
evalcond[3]=(x298+new_r01);
evalcond[4]=(x298+new_r10);
evalcond[5]=(((cj3*x293))+new_r00+(((-1.0)*x292*x294)));
evalcond[6]=((((-1.0)*cj3*x297))+new_r11+((sj3*x292)));
evalcond[7]=((((-1.0)*new_r01*x294))+(((-1.0)*x297))+((cj3*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x299=(new_r22+(((-1.0)*cj4)));
IkReal x300=(sj4+new_r12);
IkReal x301=((1.0)*sj4);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=x299;
evalcond[2]=x299;
evalcond[3]=x300;
evalcond[4]=new_r02;
evalcond[5]=x300;
evalcond[6]=(((cj4*new_r12))+((new_r22*sj4)));
evalcond[7]=(((cj4*new_r20))+(((-1.0)*new_r10*x301)));
evalcond[8]=(((cj4*new_r21))+(((-1.0)*new_r11*x301)));
evalcond[9]=((-1.0)+((cj4*new_r22))+(((-1.0)*new_r12*x301)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x302=IKcos(j5);
IkReal x303=IKsin(j5);
IkReal x304=((1.0)*new_r12);
IkReal x305=((1.0)*x302);
evalcond[0]=(x303+new_r00);
evalcond[1]=(x302+new_r01);
evalcond[2]=(((new_r12*x302))+new_r20);
evalcond[3]=(((new_r22*x303))+new_r11);
evalcond[4]=((((-1.0)*x303*x304))+new_r21);
evalcond[5]=((((-1.0)*new_r22*x305))+new_r10);
evalcond[6]=((((-1.0)*new_r21*x304))+x303+((new_r11*new_r22)));
evalcond[7]=((((-1.0)*new_r20*x304))+((new_r10*new_r22))+(((-1.0)*x305)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x306=(new_r22+(((-1.0)*cj4)));
IkReal x307=((1.0)*cj4);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=x306;
evalcond[2]=x306;
evalcond[3]=((((-1.0)*sj4))+new_r12);
evalcond[4]=new_r02;
evalcond[5]=(sj4+(((-1.0)*new_r12)));
evalcond[6]=(((new_r22*sj4))+(((-1.0)*new_r12*x307)));
evalcond[7]=(((new_r10*sj4))+((cj4*new_r20)));
evalcond[8]=(((new_r11*sj4))+((cj4*new_r21)));
evalcond[9]=((-1.0)+((new_r12*sj4))+((cj4*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r00, new_r01);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x308=IKsin(j5);
IkReal x309=IKcos(j5);
IkReal x310=((1.0)*new_r22);
IkReal x311=((1.0)*x309);
evalcond[0]=(((new_r12*x308))+new_r21);
evalcond[1]=(x308+(((-1.0)*new_r00)));
evalcond[2]=(x309+(((-1.0)*new_r01)));
evalcond[3]=(((new_r22*x309))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x311))+new_r20);
evalcond[5]=((((-1.0)*x308*x310))+new_r11);
evalcond[6]=((((-1.0)*new_r11*x310))+x308+((new_r12*new_r21)));
evalcond[7]=(((new_r12*new_r20))+(((-1.0)*new_r10*x310))+(((-1.0)*x311)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x313=IKPowWithIntegerCheck(sj4,-1);
if(!x313.valid){
continue;
}
IkReal x312=x313.value;
CheckValue<IkReal> x314=IKPowWithIntegerCheck(sj3,-1);
if(!x314.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x312)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x312*(x314.value)*((((cj3*cj4*new_r21))+(((-1.0)*new_r11*sj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x312))+IKsqr((x312*(x314.value)*((((cj3*cj4*new_r21))+(((-1.0)*new_r11*sj4))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r21*x312), (x312*(x314.value)*((((cj3*cj4*new_r21))+(((-1.0)*new_r11*sj4))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x315=IKsin(j5);
IkReal x316=IKcos(j5);
IkReal x317=(cj4*sj3);
IkReal x318=(cj3*new_r10);
IkReal x319=((1.0)*new_r01);
IkReal x320=((1.0)*cj4);
IkReal x321=((1.0)*new_r00);
IkReal x322=(cj3*new_r11);
IkReal x323=(cj3*x316);
IkReal x324=(cj3*x315);
IkReal x325=((1.0)*x316);
evalcond[0]=(((sj4*x315))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*sj4*x325)));
evalcond[2]=(((new_r10*sj3))+x315+((cj3*new_r00)));
evalcond[3]=(((new_r11*sj3))+x316+((cj3*new_r01)));
evalcond[4]=(x324+new_r00+((x316*x317)));
evalcond[5]=(((cj4*x324))+new_r11+((sj3*x316)));
evalcond[6]=(((cj4*x315))+(((-1.0)*sj3*x319))+x322);
evalcond[7]=(x323+new_r01+(((-1.0)*x315*x317)));
evalcond[8]=((((-1.0)*x320*x323))+new_r10+((sj3*x315)));
evalcond[9]=(x318+(((-1.0)*x316*x320))+(((-1.0)*sj3*x321)));
evalcond[10]=(x315+((cj4*x322))+((new_r21*sj4))+(((-1.0)*x317*x319)));
evalcond[11]=(((new_r20*sj4))+((cj4*x318))+(((-1.0)*x317*x321))+(((-1.0)*x325)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x326=IKPowWithIntegerCheck(sj4,-1);
if(!x326.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*(x326.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj3*new_r01))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x326.value)))+IKsqr(((((-1.0)*cj3*new_r01))+(((-1.0)*new_r11*sj3))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*new_r21*(x326.value)), ((((-1.0)*cj3*new_r01))+(((-1.0)*new_r11*sj3))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x327=IKsin(j5);
IkReal x328=IKcos(j5);
IkReal x329=(cj4*sj3);
IkReal x330=(cj3*new_r10);
IkReal x331=((1.0)*new_r01);
IkReal x332=((1.0)*cj4);
IkReal x333=((1.0)*new_r00);
IkReal x334=(cj3*new_r11);
IkReal x335=(cj3*x328);
IkReal x336=(cj3*x327);
IkReal x337=((1.0)*x328);
evalcond[0]=(((sj4*x327))+new_r21);
evalcond[1]=((((-1.0)*sj4*x337))+new_r20);
evalcond[2]=(((new_r10*sj3))+x327+((cj3*new_r00)));
evalcond[3]=(((new_r11*sj3))+x328+((cj3*new_r01)));
evalcond[4]=(((x328*x329))+x336+new_r00);
evalcond[5]=(((sj3*x328))+((cj4*x336))+new_r11);
evalcond[6]=((((-1.0)*sj3*x331))+x334+((cj4*x327)));
evalcond[7]=(x335+(((-1.0)*x327*x329))+new_r01);
evalcond[8]=(((sj3*x327))+(((-1.0)*x332*x335))+new_r10);
evalcond[9]=((((-1.0)*sj3*x333))+(((-1.0)*x328*x332))+x330);
evalcond[10]=((((-1.0)*x329*x331))+x327+((cj4*x334))+((new_r21*sj4)));
evalcond[11]=(((new_r20*sj4))+(((-1.0)*x329*x333))+(((-1.0)*x337))+((cj4*x330)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x338 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x338.valid){
continue;
}
CheckValue<IkReal> x339=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x339.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x338.value)+(((1.5707963267949)*(x339.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x340=IKsin(j5);
IkReal x341=IKcos(j5);
IkReal x342=(cj4*sj3);
IkReal x343=(cj3*new_r10);
IkReal x344=((1.0)*new_r01);
IkReal x345=((1.0)*cj4);
IkReal x346=((1.0)*new_r00);
IkReal x347=(cj3*new_r11);
IkReal x348=(cj3*x341);
IkReal x349=(cj3*x340);
IkReal x350=((1.0)*x341);
evalcond[0]=(((sj4*x340))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*sj4*x350)));
evalcond[2]=(((new_r10*sj3))+x340+((cj3*new_r00)));
evalcond[3]=(((new_r11*sj3))+x341+((cj3*new_r01)));
evalcond[4]=(x349+((x341*x342))+new_r00);
evalcond[5]=(((sj3*x341))+((cj4*x349))+new_r11);
evalcond[6]=(x347+((cj4*x340))+(((-1.0)*sj3*x344)));
evalcond[7]=(x348+(((-1.0)*x340*x342))+new_r01);
evalcond[8]=(((sj3*x340))+(((-1.0)*x345*x348))+new_r10);
evalcond[9]=(x343+(((-1.0)*x341*x345))+(((-1.0)*sj3*x346)));
evalcond[10]=(x340+((cj4*x347))+((new_r21*sj4))+(((-1.0)*x342*x344)));
evalcond[11]=(((new_r20*sj4))+(((-1.0)*x350))+((cj4*x343))+(((-1.0)*x342*x346)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "932c89545e6a1721f49778d9ea6940ca"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
