/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2015-10-07 00:42:46.353013
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68,x69,x70;
x0=IKsin(j[4]);
x1=IKsin(j[1]);
x2=IKcos(j[0]);
x3=IKcos(j[2]);
x4=(x1*x2*x3);
x5=IKsin(j[2]);
x6=IKcos(j[1]);
x7=(x5*x6);
x8=((1.0)*x7);
x9=((((-1.0)*(1.0)*x2*x8))+(((-1.0)*(1.0)*x4)));
x10=IKcos(j[4]);
x11=IKsin(j[0]);
x12=IKsin(j[3]);
x13=(x11*x12);
x14=((1.0)*x13);
x15=IKcos(j[3]);
x16=(x3*x6);
x17=(x16*x2);
x18=(x1*x2*x5);
x19=((1.0)*x18);
x20=(x15*((x17+(((-1.0)*(1.0)*x19)))));
x21=IKcos(j[5]);
x22=((1.0)*x11);
x23=(x15*x22);
x24=((1.0)*x16);
x25=(x12*((x19+(((-1.0)*(1.0)*x2*x24)))));
x26=IKsin(j[5]);
x27=((1.0)*x10);
x28=((1.0)*x0);
x29=((((-1.0)*(1.0)*x27*x9))+((x28*(((((1.0)*x20))+(((-1.0)*(1.0)*x14)))))));
x30=((0.09)*x7);
x31=((0.04)*x7);
x32=(x1*x5);
x33=(x32+(((-1.0)*(1.0)*x24)));
x34=(x0*x33);
x35=(x1*x3);
x36=((1.0)*x35);
x37=((((-1.0)*(1.0)*x36))+(((-1.0)*(1.0)*x8)));
x38=(x10*x15*x37);
x39=(x1*x11*x3);
x40=((((-1.0)*(1.0)*x22*x7))+(((-1.0)*(1.0)*x39)));
x41=(x0*x40);
x42=(x12*x2);
x43=(x11*x16);
x44=(x22*x32);
x45=(x15*(((((-1.0)*(1.0)*x44))+x43)));
x46=(x10*((x42+x45)));
x47=(x36+x8);
x48=(x12*x21*x47);
x49=(x15*x2);
x50=(x12*((x44+(((-1.0)*(1.0)*x16*x22)))));
x51=(x21*((x49+x50)));
x52=((((-1.0)*(1.0)*x27*x33))+(((-1.0)*(1.0)*x15*x28*x47)));
x53=(x26*x52);
x54=((((-1.0)*(1.0)*x27*x40))+((x28*(((((1.0)*x45))+(((1.0)*x42)))))));
x55=(x26*x54);
x56=(x12*x26*x37);
x57=(x26*(((((-1.0)*(1.0)*x49))+(((-1.0)*(1.0)*x50)))));
x58=(x21*x52);
x59=(x21*x54);
x60=(x1*x11);
x61=(x1*x11*x5);
x62=(x11*x5*x6);
x63=(x0*(((((0.04)*x16))+(((-1.0)*(0.04)*x32)))));
x64=(x10*(((((0.09)*x32))+(((-1.0)*(0.09)*x16)))));
x65=(x10*x15*((x31+(((0.04)*x35)))));
x66=(x0*x15*((x30+(((0.09)*x35)))));
x67=(x10*(((((-1.0)*(1.0)*x11*x30))+(((-1.0)*(0.09)*x39)))));
x68=(x0*((((x11*x31))+(((0.04)*x39)))));
x69=(x0*(((((-1.0)*(0.09)*x45))+(((-1.0)*(0.09)*x42)))));
x70=(x10*(((((-1.0)*(0.04)*x42))+(((-1.0)*(0.04)*x45)))));
eerot[0]=(((x0*x9))+((x10*(((((-1.0)*(1.0)*x14))+x20)))));
eerot[1]=(((x21*(((((-1.0)*(1.0)*x23))+x25))))+((x26*x29)));
eerot[2]=(((x21*x29))+((x26*((x23+(((-1.0)*(1.0)*x25)))))));
eetrans[0]=(((x10*(((((-1.0)*(1.0)*x2*x30))+(((-1.0)*(0.09)*x4))))))+(((-1.0)*(0.235)*x4))+((x10*(((((-1.0)*(0.04)*x20))+(((0.04)*x13))))))+(((-1.0)*(0.25)*x1*x2))+((x0*((((x2*x31))+(((0.04)*x4))))))+((x0*(((((0.09)*x13))+(((-1.0)*(0.09)*x20))))))+(((0.03)*x18))+(((0.095)*x11))+(((-1.0)*(0.235)*x2*x7))+(((-1.0)*(0.03)*x17)));
eerot[3]=((((0.965925532213041)*x41))+(((0.965925532213041)*x46))+(((-1.0)*(0.258820142606703)*x34))+(((-1.0)*(0.258820142606703)*x38)));
eerot[4]=((((-1.0)*(0.258820142606703)*x48))+(((-1.0)*(0.258820142606703)*x53))+(((0.965925532213041)*x51))+(((0.965925532213041)*x55)));
eerot[5]=((((-1.0)*(0.258820142606703)*x58))+(((0.965925532213041)*x59))+(((-1.0)*(0.258820142606703)*x56))+(((0.965925532213041)*x57)));
eetrans[1]=((-0.145)+(((0.0647050356516757)*x6))+(((-1.0)*(0.0289777659663912)*x43))+(((0.965925532213041)*x70))+(((0.965925532213041)*x68))+(((-1.0)*(0.226992500070065)*x62))+(((-1.0)*(0.258820142606703)*x66))+(((0.965925532213041)*x69))+(((-1.0)*(0.0917629255602389)*x2))+(((-1.0)*(0.226992500070065)*x39))+(((-1.0)*(0.258820142606703)*x63))+(((-1.0)*(0.258820142606703)*x65))+(((0.0289777659663912)*x61))+(((-1.0)*(0.00776460427820108)*x7))+(((-1.0)*(0.00776460427820108)*x35))+(((-1.0)*(0.258820142606703)*x64))+(((-1.0)*(0.0608227335125751)*x32))+(((-1.0)*(0.24148138305326)*x60))+(((0.0608227335125751)*x16))+(((0.965925532213041)*x67)));
eerot[6]=((((0.965925532213041)*x38))+(((0.258820142606703)*x46))+(((0.965925532213041)*x34))+(((0.258820142606703)*x41)));
eerot[7]=((((0.258820142606703)*x55))+(((0.965925532213041)*x53))+(((0.965925532213041)*x48))+(((0.258820142606703)*x51)));
eerot[8]=((((0.258820142606703)*x59))+(((0.965925532213041)*x56))+(((0.258820142606703)*x57))+(((0.965925532213041)*x58)));
eetrans[2]=((0.370296)+(((-1.0)*(0.0647050356516757)*x60))+(((0.0289777659663912)*x35))+(((0.965925532213041)*x66))+(((0.258820142606703)*x70))+(((-1.0)*(0.226992500070065)*x16))+(((0.258820142606703)*x67))+(((-1.0)*(0.0245879135476367)*x2))+(((-1.0)*(0.0608227335125751)*x62))+(((-1.0)*(0.24148138305326)*x6))+(((0.226992500070065)*x32))+(((0.0289777659663912)*x7))+(((0.00776460427820108)*x61))+(((-1.0)*(0.0608227335125751)*x39))+(((0.965925532213041)*x63))+(((0.258820142606703)*x68))+(((-1.0)*(0.00776460427820108)*x43))+(((0.965925532213041)*x65))+(((0.258820142606703)*x69))+(((0.965925532213041)*x64)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j7,cj7,sj7,htj7,j7mul,j8,cj8,sj8,htj8,j8mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij7[2], _nj7,_ij8[2], _nj8;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1; j7=numeric_limits<IkReal>::quiet_NaN(); _ij7[0] = -1; _ij7[1] = -1; _nj7 = -1; j8=numeric_limits<IkReal>::quiet_NaN(); _ij8[0] = -1; _ij8[1] = -1; _nj8 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*(((1.0)*r02)));
new_r01=r01;
new_r02=r00;
new_px=(px+(((0.04)*r00)));
new_r10=((((-1.0)*(0.965925532213041)*r12))+(((-1.0)*(0.258820142606703)*r22)));
new_r11=((((0.258820142606703)*r21))+(((0.965925532213041)*r11)));
new_r12=((((0.258820142606703)*r20))+(((0.965925532213041)*r10)));
new_py=((0.0442191386441994)+(((0.258820142606703)*pz))+(((0.0103528057042681)*r20))+(((0.0386370212885216)*r10))+(((0.965925532213041)*py)));
new_r20=((((-1.0)*(0.965925532213041)*r22))+(((0.258820142606703)*r12)));
new_r21=((((0.965925532213041)*r21))+(((-1.0)*(0.258820142606703)*r11)));
new_r22=((((0.965925532213041)*r20))+(((-1.0)*(0.258820142606703)*r10)));
new_pz=((-0.395207281554332)+(((-1.0)*(0.258820142606703)*py))+(((-1.0)*(0.0103528057042681)*r10))+(((0.965925532213041)*pz))+(((0.0386370212885216)*r20)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x71=((1.0)*py);
IkReal x72=((1.0)*pz);
IkReal x73=((1.0)*px);
pp=((pz*pz)+(py*py)+(px*px));
npx=(((pz*r20))+((py*r10))+((px*r00)));
npy=(((pz*r21))+((py*r11))+((px*r01)));
npz=(((px*r02))+((pz*r22))+((py*r12)));
rxp0_0=((((-1.0)*r20*x71))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x72)));
rxp0_2=(((py*r00))+(((-1.0)*r10*x73)));
rxp1_0=((((-1.0)*r21*x71))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x72)));
rxp1_2=(((py*r01))+(((-1.0)*r11*x73)));
rxp2_0=((((-1.0)*r22*x71))+((pz*r12)));
rxp2_1=((((-1.0)*r02*x72))+((px*r22)));
rxp2_2=((((-1.0)*r12*x73))+((py*r02)));
IkReal op[72], zeror[48];
int numroots;;
IkReal x74=(cj6*r21);
IkReal x75=(r22*sj6);
IkReal x76=((2.0)*r20);
IkReal x77=(cj6*x76);
IkReal x78=((-1.0)*x74);
IkReal x79=((0.57)*r20);
IkReal x80=((6.0)*rxp0_0);
IkReal x81=(x80+(((-1.0)*x79)));
IkReal x82=((65.0)*npx);
IkReal x83=((100.0)*pp);
IkReal x84=((6.0)*rxp0_1);
IkReal x85=(x83+x84);
IkReal x86=((1.14)*r21);
IkReal x87=((12.0)*rxp1_0);
IkReal x88=((12.0)*rxp1_1);
IkReal x89=((((-1.0)*x80))+x79);
IkReal x90=(x83+(((-1.0)*x84)));
IkReal x91=(r21*sj6);
IkReal x92=(cj6*r22);
IkReal x93=((-1.0)*x92);
IkReal x94=((2.0)*r01);
IkReal x95=(sj6*x76);
IkReal x96=((2.0)*r11);
IkReal x97=((-1.0)*(((1.0)*r00)));
IkReal x98=((-1.0)*x91);
IkReal x99=((-1.0)*(((1.0)*r10)));
IkReal x100=((0.095)*r00);
IkReal x101=(x100+rxp0_2);
IkReal x102=((0.095)*r10);
IkReal x103=((0.19)*r01);
IkReal x104=((2.0)*rxp1_2);
IkReal x105=((0.19)*r11);
IkReal x106=((((-1.0)*(1.0)*rxp0_2))+(((-1.0)*x100)));
IkReal x107=((-1.0)*x102);
IkReal x108=((1.08)*r01);
IkReal x109=((((12.0)*rxp2_0))+(((-1.0)*(1.14)*r22)));
IkReal x110=((1.08)*r11);
IkReal x111=((((12.0)*rxp2_1))+(((-1.0)*(94.0)*npz)));
IkReal x112=((2.0)*r02);
IkReal x113=((2.0)*r12);
IkReal x114=((0.18)*r21);
IkReal x115=((((2.0)*rxp2_2))+(((0.19)*r02)));
IkReal x116=((0.19)*r12);
IkReal x117=((-1.0)*x75);
IkReal x118=((29.0)*npx);
op[0]=(x75+x74);
op[1]=0;
op[2]=x77;
op[3]=0;
op[4]=(x75+x78);
op[5]=0;
op[6]=x81;
op[7]=((3.5)+(((-1.0)*x82))+x85);
op[8]=(x86+(((-1.0)*x87)));
op[9]=((((130.0)*npy))+(((-1.0)*x88)));
op[10]=x89;
op[11]=((3.5)+x90+x82);
op[12]=(x91+x93+r00);
op[13]=r10;
op[14]=((((-1.0)*x94))+x95);
op[15]=((-1.0)*x96);
op[16]=(x98+x93+x97);
op[17]=x99;
op[18]=x101;
op[19]=x102;
op[20]=((((-1.0)*x104))+(((-1.0)*x103)));
op[21]=((-1.0)*x105);
op[22]=x106;
op[23]=x107;
op[24]=((-1.0)*x95);
op[25]=0;
op[26]=((4.0)*x91);
op[27]=0;
op[28]=x95;
op[29]=0;
op[30]=(x109+(((-1.0)*x108)));
op[31]=((((-1.0)*x110))+x111);
op[32]=((-1.0)*(((2.16)*r00)));
op[33]=((-1.0)*(((2.16)*r10)));
op[34]=(x109+x108);
op[35]=(x111+x110);
op[36]=(x77+x112);
op[37]=x113;
op[38]=((-4.0)*x74);
op[39]=0;
op[40]=((((-1.0)*x77))+x112);
op[41]=x113;
op[42]=((((-1.0)*x114))+x115);
op[43]=x116;
op[44]=((-1.0)*(((0.36)*r20)));
op[45]=0;
op[46]=(x115+x114);
op[47]=x116;
op[48]=(x74+x117);
op[49]=0;
op[50]=x77;
op[51]=0;
op[52]=(x78+x117);
op[53]=0;
op[54]=x89;
op[55]=((-4.96)+x90+x118);
op[56]=((((-1.0)*x86))+x87);
op[57]=(x88+(((-1.0)*(58.0)*npy)));
op[58]=x81;
op[59]=((-4.96)+(((-1.0)*x118))+x85);
op[60]=(x91+x92+x97);
op[61]=x99;
op[62]=(x95+x94);
op[63]=x96;
op[64]=(x98+x92+r00);
op[65]=r10;
op[66]=x106;
op[67]=x107;
op[68]=(x103+x104);
op[69]=x105;
op[70]=x101;
op[71]=x102;
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j7array[16], cj7array[16], sj7array[16], j8array[16], cj8array[16], sj8array[16], j3array[16], cj3array[16], sj3array[16];
int numsolutions = 0;
for(int ij7 = 0; ij7 < numroots; ij7 += 3)
{
IkReal htj7 = zeror[ij7+0], htj8 = zeror[ij7+1], htj3 = zeror[ij7+2];
if(isnan(htj7)||isnan(htj8)||isnan(htj3)){
continue;
}
j7array[numsolutions]=((2.0)*(atan(htj7)));
j8array[numsolutions]=((2.0)*(atan(htj8)));
j3array[numsolutions]=((2.0)*(atan(htj3)));
if(isinf(htj7)){
cj7array[numsolutions] = IKcos(j7array[numsolutions]);
sj7array[numsolutions] = IKsin(j7array[numsolutions]);
}
else{
IkReal x119=htj7*htj7;
CheckValue<IkReal> x120=IKPowWithIntegerCheck(((1.0)+x119),-1);
if(!x120.valid){
continue;
}
cj7array[numsolutions]=((x120.value)*(((1.0)+(((-1.0)*x119)))));
CheckValue<IkReal> x121=IKPowWithIntegerCheck(((1.0)+(htj7*htj7)),-1);
if(!x121.valid){
continue;
}
sj7array[numsolutions]=((2.0)*htj7*(x121.value));
}
if(isinf(htj8)){
cj8array[numsolutions] = IKcos(j8array[numsolutions]);
sj8array[numsolutions] = IKsin(j8array[numsolutions]);
}
else{
IkReal x122=htj8*htj8;
CheckValue<IkReal> x123=IKPowWithIntegerCheck(((1.0)+x122),-1);
if(!x123.valid){
continue;
}
cj8array[numsolutions]=((x123.value)*(((1.0)+(((-1.0)*x122)))));
CheckValue<IkReal> x124=IKPowWithIntegerCheck(((1.0)+(htj8*htj8)),-1);
if(!x124.valid){
continue;
}
sj8array[numsolutions]=((2.0)*htj8*(x124.value));
}
if(isinf(htj3)){
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
}
else{
IkReal x125=htj3*htj3;
CheckValue<IkReal> x126=IKPowWithIntegerCheck(((1.0)+x125),-1);
if(!x126.valid){
continue;
}
cj3array[numsolutions]=((x126.value)*(((1.0)+(((-1.0)*x125)))));
CheckValue<IkReal> x127=IKPowWithIntegerCheck(((1.0)+(htj3*htj3)),-1);
if(!x127.valid){
continue;
}
sj3array[numsolutions]=((2.0)*htj3*(x127.value));
}
if( j7array[numsolutions] > IKPI )
{
    j7array[numsolutions]-=IK2PI;
}
else if( j7array[numsolutions] < -IKPI )
{
    j7array[numsolutions]+=IK2PI;
}
if( j8array[numsolutions] > IKPI )
{
    j8array[numsolutions]-=IK2PI;
}
else if( j8array[numsolutions] < -IKPI )
{
    j8array[numsolutions]+=IK2PI;
}
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j7valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj7 = 16;
_nj8 = 1;
_nj3 = 1;
for(int ij7 = 0; ij7 < numsolutions; ++ij7)
    {
if( !j7valid[ij7] )
{
    continue;
}
_ij7[0] = ij7; _ij7[1] = -1;
_ij8[0] = 0; _ij8[1] = -1;
_ij3[0] = 0; _ij3[1] = -1;
for(int iij7 = ij7+1; iij7 < numsolutions; ++iij7)
{
if( !j7valid[iij7] ) { continue; }
if( IKabs(cj7array[ij7]-cj7array[iij7]) < IKFAST_SOLUTION_THRESH && IKabs(sj7array[ij7]-sj7array[iij7]) < IKFAST_SOLUTION_THRESH && IKabs(cj8array[ij7]-cj8array[iij7]) < IKFAST_SOLUTION_THRESH && IKabs(sj8array[ij7]-sj8array[iij7]) < IKFAST_SOLUTION_THRESH && IKabs(cj3array[ij7]-cj3array[iij7]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij7]-sj3array[iij7]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j7valid[iij7]=false; _ij7[1] = iij7; _ij8[1] = 0; _ij3[1] = 0;  break; 
}
}
    j7 = j7array[ij7]; cj7 = cj7array[ij7]; sj7 = sj7array[ij7];

    j8 = j8array[ij7]; cj8 = cj8array[ij7]; sj8 = sj8array[ij7];

    j3 = j3array[ij7]; cj3 = cj3array[ij7]; sj3 = sj3array[ij7];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j6eval[3];
IkReal x128=((1.0)*cj7);
IkReal x129=(((cj7*r01*sj8))+(((-1.0)*cj8*r00*x128))+(((-1.0)*r02*sj7)));
IkReal x130=(cj3*cj8);
IkReal x131=(cj3*sj8);
j6eval[0]=x129;
j6eval[1]=((IKabs(((((-1.0)*r21*sj7*x131))+(((-1.0)*cj3*r22*x128))+((r20*sj7*x130)))))+(IKabs((((r21*x130))+((r20*x131))))));
j6eval[2]=IKsign(x129);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x132=((((-1.0)*(1.0)*cj7*r11*sj8))+((cj7*cj8*r10))+((r12*sj7)));
IkReal x133=(r21*sj3);
IkReal x134=(r20*sj3);
j6eval[0]=x132;
j6eval[1]=((IKabs((((cj7*r22*sj3))+(((-1.0)*cj8*sj7*x134))+((sj7*sj8*x133)))))+(IKabs((((sj8*x134))+((cj8*x133))))));
j6eval[2]=IKsign(x132);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x135=(((cj7*r21*sj8))+(((-1.0)*(1.0)*r22*sj7))+(((-1.0)*(1.0)*cj7*cj8*r20)));
j6eval[0]=x135;
j6eval[1]=IKsign(x135);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
IkReal x136=(cj8*r10);
IkReal x137=(r11*sj8);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj7*x137))+((r12*sj7))+((cj7*x136)));
evalcond[2]=((-0.095)+(((-1.0)*(1.0)*py))+(((-0.09)*x137))+(((0.09)*x136)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj3=0;
cj3=1.0;
j3=0;
IkReal x138=((1.0)*cj7);
IkReal x139=(((cj7*cj8*r20))+(((-1.0)*r21*sj8*x138))+((r22*sj7)));
j6eval[0]=x139;
j6eval[1]=IKsign(x139);
j6eval[2]=((IKabs((((cj8*r01))+((r00*sj8)))))+(IKabs(((((-1.0)*(1.0)*r01*sj7*sj8))+(((-1.0)*r02*x138))+((cj8*r00*sj7))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj3=0;
cj3=1.0;
j3=0;
IkReal x140=((1.0)*sj7);
IkReal x141=((1.0)*cj7);
IkReal x142=(((cj7*r01*sj8))+(((-1.0)*r02*x140))+(((-1.0)*cj8*r00*x141)));
j6eval[0]=x142;
j6eval[1]=((IKabs((((cj8*r20*sj7))+(((-1.0)*r22*x141))+(((-1.0)*r21*sj8*x140)))))+(IKabs((((r20*sj8))+((cj8*r21))))));
j6eval[2]=IKsign(x142);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj3=0;
cj3=1.0;
j3=0;
IkReal x143=r10*r10;
IkReal x144=r11*r11;
IkReal x145=cj7*cj7;
IkReal x146=((2.0)*cj7*r12);
IkReal x147=(cj8*r10*sj7);
IkReal x148=(r11*sj7*sj8);
IkReal x149=(x144*x145);
IkReal x150=(r10*sj8);
IkReal x151=cj8*cj8;
IkReal x152=((((-1.0)*x149))+((x145*(r12*r12)))+(((-1.0)*x143*x145*x151))+x143+x144+(((-1.0)*x146*x147))+((x146*x148))+((x149*x151))+(((2.0)*cj8*r11*x145*x150)));
j6eval[0]=x152;
j6eval[1]=IKsign(x152);
j6eval[2]=((IKabs((x150+((cj8*r11)))))+(IKabs((x148+(((-1.0)*x147))+((cj7*r12))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j4, j5, j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x153=(r11*sj7*sj8);
IkReal x154=(cj8*r10*sj7);
IkReal x155=(r10*sj8);
IkReal x156=r10*r10;
IkReal x157=r11*r11;
IkReal x158=cj7*cj7;
IkReal x159=((2.0)*cj7*r12);
IkReal x160=(x157*x158);
IkReal x161=cj8*cj8;
CheckValue<IkReal> x162 = IKatan2WithCheck(IkReal(((((-1.0)*x154))+x153+((cj7*r12)))),IkReal((x155+((cj8*r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x162.valid){
continue;
}
CheckValue<IkReal> x163=IKPowWithIntegerCheck(IKsign(((((2.0)*cj8*r11*x155*x158))+x156+x157+(((-1.0)*x156*x158*x161))+((x158*(r12*r12)))+((x153*x159))+(((-1.0)*x154*x159))+(((-1.0)*x160))+((x160*x161)))),-1);
if(!x163.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x162.value)+(((1.5707963267949)*(x163.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x164=IKsin(j6);
IkReal x165=(cj8*r11);
IkReal x166=(r10*sj8);
IkReal x167=IKcos(j6);
IkReal x168=((1.0)*x167);
IkReal x169=((1.0)*sj8*x167);
IkReal x170=((1.0)*cj7*x164);
IkReal x171=((1.0)*cj8*x167);
IkReal x172=(cj8*sj7*x164);
IkReal x173=((1.0)*sj7*sj8*x164);
evalcond[0]=((((-1.0)*cj7*r12*x168))+((cj8*r10*sj7*x167))+(((-1.0)*r11*sj7*x169))+((x164*x166))+((x164*x165)));
evalcond[1]=((((-1.0)*r20*x169))+((r20*x172))+(((-1.0)*r21*x173))+(((-1.0)*r21*x171))+(((-1.0)*r22*x170)));
evalcond[2]=((((-1.0)*r02*x170))+(((-1.0)*r00*x169))+(((-1.0)*r01*x173))+(((-1.0)*r01*x171))+((r00*x172)));
evalcond[3]=((1.0)+(((-1.0)*r11*x173))+((r10*x172))+(((-1.0)*r12*x170))+(((-1.0)*x166*x168))+(((-1.0)*x165*x168)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=1.0;
j3=0;
IkReal x174=(cj8*r20);
IkReal x175=(r02*sj7);
IkReal x176=(r21*sj8);
IkReal x177=(r22*sj7);
IkReal x178=(cj7*cj8*r00);
IkReal x179=(cj7*cj8*r20);
IkReal x180=(cj7*r01*sj8);
IkReal x181=(cj7*r21*sj8);
IkReal x182=((((-1.0)*(12.0)*pz))+(((2.82)*x177))+(((-0.36)*x178))+(((1.08)*x174))+(((-1.08)*x176))+(((-0.36)*x175))+(((2.82)*x179))+(((-2.82)*x181))+(((0.36)*x180)));
j4eval[0]=((IKabs(((1.0)+x182)))+(IKabs(((1.0)+(((0.12)*x180))+(((-1.0)*(4.0)*pz))+(((0.36)*x174))+(((-0.12)*x175))+(((-0.36)*x176))+(((-0.94)*x181))+(((0.94)*x179))+(((-0.12)*x178))+(((0.94)*x177)))))+(IKabs(((-1.0)+x182))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x183=(cj8*r20);
IkReal x184=(r02*sj7);
IkReal x185=(r21*sj8);
IkReal x186=(r22*sj7);
IkReal x187=(cj7*cj8*r00);
IkReal x188=(cj7*cj8*r20);
IkReal x189=(cj7*r01*sj8);
IkReal x190=(cj7*r21*sj8);
IkReal x191=((((0.94)*x188))+(((-0.94)*x190))+(((-1.0)*(4.0)*pz))+(((-0.12)*x184))+(((0.12)*x189))+(((-0.36)*x185))+(((0.94)*x186))+(((-0.12)*x187))+(((0.36)*x183)));
IkReal x192=((((-1.0)*(12.0)*pz))+(((-1.08)*x185))+(((2.82)*x188))+(((-0.36)*x187))+(((0.36)*x189))+(((-2.82)*x190))+(((-0.36)*x184))+(((2.82)*x186))+(((1.08)*x183)));
op[0]=((1.0)+x191);
op[1]=0;
op[2]=((1.0)+x192);
op[3]=0;
op[4]=((-1.0)+x192);
op[5]=0;
op[6]=((-1.0)+x191);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x193=(cj8*r00);
IkReal x194=(cj8*r20);
IkReal x195=(r01*sj8);
IkReal x196=(r21*sj8);
IkReal x197=(r22*sj7);
IkReal x198=(cj7*cj8*r20);
IkReal x199=(cj7*r21*sj8);
IkReal x200=((((0.0846)*x194))+(((-0.0108)*x195))+(((0.2245)*x198))+(((-1.0)*(0.94)*pz))+(((0.0108)*x193))+(((-0.2245)*x199))+(((0.2245)*x197))+(((-0.0846)*x196))+(((-1.0)*(0.12)*px)));
IkReal x201=((((0.0324)*x193))+(((0.6735)*x198))+(((-0.2538)*x196))+(((-1.0)*(0.36)*px))+(((0.2538)*x194))+(((-0.0324)*x195))+(((-0.6735)*x199))+(((-1.0)*(2.82)*pz))+(((0.6735)*x197)));
j4evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj4*htj4*htj4)))+(((htj4*htj4*htj4*htj4)*(((0.235)+x201))))+(((htj4*htj4)*(((-0.235)+x201))))+(((-1.0)*(0.06)*(htj4*htj4*htj4*htj4*htj4)))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((0.235)+x200))))+(((-1.0)*(0.06)*htj4))+x200);
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x202=(r22*sj7);
IkReal x203=((1.0)*cj4);
IkReal x204=(r02*sj7);
IkReal x205=(cj4*cj7*sj8);
IkReal x206=(cj7*sj4);
IkReal x207=(cj8*r20);
IkReal x208=(cj8*r00);
IkReal x209=((1.0)*cj4*cj7);
IkReal x210=((1.0)*cj7*sj4);
if( IKabs((((sj4*x202))+(((-1.0)*x203*x204))+((x206*x207))+((r01*x205))+(((-1.0)*x208*x209))+(((-1.0)*r21*sj8*x210)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x202*x203))+(((-1.0)*x207*x209))+((r01*sj8*x206))+((r21*x205))+(((-1.0)*x208*x210))+(((-1.0)*sj4*x204)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj4*x202))+(((-1.0)*x203*x204))+((x206*x207))+((r01*x205))+(((-1.0)*x208*x209))+(((-1.0)*r21*sj8*x210))))+IKsqr(((((-1.0)*x202*x203))+(((-1.0)*x207*x209))+((r01*sj8*x206))+((r21*x205))+(((-1.0)*x208*x210))+(((-1.0)*sj4*x204))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((sj4*x202))+(((-1.0)*x203*x204))+((x206*x207))+((r01*x205))+(((-1.0)*x208*x209))+(((-1.0)*r21*sj8*x210))), ((((-1.0)*x202*x203))+(((-1.0)*x207*x209))+((r01*sj8*x206))+((r21*x205))+(((-1.0)*x208*x210))+(((-1.0)*sj4*x204))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x211=IKsin(j5);
IkReal x212=(cj4*x211);
IkReal x213=IKcos(j5);
IkReal x214=(sj4*x213);
IkReal x215=(cj7*cj8);
IkReal x216=((1.0)*cj7*sj8);
IkReal x217=(cj4*x213);
IkReal x218=(sj4*x211);
IkReal x219=((((-1.0)*x218))+x217);
IkReal x220=(cj8*sj6);
IkReal x221=(sj6*sj8);
IkReal x222=((1.0)*cj6*cj7);
IkReal x223=(cj6*cj8*sj7);
IkReal x224=((1.0)*cj6*sj7*sj8);
IkReal x225=((0.09)*cj8);
IkReal x226=((0.09)*sj8);
evalcond[0]=((((-1.0)*r01*x216))+((r02*sj7))+x214+x212+((r00*x215)));
evalcond[1]=(((r20*x215))+x219+((r22*sj7))+(((-1.0)*r21*x216)));
evalcond[2]=(((r00*x223))+(((-1.0)*r02*x222))+(((-1.0)*r01*x224))+((r00*x221))+x219+((r01*x220)));
evalcond[3]=((((-1.0)*x212))+(((-1.0)*r21*x224))+(((-1.0)*r22*x222))+((r20*x223))+((r20*x221))+(((-1.0)*x214))+((r21*x220)));
evalcond[4]=((((-1.0)*r21*x226))+(((-1.0)*(1.0)*pz))+(((0.03)*x212))+(((-0.235)*x217))+((r20*x225))+(((0.03)*x214))+(((-1.0)*(0.25)*cj4))+(((0.235)*x218)));
evalcond[5]=((((-1.0)*(1.0)*px))+(((-0.235)*x212))+(((-0.235)*x214))+(((-0.03)*x217))+(((-1.0)*r01*x226))+(((0.03)*x218))+(((-1.0)*(0.25)*sj4))+((r00*x225)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x227=((1.0)*sj7);
IkReal x228=((1.0)*cj7);
CheckValue<IkReal> x229=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj8*r00*x228))+((cj7*r01*sj8))+(((-1.0)*r02*x227)))),-1);
if(!x229.valid){
continue;
}
CheckValue<IkReal> x230 = IKatan2WithCheck(IkReal((((r20*sj8))+((cj8*r21)))),IkReal((((cj8*r20*sj7))+(((-1.0)*r21*sj8*x227))+(((-1.0)*r22*x228)))),IKFAST_ATAN2_MAGTHRESH);
if(!x230.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x229.value)))+(x230.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x231=IKsin(j6);
IkReal x232=(cj8*r11);
IkReal x233=(r10*sj8);
IkReal x234=IKcos(j6);
IkReal x235=((1.0)*x234);
IkReal x236=((1.0)*sj8*x234);
IkReal x237=((1.0)*cj7*x231);
IkReal x238=((1.0)*cj8*x234);
IkReal x239=(cj8*sj7*x231);
IkReal x240=((1.0)*sj7*sj8*x231);
evalcond[0]=(((x231*x233))+((x231*x232))+((cj8*r10*sj7*x234))+(((-1.0)*r11*sj7*x236))+(((-1.0)*cj7*r12*x235)));
evalcond[1]=((((-1.0)*r22*x237))+(((-1.0)*r21*x240))+(((-1.0)*r20*x236))+((r20*x239))+(((-1.0)*r21*x238)));
evalcond[2]=((((-1.0)*r02*x237))+(((-1.0)*r01*x238))+((r00*x239))+(((-1.0)*r01*x240))+(((-1.0)*r00*x236)));
evalcond[3]=((1.0)+(((-1.0)*r12*x237))+(((-1.0)*x233*x235))+(((-1.0)*x232*x235))+(((-1.0)*r11*x240))+((r10*x239)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=1.0;
j3=0;
IkReal x241=(cj8*r20);
IkReal x242=(r02*sj7);
IkReal x243=(r21*sj8);
IkReal x244=(r22*sj7);
IkReal x245=(cj7*cj8*r00);
IkReal x246=(cj7*cj8*r20);
IkReal x247=(cj7*r01*sj8);
IkReal x248=(cj7*r21*sj8);
IkReal x249=((((-0.36)*x242))+(((-2.82)*x248))+(((0.36)*x247))+(((-1.0)*(12.0)*pz))+(((1.08)*x241))+(((2.82)*x244))+(((-1.08)*x243))+(((2.82)*x246))+(((-0.36)*x245)));
j4eval[0]=((IKabs(((1.0)+(((-0.94)*x248))+(((-1.0)*(4.0)*pz))+(((0.12)*x247))+(((0.36)*x241))+(((0.94)*x244))+(((0.94)*x246))+(((-0.12)*x242))+(((-0.12)*x245))+(((-0.36)*x243)))))+(IKabs(((1.0)+x249)))+(IKabs(((-1.0)+x249))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x250=(cj8*r20);
IkReal x251=(r02*sj7);
IkReal x252=(r21*sj8);
IkReal x253=(r22*sj7);
IkReal x254=(cj7*cj8*r00);
IkReal x255=(cj7*cj8*r20);
IkReal x256=(cj7*r01*sj8);
IkReal x257=(cj7*r21*sj8);
IkReal x258=((((-0.36)*x252))+(((-1.0)*(4.0)*pz))+(((0.12)*x256))+(((0.36)*x250))+(((0.94)*x253))+(((-0.12)*x254))+(((0.94)*x255))+(((-0.12)*x251))+(((-0.94)*x257)));
IkReal x259=((((2.82)*x255))+(((0.36)*x256))+(((-1.0)*(12.0)*pz))+(((-2.82)*x257))+(((-1.08)*x252))+(((-0.36)*x254))+(((-0.36)*x251))+(((1.08)*x250))+(((2.82)*x253)));
op[0]=((1.0)+x258);
op[1]=0;
op[2]=((1.0)+x259);
op[3]=0;
op[4]=((-1.0)+x259);
op[5]=0;
op[6]=((-1.0)+x258);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x260=(cj8*r00);
IkReal x261=(cj8*r20);
IkReal x262=(r01*sj8);
IkReal x263=(r21*sj8);
IkReal x264=(r22*sj7);
IkReal x265=(cj7*cj8*r20);
IkReal x266=(cj7*r21*sj8);
IkReal x267=((((0.0108)*x260))+(((-0.0846)*x263))+(((0.2245)*x264))+(((-1.0)*(0.94)*pz))+(((0.0846)*x261))+(((0.2245)*x265))+(((-0.0108)*x262))+(((-0.2245)*x266))+(((-1.0)*(0.12)*px)));
IkReal x268=((((0.0324)*x260))+(((-1.0)*(0.36)*px))+(((0.6735)*x264))+(((-0.6735)*x266))+(((-0.2538)*x263))+(((-0.0324)*x262))+(((0.6735)*x265))+(((-1.0)*(2.82)*pz))+(((0.2538)*x261)));
j4evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj4*htj4*htj4)))+x267+(((-1.0)*(0.06)*(htj4*htj4*htj4*htj4*htj4)))+(((-1.0)*(0.06)*htj4))+(((htj4*htj4*htj4*htj4)*(((0.235)+x268))))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((0.235)+x267))))+(((htj4*htj4)*(((-0.235)+x268)))));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x269=(r22*sj7);
IkReal x270=((1.0)*cj4);
IkReal x271=(r02*sj7);
IkReal x272=(cj4*cj7*sj8);
IkReal x273=(cj7*sj4);
IkReal x274=(cj8*r20);
IkReal x275=(cj8*r00);
IkReal x276=((1.0)*cj4*cj7);
IkReal x277=((1.0)*cj7*sj4);
if( IKabs(((((-1.0)*x275*x276))+((x273*x274))+((sj4*x269))+((r01*x272))+(((-1.0)*x270*x271))+(((-1.0)*r21*sj8*x277)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x274*x276))+((r21*x272))+(((-1.0)*sj4*x271))+((r01*sj8*x273))+(((-1.0)*x269*x270))+(((-1.0)*x275*x277)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x275*x276))+((x273*x274))+((sj4*x269))+((r01*x272))+(((-1.0)*x270*x271))+(((-1.0)*r21*sj8*x277))))+IKsqr(((((-1.0)*x274*x276))+((r21*x272))+(((-1.0)*sj4*x271))+((r01*sj8*x273))+(((-1.0)*x269*x270))+(((-1.0)*x275*x277))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x275*x276))+((x273*x274))+((sj4*x269))+((r01*x272))+(((-1.0)*x270*x271))+(((-1.0)*r21*sj8*x277))), ((((-1.0)*x274*x276))+((r21*x272))+(((-1.0)*sj4*x271))+((r01*sj8*x273))+(((-1.0)*x269*x270))+(((-1.0)*x275*x277))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x278=IKsin(j5);
IkReal x279=(cj4*x278);
IkReal x280=IKcos(j5);
IkReal x281=(sj4*x280);
IkReal x282=(cj7*cj8);
IkReal x283=((1.0)*cj7*sj8);
IkReal x284=(cj4*x280);
IkReal x285=(sj4*x278);
IkReal x286=(x284+(((-1.0)*x285)));
IkReal x287=(cj8*sj6);
IkReal x288=(sj6*sj8);
IkReal x289=((1.0)*cj6*cj7);
IkReal x290=(cj6*cj8*sj7);
IkReal x291=((1.0)*cj6*sj7*sj8);
IkReal x292=((0.09)*cj8);
IkReal x293=((0.09)*sj8);
evalcond[0]=((((-1.0)*r01*x283))+((r02*sj7))+((r00*x282))+x279+x281);
evalcond[1]=((((-1.0)*r21*x283))+((r20*x282))+((r22*sj7))+x286);
evalcond[2]=(((r00*x288))+((r00*x290))+(((-1.0)*r02*x289))+(((-1.0)*r01*x291))+((r01*x287))+x286);
evalcond[3]=(((r21*x287))+(((-1.0)*r21*x291))+(((-1.0)*r22*x289))+(((-1.0)*x281))+((r20*x288))+((r20*x290))+(((-1.0)*x279)));
evalcond[4]=(((r20*x292))+(((0.235)*x285))+(((-1.0)*(1.0)*pz))+(((-1.0)*(0.25)*cj4))+(((-0.235)*x284))+(((0.03)*x281))+(((0.03)*x279))+(((-1.0)*r21*x293)));
evalcond[5]=((((-1.0)*r01*x293))+(((-1.0)*(1.0)*px))+(((0.03)*x285))+((r00*x292))+(((-0.235)*x281))+(((-0.235)*x279))+(((-0.03)*x284))+(((-1.0)*(0.25)*sj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x294=((1.0)*cj7);
CheckValue<IkReal> x295=IKPowWithIntegerCheck(IKsign(((((-1.0)*r21*sj8*x294))+((cj7*cj8*r20))+((r22*sj7)))),-1);
if(!x295.valid){
continue;
}
CheckValue<IkReal> x296 = IKatan2WithCheck(IkReal((((cj8*r01))+((r00*sj8)))),IkReal(((((-1.0)*r02*x294))+(((-1.0)*(1.0)*r01*sj7*sj8))+((cj8*r00*sj7)))),IKFAST_ATAN2_MAGTHRESH);
if(!x296.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x295.value)))+(x296.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x297=IKsin(j6);
IkReal x298=(cj8*r11);
IkReal x299=(r10*sj8);
IkReal x300=IKcos(j6);
IkReal x301=((1.0)*x300);
IkReal x302=((1.0)*sj8*x300);
IkReal x303=((1.0)*cj7*x297);
IkReal x304=((1.0)*cj8*x300);
IkReal x305=(cj8*sj7*x297);
IkReal x306=((1.0)*sj7*sj8*x297);
evalcond[0]=((((-1.0)*cj7*r12*x301))+(((-1.0)*r11*sj7*x302))+((x297*x298))+((cj8*r10*sj7*x300))+((x297*x299)));
evalcond[1]=(((r20*x305))+(((-1.0)*r21*x304))+(((-1.0)*r22*x303))+(((-1.0)*r21*x306))+(((-1.0)*r20*x302)));
evalcond[2]=((((-1.0)*r02*x303))+(((-1.0)*r00*x302))+(((-1.0)*r01*x304))+((r00*x305))+(((-1.0)*r01*x306)));
evalcond[3]=((1.0)+(((-1.0)*r12*x303))+((r10*x305))+(((-1.0)*x298*x301))+(((-1.0)*x299*x301))+(((-1.0)*r11*x306)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=1.0;
j3=0;
IkReal x307=(cj8*r20);
IkReal x308=(r02*sj7);
IkReal x309=(r21*sj8);
IkReal x310=(r22*sj7);
IkReal x311=(cj7*cj8*r00);
IkReal x312=(cj7*cj8*r20);
IkReal x313=(cj7*r01*sj8);
IkReal x314=(cj7*r21*sj8);
IkReal x315=((((1.08)*x307))+(((0.36)*x313))+(((-1.0)*(12.0)*pz))+(((-0.36)*x308))+(((-0.36)*x311))+(((-1.08)*x309))+(((-2.82)*x314))+(((2.82)*x310))+(((2.82)*x312)));
j4eval[0]=((IKabs(((1.0)+x315)))+(IKabs(((1.0)+(((-1.0)*(4.0)*pz))+(((0.94)*x310))+(((0.94)*x312))+(((-0.36)*x309))+(((0.36)*x307))+(((0.12)*x313))+(((-0.12)*x311))+(((-0.94)*x314))+(((-0.12)*x308)))))+(IKabs(((-1.0)+x315))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x316=(cj8*r20);
IkReal x317=(r02*sj7);
IkReal x318=(r21*sj8);
IkReal x319=(r22*sj7);
IkReal x320=(cj7*cj8*r00);
IkReal x321=(cj7*cj8*r20);
IkReal x322=(cj7*r01*sj8);
IkReal x323=(cj7*r21*sj8);
IkReal x324=((((-0.12)*x320))+(((-1.0)*(4.0)*pz))+(((-0.94)*x323))+(((0.12)*x322))+(((0.36)*x316))+(((-0.36)*x318))+(((0.94)*x319))+(((-0.12)*x317))+(((0.94)*x321)));
IkReal x325=((((-1.0)*(12.0)*pz))+(((0.36)*x322))+(((-2.82)*x323))+(((-0.36)*x317))+(((1.08)*x316))+(((2.82)*x319))+(((2.82)*x321))+(((-0.36)*x320))+(((-1.08)*x318)));
op[0]=((1.0)+x324);
op[1]=0;
op[2]=((1.0)+x325);
op[3]=0;
op[4]=((-1.0)+x325);
op[5]=0;
op[6]=((-1.0)+x324);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x326=(cj8*r00);
IkReal x327=(cj8*r20);
IkReal x328=(r01*sj8);
IkReal x329=(r21*sj8);
IkReal x330=(r22*sj7);
IkReal x331=(cj7*cj8*r20);
IkReal x332=(cj7*r21*sj8);
IkReal x333=((((0.0846)*x327))+(((-0.0108)*x328))+(((0.2245)*x331))+(((0.2245)*x330))+(((0.0108)*x326))+(((-0.2245)*x332))+(((-0.0846)*x329))+(((-1.0)*(0.94)*pz))+(((-1.0)*(0.12)*px)));
IkReal x334=((((-1.0)*(0.36)*px))+(((0.6735)*x331))+(((0.6735)*x330))+(((0.2538)*x327))+(((-0.0324)*x328))+(((-0.6735)*x332))+(((-0.2538)*x329))+(((-1.0)*(2.82)*pz))+(((0.0324)*x326)));
j4evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj4*htj4*htj4)))+(((-1.0)*(0.06)*(htj4*htj4*htj4*htj4*htj4)))+(((htj4*htj4)*(((-0.235)+x334))))+x333+(((-1.0)*(0.06)*htj4))+(((htj4*htj4*htj4*htj4)*(((0.235)+x334))))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((0.235)+x333)))));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x335=(r22*sj7);
IkReal x336=((1.0)*cj4);
IkReal x337=(r02*sj7);
IkReal x338=(cj4*cj7*sj8);
IkReal x339=(cj7*sj4);
IkReal x340=(cj8*r20);
IkReal x341=(cj8*r00);
IkReal x342=((1.0)*cj4*cj7);
IkReal x343=((1.0)*cj7*sj4);
if( IKabs(((((-1.0)*x341*x342))+((x339*x340))+((r01*x338))+(((-1.0)*r21*sj8*x343))+(((-1.0)*x336*x337))+((sj4*x335)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj4*x337))+(((-1.0)*x341*x343))+((r21*x338))+(((-1.0)*x340*x342))+(((-1.0)*x335*x336))+((r01*sj8*x339)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x341*x342))+((x339*x340))+((r01*x338))+(((-1.0)*r21*sj8*x343))+(((-1.0)*x336*x337))+((sj4*x335))))+IKsqr(((((-1.0)*sj4*x337))+(((-1.0)*x341*x343))+((r21*x338))+(((-1.0)*x340*x342))+(((-1.0)*x335*x336))+((r01*sj8*x339))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x341*x342))+((x339*x340))+((r01*x338))+(((-1.0)*r21*sj8*x343))+(((-1.0)*x336*x337))+((sj4*x335))), ((((-1.0)*sj4*x337))+(((-1.0)*x341*x343))+((r21*x338))+(((-1.0)*x340*x342))+(((-1.0)*x335*x336))+((r01*sj8*x339))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x344=IKsin(j5);
IkReal x345=(cj4*x344);
IkReal x346=IKcos(j5);
IkReal x347=(sj4*x346);
IkReal x348=(cj7*cj8);
IkReal x349=((1.0)*cj7*sj8);
IkReal x350=(cj4*x346);
IkReal x351=(sj4*x344);
IkReal x352=(x350+(((-1.0)*x351)));
IkReal x353=(cj8*sj6);
IkReal x354=(sj6*sj8);
IkReal x355=((1.0)*cj6*cj7);
IkReal x356=(cj6*cj8*sj7);
IkReal x357=((1.0)*cj6*sj7*sj8);
IkReal x358=((0.09)*cj8);
IkReal x359=((0.09)*sj8);
evalcond[0]=(((r02*sj7))+((r00*x348))+(((-1.0)*r01*x349))+x345+x347);
evalcond[1]=(x352+((r20*x348))+((r22*sj7))+(((-1.0)*r21*x349)));
evalcond[2]=(((r01*x353))+((r00*x356))+(((-1.0)*r02*x355))+(((-1.0)*r01*x357))+x352+((r00*x354)));
evalcond[3]=((((-1.0)*x347))+((r20*x354))+(((-1.0)*r22*x355))+(((-1.0)*x345))+(((-1.0)*r21*x357))+((r20*x356))+((r21*x353)));
evalcond[4]=((((-0.235)*x350))+(((-1.0)*(1.0)*pz))+(((0.235)*x351))+(((0.03)*x347))+(((-1.0)*r21*x359))+(((-1.0)*(0.25)*cj4))+(((0.03)*x345))+((r20*x358)));
evalcond[5]=((((-1.0)*r01*x359))+(((-1.0)*(1.0)*px))+(((-0.235)*x345))+(((-0.235)*x347))+(((0.03)*x351))+(((-0.03)*x350))+(((-1.0)*(0.25)*sj4))+((r00*x358)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x360=(cj8*r10);
IkReal x361=(r11*sj8);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=(((cj7*x360))+((r12*sj7))+(((-1.0)*cj7*x361)));
evalcond[2]=((0.095)+(((0.09)*x360))+(((-1.0)*(1.0)*py))+(((-0.09)*x361)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x362=((1.0)*sj8);
IkReal x363=(((cj7*cj8*r20))+(((-1.0)*cj7*r21*x362))+((r22*sj7)));
IkReal x364=((1.0)*cj8);
j6eval[0]=x363;
j6eval[1]=IKsign(x363);
j6eval[2]=((IKabs(((((-1.0)*r00*sj7*x364))+((r01*sj7*sj8))+((cj7*r02)))))+(IKabs(((((-1.0)*r00*x362))+(((-1.0)*r01*x364))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x365=((1.0)*cj8);
IkReal x366=(((cj7*r01*sj8))+(((-1.0)*(1.0)*r02*sj7))+(((-1.0)*cj7*r00*x365)));
j6eval[0]=x366;
j6eval[1]=IKsign(x366);
j6eval[2]=((IKabs((((cj7*r22))+((r21*sj7*sj8))+(((-1.0)*r20*sj7*x365)))))+(IKabs(((((-1.0)*r21*x365))+(((-1.0)*(1.0)*r20*sj8))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x367=r10*r10;
IkReal x368=r11*r11;
IkReal x369=cj7*cj7;
IkReal x370=((2.0)*cj7*r12);
IkReal x371=(cj8*r10*sj7);
IkReal x372=(x368*x369);
IkReal x373=(r10*sj8);
IkReal x374=cj8*cj8;
IkReal x375=(((x372*x374))+(((2.0)*cj8*r11*x369*x373))+(((-1.0)*x367*x369*x374))+(((-1.0)*x370*x371))+((r11*sj7*sj8*x370))+(((-1.0)*x372))+x368+x367+((x369*(r12*r12))));
IkReal x376=((1.0)*r11);
j6eval[0]=x375;
j6eval[1]=IKsign(x375);
j6eval[2]=((IKabs(((((-1.0)*cj8*x376))+(((-1.0)*x373)))))+(IKabs(((((-1.0)*sj7*sj8*x376))+x371+(((-1.0)*cj7*r12))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j4, j5, j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x377=(cj8*r10*sj7);
IkReal x378=((1.0)*r11);
IkReal x379=(r10*sj8);
IkReal x380=r10*r10;
IkReal x381=r11*r11;
IkReal x382=cj7*cj7;
IkReal x383=((2.0)*cj7*r12);
IkReal x384=(x381*x382);
IkReal x385=cj8*cj8;
CheckValue<IkReal> x386 = IKatan2WithCheck(IkReal(((((-1.0)*sj7*sj8*x378))+x377+(((-1.0)*cj7*r12)))),IkReal(((((-1.0)*x379))+(((-1.0)*cj8*x378)))),IKFAST_ATAN2_MAGTHRESH);
if(!x386.valid){
continue;
}
CheckValue<IkReal> x387=IKPowWithIntegerCheck(IKsign((((x384*x385))+((x382*(r12*r12)))+x381+x380+(((-1.0)*x377*x383))+(((2.0)*cj8*r11*x379*x382))+((r11*sj7*sj8*x383))+(((-1.0)*x380*x382*x385))+(((-1.0)*x384)))),-1);
if(!x387.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x386.value)+(((1.5707963267949)*(x387.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x388=IKsin(j6);
IkReal x389=(cj8*r11);
IkReal x390=(r10*sj8);
IkReal x391=IKcos(j6);
IkReal x392=((1.0)*x391);
IkReal x393=((1.0)*sj8*x391);
IkReal x394=((1.0)*cj7*x388);
IkReal x395=((1.0)*cj8*x391);
IkReal x396=(cj8*sj7*x388);
IkReal x397=((1.0)*sj7*sj8*x388);
evalcond[0]=(((x388*x390))+(((-1.0)*r11*sj7*x393))+(((-1.0)*cj7*r12*x392))+((x388*x389))+((cj8*r10*sj7*x391)));
evalcond[1]=((((-1.0)*r21*x397))+(((-1.0)*r20*x393))+(((-1.0)*r22*x394))+((r20*x396))+(((-1.0)*r21*x395)));
evalcond[2]=((((-1.0)*r02*x394))+(((-1.0)*r01*x397))+((r00*x396))+(((-1.0)*r00*x393))+(((-1.0)*r01*x395)));
evalcond[3]=((-1.0)+(((-1.0)*r12*x394))+((r10*x396))+(((-1.0)*r11*x397))+(((-1.0)*x390*x392))+(((-1.0)*x389*x392)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x398=(cj8*r20);
IkReal x399=(r02*sj7);
IkReal x400=(r21*sj8);
IkReal x401=(r22*sj7);
IkReal x402=(cj7*cj8*r00);
IkReal x403=(cj7*cj8*r20);
IkReal x404=(cj7*r01*sj8);
IkReal x405=(cj7*r21*sj8);
IkReal x406=((((-0.36)*x399))+(((-0.36)*x402))+(((-2.82)*x401))+(((2.82)*x405))+(((-2.82)*x403))+(((0.36)*x404))+(((1.08)*x400))+(((-1.08)*x398))+(((12.0)*pz)));
j4eval[0]=((IKabs(((-1.0)+(((0.12)*x404))+(((0.36)*x400))+(((-0.12)*x399))+(((-0.36)*x398))+(((4.0)*pz))+(((-0.94)*x401))+(((-0.12)*x402))+(((-0.94)*x403))+(((0.94)*x405)))))+(IKabs(((1.0)+x406)))+(IKabs(((-1.0)+x406))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x407=(cj8*r20);
IkReal x408=(r02*sj7);
IkReal x409=(r21*sj8);
IkReal x410=(r22*sj7);
IkReal x411=(cj7*cj8*r00);
IkReal x412=(cj7*cj8*r20);
IkReal x413=(cj7*r01*sj8);
IkReal x414=(cj7*r21*sj8);
IkReal x415=((((-0.12)*x408))+(((0.94)*x414))+(((0.12)*x413))+(((-0.94)*x412))+(((0.36)*x409))+(((4.0)*pz))+(((-0.94)*x410))+(((-0.12)*x411))+(((-0.36)*x407)));
IkReal x416=((((-1.08)*x407))+(((1.08)*x409))+(((-0.36)*x408))+(((-0.36)*x411))+(((2.82)*x414))+(((0.36)*x413))+(((12.0)*pz))+(((-2.82)*x412))+(((-2.82)*x410)));
op[0]=((-1.0)+x415);
op[1]=0;
op[2]=((-1.0)+x416);
op[3]=0;
op[4]=((1.0)+x416);
op[5]=0;
op[6]=((1.0)+x415);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x417=(cj8*r20);
IkReal x418=((0.36)*x417);
IkReal x419=(r21*sj8);
IkReal x420=((0.36)*x419);
IkReal x421=(r22*sj7);
IkReal x422=(cj6*cj7*r22);
IkReal x423=(cj7*cj8*r20);
IkReal x424=(cj7*r21*sj8);
IkReal x425=(cj8*r21*sj6);
IkReal x426=(r20*sj6*sj8);
IkReal x427=((0.12)*cj6*sj7);
IkReal x428=((((0.94)*x421))+(((-0.94)*x424))+(((-1.0)*x419*x427))+(((0.12)*x425))+(((-1.0)*(4.0)*pz))+(((-1.0)*x420))+x418+((x417*x427))+(((0.12)*x426))+(((0.94)*x423))+(((-0.12)*x422)));
IkReal x429=(cj6*sj7);
IkReal x430=((((0.36)*x425))+(((-2.82)*x424))+(((-1.0)*(12.0)*pz))+(((-1.0)*x420*x429))+(((2.82)*x421))+((x418*x429))+(((-1.08)*x419))+(((0.36)*x426))+(((2.82)*x423))+(((-0.36)*x422))+(((1.08)*x417)));
j4evalpoly[0]=((-1.0)+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((1.0)+x428))))+(((htj4*htj4)*(((-1.0)+x430))))+x428+(((htj4*htj4*htj4*htj4)*(((1.0)+x430)))));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x431=(r02*sj7);
IkReal x432=(r22*sj7);
IkReal x433=(cj4*cj7);
IkReal x434=(cj8*r00);
IkReal x435=(cj7*sj4);
IkReal x436=(cj8*r20);
IkReal x437=(r01*sj8);
IkReal x438=((1.0)*cj4*cj7);
IkReal x439=(r21*sj8);
IkReal x440=((1.0)*cj7*sj4);
if( IKabs(((((-1.0)*x439*x440))+((x435*x436))+((x433*x434))+((cj4*x431))+((sj4*x432))+(((-1.0)*x437*x438)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj4*x431))+(((-1.0)*x437*x440))+((x434*x435))+((x433*x439))+(((-1.0)*x436*x438))+(((-1.0)*cj4*x432)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x439*x440))+((x435*x436))+((x433*x434))+((cj4*x431))+((sj4*x432))+(((-1.0)*x437*x438))))+IKsqr((((sj4*x431))+(((-1.0)*x437*x440))+((x434*x435))+((x433*x439))+(((-1.0)*x436*x438))+(((-1.0)*cj4*x432))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x439*x440))+((x435*x436))+((x433*x434))+((cj4*x431))+((sj4*x432))+(((-1.0)*x437*x438))), (((sj4*x431))+(((-1.0)*x437*x440))+((x434*x435))+((x433*x439))+(((-1.0)*x436*x438))+(((-1.0)*cj4*x432))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x441=IKcos(j5);
IkReal x442=(cj4*x441);
IkReal x443=(cj7*cj8);
IkReal x444=IKsin(j5);
IkReal x445=(sj4*x444);
IkReal x446=((1.0)*cj7*sj8);
IkReal x447=(cj4*x444);
IkReal x448=(sj4*x441);
IkReal x449=((((-1.0)*x448))+(((-1.0)*x447)));
IkReal x450=(cj8*sj6);
IkReal x451=(sj6*sj8);
IkReal x452=((1.0)*cj6*cj7);
IkReal x453=(cj6*cj8*sj7);
IkReal x454=((1.0)*cj6*sj7*sj8);
IkReal x455=((0.09)*cj8);
IkReal x456=((0.09)*sj8);
evalcond[0]=((((-1.0)*r21*x446))+((r20*x443))+x442+((r22*sj7))+(((-1.0)*x445)));
evalcond[1]=(((r02*sj7))+(((-1.0)*r01*x446))+((r00*x443))+x449);
evalcond[2]=((((-1.0)*r02*x452))+((r01*x450))+(((-1.0)*r01*x454))+(((-1.0)*x442))+((r00*x453))+x445+((r00*x451)));
evalcond[3]=((((-1.0)*r21*x454))+((r20*x453))+x449+(((-1.0)*r22*x452))+((r21*x450))+((r20*x451)));
evalcond[4]=(((r20*x455))+(((0.03)*x448))+(((-1.0)*(1.0)*pz))+(((-1.0)*r21*x456))+(((0.235)*x445))+(((-0.235)*x442))+(((-1.0)*(0.25)*cj4))+(((0.03)*x447)));
evalcond[5]=((((-1.0)*(1.0)*px))+(((0.235)*x447))+(((0.03)*x442))+(((-1.0)*r01*x456))+(((0.25)*sj4))+(((-0.03)*x445))+((r00*x455))+(((0.235)*x448)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x457=((1.0)*cj8);
CheckValue<IkReal> x458=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj7*r00*x457))+((cj7*r01*sj8))+(((-1.0)*(1.0)*r02*sj7)))),-1);
if(!x458.valid){
continue;
}
CheckValue<IkReal> x459 = IKatan2WithCheck(IkReal(((((-1.0)*(1.0)*r20*sj8))+(((-1.0)*r21*x457)))),IkReal((((cj7*r22))+((r21*sj7*sj8))+(((-1.0)*r20*sj7*x457)))),IKFAST_ATAN2_MAGTHRESH);
if(!x459.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x458.value)))+(x459.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x460=IKsin(j6);
IkReal x461=(cj8*r11);
IkReal x462=(r10*sj8);
IkReal x463=IKcos(j6);
IkReal x464=((1.0)*x463);
IkReal x465=((1.0)*sj8*x463);
IkReal x466=((1.0)*cj7*x460);
IkReal x467=((1.0)*cj8*x463);
IkReal x468=(cj8*sj7*x460);
IkReal x469=((1.0)*sj7*sj8*x460);
evalcond[0]=(((cj8*r10*sj7*x463))+(((-1.0)*cj7*r12*x464))+(((-1.0)*r11*sj7*x465))+((x460*x462))+((x460*x461)));
evalcond[1]=(((r20*x468))+(((-1.0)*r21*x469))+(((-1.0)*r22*x466))+(((-1.0)*r20*x465))+(((-1.0)*r21*x467)));
evalcond[2]=((((-1.0)*r02*x466))+(((-1.0)*r01*x469))+(((-1.0)*r01*x467))+((r00*x468))+(((-1.0)*r00*x465)));
evalcond[3]=((-1.0)+(((-1.0)*r12*x466))+(((-1.0)*x461*x464))+(((-1.0)*x462*x464))+(((-1.0)*r11*x469))+((r10*x468)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x470=(cj8*r20);
IkReal x471=(r02*sj7);
IkReal x472=(r21*sj8);
IkReal x473=(r22*sj7);
IkReal x474=(cj7*cj8*r00);
IkReal x475=(cj7*cj8*r20);
IkReal x476=(cj7*r01*sj8);
IkReal x477=(cj7*r21*sj8);
IkReal x478=((((2.82)*x477))+(((0.36)*x476))+(((-1.08)*x470))+(((-2.82)*x473))+(((-2.82)*x475))+(((1.08)*x472))+(((-0.36)*x474))+(((12.0)*pz))+(((-0.36)*x471)));
j4eval[0]=((IKabs(((-1.0)+(((0.12)*x476))+(((-0.12)*x474))+(((0.94)*x477))+(((0.36)*x472))+(((4.0)*pz))+(((-0.94)*x475))+(((-0.12)*x471))+(((-0.36)*x470))+(((-0.94)*x473)))))+(IKabs(((-1.0)+x478)))+(IKabs(((1.0)+x478))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x479=(cj8*r20);
IkReal x480=(r02*sj7);
IkReal x481=(r21*sj8);
IkReal x482=(r22*sj7);
IkReal x483=(cj7*cj8*r00);
IkReal x484=(cj7*cj8*r20);
IkReal x485=(cj7*r01*sj8);
IkReal x486=(cj7*r21*sj8);
IkReal x487=((((-0.94)*x484))+(((-0.94)*x482))+(((0.12)*x485))+(((4.0)*pz))+(((0.94)*x486))+(((0.36)*x481))+(((-0.36)*x479))+(((-0.12)*x480))+(((-0.12)*x483)));
IkReal x488=((((1.08)*x481))+(((-0.36)*x483))+(((0.36)*x485))+(((-1.08)*x479))+(((-2.82)*x484))+(((-0.36)*x480))+(((-2.82)*x482))+(((2.82)*x486))+(((12.0)*pz)));
op[0]=((-1.0)+x487);
op[1]=0;
op[2]=((-1.0)+x488);
op[3]=0;
op[4]=((1.0)+x488);
op[5]=0;
op[6]=((1.0)+x487);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x489=(cj8*r20);
IkReal x490=((0.36)*x489);
IkReal x491=(r21*sj8);
IkReal x492=((0.36)*x491);
IkReal x493=(r22*sj7);
IkReal x494=(cj6*cj7*r22);
IkReal x495=(cj7*cj8*r20);
IkReal x496=(cj7*r21*sj8);
IkReal x497=(cj8*r21*sj6);
IkReal x498=(r20*sj6*sj8);
IkReal x499=((0.12)*cj6*sj7);
IkReal x500=((((0.94)*x493))+(((-1.0)*(4.0)*pz))+(((-1.0)*x491*x499))+(((0.12)*x497))+(((0.94)*x495))+((x489*x499))+(((-1.0)*x492))+(((0.12)*x498))+(((-0.12)*x494))+x490+(((-0.94)*x496)));
IkReal x501=(cj6*sj7);
IkReal x502=((((0.36)*x497))+((x490*x501))+(((-1.0)*(12.0)*pz))+(((2.82)*x495))+(((2.82)*x493))+(((-0.36)*x494))+(((-2.82)*x496))+(((-1.08)*x491))+(((-1.0)*x492*x501))+(((0.36)*x498))+(((1.08)*x489)));
j4evalpoly[0]=((-1.0)+x500+(((htj4*htj4)*(((-1.0)+x502))))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((1.0)+x500))))+(((htj4*htj4*htj4*htj4)*(((1.0)+x502)))));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x503=(r02*sj7);
IkReal x504=(r22*sj7);
IkReal x505=(cj4*cj7);
IkReal x506=(cj8*r00);
IkReal x507=(cj7*sj4);
IkReal x508=(cj8*r20);
IkReal x509=(r01*sj8);
IkReal x510=((1.0)*cj4*cj7);
IkReal x511=(r21*sj8);
IkReal x512=((1.0)*cj7*sj4);
if( IKabs(((((-1.0)*x511*x512))+(((-1.0)*x509*x510))+((x507*x508))+((x505*x506))+((sj4*x504))+((cj4*x503)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x509*x512))+((x506*x507))+((x505*x511))+(((-1.0)*x508*x510))+((sj4*x503))+(((-1.0)*cj4*x504)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x511*x512))+(((-1.0)*x509*x510))+((x507*x508))+((x505*x506))+((sj4*x504))+((cj4*x503))))+IKsqr(((((-1.0)*x509*x512))+((x506*x507))+((x505*x511))+(((-1.0)*x508*x510))+((sj4*x503))+(((-1.0)*cj4*x504))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x511*x512))+(((-1.0)*x509*x510))+((x507*x508))+((x505*x506))+((sj4*x504))+((cj4*x503))), ((((-1.0)*x509*x512))+((x506*x507))+((x505*x511))+(((-1.0)*x508*x510))+((sj4*x503))+(((-1.0)*cj4*x504))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x513=IKcos(j5);
IkReal x514=(cj4*x513);
IkReal x515=(cj7*cj8);
IkReal x516=IKsin(j5);
IkReal x517=(sj4*x516);
IkReal x518=((1.0)*cj7*sj8);
IkReal x519=(cj4*x516);
IkReal x520=(sj4*x513);
IkReal x521=((((-1.0)*x519))+(((-1.0)*x520)));
IkReal x522=(cj8*sj6);
IkReal x523=(sj6*sj8);
IkReal x524=((1.0)*cj6*cj7);
IkReal x525=(cj6*cj8*sj7);
IkReal x526=((1.0)*cj6*sj7*sj8);
IkReal x527=((0.09)*cj8);
IkReal x528=((0.09)*sj8);
evalcond[0]=(((r20*x515))+(((-1.0)*x517))+(((-1.0)*r21*x518))+x514+((r22*sj7)));
evalcond[1]=(((r02*sj7))+((r00*x515))+(((-1.0)*r01*x518))+x521);
evalcond[2]=(((r00*x523))+(((-1.0)*r02*x524))+(((-1.0)*x514))+x517+((r01*x522))+((r00*x525))+(((-1.0)*r01*x526)));
evalcond[3]=(((r20*x523))+((r21*x522))+(((-1.0)*r21*x526))+((r20*x525))+(((-1.0)*r22*x524))+x521);
evalcond[4]=((((-1.0)*(1.0)*pz))+(((0.235)*x517))+(((-1.0)*r21*x528))+(((0.03)*x519))+(((-0.235)*x514))+(((0.03)*x520))+(((-1.0)*(0.25)*cj4))+((r20*x527)));
evalcond[5]=((((-1.0)*(1.0)*px))+((r00*x527))+(((0.235)*x520))+(((0.235)*x519))+(((0.25)*sj4))+(((-1.0)*r01*x528))+(((0.03)*x514))+(((-0.03)*x517)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x529=((1.0)*sj8);
IkReal x530=((1.0)*cj8);
CheckValue<IkReal> x531=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj7*r21*x529))+((cj7*cj8*r20))+((r22*sj7)))),-1);
if(!x531.valid){
continue;
}
CheckValue<IkReal> x532 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x529))+(((-1.0)*r01*x530)))),IkReal((((r01*sj7*sj8))+((cj7*r02))+(((-1.0)*r00*sj7*x530)))),IKFAST_ATAN2_MAGTHRESH);
if(!x532.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x531.value)))+(x532.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x533=IKsin(j6);
IkReal x534=(cj8*r11);
IkReal x535=(r10*sj8);
IkReal x536=IKcos(j6);
IkReal x537=((1.0)*x536);
IkReal x538=((1.0)*sj8*x536);
IkReal x539=((1.0)*cj7*x533);
IkReal x540=((1.0)*cj8*x536);
IkReal x541=(cj8*sj7*x533);
IkReal x542=((1.0)*sj7*sj8*x533);
evalcond[0]=(((x533*x534))+(((-1.0)*r11*sj7*x538))+(((-1.0)*cj7*r12*x537))+((x533*x535))+((cj8*r10*sj7*x536)));
evalcond[1]=((((-1.0)*r21*x540))+(((-1.0)*r20*x538))+(((-1.0)*r22*x539))+((r20*x541))+(((-1.0)*r21*x542)));
evalcond[2]=((((-1.0)*r02*x539))+(((-1.0)*r01*x540))+((r00*x541))+(((-1.0)*r01*x542))+(((-1.0)*r00*x538)));
evalcond[3]=((-1.0)+((r10*x541))+(((-1.0)*x535*x537))+(((-1.0)*r11*x542))+(((-1.0)*r12*x539))+(((-1.0)*x534*x537)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x543=(cj8*r20);
IkReal x544=(r02*sj7);
IkReal x545=(r21*sj8);
IkReal x546=(r22*sj7);
IkReal x547=(cj7*cj8*r00);
IkReal x548=(cj7*cj8*r20);
IkReal x549=(cj7*r01*sj8);
IkReal x550=(cj7*r21*sj8);
IkReal x551=((((1.08)*x545))+(((2.82)*x550))+(((-1.08)*x543))+(((0.36)*x549))+(((-0.36)*x544))+(((-2.82)*x548))+(((12.0)*pz))+(((-2.82)*x546))+(((-0.36)*x547)));
j4eval[0]=((IKabs(((1.0)+x551)))+(IKabs(((-1.0)+x551)))+(IKabs(((-1.0)+(((-0.12)*x547))+(((-0.94)*x548))+(((-0.94)*x546))+(((0.94)*x550))+(((4.0)*pz))+(((0.12)*x549))+(((-0.36)*x543))+(((0.36)*x545))+(((-0.12)*x544))))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x552=(cj8*r20);
IkReal x553=(r02*sj7);
IkReal x554=(r21*sj8);
IkReal x555=(r22*sj7);
IkReal x556=(cj7*cj8*r00);
IkReal x557=(cj7*cj8*r20);
IkReal x558=(cj7*r01*sj8);
IkReal x559=(cj7*r21*sj8);
IkReal x560=((((0.12)*x558))+(((-0.94)*x557))+(((0.94)*x559))+(((-0.12)*x553))+(((-0.36)*x552))+(((4.0)*pz))+(((-0.12)*x556))+(((0.36)*x554))+(((-0.94)*x555)));
IkReal x561=((((-0.36)*x556))+(((-2.82)*x555))+(((-2.82)*x557))+(((-1.08)*x552))+(((-0.36)*x553))+(((0.36)*x558))+(((12.0)*pz))+(((1.08)*x554))+(((2.82)*x559)));
op[0]=((-1.0)+x560);
op[1]=0;
op[2]=((-1.0)+x561);
op[3]=0;
op[4]=((1.0)+x561);
op[5]=0;
op[6]=((1.0)+x560);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x562=(cj8*r20);
IkReal x563=((0.36)*x562);
IkReal x564=(r21*sj8);
IkReal x565=((0.36)*x564);
IkReal x566=(r22*sj7);
IkReal x567=(cj6*cj7*r22);
IkReal x568=(cj7*cj8*r20);
IkReal x569=(cj7*r21*sj8);
IkReal x570=(cj8*r21*sj6);
IkReal x571=(r20*sj6*sj8);
IkReal x572=((0.12)*cj6*sj7);
IkReal x573=((((0.12)*x570))+(((-0.12)*x567))+(((0.12)*x571))+(((-1.0)*x565))+(((0.94)*x568))+(((-1.0)*(4.0)*pz))+(((-1.0)*x564*x572))+((x562*x572))+(((0.94)*x566))+(((-0.94)*x569))+x563);
IkReal x574=(cj6*sj7);
IkReal x575=((((-2.82)*x569))+(((-1.0)*(12.0)*pz))+(((2.82)*x568))+(((1.08)*x562))+((x563*x574))+(((-1.08)*x564))+(((2.82)*x566))+(((0.36)*x570))+(((-1.0)*x565*x574))+(((0.36)*x571))+(((-0.36)*x567)));
j4evalpoly[0]=((-1.0)+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((1.0)+x573))))+x573+(((htj4*htj4)*(((-1.0)+x575))))+(((htj4*htj4*htj4*htj4)*(((1.0)+x575)))));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x576=(r02*sj7);
IkReal x577=(r22*sj7);
IkReal x578=(cj4*cj7);
IkReal x579=(cj8*r00);
IkReal x580=(cj7*sj4);
IkReal x581=(cj8*r20);
IkReal x582=(r01*sj8);
IkReal x583=((1.0)*cj4*cj7);
IkReal x584=(r21*sj8);
IkReal x585=((1.0)*cj7*sj4);
if( IKabs((((cj4*x576))+((sj4*x577))+((x578*x579))+(((-1.0)*x584*x585))+(((-1.0)*x582*x583))+((x580*x581)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj4*x576))+(((-1.0)*x582*x585))+((x578*x584))+(((-1.0)*x581*x583))+(((-1.0)*cj4*x577))+((x579*x580)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*x576))+((sj4*x577))+((x578*x579))+(((-1.0)*x584*x585))+(((-1.0)*x582*x583))+((x580*x581))))+IKsqr((((sj4*x576))+(((-1.0)*x582*x585))+((x578*x584))+(((-1.0)*x581*x583))+(((-1.0)*cj4*x577))+((x579*x580))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj4*x576))+((sj4*x577))+((x578*x579))+(((-1.0)*x584*x585))+(((-1.0)*x582*x583))+((x580*x581))), (((sj4*x576))+(((-1.0)*x582*x585))+((x578*x584))+(((-1.0)*x581*x583))+(((-1.0)*cj4*x577))+((x579*x580))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x586=IKcos(j5);
IkReal x587=(cj4*x586);
IkReal x588=(cj7*cj8);
IkReal x589=IKsin(j5);
IkReal x590=(sj4*x589);
IkReal x591=((1.0)*cj7*sj8);
IkReal x592=(cj4*x589);
IkReal x593=(sj4*x586);
IkReal x594=((((-1.0)*x593))+(((-1.0)*x592)));
IkReal x595=(cj8*sj6);
IkReal x596=(sj6*sj8);
IkReal x597=((1.0)*cj6*cj7);
IkReal x598=(cj6*cj8*sj7);
IkReal x599=((1.0)*cj6*sj7*sj8);
IkReal x600=((0.09)*cj8);
IkReal x601=((0.09)*sj8);
evalcond[0]=((((-1.0)*r21*x591))+((r20*x588))+(((-1.0)*x590))+((r22*sj7))+x587);
evalcond[1]=(((r02*sj7))+(((-1.0)*r01*x591))+((r00*x588))+x594);
evalcond[2]=(((r00*x596))+(((-1.0)*r01*x599))+(((-1.0)*x587))+((r00*x598))+((r01*x595))+(((-1.0)*r02*x597))+x590);
evalcond[3]=((((-1.0)*r22*x597))+((r21*x595))+((r20*x598))+(((-1.0)*r21*x599))+((r20*x596))+x594);
evalcond[4]=((((0.03)*x593))+(((-1.0)*(1.0)*pz))+(((0.235)*x590))+(((-0.235)*x587))+(((-1.0)*(0.25)*cj4))+(((0.03)*x592))+(((-1.0)*r21*x601))+((r20*x600)));
evalcond[5]=((((-1.0)*(1.0)*px))+(((0.235)*x593))+(((-0.03)*x590))+(((-1.0)*r01*x601))+(((0.25)*sj4))+(((0.235)*x592))+((r00*x600))+(((0.03)*x587)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x602=(cj8*r00);
IkReal x603=(r01*sj8);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=(((cj7*x602))+((r02*sj7))+(((-1.0)*cj7*x603)));
evalcond[2]=((0.095)+(((-1.0)*(1.0)*px))+(((0.09)*x602))+(((-0.09)*x603)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
IkReal x604=((1.0)*sj8);
IkReal x605=(((cj7*cj8*r10))+((r12*sj7))+(((-1.0)*cj7*r11*x604)));
IkReal x606=((1.0)*cj8);
j6eval[0]=x605;
j6eval[1]=IKsign(x605);
j6eval[2]=((IKabs((((cj7*r22))+((r21*sj7*sj8))+(((-1.0)*r20*sj7*x606)))))+(IKabs(((((-1.0)*r20*x604))+(((-1.0)*r21*x606))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
IkReal x607=((1.0)*cj8);
IkReal x608=(((cj7*r21*sj8))+(((-1.0)*cj7*r20*x607))+(((-1.0)*(1.0)*r22*sj7)));
j6eval[0]=x608;
j6eval[1]=((IKabs((((cj7*r12))+(((-1.0)*r10*sj7*x607))+((r11*sj7*sj8)))))+(IKabs(((((-1.0)*r11*x607))+(((-1.0)*(1.0)*r10*sj8))))));
j6eval[2]=IKsign(x608);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
IkReal x609=r00*r00;
IkReal x610=r01*r01;
IkReal x611=cj7*cj7;
IkReal x612=((2.0)*cj7*r02);
IkReal x613=(cj8*r00*sj7);
IkReal x614=(x610*x611);
IkReal x615=(r00*sj8);
IkReal x616=cj8*cj8;
IkReal x617=(x610+((x614*x616))+((r01*sj7*sj8*x612))+(((-1.0)*x614))+(((2.0)*cj8*r01*x611*x615))+(((-1.0)*x612*x613))+(((-1.0)*x609*x611*x616))+x609+((x611*(r02*r02))));
IkReal x618=((1.0)*r01);
j6eval[0]=x617;
j6eval[1]=((IKabs((x613+(((-1.0)*cj7*r02))+(((-1.0)*sj7*sj8*x618)))))+(IKabs(((((-1.0)*x615))+(((-1.0)*cj8*x618))))));
j6eval[2]=IKsign(x617);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j4, j5, j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x619=(cj8*r00*sj7);
IkReal x620=((1.0)*r01);
IkReal x621=(r00*sj8);
IkReal x622=r00*r00;
IkReal x623=r01*r01;
IkReal x624=cj7*cj7;
IkReal x625=((2.0)*cj7*r02);
IkReal x626=(x623*x624);
IkReal x627=cj8*cj8;
CheckValue<IkReal> x628 = IKatan2WithCheck(IkReal((x619+(((-1.0)*cj7*r02))+(((-1.0)*sj7*sj8*x620)))),IkReal(((((-1.0)*cj8*x620))+(((-1.0)*x621)))),IKFAST_ATAN2_MAGTHRESH);
if(!x628.valid){
continue;
}
CheckValue<IkReal> x629=IKPowWithIntegerCheck(IKsign((((r01*sj7*sj8*x625))+((x624*(r02*r02)))+x622+x623+(((2.0)*cj8*r01*x621*x624))+(((-1.0)*x626))+(((-1.0)*x619*x625))+((x626*x627))+(((-1.0)*x622*x624*x627)))),-1);
if(!x629.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x628.value)+(((1.5707963267949)*(x629.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x630=IKsin(j6);
IkReal x631=(cj8*r01);
IkReal x632=(r00*sj8);
IkReal x633=IKcos(j6);
IkReal x634=((1.0)*cj7*r02);
IkReal x635=(cj8*r00*sj7);
IkReal x636=(r01*sj7);
IkReal x637=((1.0)*sj8*x633);
IkReal x638=((1.0)*cj7*x630);
IkReal x639=((1.0)*cj8*x633);
IkReal x640=(cj8*sj7*x630);
IkReal x641=((1.0)*sj7*sj8*x630);
IkReal x642=((1.0)*x633);
evalcond[0]=(((x630*x632))+((x633*x635))+(((-1.0)*x636*x637))+((x630*x631))+(((-1.0)*x633*x634)));
evalcond[1]=((((-1.0)*r20*x637))+(((-1.0)*r21*x641))+(((-1.0)*r21*x639))+((r20*x640))+(((-1.0)*r22*x638)));
evalcond[2]=((((-1.0)*r12*x638))+(((-1.0)*r10*x637))+(((-1.0)*r11*x641))+((r10*x640))+(((-1.0)*r11*x639)));
evalcond[3]=((-1.0)+(((-1.0)*x631*x642))+((x630*x635))+(((-1.0)*x630*x634))+(((-1.0)*sj8*x630*x636))+(((-1.0)*x632*x642)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
IkReal x643=(cj8*r20);
IkReal x644=(r12*sj7);
IkReal x645=(r21*sj8);
IkReal x646=(r22*sj7);
IkReal x647=(cj7*cj8*r10);
IkReal x648=(cj7*cj8*r20);
IkReal x649=(cj7*r11*sj8);
IkReal x650=(cj7*r21*sj8);
IkReal x651=((((1.08)*x643))+(((-2.82)*x650))+(((-1.0)*(12.0)*pz))+(((0.36)*x649))+(((-0.36)*x647))+(((2.82)*x648))+(((-0.36)*x644))+(((2.82)*x646))+(((-1.08)*x645)));
j4eval[0]=((IKabs(((1.0)+x651)))+(IKabs(((-1.0)+x651)))+(IKabs(((1.0)+(((-0.12)*x644))+(((-0.12)*x647))+(((-0.36)*x645))+(((-1.0)*(4.0)*pz))+(((0.36)*x643))+(((-0.94)*x650))+(((0.94)*x648))+(((0.94)*x646))+(((0.12)*x649))))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x652=(cj8*r20);
IkReal x653=(r12*sj7);
IkReal x654=(r21*sj8);
IkReal x655=(r22*sj7);
IkReal x656=(cj7*cj8*r10);
IkReal x657=(cj7*cj8*r20);
IkReal x658=(cj7*r11*sj8);
IkReal x659=(cj7*r21*sj8);
IkReal x660=((((0.94)*x655))+(((-1.0)*(4.0)*pz))+(((0.36)*x652))+(((-0.36)*x654))+(((0.12)*x658))+(((-0.94)*x659))+(((0.94)*x657))+(((-0.12)*x653))+(((-0.12)*x656)));
IkReal x661=((((-1.0)*(12.0)*pz))+(((1.08)*x652))+(((-1.08)*x654))+(((2.82)*x655))+(((-0.36)*x653))+(((2.82)*x657))+(((-2.82)*x659))+(((-0.36)*x656))+(((0.36)*x658)));
op[0]=((1.0)+x660);
op[1]=0;
op[2]=((1.0)+x661);
op[3]=0;
op[4]=((-1.0)+x661);
op[5]=0;
op[6]=((-1.0)+x660);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x662=(cj8*r10);
IkReal x663=(cj8*r20);
IkReal x664=(r11*sj8);
IkReal x665=(r21*sj8);
IkReal x666=(r22*sj7);
IkReal x667=(cj7*cj8*r20);
IkReal x668=(cj7*r21*sj8);
IkReal x669=((((0.2245)*x666))+(((-1.0)*(0.12)*py))+(((-0.0846)*x665))+(((-0.0108)*x664))+(((0.0846)*x663))+(((-0.2245)*x668))+(((-1.0)*(0.94)*pz))+(((0.0108)*x662))+(((0.2245)*x667)));
IkReal x670=((((-0.6735)*x668))+(((0.6735)*x667))+(((-1.0)*(0.36)*py))+(((0.6735)*x666))+(((0.0324)*x662))+(((-0.0324)*x664))+(((0.2538)*x663))+(((-1.0)*(2.82)*pz))+(((-0.2538)*x665)));
j4evalpoly[0]=((-0.235)+(((htj4*htj4)*(((-0.235)+x670))))+(((-1.0)*(0.12)*(htj4*htj4*htj4)))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((0.235)+x669))))+(((htj4*htj4*htj4*htj4)*(((0.235)+x670))))+(((-1.0)*(0.06)*(htj4*htj4*htj4*htj4*htj4)))+(((-1.0)*(0.06)*htj4))+x669);
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x671=(r22*sj7);
IkReal x672=((1.0)*cj4);
IkReal x673=(r12*sj7);
IkReal x674=(cj4*cj7*sj8);
IkReal x675=(cj7*sj4);
IkReal x676=(cj8*r20);
IkReal x677=(cj8*r10);
IkReal x678=((1.0)*cj4*cj7);
IkReal x679=((1.0)*cj7*sj4);
if( IKabs((((r11*x674))+((x675*x676))+(((-1.0)*x672*x673))+((sj4*x671))+(((-1.0)*x677*x678))+(((-1.0)*r21*sj8*x679)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x671*x672))+(((-1.0)*sj4*x673))+((r11*sj8*x675))+((r21*x674))+(((-1.0)*x677*x679))+(((-1.0)*x676*x678)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r11*x674))+((x675*x676))+(((-1.0)*x672*x673))+((sj4*x671))+(((-1.0)*x677*x678))+(((-1.0)*r21*sj8*x679))))+IKsqr(((((-1.0)*x671*x672))+(((-1.0)*sj4*x673))+((r11*sj8*x675))+((r21*x674))+(((-1.0)*x677*x679))+(((-1.0)*x676*x678))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r11*x674))+((x675*x676))+(((-1.0)*x672*x673))+((sj4*x671))+(((-1.0)*x677*x678))+(((-1.0)*r21*sj8*x679))), ((((-1.0)*x671*x672))+(((-1.0)*sj4*x673))+((r11*sj8*x675))+((r21*x674))+(((-1.0)*x677*x679))+(((-1.0)*x676*x678))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x680=IKsin(j5);
IkReal x681=(cj4*x680);
IkReal x682=IKcos(j5);
IkReal x683=(sj4*x682);
IkReal x684=(cj7*cj8);
IkReal x685=((1.0)*cj7*sj8);
IkReal x686=(cj4*x682);
IkReal x687=(sj4*x680);
IkReal x688=((((-1.0)*x687))+x686);
IkReal x689=(cj8*sj6);
IkReal x690=(sj6*sj8);
IkReal x691=((1.0)*cj6*cj7);
IkReal x692=(cj6*cj8*sj7);
IkReal x693=((1.0)*cj6*sj7*sj8);
IkReal x694=((0.09)*cj8);
IkReal x695=((0.09)*sj8);
evalcond[0]=((((-1.0)*r11*x685))+((r10*x684))+((r12*sj7))+x683+x681);
evalcond[1]=(((r20*x684))+((r22*sj7))+(((-1.0)*r21*x685))+x688);
evalcond[2]=((((-1.0)*r11*x693))+((r10*x690))+(((-1.0)*r12*x691))+x688+((r11*x689))+((r10*x692)));
evalcond[3]=(((r20*x690))+(((-1.0)*r21*x693))+(((-1.0)*x683))+((r20*x692))+((r21*x689))+(((-1.0)*x681))+(((-1.0)*r22*x691)));
evalcond[4]=((((-1.0)*(1.0)*pz))+(((0.03)*x681))+((r20*x694))+(((0.235)*x687))+(((-0.235)*x686))+(((-1.0)*(0.25)*cj4))+(((-1.0)*r21*x695))+(((0.03)*x683)));
evalcond[5]=((((-1.0)*(1.0)*py))+(((-0.235)*x683))+((r10*x694))+(((-0.03)*x686))+(((-1.0)*r11*x695))+(((-0.235)*x681))+(((-1.0)*(0.25)*sj4))+(((0.03)*x687)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x696=((1.0)*cj8);
CheckValue<IkReal> x697 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x696))+(((-1.0)*(1.0)*r10*sj8)))),IkReal((((cj7*r12))+((r11*sj7*sj8))+(((-1.0)*r10*sj7*x696)))),IKFAST_ATAN2_MAGTHRESH);
if(!x697.valid){
continue;
}
CheckValue<IkReal> x698=IKPowWithIntegerCheck(IKsign((((cj7*r21*sj8))+(((-1.0)*(1.0)*r22*sj7))+(((-1.0)*cj7*r20*x696)))),-1);
if(!x698.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x697.value)+(((1.5707963267949)*(x698.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x699=IKsin(j6);
IkReal x700=(cj8*r01);
IkReal x701=(r00*sj8);
IkReal x702=IKcos(j6);
IkReal x703=((1.0)*cj7*r02);
IkReal x704=(cj8*r00*sj7);
IkReal x705=(r01*sj7);
IkReal x706=((1.0)*sj8*x702);
IkReal x707=((1.0)*cj7*x699);
IkReal x708=((1.0)*cj8*x702);
IkReal x709=(cj8*sj7*x699);
IkReal x710=((1.0)*sj7*sj8*x699);
IkReal x711=((1.0)*x702);
evalcond[0]=(((x699*x700))+((x699*x701))+(((-1.0)*x705*x706))+(((-1.0)*x702*x703))+((x702*x704)));
evalcond[1]=((((-1.0)*r21*x710))+(((-1.0)*r20*x706))+(((-1.0)*r21*x708))+(((-1.0)*r22*x707))+((r20*x709)));
evalcond[2]=((((-1.0)*r11*x708))+((r10*x709))+(((-1.0)*r11*x710))+(((-1.0)*r10*x706))+(((-1.0)*r12*x707)));
evalcond[3]=((-1.0)+(((-1.0)*x701*x711))+(((-1.0)*sj8*x699*x705))+(((-1.0)*x700*x711))+(((-1.0)*x699*x703))+((x699*x704)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
IkReal x712=(cj8*r20);
IkReal x713=(r12*sj7);
IkReal x714=(r21*sj8);
IkReal x715=(r22*sj7);
IkReal x716=(cj7*cj8*r10);
IkReal x717=(cj7*cj8*r20);
IkReal x718=(cj7*r11*sj8);
IkReal x719=(cj7*r21*sj8);
IkReal x720=((((-1.0)*(12.0)*pz))+(((0.36)*x718))+(((-0.36)*x716))+(((1.08)*x712))+(((-1.08)*x714))+(((2.82)*x715))+(((2.82)*x717))+(((-0.36)*x713))+(((-2.82)*x719)));
j4eval[0]=((IKabs(((-1.0)+x720)))+(IKabs(((1.0)+x720)))+(IKabs(((1.0)+(((-0.36)*x714))+(((-0.12)*x716))+(((0.94)*x717))+(((-1.0)*(4.0)*pz))+(((0.36)*x712))+(((-0.12)*x713))+(((-0.94)*x719))+(((0.12)*x718))+(((0.94)*x715))))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x721=(cj8*r20);
IkReal x722=(r12*sj7);
IkReal x723=(r21*sj8);
IkReal x724=(r22*sj7);
IkReal x725=(cj7*cj8*r10);
IkReal x726=(cj7*cj8*r20);
IkReal x727=(cj7*r11*sj8);
IkReal x728=(cj7*r21*sj8);
IkReal x729=((((-0.94)*x728))+(((0.12)*x727))+(((-0.12)*x725))+(((-1.0)*(4.0)*pz))+(((-0.36)*x723))+(((0.94)*x726))+(((-0.12)*x722))+(((0.36)*x721))+(((0.94)*x724)));
IkReal x730=((((-2.82)*x728))+(((-1.08)*x723))+(((-1.0)*(12.0)*pz))+(((1.08)*x721))+(((2.82)*x726))+(((2.82)*x724))+(((-0.36)*x725))+(((0.36)*x727))+(((-0.36)*x722)));
op[0]=((1.0)+x729);
op[1]=0;
op[2]=((1.0)+x730);
op[3]=0;
op[4]=((-1.0)+x730);
op[5]=0;
op[6]=((-1.0)+x729);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x731=(cj8*r10);
IkReal x732=(cj8*r20);
IkReal x733=(r11*sj8);
IkReal x734=(r21*sj8);
IkReal x735=(r22*sj7);
IkReal x736=(cj7*cj8*r20);
IkReal x737=(cj7*r21*sj8);
IkReal x738=((((-1.0)*(0.12)*py))+(((0.0108)*x731))+(((0.0846)*x732))+(((-0.0108)*x733))+(((0.2245)*x735))+(((-1.0)*(0.94)*pz))+(((-0.0846)*x734))+(((0.2245)*x736))+(((-0.2245)*x737)));
IkReal x739=((((-1.0)*(0.36)*py))+(((0.2538)*x732))+(((-0.6735)*x737))+(((-0.0324)*x733))+(((0.0324)*x731))+(((0.6735)*x736))+(((0.6735)*x735))+(((-0.2538)*x734))+(((-1.0)*(2.82)*pz)));
j4evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj4*htj4*htj4)))+(((htj4*htj4)*(((-0.235)+x739))))+(((-1.0)*(0.06)*(htj4*htj4*htj4*htj4*htj4)))+(((htj4*htj4*htj4*htj4)*(((0.235)+x739))))+(((-1.0)*(0.06)*htj4))+x738+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((0.235)+x738)))));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x740=(r22*sj7);
IkReal x741=((1.0)*cj4);
IkReal x742=(r12*sj7);
IkReal x743=(cj4*cj7*sj8);
IkReal x744=(cj7*sj4);
IkReal x745=(cj8*r20);
IkReal x746=(cj8*r10);
IkReal x747=((1.0)*cj4*cj7);
IkReal x748=((1.0)*cj7*sj4);
if( IKabs((((x744*x745))+((sj4*x740))+(((-1.0)*x741*x742))+((r11*x743))+(((-1.0)*r21*sj8*x748))+(((-1.0)*x746*x747)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x745*x747))+(((-1.0)*x746*x748))+(((-1.0)*sj4*x742))+(((-1.0)*x740*x741))+((r11*sj8*x744))+((r21*x743)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x744*x745))+((sj4*x740))+(((-1.0)*x741*x742))+((r11*x743))+(((-1.0)*r21*sj8*x748))+(((-1.0)*x746*x747))))+IKsqr(((((-1.0)*x745*x747))+(((-1.0)*x746*x748))+(((-1.0)*sj4*x742))+(((-1.0)*x740*x741))+((r11*sj8*x744))+((r21*x743))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((x744*x745))+((sj4*x740))+(((-1.0)*x741*x742))+((r11*x743))+(((-1.0)*r21*sj8*x748))+(((-1.0)*x746*x747))), ((((-1.0)*x745*x747))+(((-1.0)*x746*x748))+(((-1.0)*sj4*x742))+(((-1.0)*x740*x741))+((r11*sj8*x744))+((r21*x743))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x749=IKsin(j5);
IkReal x750=(cj4*x749);
IkReal x751=IKcos(j5);
IkReal x752=(sj4*x751);
IkReal x753=(cj7*cj8);
IkReal x754=((1.0)*cj7*sj8);
IkReal x755=(cj4*x751);
IkReal x756=(sj4*x749);
IkReal x757=((((-1.0)*x756))+x755);
IkReal x758=(cj8*sj6);
IkReal x759=(sj6*sj8);
IkReal x760=((1.0)*cj6*cj7);
IkReal x761=(cj6*cj8*sj7);
IkReal x762=((1.0)*cj6*sj7*sj8);
IkReal x763=((0.09)*cj8);
IkReal x764=((0.09)*sj8);
evalcond[0]=((((-1.0)*r11*x754))+((r12*sj7))+((r10*x753))+x752+x750);
evalcond[1]=((((-1.0)*r21*x754))+((r22*sj7))+((r20*x753))+x757);
evalcond[2]=(((r10*x761))+(((-1.0)*r11*x762))+(((-1.0)*r12*x760))+((r11*x758))+x757+((r10*x759)));
evalcond[3]=(((r20*x761))+(((-1.0)*x750))+(((-1.0)*r22*x760))+(((-1.0)*x752))+((r21*x758))+(((-1.0)*r21*x762))+((r20*x759)));
evalcond[4]=((((0.03)*x752))+(((0.235)*x756))+(((0.03)*x750))+(((-1.0)*(1.0)*pz))+(((-0.235)*x755))+(((-1.0)*r21*x764))+((r20*x763))+(((-1.0)*(0.25)*cj4)));
evalcond[5]=((((-0.235)*x750))+(((-1.0)*(1.0)*py))+(((-1.0)*r11*x764))+(((-0.235)*x752))+(((-0.03)*x755))+(((-1.0)*(0.25)*sj4))+(((0.03)*x756))+((r10*x763)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x765=((1.0)*sj8);
IkReal x766=((1.0)*cj8);
CheckValue<IkReal> x767=IKPowWithIntegerCheck(IKsign((((cj7*cj8*r10))+((r12*sj7))+(((-1.0)*cj7*r11*x765)))),-1);
if(!x767.valid){
continue;
}
CheckValue<IkReal> x768 = IKatan2WithCheck(IkReal(((((-1.0)*r20*x765))+(((-1.0)*r21*x766)))),IkReal((((cj7*r22))+((r21*sj7*sj8))+(((-1.0)*r20*sj7*x766)))),IKFAST_ATAN2_MAGTHRESH);
if(!x768.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x767.value)))+(x768.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x769=IKsin(j6);
IkReal x770=(cj8*r01);
IkReal x771=(r00*sj8);
IkReal x772=IKcos(j6);
IkReal x773=((1.0)*cj7*r02);
IkReal x774=(cj8*r00*sj7);
IkReal x775=(r01*sj7);
IkReal x776=((1.0)*sj8*x772);
IkReal x777=((1.0)*cj7*x769);
IkReal x778=((1.0)*cj8*x772);
IkReal x779=(cj8*sj7*x769);
IkReal x780=((1.0)*sj7*sj8*x769);
IkReal x781=((1.0)*x772);
evalcond[0]=(((x769*x770))+(((-1.0)*x772*x773))+(((-1.0)*x775*x776))+((x772*x774))+((x769*x771)));
evalcond[1]=((((-1.0)*r21*x778))+(((-1.0)*r21*x780))+(((-1.0)*r22*x777))+(((-1.0)*r20*x776))+((r20*x779)));
evalcond[2]=((((-1.0)*r11*x778))+(((-1.0)*r10*x776))+(((-1.0)*r11*x780))+(((-1.0)*r12*x777))+((r10*x779)));
evalcond[3]=((-1.0)+((x769*x774))+(((-1.0)*x769*x773))+(((-1.0)*x770*x781))+(((-1.0)*sj8*x769*x775))+(((-1.0)*x771*x781)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
IkReal x782=(cj8*r20);
IkReal x783=(r12*sj7);
IkReal x784=(r21*sj8);
IkReal x785=(r22*sj7);
IkReal x786=(cj7*cj8*r10);
IkReal x787=(cj7*cj8*r20);
IkReal x788=(cj7*r11*sj8);
IkReal x789=(cj7*r21*sj8);
IkReal x790=((((-1.0)*(12.0)*pz))+(((1.08)*x782))+(((-1.08)*x784))+(((-0.36)*x783))+(((0.36)*x788))+(((2.82)*x787))+(((-0.36)*x786))+(((-2.82)*x789))+(((2.82)*x785)));
j4eval[0]=((IKabs(((-1.0)+x790)))+(IKabs(((1.0)+(((0.94)*x785))+(((-0.36)*x784))+(((-1.0)*(4.0)*pz))+(((-0.94)*x789))+(((0.94)*x787))+(((-0.12)*x786))+(((-0.12)*x783))+(((0.12)*x788))+(((0.36)*x782)))))+(IKabs(((1.0)+x790))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x791=(cj8*r20);
IkReal x792=(r12*sj7);
IkReal x793=(r21*sj8);
IkReal x794=(r22*sj7);
IkReal x795=(cj7*cj8*r10);
IkReal x796=(cj7*cj8*r20);
IkReal x797=(cj7*r11*sj8);
IkReal x798=(cj7*r21*sj8);
IkReal x799=((((0.94)*x796))+(((-1.0)*(4.0)*pz))+(((-0.12)*x795))+(((-0.36)*x793))+(((0.94)*x794))+(((-0.12)*x792))+(((0.36)*x791))+(((0.12)*x797))+(((-0.94)*x798)));
IkReal x800=((((-1.0)*(12.0)*pz))+(((1.08)*x791))+(((-1.08)*x793))+(((-0.36)*x795))+(((-0.36)*x792))+(((0.36)*x797))+(((2.82)*x796))+(((-2.82)*x798))+(((2.82)*x794)));
op[0]=((1.0)+x799);
op[1]=0;
op[2]=((1.0)+x800);
op[3]=0;
op[4]=((-1.0)+x800);
op[5]=0;
op[6]=((-1.0)+x799);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x801=(cj8*r10);
IkReal x802=(cj8*r20);
IkReal x803=(r11*sj8);
IkReal x804=(r21*sj8);
IkReal x805=(r22*sj7);
IkReal x806=(cj7*cj8*r20);
IkReal x807=(cj7*r21*sj8);
IkReal x808=((((-1.0)*(0.12)*py))+(((0.0846)*x802))+(((0.2245)*x805))+(((-0.2245)*x807))+(((0.0108)*x801))+(((-1.0)*(0.94)*pz))+(((-0.0108)*x803))+(((-0.0846)*x804))+(((0.2245)*x806)));
IkReal x809=((((-1.0)*(0.36)*py))+(((-0.6735)*x807))+(((-0.0324)*x803))+(((0.6735)*x805))+(((0.2538)*x802))+(((0.0324)*x801))+(((-1.0)*(2.82)*pz))+(((0.6735)*x806))+(((-0.2538)*x804)));
j4evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj4*htj4*htj4)))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((0.235)+x808))))+(((htj4*htj4*htj4*htj4)*(((0.235)+x809))))+x808+(((-1.0)*(0.06)*(htj4*htj4*htj4*htj4*htj4)))+(((htj4*htj4)*(((-0.235)+x809))))+(((-1.0)*(0.06)*htj4)));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x810=(r22*sj7);
IkReal x811=((1.0)*cj4);
IkReal x812=(r12*sj7);
IkReal x813=(cj4*cj7*sj8);
IkReal x814=(cj7*sj4);
IkReal x815=(cj8*r20);
IkReal x816=(cj8*r10);
IkReal x817=((1.0)*cj4*cj7);
IkReal x818=((1.0)*cj7*sj4);
if( IKabs(((((-1.0)*x816*x817))+((x814*x815))+((r11*x813))+(((-1.0)*r21*sj8*x818))+(((-1.0)*x811*x812))+((sj4*x810)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj4*x812))+((r11*sj8*x814))+(((-1.0)*x810*x811))+(((-1.0)*x815*x817))+((r21*x813))+(((-1.0)*x816*x818)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x816*x817))+((x814*x815))+((r11*x813))+(((-1.0)*r21*sj8*x818))+(((-1.0)*x811*x812))+((sj4*x810))))+IKsqr(((((-1.0)*sj4*x812))+((r11*sj8*x814))+(((-1.0)*x810*x811))+(((-1.0)*x815*x817))+((r21*x813))+(((-1.0)*x816*x818))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x816*x817))+((x814*x815))+((r11*x813))+(((-1.0)*r21*sj8*x818))+(((-1.0)*x811*x812))+((sj4*x810))), ((((-1.0)*sj4*x812))+((r11*sj8*x814))+(((-1.0)*x810*x811))+(((-1.0)*x815*x817))+((r21*x813))+(((-1.0)*x816*x818))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x819=IKsin(j5);
IkReal x820=(cj4*x819);
IkReal x821=IKcos(j5);
IkReal x822=(sj4*x821);
IkReal x823=(cj7*cj8);
IkReal x824=((1.0)*cj7*sj8);
IkReal x825=(cj4*x821);
IkReal x826=(sj4*x819);
IkReal x827=((((-1.0)*x826))+x825);
IkReal x828=(cj8*sj6);
IkReal x829=(sj6*sj8);
IkReal x830=((1.0)*cj6*cj7);
IkReal x831=(cj6*cj8*sj7);
IkReal x832=((1.0)*cj6*sj7*sj8);
IkReal x833=((0.09)*cj8);
IkReal x834=((0.09)*sj8);
evalcond[0]=((((-1.0)*r11*x824))+((r12*sj7))+x820+x822+((r10*x823)));
evalcond[1]=((((-1.0)*r21*x824))+((r20*x823))+x827+((r22*sj7)));
evalcond[2]=((((-1.0)*r12*x830))+((r11*x828))+x827+((r10*x831))+(((-1.0)*r11*x832))+((r10*x829)));
evalcond[3]=((((-1.0)*x820))+((r20*x829))+(((-1.0)*x822))+(((-1.0)*r21*x832))+((r20*x831))+((r21*x828))+(((-1.0)*r22*x830)));
evalcond[4]=((((-1.0)*r21*x834))+(((-1.0)*(1.0)*pz))+(((0.235)*x826))+(((-0.235)*x825))+(((-1.0)*(0.25)*cj4))+(((0.03)*x822))+(((0.03)*x820))+((r20*x833)));
evalcond[5]=((((-0.235)*x820))+(((0.03)*x826))+(((-1.0)*(1.0)*py))+(((-0.03)*x825))+(((-1.0)*r11*x834))+((r10*x833))+(((-1.0)*(0.25)*sj4))+(((-0.235)*x822)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x835=(cj8*r00);
IkReal x836=(r01*sj8);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=(((r02*sj7))+((cj7*x835))+(((-1.0)*cj7*x836)));
evalcond[2]=((-0.095)+(((-0.09)*x836))+(((-1.0)*(1.0)*px))+(((0.09)*x835)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
IkReal x837=((1.0)*cj7);
IkReal x838=(((cj7*cj8*r10))+(((-1.0)*r11*sj8*x837))+((r12*sj7)));
j6eval[0]=x838;
j6eval[1]=((IKabs((((cj8*r20*sj7))+(((-1.0)*(1.0)*r21*sj7*sj8))+(((-1.0)*r22*x837)))))+(IKabs((((r20*sj8))+((cj8*r21))))));
j6eval[2]=IKsign(x838);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
IkReal x839=((1.0)*sj7);
IkReal x840=((1.0)*cj7);
IkReal x841=(((cj7*r21*sj8))+(((-1.0)*cj8*r20*x840))+(((-1.0)*r22*x839)));
j6eval[0]=x841;
j6eval[1]=((IKabs((((r10*sj8))+((cj8*r11)))))+(IKabs(((((-1.0)*r12*x840))+(((-1.0)*r11*sj8*x839))+((cj8*r10*sj7))))));
j6eval[2]=IKsign(x841);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
IkReal x842=r00*r00;
IkReal x843=r01*r01;
IkReal x844=cj7*cj7;
IkReal x845=((2.0)*cj7*r02);
IkReal x846=(cj8*r00*sj7);
IkReal x847=(r01*sj7*sj8);
IkReal x848=(x843*x844);
IkReal x849=(r00*sj8);
IkReal x850=cj8*cj8;
IkReal x851=(((x848*x850))+((x845*x847))+(((2.0)*cj8*r01*x844*x849))+(((-1.0)*x842*x844*x850))+x843+x842+(((-1.0)*x848))+(((-1.0)*x845*x846))+((x844*(r02*r02))));
j6eval[0]=x851;
j6eval[1]=((IKabs((x847+(((-1.0)*x846))+((cj7*r02)))))+(IKabs((((cj8*r01))+x849))));
j6eval[2]=IKsign(x851);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j4, j5, j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x852=(r01*sj7*sj8);
IkReal x853=(cj8*r00*sj7);
IkReal x854=(r00*sj8);
IkReal x855=r00*r00;
IkReal x856=r01*r01;
IkReal x857=cj7*cj7;
IkReal x858=((2.0)*cj7*r02);
IkReal x859=(x856*x857);
IkReal x860=cj8*cj8;
CheckValue<IkReal> x861=IKPowWithIntegerCheck(IKsign(((((-1.0)*x853*x858))+(((-1.0)*x859))+(((2.0)*cj8*r01*x854*x857))+((x857*(r02*r02)))+((x859*x860))+x855+x856+((x852*x858))+(((-1.0)*x855*x857*x860)))),-1);
if(!x861.valid){
continue;
}
CheckValue<IkReal> x862 = IKatan2WithCheck(IkReal(((((-1.0)*x853))+x852+((cj7*r02)))),IkReal((((cj8*r01))+x854)),IKFAST_ATAN2_MAGTHRESH);
if(!x862.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x861.value)))+(x862.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x863=IKsin(j6);
IkReal x864=(cj8*r01);
IkReal x865=(r00*sj8);
IkReal x866=IKcos(j6);
IkReal x867=((1.0)*cj7*r02);
IkReal x868=(cj8*r00*sj7);
IkReal x869=(r01*sj7);
IkReal x870=((1.0)*sj8*x866);
IkReal x871=((1.0)*cj7*x863);
IkReal x872=((1.0)*cj8*x866);
IkReal x873=(cj8*sj7*x863);
IkReal x874=((1.0)*sj7*sj8*x863);
IkReal x875=((1.0)*x866);
evalcond[0]=((((-1.0)*x866*x867))+((x863*x864))+((x863*x865))+(((-1.0)*x869*x870))+((x866*x868)));
evalcond[1]=((((-1.0)*r21*x874))+(((-1.0)*r20*x870))+(((-1.0)*r22*x871))+((r20*x873))+(((-1.0)*r21*x872)));
evalcond[2]=((((-1.0)*r10*x870))+(((-1.0)*r11*x874))+(((-1.0)*r12*x871))+(((-1.0)*r11*x872))+((r10*x873)));
evalcond[3]=((1.0)+(((-1.0)*x865*x875))+(((-1.0)*sj8*x863*x869))+((x863*x868))+(((-1.0)*x863*x867))+(((-1.0)*x864*x875)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
IkReal x876=(cj8*r20);
IkReal x877=(r12*sj7);
IkReal x878=(r21*sj8);
IkReal x879=(r22*sj7);
IkReal x880=(cj7*cj8*r10);
IkReal x881=(cj7*cj8*r20);
IkReal x882=(cj7*r11*sj8);
IkReal x883=(cj7*r21*sj8);
IkReal x884=((((-0.36)*x880))+(((-1.08)*x876))+(((-2.82)*x881))+(((-0.36)*x877))+(((-2.82)*x879))+(((2.82)*x883))+(((1.08)*x878))+(((0.36)*x882))+(((12.0)*pz)));
j4eval[0]=((IKabs(((1.0)+x884)))+(IKabs(((-1.0)+x884)))+(IKabs(((-1.0)+(((-0.94)*x879))+(((-0.12)*x880))+(((-0.36)*x876))+(((0.36)*x878))+(((4.0)*pz))+(((0.12)*x882))+(((-0.94)*x881))+(((-0.12)*x877))+(((0.94)*x883))))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x885=(cj8*r20);
IkReal x886=(r12*sj7);
IkReal x887=(r21*sj8);
IkReal x888=(r22*sj7);
IkReal x889=(cj7*cj8*r10);
IkReal x890=(cj7*cj8*r20);
IkReal x891=(cj7*r11*sj8);
IkReal x892=(cj7*r21*sj8);
IkReal x893=((((0.12)*x891))+(((-0.94)*x890))+(((-0.36)*x885))+(((0.36)*x887))+(((-0.94)*x888))+(((4.0)*pz))+(((-0.12)*x889))+(((-0.12)*x886))+(((0.94)*x892)));
IkReal x894=((((-1.08)*x885))+(((-0.36)*x886))+(((2.82)*x892))+(((-2.82)*x888))+(((-0.36)*x889))+(((1.08)*x887))+(((0.36)*x891))+(((-2.82)*x890))+(((12.0)*pz)));
op[0]=((-1.0)+x893);
op[1]=0;
op[2]=((-1.0)+x894);
op[3]=0;
op[4]=((1.0)+x894);
op[5]=0;
op[6]=((1.0)+x893);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x895=(cj8*r20);
IkReal x896=((0.36)*x895);
IkReal x897=(r21*sj8);
IkReal x898=((0.36)*x897);
IkReal x899=(r22*sj7);
IkReal x900=(cj6*cj7*r22);
IkReal x901=(cj7*cj8*r20);
IkReal x902=(cj7*r21*sj8);
IkReal x903=(cj8*r21*sj6);
IkReal x904=(r20*sj6*sj8);
IkReal x905=((0.12)*cj6*sj7);
IkReal x906=((((0.94)*x899))+(((-1.0)*x898))+(((0.94)*x901))+(((-1.0)*(4.0)*pz))+(((0.12)*x903))+(((-1.0)*x897*x905))+(((0.12)*x904))+((x895*x905))+(((-0.12)*x900))+x896+(((-0.94)*x902)));
IkReal x907=(cj6*sj7);
IkReal x908=((((-1.08)*x897))+(((1.08)*x895))+(((-1.0)*(12.0)*pz))+(((-2.82)*x902))+(((2.82)*x899))+(((0.36)*x904))+(((0.36)*x903))+(((-0.36)*x900))+(((-1.0)*x898*x907))+(((2.82)*x901))+((x896*x907)));
j4evalpoly[0]=((-1.0)+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((1.0)+x906))))+x906+(((htj4*htj4*htj4*htj4)*(((1.0)+x908))))+(((htj4*htj4)*(((-1.0)+x908)))));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x909=(r12*sj7);
IkReal x910=(r22*sj7);
IkReal x911=(cj4*cj7);
IkReal x912=(cj8*r10);
IkReal x913=(cj7*sj4);
IkReal x914=(cj8*r20);
IkReal x915=(r11*sj8);
IkReal x916=((1.0)*cj4*cj7);
IkReal x917=(r21*sj8);
IkReal x918=((1.0)*cj7*sj4);
if( IKabs(((((-1.0)*x915*x916))+((x913*x914))+((x911*x912))+(((-1.0)*x917*x918))+((sj4*x910))+((cj4*x909)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x915*x918))+((x911*x917))+(((-1.0)*x914*x916))+((x912*x913))+(((-1.0)*cj4*x910))+((sj4*x909)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x915*x916))+((x913*x914))+((x911*x912))+(((-1.0)*x917*x918))+((sj4*x910))+((cj4*x909))))+IKsqr(((((-1.0)*x915*x918))+((x911*x917))+(((-1.0)*x914*x916))+((x912*x913))+(((-1.0)*cj4*x910))+((sj4*x909))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x915*x916))+((x913*x914))+((x911*x912))+(((-1.0)*x917*x918))+((sj4*x910))+((cj4*x909))), ((((-1.0)*x915*x918))+((x911*x917))+(((-1.0)*x914*x916))+((x912*x913))+(((-1.0)*cj4*x910))+((sj4*x909))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x919=IKcos(j5);
IkReal x920=(cj4*x919);
IkReal x921=(cj7*cj8);
IkReal x922=IKsin(j5);
IkReal x923=(sj4*x922);
IkReal x924=((1.0)*cj7*sj8);
IkReal x925=(cj4*x922);
IkReal x926=(sj4*x919);
IkReal x927=((((-1.0)*x925))+(((-1.0)*x926)));
IkReal x928=(cj8*sj6);
IkReal x929=(sj6*sj8);
IkReal x930=((1.0)*cj6*cj7);
IkReal x931=(cj6*cj8*sj7);
IkReal x932=((1.0)*cj6*sj7*sj8);
IkReal x933=((0.09)*cj8);
IkReal x934=((0.09)*sj8);
evalcond[0]=((((-1.0)*r21*x924))+((r20*x921))+(((-1.0)*x923))+((r22*sj7))+x920);
evalcond[1]=(((r10*x921))+(((-1.0)*r11*x924))+((r12*sj7))+x927);
evalcond[2]=(((r11*x928))+(((-1.0)*r11*x932))+(((-1.0)*x920))+((r10*x929))+(((-1.0)*r12*x930))+x923+((r10*x931)));
evalcond[3]=(((r21*x928))+(((-1.0)*r21*x932))+((r20*x931))+(((-1.0)*r22*x930))+x927+((r20*x929)));
evalcond[4]=((((-1.0)*(1.0)*pz))+(((0.03)*x925))+(((0.03)*x926))+(((-1.0)*r21*x934))+(((-0.235)*x920))+(((-1.0)*(0.25)*cj4))+(((0.235)*x923))+((r20*x933)));
evalcond[5]=((((-1.0)*(1.0)*py))+(((0.235)*x926))+(((0.25)*sj4))+(((0.235)*x925))+(((-0.03)*x923))+((r10*x933))+(((-1.0)*r11*x934))+(((0.03)*x920)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x935=((1.0)*sj7);
IkReal x936=((1.0)*cj7);
CheckValue<IkReal> x937 = IKatan2WithCheck(IkReal((((r10*sj8))+((cj8*r11)))),IkReal(((((-1.0)*r11*sj8*x935))+(((-1.0)*r12*x936))+((cj8*r10*sj7)))),IKFAST_ATAN2_MAGTHRESH);
if(!x937.valid){
continue;
}
CheckValue<IkReal> x938=IKPowWithIntegerCheck(IKsign((((cj7*r21*sj8))+(((-1.0)*r22*x935))+(((-1.0)*cj8*r20*x936)))),-1);
if(!x938.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x937.value)+(((1.5707963267949)*(x938.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x939=IKsin(j6);
IkReal x940=(cj8*r01);
IkReal x941=(r00*sj8);
IkReal x942=IKcos(j6);
IkReal x943=((1.0)*cj7*r02);
IkReal x944=(cj8*r00*sj7);
IkReal x945=(r01*sj7);
IkReal x946=((1.0)*sj8*x942);
IkReal x947=((1.0)*cj7*x939);
IkReal x948=((1.0)*cj8*x942);
IkReal x949=(cj8*sj7*x939);
IkReal x950=((1.0)*sj7*sj8*x939);
IkReal x951=((1.0)*x942);
evalcond[0]=((((-1.0)*x945*x946))+((x942*x944))+(((-1.0)*x942*x943))+((x939*x941))+((x939*x940)));
evalcond[1]=(((r20*x949))+(((-1.0)*r21*x948))+(((-1.0)*r22*x947))+(((-1.0)*r20*x946))+(((-1.0)*r21*x950)));
evalcond[2]=((((-1.0)*r11*x950))+((r10*x949))+(((-1.0)*r12*x947))+(((-1.0)*r11*x948))+(((-1.0)*r10*x946)));
evalcond[3]=((1.0)+(((-1.0)*x941*x951))+(((-1.0)*x940*x951))+(((-1.0)*sj8*x939*x945))+((x939*x944))+(((-1.0)*x939*x943)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
IkReal x952=(cj8*r20);
IkReal x953=(r12*sj7);
IkReal x954=(r21*sj8);
IkReal x955=(r22*sj7);
IkReal x956=(cj7*cj8*r10);
IkReal x957=(cj7*cj8*r20);
IkReal x958=(cj7*r11*sj8);
IkReal x959=(cj7*r21*sj8);
IkReal x960=((((-1.08)*x952))+(((-2.82)*x957))+(((-0.36)*x953))+(((2.82)*x959))+(((-2.82)*x955))+(((0.36)*x958))+(((12.0)*pz))+(((-0.36)*x956))+(((1.08)*x954)));
j4eval[0]=((IKabs(((1.0)+x960)))+(IKabs(((-1.0)+x960)))+(IKabs(((-1.0)+(((-0.36)*x952))+(((-0.12)*x953))+(((0.36)*x954))+(((4.0)*pz))+(((-0.94)*x957))+(((0.94)*x959))+(((-0.94)*x955))+(((0.12)*x958))+(((-0.12)*x956))))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x961=(cj8*r20);
IkReal x962=(r12*sj7);
IkReal x963=(r21*sj8);
IkReal x964=(r22*sj7);
IkReal x965=(cj7*cj8*r10);
IkReal x966=(cj7*cj8*r20);
IkReal x967=(cj7*r11*sj8);
IkReal x968=(cj7*r21*sj8);
IkReal x969=((((0.12)*x967))+(((-0.94)*x964))+(((-0.36)*x961))+(((0.94)*x968))+(((0.36)*x963))+(((4.0)*pz))+(((-0.12)*x965))+(((-0.94)*x966))+(((-0.12)*x962)));
IkReal x970=((((-2.82)*x964))+(((2.82)*x968))+(((1.08)*x963))+(((-0.36)*x962))+(((0.36)*x967))+(((-2.82)*x966))+(((-0.36)*x965))+(((-1.08)*x961))+(((12.0)*pz)));
op[0]=((-1.0)+x969);
op[1]=0;
op[2]=((-1.0)+x970);
op[3]=0;
op[4]=((1.0)+x970);
op[5]=0;
op[6]=((1.0)+x969);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x971=(cj8*r20);
IkReal x972=((0.36)*x971);
IkReal x973=(r21*sj8);
IkReal x974=((0.36)*x973);
IkReal x975=(r22*sj7);
IkReal x976=(cj6*cj7*r22);
IkReal x977=(cj7*cj8*r20);
IkReal x978=(cj7*r21*sj8);
IkReal x979=(cj8*r21*sj6);
IkReal x980=(r20*sj6*sj8);
IkReal x981=((0.12)*cj6*sj7);
IkReal x982=((((0.12)*x979))+(((-0.94)*x978))+(((-1.0)*x974))+((x971*x981))+(((-1.0)*(4.0)*pz))+(((-0.12)*x976))+(((0.94)*x975))+(((-1.0)*x973*x981))+x972+(((0.94)*x977))+(((0.12)*x980)));
IkReal x983=(cj6*sj7);
IkReal x984=((((-1.0)*(12.0)*pz))+(((1.08)*x971))+(((0.36)*x980))+(((-1.08)*x973))+(((-1.0)*x974*x983))+(((-2.82)*x978))+(((2.82)*x975))+(((-0.36)*x976))+(((2.82)*x977))+(((0.36)*x979))+((x972*x983)));
j4evalpoly[0]=((-1.0)+(((htj4*htj4*htj4*htj4)*(((1.0)+x984))))+(((htj4*htj4)*(((-1.0)+x984))))+x982+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((1.0)+x982)))));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x985=(r12*sj7);
IkReal x986=(r22*sj7);
IkReal x987=(cj4*cj7);
IkReal x988=(cj8*r10);
IkReal x989=(cj7*sj4);
IkReal x990=(cj8*r20);
IkReal x991=(r11*sj8);
IkReal x992=((1.0)*cj4*cj7);
IkReal x993=(r21*sj8);
IkReal x994=((1.0)*cj7*sj4);
if( IKabs(((((-1.0)*x991*x992))+((cj4*x985))+((sj4*x986))+(((-1.0)*x993*x994))+((x987*x988))+((x989*x990)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x988*x989))+(((-1.0)*cj4*x986))+(((-1.0)*x990*x992))+(((-1.0)*x991*x994))+((sj4*x985))+((x987*x993)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x991*x992))+((cj4*x985))+((sj4*x986))+(((-1.0)*x993*x994))+((x987*x988))+((x989*x990))))+IKsqr((((x988*x989))+(((-1.0)*cj4*x986))+(((-1.0)*x990*x992))+(((-1.0)*x991*x994))+((sj4*x985))+((x987*x993))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x991*x992))+((cj4*x985))+((sj4*x986))+(((-1.0)*x993*x994))+((x987*x988))+((x989*x990))), (((x988*x989))+(((-1.0)*cj4*x986))+(((-1.0)*x990*x992))+(((-1.0)*x991*x994))+((sj4*x985))+((x987*x993))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x995=IKcos(j5);
IkReal x996=(cj4*x995);
IkReal x997=(cj7*cj8);
IkReal x998=IKsin(j5);
IkReal x999=(sj4*x998);
IkReal x1000=((1.0)*cj7*sj8);
IkReal x1001=(cj4*x998);
IkReal x1002=(sj4*x995);
IkReal x1003=((((-1.0)*x1002))+(((-1.0)*x1001)));
IkReal x1004=(cj8*sj6);
IkReal x1005=(sj6*sj8);
IkReal x1006=((1.0)*cj6*cj7);
IkReal x1007=(cj6*cj8*sj7);
IkReal x1008=((1.0)*cj6*sj7*sj8);
IkReal x1009=((0.09)*cj8);
IkReal x1010=((0.09)*sj8);
evalcond[0]=((((-1.0)*x999))+(((-1.0)*r21*x1000))+((r20*x997))+((r22*sj7))+x996);
evalcond[1]=((((-1.0)*r11*x1000))+x1003+((r12*sj7))+((r10*x997)));
evalcond[2]=((((-1.0)*x996))+(((-1.0)*r12*x1006))+((r10*x1005))+(((-1.0)*r11*x1008))+((r10*x1007))+((r11*x1004))+x999);
evalcond[3]=(((r21*x1004))+x1003+((r20*x1007))+(((-1.0)*r22*x1006))+(((-1.0)*r21*x1008))+((r20*x1005)));
evalcond[4]=((((-0.235)*x996))+((r20*x1009))+(((-1.0)*(1.0)*pz))+(((-1.0)*r21*x1010))+(((0.03)*x1002))+(((0.235)*x999))+(((-1.0)*(0.25)*cj4))+(((0.03)*x1001)));
evalcond[5]=((((-1.0)*(1.0)*py))+(((0.25)*sj4))+(((0.03)*x996))+(((-0.03)*x999))+(((0.235)*x1002))+(((0.235)*x1001))+(((-1.0)*r11*x1010))+((r10*x1009)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1011=((1.0)*cj7);
CheckValue<IkReal> x1012=IKPowWithIntegerCheck(IKsign((((cj7*cj8*r10))+((r12*sj7))+(((-1.0)*r11*sj8*x1011)))),-1);
if(!x1012.valid){
continue;
}
CheckValue<IkReal> x1013 = IKatan2WithCheck(IkReal((((r20*sj8))+((cj8*r21)))),IkReal(((((-1.0)*r22*x1011))+((cj8*r20*sj7))+(((-1.0)*(1.0)*r21*sj7*sj8)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1013.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1012.value)))+(x1013.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x1014=IKsin(j6);
IkReal x1015=(cj8*r01);
IkReal x1016=(r00*sj8);
IkReal x1017=IKcos(j6);
IkReal x1018=((1.0)*cj7*r02);
IkReal x1019=(cj8*r00*sj7);
IkReal x1020=(r01*sj7);
IkReal x1021=((1.0)*sj8*x1017);
IkReal x1022=((1.0)*cj7*x1014);
IkReal x1023=((1.0)*cj8*x1017);
IkReal x1024=(cj8*sj7*x1014);
IkReal x1025=((1.0)*sj7*sj8*x1014);
IkReal x1026=((1.0)*x1017);
evalcond[0]=((((-1.0)*x1017*x1018))+(((-1.0)*x1020*x1021))+((x1014*x1015))+((x1014*x1016))+((x1017*x1019)));
evalcond[1]=(((r20*x1024))+(((-1.0)*r21*x1023))+(((-1.0)*r20*x1021))+(((-1.0)*r21*x1025))+(((-1.0)*r22*x1022)));
evalcond[2]=((((-1.0)*r12*x1022))+(((-1.0)*r11*x1025))+((r10*x1024))+(((-1.0)*r10*x1021))+(((-1.0)*r11*x1023)));
evalcond[3]=((1.0)+(((-1.0)*x1014*x1018))+((x1014*x1019))+(((-1.0)*sj8*x1014*x1020))+(((-1.0)*x1015*x1026))+(((-1.0)*x1016*x1026)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
IkReal x1027=(cj8*r20);
IkReal x1028=(r12*sj7);
IkReal x1029=(r21*sj8);
IkReal x1030=(r22*sj7);
IkReal x1031=(cj7*cj8*r10);
IkReal x1032=(cj7*cj8*r20);
IkReal x1033=(cj7*r11*sj8);
IkReal x1034=(cj7*r21*sj8);
IkReal x1035=((((0.36)*x1033))+(((-1.08)*x1027))+(((-0.36)*x1028))+(((1.08)*x1029))+(((-2.82)*x1032))+(((2.82)*x1034))+(((-0.36)*x1031))+(((-2.82)*x1030))+(((12.0)*pz)));
j4eval[0]=((IKabs(((1.0)+x1035)))+(IKabs(((-1.0)+x1035)))+(IKabs(((-1.0)+(((0.36)*x1029))+(((-0.12)*x1028))+(((0.12)*x1033))+(((4.0)*pz))+(((-0.36)*x1027))+(((-0.12)*x1031))+(((-0.94)*x1032))+(((-0.94)*x1030))+(((0.94)*x1034))))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x1036=(cj8*r20);
IkReal x1037=(r12*sj7);
IkReal x1038=(r21*sj8);
IkReal x1039=(r22*sj7);
IkReal x1040=(cj7*cj8*r10);
IkReal x1041=(cj7*cj8*r20);
IkReal x1042=(cj7*r11*sj8);
IkReal x1043=(cj7*r21*sj8);
IkReal x1044=((((-0.94)*x1039))+(((0.12)*x1042))+(((-0.94)*x1041))+(((-0.12)*x1037))+(((4.0)*pz))+(((-0.12)*x1040))+(((0.94)*x1043))+(((0.36)*x1038))+(((-0.36)*x1036)));
IkReal x1045=((((-2.82)*x1041))+(((-0.36)*x1037))+(((-0.36)*x1040))+(((2.82)*x1043))+(((1.08)*x1038))+(((-1.08)*x1036))+(((12.0)*pz))+(((-2.82)*x1039))+(((0.36)*x1042)));
op[0]=((-1.0)+x1044);
op[1]=0;
op[2]=((-1.0)+x1045);
op[3]=0;
op[4]=((1.0)+x1045);
op[5]=0;
op[6]=((1.0)+x1044);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x1046=(cj8*r20);
IkReal x1047=((0.36)*x1046);
IkReal x1048=(r21*sj8);
IkReal x1049=((0.36)*x1048);
IkReal x1050=(r22*sj7);
IkReal x1051=(cj6*cj7*r22);
IkReal x1052=(cj7*cj8*r20);
IkReal x1053=(cj7*r21*sj8);
IkReal x1054=(cj8*r21*sj6);
IkReal x1055=(r20*sj6*sj8);
IkReal x1056=((0.12)*cj6*sj7);
IkReal x1057=((((-0.12)*x1051))+(((0.12)*x1054))+(((0.94)*x1050))+(((-1.0)*(4.0)*pz))+(((0.94)*x1052))+(((-0.94)*x1053))+x1047+((x1046*x1056))+(((0.12)*x1055))+(((-1.0)*x1049))+(((-1.0)*x1048*x1056)));
IkReal x1058=(cj6*sj7);
IkReal x1059=((((-0.36)*x1051))+(((-1.0)*(12.0)*pz))+(((-1.08)*x1048))+(((-2.82)*x1053))+(((0.36)*x1055))+(((0.36)*x1054))+(((-1.0)*x1049*x1058))+(((2.82)*x1050))+(((1.08)*x1046))+(((2.82)*x1052))+((x1047*x1058)));
j4evalpoly[0]=((-1.0)+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((1.0)+x1057))))+(((htj4*htj4)*(((-1.0)+x1059))))+x1057+(((htj4*htj4*htj4*htj4)*(((1.0)+x1059)))));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1060=(r12*sj7);
IkReal x1061=(r22*sj7);
IkReal x1062=(cj4*cj7);
IkReal x1063=(cj8*r10);
IkReal x1064=(cj7*sj4);
IkReal x1065=(cj8*r20);
IkReal x1066=(r11*sj8);
IkReal x1067=((1.0)*cj4*cj7);
IkReal x1068=(r21*sj8);
IkReal x1069=((1.0)*cj7*sj4);
if( IKabs(((((-1.0)*x1068*x1069))+((cj4*x1060))+((x1064*x1065))+((sj4*x1061))+((x1062*x1063))+(((-1.0)*x1066*x1067)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x1063*x1064))+(((-1.0)*cj4*x1061))+((sj4*x1060))+(((-1.0)*x1066*x1069))+(((-1.0)*x1065*x1067))+((x1062*x1068)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1068*x1069))+((cj4*x1060))+((x1064*x1065))+((sj4*x1061))+((x1062*x1063))+(((-1.0)*x1066*x1067))))+IKsqr((((x1063*x1064))+(((-1.0)*cj4*x1061))+((sj4*x1060))+(((-1.0)*x1066*x1069))+(((-1.0)*x1065*x1067))+((x1062*x1068))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x1068*x1069))+((cj4*x1060))+((x1064*x1065))+((sj4*x1061))+((x1062*x1063))+(((-1.0)*x1066*x1067))), (((x1063*x1064))+(((-1.0)*cj4*x1061))+((sj4*x1060))+(((-1.0)*x1066*x1069))+(((-1.0)*x1065*x1067))+((x1062*x1068))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1070=IKcos(j5);
IkReal x1071=(cj4*x1070);
IkReal x1072=(cj7*cj8);
IkReal x1073=IKsin(j5);
IkReal x1074=(sj4*x1073);
IkReal x1075=((1.0)*cj7*sj8);
IkReal x1076=(cj4*x1073);
IkReal x1077=(sj4*x1070);
IkReal x1078=((((-1.0)*x1076))+(((-1.0)*x1077)));
IkReal x1079=(cj8*sj6);
IkReal x1080=(sj6*sj8);
IkReal x1081=((1.0)*cj6*cj7);
IkReal x1082=(cj6*cj8*sj7);
IkReal x1083=((1.0)*cj6*sj7*sj8);
IkReal x1084=((0.09)*cj8);
IkReal x1085=((0.09)*sj8);
evalcond[0]=((((-1.0)*x1074))+x1071+((r20*x1072))+(((-1.0)*r21*x1075))+((r22*sj7)));
evalcond[1]=(x1078+(((-1.0)*r11*x1075))+((r10*x1072))+((r12*sj7)));
evalcond[2]=(((r10*x1082))+((r10*x1080))+(((-1.0)*x1071))+x1074+(((-1.0)*r12*x1081))+(((-1.0)*r11*x1083))+((r11*x1079)));
evalcond[3]=(((r20*x1082))+(((-1.0)*r22*x1081))+x1078+(((-1.0)*r21*x1083))+((r20*x1080))+((r21*x1079)));
evalcond[4]=((((0.03)*x1077))+(((-1.0)*(1.0)*pz))+(((-0.235)*x1071))+(((-1.0)*r21*x1085))+(((-1.0)*(0.25)*cj4))+((r20*x1084))+(((0.03)*x1076))+(((0.235)*x1074)));
evalcond[5]=((((-1.0)*(1.0)*py))+(((0.25)*sj4))+(((0.235)*x1077))+(((0.235)*x1076))+(((-0.03)*x1074))+(((0.03)*x1071))+(((-1.0)*r11*x1085))+((r10*x1084)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j5, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1086=((1.0)*cj8);
IkReal x1087=((1.0)*cj3);
IkReal x1088=(r11*sj3);
IkReal x1089=(r10*sj3);
IkReal x1090=(sj7*sj8);
IkReal x1091=((1.0)*cj8*sj7);
CheckValue<IkReal> x1092=IKPowWithIntegerCheck(IKsign((((cj7*r21*sj8))+(((-1.0)*cj7*r20*x1086))+(((-1.0)*r22*sj7)))),-1);
if(!x1092.valid){
continue;
}
CheckValue<IkReal> x1093 = IKatan2WithCheck(IkReal(((((-1.0)*sj8*x1089))+(((-1.0)*cj8*r01*x1087))+(((-1.0)*x1086*x1088))+(((-1.0)*r00*sj8*x1087)))),IkReal((((x1088*x1090))+((cj3*cj7*r02))+(((-1.0)*x1089*x1091))+((cj3*r01*x1090))+((cj7*r12*sj3))+(((-1.0)*cj3*r00*x1091)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1093.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1092.value)))+(x1093.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1094=IKsin(j6);
IkReal x1095=((1.0)*cj7*x1094);
IkReal x1096=IKcos(j6);
IkReal x1097=((1.0)*cj8*x1096);
IkReal x1098=((1.0)*sj8*x1096);
IkReal x1099=(cj8*sj7*x1094);
IkReal x1100=((1.0)*sj7*sj8*x1094);
evalcond[0]=((((-1.0)*r22*x1095))+(((-1.0)*r21*x1100))+(((-1.0)*r20*x1098))+(((-1.0)*r21*x1097))+((r20*x1099)));
evalcond[1]=((((-1.0)*r12*x1095))+(((-1.0)*r10*x1098))+((r10*x1099))+cj3+(((-1.0)*r11*x1100))+(((-1.0)*r11*x1097)));
evalcond[2]=((((-1.0)*r00*x1098))+((r00*x1099))+(((-1.0)*r02*x1095))+(((-1.0)*r01*x1097))+(((-1.0)*r01*x1100))+(((-1.0)*(1.0)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
IkReal x1101=(cj3*pz);
IkReal x1102=(r02*sj7);
IkReal x1103=(cj3*cj8*r20);
IkReal x1104=(cj3*r21*sj8);
IkReal x1105=(cj3*r22*sj7);
IkReal x1106=(cj7*cj8*r00);
IkReal x1107=(cj7*r01*sj8);
IkReal x1108=(cj3*cj7*cj8*r20);
IkReal x1109=(cj3*cj7*r21*sj8);
IkReal x1110=((((-12.0)*x1101))+(((2.82)*x1108))+(((-2.82)*x1109))+(((-0.36)*x1102))+(((-0.36)*x1106))+(((0.36)*x1107))+(((1.08)*x1103))+(((-1.08)*x1104))+(((2.82)*x1105)));
j4eval[0]=((IKabs((x1110+(((-1.0)*(1.0)*cj3)))))+(IKabs((x1110+cj3)))+(IKabs(((((0.12)*x1107))+(((0.94)*x1105))+(((-0.94)*x1109))+(((-0.12)*x1106))+(((0.94)*x1108))+cj3+(((-4.0)*x1101))+(((-0.36)*x1104))+(((-0.12)*x1102))+(((0.36)*x1103))))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x1111=(cj3*pz);
IkReal x1112=(r02*sj7);
IkReal x1113=(cj3*cj8*r20);
IkReal x1114=(cj3*r21*sj8);
IkReal x1115=(cj3*r22*sj7);
IkReal x1116=(cj7*cj8*r00);
IkReal x1117=(cj7*r01*sj8);
IkReal x1118=(cj3*cj7*cj8*r20);
IkReal x1119=(cj3*cj7*r21*sj8);
IkReal x1120=((((-0.12)*x1112))+(((0.36)*x1113))+(((-4.0)*x1111))+(((0.94)*x1115))+(((-0.12)*x1116))+(((0.94)*x1118))+(((-0.36)*x1114))+(((0.12)*x1117))+(((-0.94)*x1119)));
IkReal x1121=((((-0.36)*x1112))+(((1.08)*x1113))+(((0.36)*x1117))+(((2.82)*x1118))+(((2.82)*x1115))+(((-0.36)*x1116))+(((-12.0)*x1111))+(((-2.82)*x1119))+(((-1.08)*x1114)));
IkReal x1122=((-1.0)*(((1.0)*cj3)));
op[0]=(x1120+cj3);
op[1]=0;
op[2]=(x1121+cj3);
op[3]=0;
op[4]=(x1121+x1122);
op[5]=0;
op[6]=(x1122+x1120);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x1123=(pz*sj3);
IkReal x1124=(r12*sj7);
IkReal x1125=(cj7*cj8*r10);
IkReal x1126=(cj7*r11*sj8);
IkReal x1127=(cj8*r20*sj3);
IkReal x1128=(r21*sj3*sj8);
IkReal x1129=(r22*sj3*sj7);
IkReal x1130=(cj7*cj8*r20*sj3);
IkReal x1131=(cj7*r21*sj3*sj8);
IkReal x1132=((((0.12)*x1126))+(((0.94)*x1129))+(((-0.36)*x1128))+(((0.94)*x1130))+(((-0.94)*x1131))+(((-4.0)*x1123))+(((0.36)*x1127))+(((-0.12)*x1125))+(((-0.12)*x1124)));
IkReal x1133=((-1.0)*(((1.0)*sj3)));
IkReal x1134=((((-0.36)*x1125))+(((2.82)*x1130))+(((1.08)*x1127))+(((-12.0)*x1123))+(((-2.82)*x1131))+(((-1.08)*x1128))+(((-0.36)*x1124))+(((0.36)*x1126))+(((2.82)*x1129)));
j4evalpoly[0]=((((htj4*htj4*htj4*htj4)*((sj3+x1134))))+(((htj4*htj4)*((x1134+x1133))))+x1133+x1132+(((htj4*htj4*htj4*htj4*htj4*htj4)*((sj3+x1132)))));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1135=(r22*sj7);
IkReal x1136=(cj4*r21);
IkReal x1137=(cj8*sj6);
IkReal x1138=(r20*sj6*sj8);
IkReal x1139=(cj7*cj8*r20);
IkReal x1140=((1.0)*cj4);
IkReal x1141=(cj6*cj7*r22);
IkReal x1142=(cj7*sj8);
IkReal x1143=((1.0)*r21*sj4);
IkReal x1144=(cj6*cj8*r20*sj7);
IkReal x1145=(cj6*sj7*sj8);
if( IKabs(((((-1.0)*x1140*x1141))+((sj4*x1135))+((cj4*x1138))+((x1136*x1137))+(((-1.0)*cj4*r21*x1145))+(((-1.0)*x1142*x1143))+((cj4*x1144))+((sj4*x1139)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r21*sj4*x1137))+(((-1.0)*x1139*x1140))+((sj4*x1144))+(((-1.0)*sj4*x1141))+(((-1.0)*x1135*x1140))+((sj4*x1138))+((x1136*x1142))+(((-1.0)*x1143*x1145)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1140*x1141))+((sj4*x1135))+((cj4*x1138))+((x1136*x1137))+(((-1.0)*cj4*r21*x1145))+(((-1.0)*x1142*x1143))+((cj4*x1144))+((sj4*x1139))))+IKsqr((((r21*sj4*x1137))+(((-1.0)*x1139*x1140))+((sj4*x1144))+(((-1.0)*sj4*x1141))+(((-1.0)*x1135*x1140))+((sj4*x1138))+((x1136*x1142))+(((-1.0)*x1143*x1145))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x1140*x1141))+((sj4*x1135))+((cj4*x1138))+((x1136*x1137))+(((-1.0)*cj4*r21*x1145))+(((-1.0)*x1142*x1143))+((cj4*x1144))+((sj4*x1139))), (((r21*sj4*x1137))+(((-1.0)*x1139*x1140))+((sj4*x1144))+(((-1.0)*sj4*x1141))+(((-1.0)*x1135*x1140))+((sj4*x1138))+((x1136*x1142))+(((-1.0)*x1143*x1145))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[9];
IkReal x1146=IKcos(j5);
IkReal x1147=(cj4*x1146);
IkReal x1148=(cj7*cj8);
IkReal x1149=IKsin(j5);
IkReal x1150=(sj4*x1149);
IkReal x1151=((1.0)*x1150);
IkReal x1152=((1.0)*cj7*sj8);
IkReal x1153=(cj4*x1149);
IkReal x1154=(cj3*x1153);
IkReal x1155=(sj4*x1146);
IkReal x1156=(cj3*x1155);
IkReal x1157=(sj3*x1153);
IkReal x1158=(sj3*x1155);
IkReal x1159=(cj8*sj6);
IkReal x1160=(sj6*sj8);
IkReal x1161=((1.0)*cj6*cj7);
IkReal x1162=(cj6*cj8*sj7);
IkReal x1163=((1.0)*cj6*sj7*sj8);
IkReal x1164=((0.09)*cj8);
IkReal x1165=((0.09)*sj8);
IkReal x1166=(cj3*x1147);
IkReal x1167=(sj3*x1147);
IkReal x1168=((0.25)*sj4);
IkReal x1169=((0.03)*sj4*x1149);
evalcond[0]=(x1147+(((-1.0)*x1151))+((r20*x1148))+((r22*sj7))+(((-1.0)*r21*x1152)));
evalcond[1]=(((r02*sj7))+x1154+x1156+(((-1.0)*r01*x1152))+((r00*x1148)));
evalcond[2]=(x1158+x1157+(((-1.0)*r11*x1152))+((r10*x1148))+((r12*sj7)));
evalcond[3]=((((-1.0)*x1155))+((r21*x1159))+(((-1.0)*r21*x1163))+((r20*x1160))+(((-1.0)*r22*x1161))+(((-1.0)*x1153))+((r20*x1162)));
evalcond[4]=((((-1.0)*(1.0)*pz))+((r20*x1164))+(((-1.0)*r21*x1165))+(((0.03)*x1155))+(((-1.0)*(0.25)*cj4))+(((-0.235)*x1147))+(((0.235)*x1150))+(((0.03)*x1153)));
evalcond[5]=(((r01*x1159))+((r00*x1162))+(((-1.0)*cj3*x1151))+(((-1.0)*r01*x1163))+x1166+(((-1.0)*r02*x1161))+((r00*x1160)));
evalcond[6]=((((-1.0)*sj3*x1151))+(((-1.0)*r12*x1161))+x1167+((r10*x1160))+((r11*x1159))+(((-1.0)*r11*x1163))+((r10*x1162)));
evalcond[7]=((((-1.0)*(1.0)*px))+(((-0.03)*x1166))+(((-0.235)*x1156))+((r00*x1164))+((cj3*x1169))+(((-0.235)*x1154))+(((-1.0)*r01*x1165))+(((-1.0)*cj3*x1168))+(((0.095)*sj3)));
evalcond[8]=((((-1.0)*(0.095)*cj3))+(((-1.0)*(1.0)*py))+((r10*x1164))+(((-1.0)*r11*x1165))+(((-0.03)*x1167))+(((-1.0)*sj3*x1168))+((sj3*x1169))+(((-0.235)*x1157))+(((-0.235)*x1158)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1170=((1.0)*sj8);
IkReal x1171=(r21*sj3);
IkReal x1172=(r20*sj3);
CheckValue<IkReal> x1173=IKPowWithIntegerCheck(IKsign((((cj7*cj8*r10))+((r12*sj7))+(((-1.0)*cj7*r11*x1170)))),-1);
if(!x1173.valid){
continue;
}
CheckValue<IkReal> x1174 = IKatan2WithCheck(IkReal(((((-1.0)*x1170*x1172))+(((-1.0)*cj8*x1171)))),IkReal((((cj7*r22*sj3))+((sj7*sj8*x1171))+(((-1.0)*cj8*sj7*x1172)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1174.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1173.value)))+(x1174.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1175=IKsin(j6);
IkReal x1176=((1.0)*cj7*x1175);
IkReal x1177=IKcos(j6);
IkReal x1178=((1.0)*cj8*x1177);
IkReal x1179=((1.0)*sj8*x1177);
IkReal x1180=(cj8*sj7*x1175);
IkReal x1181=((1.0)*sj7*sj8*x1175);
evalcond[0]=((((-1.0)*r20*x1179))+((r20*x1180))+(((-1.0)*r21*x1181))+(((-1.0)*r21*x1178))+(((-1.0)*r22*x1176)));
evalcond[1]=((((-1.0)*r10*x1179))+(((-1.0)*r11*x1178))+((r10*x1180))+(((-1.0)*r11*x1181))+cj3+(((-1.0)*r12*x1176)));
evalcond[2]=((((-1.0)*r01*x1178))+(((-1.0)*r01*x1181))+(((-1.0)*r00*x1179))+(((-1.0)*(1.0)*sj3))+((r00*x1180))+(((-1.0)*r02*x1176)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
IkReal x1182=(cj3*pz);
IkReal x1183=(r02*sj7);
IkReal x1184=(cj3*cj8*r20);
IkReal x1185=(cj3*r21*sj8);
IkReal x1186=(cj3*r22*sj7);
IkReal x1187=(cj7*cj8*r00);
IkReal x1188=(cj7*r01*sj8);
IkReal x1189=(cj3*cj7*cj8*r20);
IkReal x1190=(cj3*cj7*r21*sj8);
IkReal x1191=((((-2.82)*x1190))+(((2.82)*x1189))+(((-0.36)*x1187))+(((-0.36)*x1183))+(((0.36)*x1188))+(((1.08)*x1184))+(((-1.08)*x1185))+(((-12.0)*x1182))+(((2.82)*x1186)));
j4eval[0]=((IKabs(((((-1.0)*(1.0)*cj3))+x1191)))+(IKabs(((((0.94)*x1189))+(((-4.0)*x1182))+(((-0.94)*x1190))+(((0.94)*x1186))+cj3+(((0.36)*x1184))+(((-0.36)*x1185))+(((-0.12)*x1183))+(((-0.12)*x1187))+(((0.12)*x1188)))))+(IKabs((cj3+x1191))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x1192=(cj3*pz);
IkReal x1193=(r02*sj7);
IkReal x1194=(cj3*cj8*r20);
IkReal x1195=(cj3*r21*sj8);
IkReal x1196=(cj3*r22*sj7);
IkReal x1197=(cj7*cj8*r00);
IkReal x1198=(cj7*r01*sj8);
IkReal x1199=(cj3*cj7*cj8*r20);
IkReal x1200=(cj3*cj7*r21*sj8);
IkReal x1201=((((0.94)*x1199))+(((0.12)*x1198))+(((0.94)*x1196))+(((-4.0)*x1192))+(((-0.36)*x1195))+(((-0.12)*x1193))+(((0.36)*x1194))+(((-0.12)*x1197))+(((-0.94)*x1200)));
IkReal x1202=((((-0.36)*x1197))+(((1.08)*x1194))+(((0.36)*x1198))+(((-0.36)*x1193))+(((2.82)*x1199))+(((2.82)*x1196))+(((-1.08)*x1195))+(((-12.0)*x1192))+(((-2.82)*x1200)));
IkReal x1203=((-1.0)*(((1.0)*cj3)));
op[0]=(x1201+cj3);
op[1]=0;
op[2]=(x1202+cj3);
op[3]=0;
op[4]=(x1202+x1203);
op[5]=0;
op[6]=(x1203+x1201);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x1204=(pz*sj3);
IkReal x1205=(r12*sj7);
IkReal x1206=(cj7*cj8*r10);
IkReal x1207=(cj7*r11*sj8);
IkReal x1208=(cj8*r20*sj3);
IkReal x1209=(r21*sj3*sj8);
IkReal x1210=(r22*sj3*sj7);
IkReal x1211=(cj7*cj8*r20*sj3);
IkReal x1212=(cj7*r21*sj3*sj8);
IkReal x1213=((((-0.12)*x1205))+(((0.36)*x1208))+(((-0.12)*x1206))+(((-0.94)*x1212))+(((0.12)*x1207))+(((0.94)*x1211))+(((-0.36)*x1209))+(((0.94)*x1210))+(((-4.0)*x1204)));
IkReal x1214=((-1.0)*(((1.0)*sj3)));
IkReal x1215=((((-1.08)*x1209))+(((0.36)*x1207))+(((-0.36)*x1206))+(((2.82)*x1211))+(((-2.82)*x1212))+(((2.82)*x1210))+(((-0.36)*x1205))+(((1.08)*x1208))+(((-12.0)*x1204)));
j4evalpoly[0]=((((htj4*htj4)*((x1215+x1214))))+(((htj4*htj4*htj4*htj4*htj4*htj4)*((sj3+x1213))))+(((htj4*htj4*htj4*htj4)*((sj3+x1215))))+x1213+x1214);
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1216=(r22*sj7);
IkReal x1217=(cj4*r21);
IkReal x1218=(cj8*sj6);
IkReal x1219=(r20*sj6*sj8);
IkReal x1220=(cj7*cj8*r20);
IkReal x1221=((1.0)*cj4);
IkReal x1222=(cj6*cj7*r22);
IkReal x1223=(cj7*sj8);
IkReal x1224=((1.0)*r21*sj4);
IkReal x1225=(cj6*cj8*r20*sj7);
IkReal x1226=(cj6*sj7*sj8);
if( IKabs((((cj4*x1219))+((sj4*x1216))+((x1217*x1218))+((cj4*x1225))+(((-1.0)*x1223*x1224))+(((-1.0)*x1221*x1222))+((sj4*x1220))+(((-1.0)*cj4*r21*x1226)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1220*x1221))+(((-1.0)*sj4*x1222))+((sj4*x1225))+(((-1.0)*x1224*x1226))+((x1217*x1223))+(((-1.0)*x1216*x1221))+((r21*sj4*x1218))+((sj4*x1219)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*x1219))+((sj4*x1216))+((x1217*x1218))+((cj4*x1225))+(((-1.0)*x1223*x1224))+(((-1.0)*x1221*x1222))+((sj4*x1220))+(((-1.0)*cj4*r21*x1226))))+IKsqr(((((-1.0)*x1220*x1221))+(((-1.0)*sj4*x1222))+((sj4*x1225))+(((-1.0)*x1224*x1226))+((x1217*x1223))+(((-1.0)*x1216*x1221))+((r21*sj4*x1218))+((sj4*x1219))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj4*x1219))+((sj4*x1216))+((x1217*x1218))+((cj4*x1225))+(((-1.0)*x1223*x1224))+(((-1.0)*x1221*x1222))+((sj4*x1220))+(((-1.0)*cj4*r21*x1226))), ((((-1.0)*x1220*x1221))+(((-1.0)*sj4*x1222))+((sj4*x1225))+(((-1.0)*x1224*x1226))+((x1217*x1223))+(((-1.0)*x1216*x1221))+((r21*sj4*x1218))+((sj4*x1219))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[9];
IkReal x1227=IKcos(j5);
IkReal x1228=(cj4*x1227);
IkReal x1229=(cj7*cj8);
IkReal x1230=IKsin(j5);
IkReal x1231=(sj4*x1230);
IkReal x1232=((1.0)*x1231);
IkReal x1233=((1.0)*cj7*sj8);
IkReal x1234=(cj4*x1230);
IkReal x1235=(cj3*x1234);
IkReal x1236=(sj4*x1227);
IkReal x1237=(cj3*x1236);
IkReal x1238=(sj3*x1234);
IkReal x1239=(sj3*x1236);
IkReal x1240=(cj8*sj6);
IkReal x1241=(sj6*sj8);
IkReal x1242=((1.0)*cj6*cj7);
IkReal x1243=(cj6*cj8*sj7);
IkReal x1244=((1.0)*cj6*sj7*sj8);
IkReal x1245=((0.09)*cj8);
IkReal x1246=((0.09)*sj8);
IkReal x1247=(cj3*x1228);
IkReal x1248=(sj3*x1228);
IkReal x1249=((0.25)*sj4);
IkReal x1250=((0.03)*sj4*x1230);
evalcond[0]=((((-1.0)*r21*x1233))+(((-1.0)*x1232))+x1228+((r20*x1229))+((r22*sj7)));
evalcond[1]=(((r00*x1229))+((r02*sj7))+x1237+x1235+(((-1.0)*r01*x1233)));
evalcond[2]=(((r10*x1229))+x1238+x1239+((r12*sj7))+(((-1.0)*r11*x1233)));
evalcond[3]=((((-1.0)*r21*x1244))+(((-1.0)*x1234))+((r21*x1240))+((r20*x1243))+(((-1.0)*r22*x1242))+(((-1.0)*x1236))+((r20*x1241)));
evalcond[4]=((((-1.0)*(1.0)*pz))+(((0.03)*x1234))+(((0.03)*x1236))+(((-0.235)*x1228))+((r20*x1245))+(((-1.0)*r21*x1246))+(((-1.0)*(0.25)*cj4))+(((0.235)*x1231)));
evalcond[5]=((((-1.0)*r02*x1242))+((r00*x1241))+((r00*x1243))+((r01*x1240))+(((-1.0)*r01*x1244))+x1247+(((-1.0)*cj3*x1232)));
evalcond[6]=((((-1.0)*sj3*x1232))+((r11*x1240))+((r10*x1241))+((r10*x1243))+x1248+(((-1.0)*r12*x1242))+(((-1.0)*r11*x1244)));
evalcond[7]=((((-1.0)*(1.0)*px))+(((-1.0)*r01*x1246))+(((-1.0)*cj3*x1249))+((r00*x1245))+((cj3*x1250))+(((-0.03)*x1247))+(((-0.235)*x1235))+(((-0.235)*x1237))+(((0.095)*sj3)));
evalcond[8]=((((-0.235)*x1239))+((sj3*x1250))+(((-1.0)*(0.095)*cj3))+(((-0.235)*x1238))+(((-1.0)*(1.0)*py))+(((-0.03)*x1248))+((r10*x1245))+(((-1.0)*r11*x1246))+(((-1.0)*sj3*x1249)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1251=((1.0)*cj7);
IkReal x1252=(cj3*cj8);
IkReal x1253=(cj3*sj8);
CheckValue<IkReal> x1254 = IKatan2WithCheck(IkReal((((r20*x1253))+((r21*x1252)))),IkReal((((r20*sj7*x1252))+(((-1.0)*r21*sj7*x1253))+(((-1.0)*cj3*r22*x1251)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1254.valid){
continue;
}
CheckValue<IkReal> x1255=IKPowWithIntegerCheck(IKsign((((cj7*r01*sj8))+(((-1.0)*cj8*r00*x1251))+(((-1.0)*r02*sj7)))),-1);
if(!x1255.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1254.value)+(((1.5707963267949)*(x1255.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1256=IKsin(j6);
IkReal x1257=((1.0)*cj7*x1256);
IkReal x1258=IKcos(j6);
IkReal x1259=((1.0)*cj8*x1258);
IkReal x1260=((1.0)*sj8*x1258);
IkReal x1261=(cj8*sj7*x1256);
IkReal x1262=((1.0)*sj7*sj8*x1256);
evalcond[0]=(((r20*x1261))+(((-1.0)*r22*x1257))+(((-1.0)*r21*x1259))+(((-1.0)*r20*x1260))+(((-1.0)*r21*x1262)));
evalcond[1]=((((-1.0)*r11*x1262))+(((-1.0)*r11*x1259))+((r10*x1261))+cj3+(((-1.0)*r12*x1257))+(((-1.0)*r10*x1260)));
evalcond[2]=((((-1.0)*r00*x1260))+(((-1.0)*r01*x1262))+(((-1.0)*r02*x1257))+(((-1.0)*(1.0)*sj3))+((r00*x1261))+(((-1.0)*r01*x1259)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
IkReal x1263=(cj3*pz);
IkReal x1264=(r02*sj7);
IkReal x1265=(cj3*cj8*r20);
IkReal x1266=(cj3*r21*sj8);
IkReal x1267=(cj3*r22*sj7);
IkReal x1268=(cj7*cj8*r00);
IkReal x1269=(cj7*r01*sj8);
IkReal x1270=(cj3*cj7*cj8*r20);
IkReal x1271=(cj3*cj7*r21*sj8);
IkReal x1272=((((0.36)*x1269))+(((-0.36)*x1264))+(((-2.82)*x1271))+(((2.82)*x1267))+(((-12.0)*x1263))+(((-0.36)*x1268))+(((1.08)*x1265))+(((2.82)*x1270))+(((-1.08)*x1266)));
j4eval[0]=((IKabs(((((-0.12)*x1268))+(((0.94)*x1270))+(((-0.12)*x1264))+(((0.12)*x1269))+(((0.36)*x1265))+(((0.94)*x1267))+cj3+(((-4.0)*x1263))+(((-0.94)*x1271))+(((-0.36)*x1266)))))+(IKabs(((((-1.0)*(1.0)*cj3))+x1272)))+(IKabs((x1272+cj3))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j4evalpoly[1];
IkReal x1273=(cj3*pz);
IkReal x1274=(r02*sj7);
IkReal x1275=(cj3*cj8*r20);
IkReal x1276=(cj3*r21*sj8);
IkReal x1277=(cj3*r22*sj7);
IkReal x1278=(cj7*cj8*r00);
IkReal x1279=(cj7*r01*sj8);
IkReal x1280=(cj3*cj7*cj8*r20);
IkReal x1281=(cj3*cj7*r21*sj8);
IkReal x1282=((((-0.12)*x1274))+(((0.94)*x1280))+(((0.12)*x1279))+(((-0.12)*x1278))+(((-0.94)*x1281))+(((-0.36)*x1276))+(((0.36)*x1275))+(((-4.0)*x1273))+(((0.94)*x1277)));
IkReal x1283=((((-2.82)*x1281))+(((-0.36)*x1278))+(((2.82)*x1280))+(((2.82)*x1277))+(((-1.08)*x1276))+(((-12.0)*x1273))+(((-0.36)*x1274))+(((0.36)*x1279))+(((1.08)*x1275)));
IkReal x1284=((-1.0)*(((1.0)*cj3)));
op[0]=(cj3+x1282);
op[1]=0;
op[2]=(cj3+x1283);
op[3]=0;
op[4]=(x1283+x1284);
op[5]=0;
op[6]=(x1282+x1284);
polyroots6(op,zeror,numroots);
IkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[6]={true,true,true,true,true,true};
_nj4 = 6;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x1285=(pz*sj3);
IkReal x1286=(r12*sj7);
IkReal x1287=(cj7*cj8*r10);
IkReal x1288=(cj7*r11*sj8);
IkReal x1289=(cj8*r20*sj3);
IkReal x1290=(r21*sj3*sj8);
IkReal x1291=(r22*sj3*sj7);
IkReal x1292=(cj7*cj8*r20*sj3);
IkReal x1293=(cj7*r21*sj3*sj8);
IkReal x1294=((((-0.36)*x1290))+(((-0.94)*x1293))+(((-0.12)*x1287))+(((0.94)*x1292))+(((-0.12)*x1286))+(((0.94)*x1291))+(((-4.0)*x1285))+(((0.12)*x1288))+(((0.36)*x1289)));
IkReal x1295=((-1.0)*(((1.0)*sj3)));
IkReal x1296=((((2.82)*x1292))+(((1.08)*x1289))+(((2.82)*x1291))+(((-0.36)*x1286))+(((0.36)*x1288))+(((-12.0)*x1285))+(((-0.36)*x1287))+(((-2.82)*x1293))+(((-1.08)*x1290)));
j4evalpoly[0]=(x1294+x1295+(((htj4*htj4)*((x1295+x1296))))+(((htj4*htj4*htj4*htj4*htj4*htj4)*((x1294+sj3))))+(((htj4*htj4*htj4*htj4)*((x1296+sj3)))));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1297=(r22*sj7);
IkReal x1298=(cj4*r21);
IkReal x1299=(cj8*sj6);
IkReal x1300=(r20*sj6*sj8);
IkReal x1301=(cj7*cj8*r20);
IkReal x1302=((1.0)*cj4);
IkReal x1303=(cj6*cj7*r22);
IkReal x1304=(cj7*sj8);
IkReal x1305=((1.0)*r21*sj4);
IkReal x1306=(cj6*cj8*r20*sj7);
IkReal x1307=(cj6*sj7*sj8);
if( IKabs((((sj4*x1301))+((x1298*x1299))+(((-1.0)*x1302*x1303))+((cj4*x1300))+(((-1.0)*x1304*x1305))+(((-1.0)*cj4*r21*x1307))+((cj4*x1306))+((sj4*x1297)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj4*x1300))+(((-1.0)*x1297*x1302))+(((-1.0)*sj4*x1303))+((r21*sj4*x1299))+((sj4*x1306))+((x1298*x1304))+(((-1.0)*x1305*x1307))+(((-1.0)*x1301*x1302)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj4*x1301))+((x1298*x1299))+(((-1.0)*x1302*x1303))+((cj4*x1300))+(((-1.0)*x1304*x1305))+(((-1.0)*cj4*r21*x1307))+((cj4*x1306))+((sj4*x1297))))+IKsqr((((sj4*x1300))+(((-1.0)*x1297*x1302))+(((-1.0)*sj4*x1303))+((r21*sj4*x1299))+((sj4*x1306))+((x1298*x1304))+(((-1.0)*x1305*x1307))+(((-1.0)*x1301*x1302))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((sj4*x1301))+((x1298*x1299))+(((-1.0)*x1302*x1303))+((cj4*x1300))+(((-1.0)*x1304*x1305))+(((-1.0)*cj4*r21*x1307))+((cj4*x1306))+((sj4*x1297))), (((sj4*x1300))+(((-1.0)*x1297*x1302))+(((-1.0)*sj4*x1303))+((r21*sj4*x1299))+((sj4*x1306))+((x1298*x1304))+(((-1.0)*x1305*x1307))+(((-1.0)*x1301*x1302))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[9];
IkReal x1308=IKcos(j5);
IkReal x1309=(cj4*x1308);
IkReal x1310=(cj7*cj8);
IkReal x1311=IKsin(j5);
IkReal x1312=(sj4*x1311);
IkReal x1313=((1.0)*x1312);
IkReal x1314=((1.0)*cj7*sj8);
IkReal x1315=(cj4*x1311);
IkReal x1316=(cj3*x1315);
IkReal x1317=(sj4*x1308);
IkReal x1318=(cj3*x1317);
IkReal x1319=(sj3*x1315);
IkReal x1320=(sj3*x1317);
IkReal x1321=(cj8*sj6);
IkReal x1322=(sj6*sj8);
IkReal x1323=((1.0)*cj6*cj7);
IkReal x1324=(cj6*cj8*sj7);
IkReal x1325=((1.0)*cj6*sj7*sj8);
IkReal x1326=((0.09)*cj8);
IkReal x1327=((0.09)*sj8);
IkReal x1328=(cj3*x1309);
IkReal x1329=(sj3*x1309);
IkReal x1330=((0.25)*sj4);
IkReal x1331=((0.03)*sj4*x1311);
evalcond[0]=(((r20*x1310))+x1309+(((-1.0)*r21*x1314))+((r22*sj7))+(((-1.0)*x1313)));
evalcond[1]=(((r02*sj7))+(((-1.0)*r01*x1314))+((r00*x1310))+x1318+x1316);
evalcond[2]=(x1320+(((-1.0)*r11*x1314))+((r12*sj7))+((r10*x1310))+x1319);
evalcond[3]=((((-1.0)*x1315))+(((-1.0)*x1317))+((r20*x1322))+((r21*x1321))+(((-1.0)*r21*x1325))+((r20*x1324))+(((-1.0)*r22*x1323)));
evalcond[4]=((((0.235)*x1312))+(((0.03)*x1317))+(((-1.0)*(1.0)*pz))+(((-0.235)*x1309))+((r20*x1326))+(((-1.0)*r21*x1327))+(((-1.0)*(0.25)*cj4))+(((0.03)*x1315)));
evalcond[5]=(x1328+(((-1.0)*r01*x1325))+((r00*x1324))+(((-1.0)*cj3*x1313))+(((-1.0)*r02*x1323))+((r01*x1321))+((r00*x1322)));
evalcond[6]=(x1329+(((-1.0)*sj3*x1313))+(((-1.0)*r12*x1323))+((r11*x1321))+((r10*x1324))+(((-1.0)*r11*x1325))+((r10*x1322)));
evalcond[7]=((((-1.0)*(1.0)*px))+(((-0.235)*x1316))+(((-0.235)*x1318))+((cj3*x1331))+(((-0.03)*x1328))+(((-1.0)*cj3*x1330))+(((-1.0)*r01*x1327))+(((0.095)*sj3))+((r00*x1326)));
evalcond[8]=((((-1.0)*(0.095)*cj3))+(((-1.0)*(1.0)*py))+((r10*x1326))+((sj3*x1331))+(((-1.0)*sj3*x1330))+(((-0.235)*x1319))+(((-0.03)*x1329))+(((-0.235)*x1320))+(((-1.0)*r11*x1327)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j3;
vinfos[0].indices[0] = _ij3[0];
vinfos[0].indices[1] = _ij3[1];
vinfos[0].maxsolutions = _nj3;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j4;
vinfos[1].indices[0] = _ij4[0];
vinfos[1].indices[1] = _ij4[1];
vinfos[1].maxsolutions = _nj4;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j5;
vinfos[2].indices[0] = _ij5[0];
vinfos[2].indices[1] = _ij5[1];
vinfos[2].maxsolutions = _nj5;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j6;
vinfos[3].indices[0] = _ij6[0];
vinfos[3].indices[1] = _ij6[1];
vinfos[3].maxsolutions = _nj6;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j7;
vinfos[4].indices[0] = _ij7[0];
vinfos[4].indices[1] = _ij7[1];
vinfos[4].maxsolutions = _nj7;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j8;
vinfos[5].indices[0] = _ij8[0];
vinfos[5].indices[1] = _ij8[1];
vinfos[5].maxsolutions = _nj8;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "556b5a549250b91dd9b64142ef6fb205"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
