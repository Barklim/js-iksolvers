{"version":3,"file":"./solvers/man1_rightarm.html","sources":["./solvers/man1_rightarm.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAIA;;;;;;;;;;;;;;;AAuwRA;AACA;AACA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAx9RA;AAAA;AAAA;;;;;;;;AAFA;AAAA;AAAA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-05-22 07:14:02.384568\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53;\nx0=IKcos(j[1]);\nx1=IKsin(j[1]);\nx2=IKsin(j[3]);\nx3=IKcos(j[3]);\nx4=IKsin(j[2]);\nx5=IKsin(j[4]);\nx6=IKcos(j[2]);\nx7=IKcos(j[4]);\nx8=IKsin(j[6]);\nx9=IKcos(j[6]);\nx10=IKsin(j[5]);\nx11=IKcos(j[5]);\nx12=IKcos(j[0]);\nx13=IKsin(j[0]);\nx14=((1.0)*x2);\nx15=((0.2617)*x13);\nx16=((1.0)*x4);\nx17=((1.0)*x13);\nx18=((1.0)*x3);\nx19=((1.0)*x7);\nx20=((1.0)*x5);\nx21=((0.2617)*x12);\nx22=((1.0)*x10);\nx23=(x0*x3);\nx24=(x0*x2);\nx25=(x1*x4);\nx26=(x0*x13);\nx27=(x0*x6);\nx28=(x1*x3);\nx29=(x12*x6);\nx30=(x0*x12);\nx31=(x1*x14);\nx32=(x1*x13*x16);\nx33=(x14*x26);\nx34=((((-1.0)*x13*x16))+((x1*x29)));\nx35=(((x12*x25))+((x13*x6)));\nx36=((((-1.0)*x32))+x29);\nx37=(((x1*x18))+((x0*x14*x4)));\nx38=((((-1.0)*x17*x6))+(((-1.0)*x1*x12*x16)));\nx39=((((-1.0)*x12*x16))+(((-1.0)*x1*x17*x6)));\nx40=(x3*x36);\nx41=(x39*x5);\nx42=(x11*x37);\nx43=(((x27*x7))+((x5*(((((-1.0)*x31))+((x23*x4)))))));\nx44=(((x27*x5))+((x7*(((((-1.0)*x16*x23))+x31)))));\nx45=((((-1.0)*x18*x36))+x33);\nx46=(((x17*x23))+((x14*(((((-1.0)*x32))+(((1.0)*x29)))))));\nx47=(x10*x44);\nx48=((((-1.0)*x18*x30))+(((-1.0)*x14*x38)));\nx49=(x11*x46);\nx50=(x11*x48);\nx51=(((x5*((((x3*x35))+((x12*x24))))))+((x34*x7)));\nx52=(((x7*(((((-1.0)*x18*x35))+(((-1.0)*x14*x30))))))+((x34*x5)));\nx53=(x10*x52);\neerot[0]=(((x8*((x47+x42))))+((x43*x9)));\neerot[1]=(((x9*(((((-1.0)*x42))+(((-1.0)*x22*x44))))))+((x43*x8)));\neerot[2]=(((x11*x44))+(((-1.0)*x10*x37)));\neetrans[0]=((-0.1744)+(((0.2617)*x24*x4))+(((0.3102)*x1))+(((0.2617)*x28)));\neerot[3]=(((x51*x9))+((x8*((x50+x53)))));\neerot[4]=(((x9*(((((-1.0)*x50))+(((-1.0)*x53))))))+((x51*x8)));\neerot[5]=(((x11*x52))+((x10*((((x2*x38))+((x12*x23)))))));\neetrans[1]=((((-1.0)*x21*x23))+((x2*((((x21*x25))+((x15*x6))))))+(((-0.3102)*x30)));\neerot[6]=((((-1.0)*x9*(((((1.0)*x39*x7))+(((1.0)*x5*(((((-1.0)*x13*x24))+x40))))))))+((x8*(((((-1.0)*x49))+(((-1.0)*x22*((x41+((x45*x7)))))))))));\neerot[7]=(((x9*((x49+((x10*((x41+((x7*(((((-1.0)*x40))+x33))))))))))))+(((-1.0)*x8*((((x19*x39))+((x20*(((((-1.0)*x33))+x40)))))))));\neerot[8]=(((x10*x46))+((x11*(((((-1.0)*x20*x39))+(((-1.0)*x19*x45)))))));\neetrans[2]=((((-1.0)*x15*x23))+((x2*(((((-1.0)*x21*x6))+((x15*x25))))))+(((-0.3102)*x26)));\n}\n\nIKFAST_API int GetNumFreeParameters() { return 1; }\nIKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }\nIKFAST_API int GetNumJoints() { return 7; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j35,cj35,sj35,htj35,j35mul,j36,cj36,sj36,htj36,j36mul,j38,cj38,sj38,htj38,j38mul,j39,cj39,sj39,htj39,j39mul,j40,cj40,sj40,htj40,j40mul,j41,cj41,sj41,htj41,j41mul,j37,cj37,sj37,htj37,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij35[2], _nj35,_ij36[2], _nj36,_ij38[2], _nj38,_ij39[2], _nj39,_ij40[2], _nj40,_ij41[2], _nj41,_ij37[2], _nj37;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj35=numeric_limits<IkReal>::quiet_NaN(); _ij35[0] = -1; _ij35[1] = -1; _nj35 = -1; j36=numeric_limits<IkReal>::quiet_NaN(); _ij36[0] = -1; _ij36[1] = -1; _nj36 = -1; j38=numeric_limits<IkReal>::quiet_NaN(); _ij38[0] = -1; _ij38[1] = -1; _nj38 = -1; j39=numeric_limits<IkReal>::quiet_NaN(); _ij39[0] = -1; _ij39[1] = -1; _nj39 = -1; j40=numeric_limits<IkReal>::quiet_NaN(); _ij40[0] = -1; _ij40[1] = -1; _nj40 = -1; j41=numeric_limits<IkReal>::quiet_NaN(); _ij41[0] = -1; _ij41[1] = -1; _nj41 = -1;  _ij37[0] = -1; _ij37[1] = -1; _nj37 = 0; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nj37=pfree[0]; cj37=cos(pfree[0]); sj37=sin(pfree[0]), htj37=tan(pfree[0]*0.5);\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=((-1.0)*r20);\nnew_r01=r21;\nnew_r02=r22;\nnew_px=((-1.0)*pz);\nnew_r10=r10;\nnew_r11=((-1.0)*r11);\nnew_r12=((-1.0)*r12);\nnew_py=py;\nnew_r20=r00;\nnew_r21=((-1.0)*r01);\nnew_r22=((-1.0)*r02);\nnew_pz=((0.1744)+px);\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x54=((1.0)*px);\nIkReal x55=((1.0)*pz);\nIkReal x56=((1.0)*py);\npp=((px*px)+(py*py)+(pz*pz));\nnpx=(((px*r00))+((py*r10))+((pz*r20)));\nnpy=(((px*r01))+((py*r11))+((pz*r21)));\nnpz=(((px*r02))+((py*r12))+((pz*r22)));\nrxp0_0=((((-1.0)*r20*x56))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x55)));\nrxp0_2=((((-1.0)*r10*x54))+((py*r00)));\nrxp1_0=((((-1.0)*r21*x56))+((pz*r11)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x55)));\nrxp1_2=((((-1.0)*r11*x54))+((py*r01)));\nrxp2_0=(((pz*r12))+(((-1.0)*r22*x56)));\nrxp2_1=(((px*r22))+(((-1.0)*r02*x55)));\nrxp2_2=((((-1.0)*r12*x54))+((py*r02)));\n{\nIkReal j38array[2], cj38array[2], sj38array[2];\nbool j38valid[2]={false};\n_nj38 = 2;\ncj38array[0]=((-1.01448798425806)+(((6.1592025754336)*pp)));\nif( cj38array[0] >= -1-IKFAST_SINCOS_THRESH && cj38array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j38valid[0] = j38valid[1] = true;\n    j38array[0] = IKacos(cj38array[0]);\n    sj38array[0] = IKsin(j38array[0]);\n    cj38array[1] = cj38array[0];\n    j38array[1] = -j38array[0];\n    sj38array[1] = -sj38array[0];\n}\nelse if( isnan(cj38array[0]) )\n{\n    // probably any value will work\n    j38valid[0] = true;\n    cj38array[0] = 1; sj38array[0] = 0; j38array[0] = 0;\n}\nfor(int ij38 = 0; ij38 < 2; ++ij38)\n{\nif( !j38valid[ij38] )\n{\n    continue;\n}\n_ij38[0] = ij38; _ij38[1] = -1;\nfor(int iij38 = ij38+1; iij38 < 2; ++iij38)\n{\nif( j38valid[iij38] && IKabs(cj38array[ij38]-cj38array[iij38]) < IKFAST_SOLUTION_THRESH && IKabs(sj38array[ij38]-sj38array[iij38]) < IKFAST_SOLUTION_THRESH )\n{\n    j38valid[iij38]=false; _ij38[1] = iij38; break; \n}\n}\nj38 = j38array[ij38]; cj38 = cj38array[ij38]; sj38 = sj38array[ij38];\n\n{\nIkReal j35eval[2];\nj35eval[0]=((px*px)+(py*py));\nj35eval[1]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j36eval[2];\nj36eval[0]=((IKabs((sj37*sj38)))+(((3.82116927779901)*(IKabs(((0.3102)+(((0.2617)*cj38))))))));\nj36eval[1]=((1.40499940937601)+(cj38*cj38)+(((sj37*sj37)*(sj38*sj38)))+(((2.3706534199465)*cj38)));\nif( IKabs(j36eval[0]) < 0.0000010000000000  || IKabs(j36eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[2];\nIkReal x57=px*px;\nIkReal x58=py*py;\nIkReal x59=cj37*cj37;\nIkReal x60=px*px*px*px;\nIkReal x61=sj37*sj37;\nIkReal x62=sj37*sj37*sj37*sj37;\nIkReal x63=cj37*cj37*cj37*cj37;\nIkReal x64=(px*py);\nIkReal x65=(x57*x58);\nIkReal x66=((2.0)*x59*x61);\nj35eval[0]=(((x60*x66))+((x60*x62))+((x60*x63))+((x62*x65))+((x63*x65))+((x65*x66)));\nj35eval[1]=((IKabs((((x59*x64))+((x61*x64)))))+(IKabs((((x57*x59))+((x57*x61))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j35, j36]\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nIkReal x67=px*px;\nIkReal x68=sj37*sj37;\nIkReal x69=cj37*cj37;\nIkReal x70=(px*py);\nIkReal x71=(((x67*x68))+((x67*x69)));\nIkReal x72=(((x69*x70))+((x68*x70)));\nCheckValue<IkReal> x75 = IKatan2WithCheck(IkReal(x71),x72,IKFAST_ATAN2_MAGTHRESH);\nif(!x75.valid){\ncontinue;\n}\nIkReal x73=((1.0)*(x75.value));\nif((((x71*x71)+(x72*x72))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x76=IKPowWithIntegerCheck(IKabs(IKsqrt(((x71*x71)+(x72*x72)))),-1);\nif(!x76.valid){\ncontinue;\n}\nif( (((0.2617)*cj37*px*sj38*(x76.value))) < -1-IKFAST_SINCOS_THRESH || (((0.2617)*cj37*px*sj38*(x76.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x74=IKasin(((0.2617)*cj37*px*sj38*(x76.value)));\nj35array[0]=((((-1.0)*x73))+x74);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x73))+(((-1.0)*x74)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[2];\nIkReal x77=IKsin(j35);\nIkReal x78=py*py;\nIkReal x79=IKcos(j35);\nIkReal x80=cj37*cj37;\nIkReal x81=sj37*sj37;\nIkReal x82=(px*py);\nIkReal x83=((1.0)*x80);\nIkReal x84=((1.0)*x81);\nIkReal x85=((0.2617)*cj37*sj38);\nevalcond[0]=(((py*x77))+((px*x79))+(((-1.0)*x85)));\nevalcond[1]=(((x79*(((((-1.0)*x82*x83))+(((-1.0)*x82*x84))))))+((py*x85))+((x77*(((((-1.0)*x78*x84))+(((-1.0)*x78*x83)))))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j36eval[3];\nIkReal x86=(sj37*sj38);\nIkReal x87=(px*sj35);\nIkReal x88=((10000.0)*pz);\nIkReal x89=(cj35*py);\nIkReal x90=((2617.0)*cj38);\nj36eval[0]=((((-1.0)*pz*x86))+(((-1.18532670997325)*x89))+(((-1.0)*cj38*x89))+((cj38*x87))+(((1.18532670997325)*x87)));\nj36eval[1]=IKsign((((x87*x90))+(((3102.0)*x87))+(((-3102.0)*x89))+(((-2617.0)*pz*x86))+(((-1.0)*x89*x90))));\nj36eval[2]=((IKabs(((962.2404)+(((684.8689)*(cj38*cj38)))+(((1623.5868)*cj38))+(((-1.0)*pz*x88)))))+(IKabs(((((-684.8689)*cj38*x86))+(((-811.7934)*x86))+(((-1.0)*x88*x89))+((x87*x88))))));\nif( IKabs(j36eval[0]) < 0.0000010000000000  || IKabs(j36eval[1]) < 0.0000010000000000  || IKabs(j36eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j36eval[3];\nIkReal x91=(px*sj35);\nIkReal x92=((6542500.0)*pp);\nIkReal x93=(sj37*sj38);\nIkReal x94=(cj35*py);\nIkReal x95=((15510000.0)*pz);\nIkReal x96=((4058967.0)*cj38);\nj36eval[0]=((((1.18532670997325)*x91))+(((-1.0)*pz*x93))+(((-1.18532670997325)*x94))+(((-1.0)*cj38*x94))+((cj38*x91)));\nj36eval[1]=((IKabs(((((-1.0)*x94*x95))+(((-181470.303875)*x93))+(((-1.0)*x92*x93))+((x91*x95)))))+(IKabs(((215101.59825)+(((-1.0)*pz*x95))+(((181470.303875)*cj38))+((cj38*x92))+(((7755000.0)*pp))))));\nj36eval[2]=IKsign(((((-1.0)*x94*x96))+(((-4811202.0)*x94))+(((-4058967.0)*pz*x93))+(((4811202.0)*x91))+((x91*x96))));\nif( IKabs(j36eval[0]) < 0.0000010000000000  || IKabs(j36eval[1]) < 0.0000010000000000  || IKabs(j36eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j36eval[3];\nIkReal x97=cj37*cj37;\nIkReal x98=cj38*cj38;\nIkReal x99=(px*sj35);\nIkReal x100=((26170000.0)*cj38);\nIkReal x101=(cj35*py);\nIkReal x102=((26170000.0)*sj37*sj38);\nIkReal x103=(x97*x98);\nj36eval[0]=((-2.40499940937601)+x97+(((-1.0)*x103))+(((-2.3706534199465)*cj38)));\nj36eval[1]=IKsign(((-16471093.0)+(((6848689.0)*x97))+(((-6848689.0)*x103))+(((-16235868.0)*cj38))));\nj36eval[2]=((IKabs(((((-1.0)*pz*x100))+(((-1.0)*x101*x102))+((x102*x99))+(((-31020000.0)*pz)))))+(IKabs(((((-1.0)*pz*x102))+(((31020000.0)*x101))+(((-1.0)*x100*x99))+(((-31020000.0)*x99))+((x100*x101))))));\nif( IKabs(j36eval[0]) < 0.0000010000000000  || IKabs(j36eval[1]) < 0.0000010000000000  || IKabs(j36eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j36]\n\n} else\n{\n{\nIkReal j36array[1], cj36array[1], sj36array[1];\nbool j36valid[1]={false};\n_nj36 = 1;\nIkReal x104=cj37*cj37;\nIkReal x105=(cj35*py);\nIkReal x106=(px*sj35);\nIkReal x107=((26170000.0)*cj38);\nIkReal x108=((6848689.0)*x104);\nIkReal x109=((26170000.0)*sj37*sj38);\nCheckValue<IkReal> x110 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x107))+((x106*x109))+(((-31020000.0)*pz))+(((-1.0)*x105*x109)))),((((-1.0)*pz*x109))+(((31020000.0)*x105))+(((-1.0)*x106*x107))+((x105*x107))+(((-31020000.0)*x106))),IKFAST_ATAN2_MAGTHRESH);\nif(!x110.valid){\ncontinue;\n}\nCheckValue<IkReal> x111=IKPowWithIntegerCheck(IKsign(((-16471093.0)+(((-1.0)*x108*(cj38*cj38)))+x108+(((-16235868.0)*cj38)))),-1);\nif(!x111.valid){\ncontinue;\n}\nj36array[0]=((-1.5707963267949)+(x110.value)+(((1.5707963267949)*(x111.value))));\nsj36array[0]=IKsin(j36array[0]);\ncj36array[0]=IKcos(j36array[0]);\nif( j36array[0] > IKPI )\n{\n    j36array[0]-=IK2PI;\n}\nelse if( j36array[0] < -IKPI )\n{    j36array[0]+=IK2PI;\n}\nj36valid[0] = true;\nfor(int ij36 = 0; ij36 < 1; ++ij36)\n{\nif( !j36valid[ij36] )\n{\n    continue;\n}\n_ij36[0] = ij36; _ij36[1] = -1;\nfor(int iij36 = ij36+1; iij36 < 1; ++iij36)\n{\nif( j36valid[iij36] && IKabs(cj36array[ij36]-cj36array[iij36]) < IKFAST_SOLUTION_THRESH && IKabs(sj36array[ij36]-sj36array[iij36]) < IKFAST_SOLUTION_THRESH )\n{\n    j36valid[iij36]=false; _ij36[1] = iij36; break; \n}\n}\nj36 = j36array[ij36]; cj36 = cj36array[ij36]; sj36 = sj36array[ij36];\n{\nIkReal evalcond[6];\nIkReal x112=IKsin(j36);\nIkReal x113=IKcos(j36);\nIkReal x114=((0.2617)*sj38);\nIkReal x115=((0.2617)*cj38);\nIkReal x116=((1.0)*pz);\nIkReal x117=(py*sj35);\nIkReal x118=((1.0)*cj37);\nIkReal x119=(px*sj35);\nIkReal x120=(cj35*py);\nIkReal x121=(cj35*px);\nIkReal x122=(sj37*x113);\nIkReal x123=(pz*x112);\nIkReal x124=((0.6204)*x113);\nIkReal x125=(sj37*x112);\nevalcond[0]=(((x112*x115))+((x114*x122))+(((-1.0)*x116))+(((0.3102)*x112)));\nevalcond[1]=((-0.3102)+((x113*x119))+(((-1.0)*x115))+x123+(((-1.0)*x113*x120)));\nevalcond[2]=((-0.02773715)+(((-1.0)*x120*x124))+(((-1.0)*pp))+(((0.6204)*x123))+((x119*x124)));\nevalcond[3]=((((-1.0)*x113*x115))+((x114*x125))+(((-0.3102)*x113))+x119+(((-1.0)*x120)));\nevalcond[4]=(((sj37*x117))+(((-1.0)*x112*x118*x120))+((sj37*x121))+(((-1.0)*cj37*x113*x116))+((cj37*x112*x119)));\nevalcond[5]=((((-1.0)*x118*x121))+(((-1.0)*x117*x118))+(((-1.0)*x116*x122))+x114+(((-1.0)*x120*x125))+((x119*x125)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j36array[1], cj36array[1], sj36array[1];\nbool j36valid[1]={false};\n_nj36 = 1;\nIkReal x564=(cj35*py);\nIkReal x565=((4058967.0)*cj38);\nIkReal x566=((6542500.0)*pp);\nIkReal x567=(px*sj35);\nIkReal x568=((15510000.0)*pz);\nIkReal x569=(sj37*sj38);\nCheckValue<IkReal> x570=IKPowWithIntegerCheck(IKsign(((((4811202.0)*x567))+(((-1.0)*x564*x565))+((x565*x567))+(((-4058967.0)*pz*x569))+(((-4811202.0)*x564)))),-1);\nif(!x570.valid){\ncontinue;\n}\nCheckValue<IkReal> x571 = IKatan2WithCheck(IkReal(((((-1.0)*x564*x568))+(((-181470.303875)*x569))+(((-1.0)*x566*x569))+((x567*x568)))),((215101.59825)+(((181470.303875)*cj38))+(((-1.0)*pz*x568))+((cj38*x566))+(((7755000.0)*pp))),IKFAST_ATAN2_MAGTHRESH);\nif(!x571.valid){\ncontinue;\n}\nj36array[0]=((-1.5707963267949)+(((1.5707963267949)*(x570.value)))+(x571.value));\nsj36array[0]=IKsin(j36array[0]);\ncj36array[0]=IKcos(j36array[0]);\nif( j36array[0] > IKPI )\n{\n    j36array[0]-=IK2PI;\n}\nelse if( j36array[0] < -IKPI )\n{    j36array[0]+=IK2PI;\n}\nj36valid[0] = true;\nfor(int ij36 = 0; ij36 < 1; ++ij36)\n{\nif( !j36valid[ij36] )\n{\n    continue;\n}\n_ij36[0] = ij36; _ij36[1] = -1;\nfor(int iij36 = ij36+1; iij36 < 1; ++iij36)\n{\nif( j36valid[iij36] && IKabs(cj36array[ij36]-cj36array[iij36]) < IKFAST_SOLUTION_THRESH && IKabs(sj36array[ij36]-sj36array[iij36]) < IKFAST_SOLUTION_THRESH )\n{\n    j36valid[iij36]=false; _ij36[1] = iij36; break; \n}\n}\nj36 = j36array[ij36]; cj36 = cj36array[ij36]; sj36 = sj36array[ij36];\n{\nIkReal evalcond[6];\nIkReal x572=IKsin(j36);\nIkReal x573=IKcos(j36);\nIkReal x574=((0.2617)*sj38);\nIkReal x575=((0.2617)*cj38);\nIkReal x576=((1.0)*pz);\nIkReal x577=(py*sj35);\nIkReal x578=((1.0)*cj37);\nIkReal x579=(px*sj35);\nIkReal x580=(cj35*py);\nIkReal x581=(cj35*px);\nIkReal x582=(sj37*x573);\nIkReal x583=(pz*x572);\nIkReal x584=((0.6204)*x573);\nIkReal x585=(sj37*x572);\nevalcond[0]=((((0.3102)*x572))+((x574*x582))+(((-1.0)*x576))+((x572*x575)));\nevalcond[1]=((-0.3102)+((x573*x579))+(((-1.0)*x575))+x583+(((-1.0)*x573*x580)));\nevalcond[2]=((-0.02773715)+(((-1.0)*x580*x584))+((x579*x584))+(((-1.0)*pp))+(((0.6204)*x583)));\nevalcond[3]=((((-1.0)*x580))+(((-1.0)*x573*x575))+((x574*x585))+x579+(((-0.3102)*x573)));\nevalcond[4]=(((cj37*x572*x579))+((sj37*x577))+(((-1.0)*cj37*x573*x576))+((sj37*x581))+(((-1.0)*x572*x578*x580)));\nevalcond[5]=(((x579*x585))+(((-1.0)*x580*x585))+(((-1.0)*x578*x581))+(((-1.0)*x577*x578))+x574+(((-1.0)*x576*x582)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j36array[1], cj36array[1], sj36array[1];\nbool j36valid[1]={false};\n_nj36 = 1;\nIkReal x586=(sj37*sj38);\nIkReal x587=(cj35*py);\nIkReal x588=((10000.0)*pz);\nIkReal x589=(px*sj35);\nIkReal x590=((2617.0)*cj38);\nCheckValue<IkReal> x591=IKPowWithIntegerCheck(IKsign(((((3102.0)*x589))+(((-1.0)*x587*x590))+(((-2617.0)*pz*x586))+(((-3102.0)*x587))+((x589*x590)))),-1);\nif(!x591.valid){\ncontinue;\n}\nCheckValue<IkReal> x592 = IKatan2WithCheck(IkReal(((((-811.7934)*x586))+((x588*x589))+(((-1.0)*x587*x588))+(((-684.8689)*cj38*x586)))),((962.2404)+(((-1.0)*pz*x588))+(((684.8689)*(cj38*cj38)))+(((1623.5868)*cj38))),IKFAST_ATAN2_MAGTHRESH);\nif(!x592.valid){\ncontinue;\n}\nj36array[0]=((-1.5707963267949)+(((1.5707963267949)*(x591.value)))+(x592.value));\nsj36array[0]=IKsin(j36array[0]);\ncj36array[0]=IKcos(j36array[0]);\nif( j36array[0] > IKPI )\n{\n    j36array[0]-=IK2PI;\n}\nelse if( j36array[0] < -IKPI )\n{    j36array[0]+=IK2PI;\n}\nj36valid[0] = true;\nfor(int ij36 = 0; ij36 < 1; ++ij36)\n{\nif( !j36valid[ij36] )\n{\n    continue;\n}\n_ij36[0] = ij36; _ij36[1] = -1;\nfor(int iij36 = ij36+1; iij36 < 1; ++iij36)\n{\nif( j36valid[iij36] && IKabs(cj36array[ij36]-cj36array[iij36]) < IKFAST_SOLUTION_THRESH && IKabs(sj36array[ij36]-sj36array[iij36]) < IKFAST_SOLUTION_THRESH )\n{\n    j36valid[iij36]=false; _ij36[1] = iij36; break; \n}\n}\nj36 = j36array[ij36]; cj36 = cj36array[ij36]; sj36 = sj36array[ij36];\n{\nIkReal evalcond[6];\nIkReal x593=IKsin(j36);\nIkReal x594=IKcos(j36);\nIkReal x595=((0.2617)*sj38);\nIkReal x596=((0.2617)*cj38);\nIkReal x597=((1.0)*pz);\nIkReal x598=(py*sj35);\nIkReal x599=((1.0)*cj37);\nIkReal x600=(px*sj35);\nIkReal x601=(cj35*py);\nIkReal x602=(cj35*px);\nIkReal x603=(sj37*x594);\nIkReal x604=(pz*x593);\nIkReal x605=((0.6204)*x594);\nIkReal x606=(sj37*x593);\nevalcond[0]=(((x595*x603))+(((-1.0)*x597))+((x593*x596))+(((0.3102)*x593)));\nevalcond[1]=((-0.3102)+((x594*x600))+(((-1.0)*x594*x601))+(((-1.0)*x596))+x604);\nevalcond[2]=((-0.02773715)+(((0.6204)*x604))+((x600*x605))+(((-1.0)*pp))+(((-1.0)*x601*x605)));\nevalcond[3]=(((x595*x606))+(((-1.0)*x601))+(((-1.0)*x594*x596))+x600+(((-0.3102)*x594)));\nevalcond[4]=((((-1.0)*cj37*x594*x597))+((sj37*x598))+(((-1.0)*x593*x599*x601))+((cj37*x593*x600))+((sj37*x602)));\nevalcond[5]=((((-1.0)*x598*x599))+(((-1.0)*x601*x606))+(((-1.0)*x597*x603))+((x600*x606))+(((-1.0)*x599*x602))+x595);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j36array[2], cj36array[2], sj36array[2];\nbool j36valid[2]={false};\n_nj36 = 2;\nIkReal x607=((0.3102)+(((0.2617)*cj38)));\nCheckValue<IkReal> x610 = IKatan2WithCheck(IkReal(((0.2617)*sj37*sj38)),x607,IKFAST_ATAN2_MAGTHRESH);\nif(!x610.valid){\ncontinue;\n}\nIkReal x608=((1.0)*(x610.value));\nif((((x607*x607)+(((0.06848689)*(sj37*sj37)*(sj38*sj38))))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x611=IKPowWithIntegerCheck(IKabs(IKsqrt(((x607*x607)+(((0.06848689)*(sj37*sj37)*(sj38*sj38)))))),-1);\nif(!x611.valid){\ncontinue;\n}\nif( ((pz*(x611.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x611.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x609=IKasin((pz*(x611.value)));\nj36array[0]=(x609+(((-1.0)*x608)));\nsj36array[0]=IKsin(j36array[0]);\ncj36array[0]=IKcos(j36array[0]);\nj36array[1]=((3.14159265358979)+(((-1.0)*x609))+(((-1.0)*x608)));\nsj36array[1]=IKsin(j36array[1]);\ncj36array[1]=IKcos(j36array[1]);\nif( j36array[0] > IKPI )\n{\n    j36array[0]-=IK2PI;\n}\nelse if( j36array[0] < -IKPI )\n{    j36array[0]+=IK2PI;\n}\nj36valid[0] = true;\nif( j36array[1] > IKPI )\n{\n    j36array[1]-=IK2PI;\n}\nelse if( j36array[1] < -IKPI )\n{    j36array[1]+=IK2PI;\n}\nj36valid[1] = true;\nfor(int ij36 = 0; ij36 < 2; ++ij36)\n{\nif( !j36valid[ij36] )\n{\n    continue;\n}\n_ij36[0] = ij36; _ij36[1] = -1;\nfor(int iij36 = ij36+1; iij36 < 2; ++iij36)\n{\nif( j36valid[iij36] && IKabs(cj36array[ij36]-cj36array[iij36]) < IKFAST_SOLUTION_THRESH && IKabs(sj36array[ij36]-sj36array[iij36]) < IKFAST_SOLUTION_THRESH )\n{\n    j36valid[iij36]=false; _ij36[1] = iij36; break; \n}\n}\nj36 = j36array[ij36]; cj36 = cj36array[ij36]; sj36 = sj36array[ij36];\n\n{\nIkReal j35eval[3];\nIkReal x612=pz*pz;\nIkReal x613=((2617.0)*py);\nIkReal x614=((10000.0)*cj36);\nIkReal x615=((2617.0)*px);\nIkReal x616=(cj36*cj37*sj38);\nIkReal x617=((10000.0)*pz*sj36);\nj35eval[0]=(((cj36*pp))+(((-1.0)*cj36*x612)));\nj35eval[1]=((IKabs((((py*x617))+(((-3102.0)*py))+((x615*x616))+(((-1.0)*cj38*x613)))))+(IKabs((((cj38*x615))+(((3102.0)*px))+((x613*x616))+(((-1.0)*px*x617))))));\nj35eval[2]=IKsign(((((-1.0)*x612*x614))+((pp*x614))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[3];\nIkReal x618=pz*pz;\nIkReal x619=((25000000.0)*pp);\nIkReal x620=(cj36*pp);\nIkReal x621=((15510000.0)*pz*sj36);\nIkReal x622=(cj36*x618);\nIkReal x623=((4058967.0)*cj36*cj37*sj38);\nj35eval[0]=(x620+(((-1.0)*x622)));\nj35eval[1]=IKsign(((((15510000.0)*x620))+(((-15510000.0)*x622))));\nj35eval[2]=((IKabs((((py*x621))+(((-693428.75)*py))+(((-1.0)*py*x619))+((px*x623)))))+(IKabs((((py*x623))+((px*x619))+(((693428.75)*px))+(((-1.0)*px*x621))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[3];\nIkReal x624=pz*pz;\nIkReal x625=((3102.0)*cj36);\nIkReal x626=(sj36*sj37);\nIkReal x627=((2617.0)*py*sj38);\nIkReal x628=((2617.0)*px*sj38);\nIkReal x629=((2617.0)*cj36*cj38);\nj35eval[0]=(pp+(((-1.0)*x624)));\nj35eval[1]=((IKabs((((cj37*x628))+(((-1.0)*py*x625))+(((-1.0)*py*x629))+((x626*x627)))))+(IKabs(((((-1.0)*x626*x628))+((cj37*x627))+((px*x625))+((px*x629))))));\nj35eval[2]=IKsign(((((10000.0)*pp))+(((-10000.0)*x624))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x630=((0.2617)*cj38);\nIkReal x631=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j36)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((0.16235868)*cj38))+(((-1.0)*x631)));\nevalcond[2]=((0.3102)+(((-1.0)*pz))+x630);\nevalcond[3]=((-0.3102)+(((-1.0)*x630))+pz);\nevalcond[4]=((-0.02773715)+(((-1.0)*x631))+(((0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[3];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nIkReal x632=pz*pz;\nIkReal x633=(sj37*sj38);\nIkReal x634=(cj37*sj38);\nj35eval[0]=(pp+(((-1.0)*x632)));\nj35eval[1]=IKsign(((((10000.0)*pp))+(((-10000.0)*x632))));\nj35eval[2]=((IKabs((((py*x634))+(((-1.0)*px*x633)))))+(IKabs((((py*x633))+((px*x634))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[3];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nIkReal x635=pz*pz;\nIkReal x636=cj37*cj37;\nIkReal x637=((10000.0)*cj37);\nIkReal x638=((1.0)*cj37);\nIkReal x639=(sj37*sj38);\nIkReal x640=((1.0)*sj38*x636);\nj35eval[0]=((((-1.0)*pp*x638))+((cj37*x635)));\nj35eval[1]=IKsign(((((-1.0)*pp*x637))+((x635*x637))));\nj35eval[2]=((IKabs(((((-1.0)*px*x640))+(((-1.0)*py*x638*x639)))))+(IKabs((((cj37*px*x639))+(((-1.0)*py*x640))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[3];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nIkReal x641=cj37*cj37;\nIkReal x642=pz*pz;\nIkReal x643=((1.0)*sj37);\nIkReal x644=(px*sj38);\nIkReal x645=(py*sj38);\nIkReal x646=(sj37*x642);\nj35eval[0]=((((-1.0)*pp*x643))+x646);\nj35eval[1]=((IKabs(((((-1.0)*x645))+((x641*x645))+(((-1.0)*cj37*x643*x644)))))+(IKabs(((((-1.0)*x641*x644))+x644+(((-1.0)*cj37*x643*x645))))));\nj35eval[2]=IKsign(((((-10000.0)*pp*sj37))+(((10000.0)*x646))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x647=((0.2617)*cj38);\nIkReal x648=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j37))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((0.16235868)*cj38))+(((-1.0)*x648)));\nevalcond[2]=((0.3102)+(((-1.0)*pz))+x647);\nevalcond[3]=((-0.3102)+(((-1.0)*x647))+pz);\nevalcond[4]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x648)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[4];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj37=0;\ncj37=1.0;\nj37=0;\nIkReal x649=pz*pz;\nj35eval[0]=((((-1.0)*x649))+pp);\nj35eval[1]=IKsign(((((-10000.0)*x649))+(((10000.0)*pp))));\nj35eval[2]=6848689.0;\nj35eval[3]=sj38;\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  || IKabs(j35eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x650=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j38))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x650)));\nevalcond[2]=((0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x650)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj37=0;\ncj37=1.0;\nj37=0;\nsj38=0;\ncj38=1.0;\nj38=0;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x652 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x652.valid){\ncontinue;\n}\nIkReal x651=x652.value;\nj35array[0]=((-1.0)*x651);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x651)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x653=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j38)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x653)));\nevalcond[2]=((0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x653)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj37=0;\ncj37=1.0;\nj37=0;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x655 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x655.valid){\ncontinue;\n}\nIkReal x654=x655.value;\nj35array[0]=((-1.0)*x654);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x654)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j35]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nIkReal x656=((2617.0)*sj38);\nCheckValue<IkReal> x657 = IKatan2WithCheck(IkReal((py*x656)),(px*x656),IKFAST_ATAN2_MAGTHRESH);\nif(!x657.valid){\ncontinue;\n}\nCheckValue<IkReal> x658=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x658.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(x657.value)+(((1.5707963267949)*(x658.value))));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[2];\nIkReal x659=IKcos(j35);\nIkReal x660=IKsin(j35);\nevalcond[0]=((((-1.0)*py*x659))+((px*x660)));\nevalcond[1]=((((-0.2617)*sj38))+((py*x660))+((px*x659)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x661=((0.2617)*cj38);\nIkReal x662=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j37)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((0.16235868)*cj38))+(((-1.0)*x662)));\nevalcond[2]=((0.3102)+(((-1.0)*pz))+x661);\nevalcond[3]=((-0.3102)+(((-1.0)*x661))+pz);\nevalcond[4]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x662)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[4];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj37=0;\ncj37=-1.0;\nj37=3.14159265358979;\nIkReal x663=pz*pz;\nj35eval[0]=((((-1.0)*pp))+x663);\nj35eval[1]=6848689.0;\nj35eval[2]=sj38;\nj35eval[3]=IKsign(((((-10000.0)*pp))+(((10000.0)*x663))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  || IKabs(j35eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x664=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j38))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x664)));\nevalcond[2]=((0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x664)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj37=0;\ncj37=-1.0;\nj37=3.14159265358979;\nsj38=0;\ncj38=1.0;\nj38=0;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x666 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x666.valid){\ncontinue;\n}\nIkReal x665=x666.value;\nj35array[0]=((-1.0)*x665);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x665)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x667=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j38)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x667)));\nevalcond[2]=((0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x667)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj37=0;\ncj37=-1.0;\nj37=3.14159265358979;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x669 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x669.valid){\ncontinue;\n}\nIkReal x668=x669.value;\nj35array[0]=((-1.0)*x668);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x668)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j35]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nIkReal x670=((2617.0)*sj38);\nCheckValue<IkReal> x671 = IKatan2WithCheck(IkReal((py*x670)),(px*x670),IKFAST_ATAN2_MAGTHRESH);\nif(!x671.valid){\ncontinue;\n}\nCheckValue<IkReal> x672=IKPowWithIntegerCheck(IKsign(((((10000.0)*(pz*pz)))+(((-10000.0)*pp)))),-1);\nif(!x672.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(x671.value)+(((1.5707963267949)*(x672.value))));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[2];\nIkReal x673=IKcos(j35);\nIkReal x674=IKsin(j35);\nevalcond[0]=((((-1.0)*py*x673))+((px*x674)));\nevalcond[1]=(((py*x674))+(((0.2617)*sj38))+((px*x673)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x675=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j38))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x675)));\nevalcond[2]=((0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x675)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj38=0;\ncj38=1.0;\nj38=0;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj38=0;\ncj38=1.0;\nj38=0;\nj35eval[0]=((IKabs((((px*sj37))+(((-1.0)*cj37*py)))))+(IKabs((((py*sj37))+((cj37*px))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj38=0;\ncj38=1.0;\nj38=0;\nIkReal x676=((1.0)*py);\nj35eval[0]=((IKabs((((px*sj37))+(((-1.0)*cj37*x676)))))+(IKabs(((((-1.0)*cj37*px))+(((-1.0)*sj37*x676))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j35]\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nIkReal x677=((1.0)*cj37);\nCheckValue<IkReal> x679 = IKatan2WithCheck(IkReal(((((-1.0)*px*x677))+(((-1.0)*py*sj37)))),((((-1.0)*py*x677))+((px*sj37))),IKFAST_ATAN2_MAGTHRESH);\nif(!x679.valid){\ncontinue;\n}\nIkReal x678=x679.value;\nj35array[0]=((-1.0)*x678);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x678)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[3];\nIkReal x680=IKsin(j35);\nIkReal x681=IKcos(j35);\nIkReal x682=(py*x680);\nIkReal x683=(px*x681);\nIkReal x684=(px*x680);\nIkReal x685=((1.0)*py*x681);\nevalcond[0]=(x683+x682);\nevalcond[1]=((((-1.0)*x685))+x684);\nevalcond[2]=(((sj37*x682))+((sj37*x683))+((cj37*x684))+(((-1.0)*cj37*x685)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x687 = IKatan2WithCheck(IkReal((((px*sj37))+(((-1.0)*cj37*py)))),(((py*sj37))+((cj37*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x687.valid){\ncontinue;\n}\nIkReal x686=x687.value;\nj35array[0]=((-1.0)*x686);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x686)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[3];\nIkReal x688=IKsin(j35);\nIkReal x689=IKcos(j35);\nIkReal x690=((1.0)*cj37);\nIkReal x691=(px*x689);\nIkReal x692=(py*x688);\nIkReal x693=(px*x688);\nIkReal x694=((1.0)*py*x689);\nevalcond[0]=(x691+x692);\nevalcond[1]=(x693+(((-1.0)*x694)));\nevalcond[2]=(((sj37*x693))+(((-1.0)*sj37*x694))+(((-1.0)*x690*x691))+(((-1.0)*x690*x692)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x696 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x696.valid){\ncontinue;\n}\nIkReal x695=x696.value;\nj35array[0]=((-1.0)*x695);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x695)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[3];\nIkReal x697=IKcos(j35);\nIkReal x698=IKsin(j35);\nIkReal x699=(py*sj37);\nIkReal x700=(px*x698);\nIkReal x701=((1.0)*x697);\nIkReal x702=(py*x701);\nevalcond[0]=((((-1.0)*x702))+x700);\nevalcond[1]=(((cj37*x700))+((px*sj37*x697))+(((-1.0)*cj37*x702))+((x698*x699)));\nevalcond[2]=((((-1.0)*cj37*px*x701))+((sj37*x700))+(((-1.0)*x699*x701))+(((-1.0)*cj37*py*x698)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x703=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j38)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x703)));\nevalcond[2]=((0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x703)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nj35eval[0]=((IKabs((((px*sj37))+(((-1.0)*cj37*py)))))+(IKabs((((py*sj37))+((cj37*px))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nIkReal x704=((1.0)*py);\nj35eval[0]=((IKabs(((((-1.0)*sj37*x704))+(((-1.0)*cj37*px)))))+(IKabs((((px*sj37))+(((-1.0)*cj37*x704))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j35]\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nIkReal x705=((1.0)*cj37);\nCheckValue<IkReal> x707 = IKatan2WithCheck(IkReal(((((-1.0)*px*x705))+(((-1.0)*py*sj37)))),((((-1.0)*py*x705))+((px*sj37))),IKFAST_ATAN2_MAGTHRESH);\nif(!x707.valid){\ncontinue;\n}\nIkReal x706=x707.value;\nj35array[0]=((-1.0)*x706);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x706)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[3];\nIkReal x708=IKsin(j35);\nIkReal x709=IKcos(j35);\nIkReal x710=(py*x708);\nIkReal x711=(px*x709);\nIkReal x712=(px*x708);\nIkReal x713=((1.0)*py*x709);\nevalcond[0]=(x711+x710);\nevalcond[1]=((((-1.0)*x713))+x712);\nevalcond[2]=(((sj37*x711))+((sj37*x710))+(((-1.0)*cj37*x713))+((cj37*x712)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x715 = IKatan2WithCheck(IkReal((((px*sj37))+(((-1.0)*cj37*py)))),(((py*sj37))+((cj37*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x715.valid){\ncontinue;\n}\nIkReal x714=x715.value;\nj35array[0]=((-1.0)*x714);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x714)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[3];\nIkReal x716=IKsin(j35);\nIkReal x717=IKcos(j35);\nIkReal x718=((1.0)*cj37);\nIkReal x719=(px*x717);\nIkReal x720=(py*x716);\nIkReal x721=(px*x716);\nIkReal x722=((1.0)*py*x717);\nevalcond[0]=(x719+x720);\nevalcond[1]=((((-1.0)*x722))+x721);\nevalcond[2]=(((sj37*x721))+(((-1.0)*x718*x719))+(((-1.0)*sj37*x722))+(((-1.0)*x718*x720)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x724 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x724.valid){\ncontinue;\n}\nIkReal x723=x724.value;\nj35array[0]=((-1.0)*x723);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x723)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[3];\nIkReal x725=IKcos(j35);\nIkReal x726=IKsin(j35);\nIkReal x727=(py*sj37);\nIkReal x728=(px*x726);\nIkReal x729=((1.0)*x725);\nIkReal x730=(py*x729);\nevalcond[0]=((((-1.0)*x730))+x728);\nevalcond[1]=(((px*sj37*x725))+(((-1.0)*cj37*x730))+((x726*x727))+((cj37*x728)));\nevalcond[2]=((((-1.0)*x727*x729))+(((-1.0)*cj37*py*x726))+((sj37*x728))+(((-1.0)*cj37*px*x729)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x731=((0.2617)*cj38);\nIkReal x732=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j37)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((0.16235868)*cj38))+(((-1.0)*x732)));\nevalcond[2]=((0.3102)+(((-1.0)*pz))+x731);\nevalcond[3]=((-0.3102)+(((-1.0)*x731))+pz);\nevalcond[4]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x732)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[4];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj37=1.0;\ncj37=0;\nj37=1.5707963267949;\nIkReal x733=pz*pz;\nj35eval[0]=((((-1.0)*pp))+x733);\nj35eval[1]=6848689.0;\nj35eval[2]=sj38;\nj35eval[3]=IKsign(((((-10000.0)*pp))+(((10000.0)*x733))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  || IKabs(j35eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x734=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j38))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x734)));\nevalcond[2]=((0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x734)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj37=1.0;\ncj37=0;\nj37=1.5707963267949;\nsj38=0;\ncj38=1.0;\nj38=0;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x736 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x736.valid){\ncontinue;\n}\nIkReal x735=x736.value;\nj35array[0]=((-1.0)*x735);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x735)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x737=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j38)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x737)));\nevalcond[2]=((0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x737)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj37=1.0;\ncj37=0;\nj37=1.5707963267949;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x739 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x739.valid){\ncontinue;\n}\nIkReal x738=x739.value;\nj35array[0]=((-1.0)*x738);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x738)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j35]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nCheckValue<IkReal> x740=IKPowWithIntegerCheck(IKsign(((((10000.0)*(pz*pz)))+(((-10000.0)*pp)))),-1);\nif(!x740.valid){\ncontinue;\n}\nCheckValue<IkReal> x741 = IKatan2WithCheck(IkReal(((2617.0)*px*sj38)),((-2617.0)*py*sj38),IKFAST_ATAN2_MAGTHRESH);\nif(!x741.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(((1.5707963267949)*(x740.value)))+(x741.value));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[2];\nIkReal x742=IKsin(j35);\nIkReal x743=IKcos(j35);\nevalcond[0]=(((py*x742))+((px*x743)));\nevalcond[1]=((((-1.0)*py*x743))+((px*x742))+(((0.2617)*sj38)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x744=((0.2617)*cj38);\nIkReal x745=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j37)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((0.16235868)*cj38))+(((-1.0)*x745)));\nevalcond[2]=((0.3102)+(((-1.0)*pz))+x744);\nevalcond[3]=((-0.3102)+pz+(((-1.0)*x744)));\nevalcond[4]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x745)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[4];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj37=-1.0;\ncj37=0;\nj37=-1.5707963267949;\nIkReal x746=pz*pz;\nj35eval[0]=(pp+(((-1.0)*x746)));\nj35eval[1]=IKsign(((((10000.0)*pp))+(((-10000.0)*x746))));\nj35eval[2]=6848689.0;\nj35eval[3]=sj38;\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  || IKabs(j35eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x747=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j38))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x747)));\nevalcond[2]=((0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x747)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj37=-1.0;\ncj37=0;\nj37=-1.5707963267949;\nsj38=0;\ncj38=1.0;\nj38=0;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x749 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x749.valid){\ncontinue;\n}\nIkReal x748=x749.value;\nj35array[0]=((-1.0)*x748);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x748)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x750=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j38)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x750)));\nevalcond[2]=((0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((0.6204)*pz))+(((-1.0)*x750)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=1.0;\ncj36=0;\nj36=1.5707963267949;\nsj37=-1.0;\ncj37=0;\nj37=-1.5707963267949;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x752 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x752.valid){\ncontinue;\n}\nIkReal x751=x752.value;\nj35array[0]=((-1.0)*x751);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x751)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j35]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nCheckValue<IkReal> x753 = IKatan2WithCheck(IkReal(((2617.0)*px*sj38)),((-2617.0)*py*sj38),IKFAST_ATAN2_MAGTHRESH);\nif(!x753.valid){\ncontinue;\n}\nCheckValue<IkReal> x754=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x754.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(x753.value)+(((1.5707963267949)*(x754.value))));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[2];\nIkReal x755=IKsin(j35);\nIkReal x756=IKcos(j35);\nevalcond[0]=(((py*x755))+((px*x756)));\nevalcond[1]=(((px*x755))+(((-0.2617)*sj38))+(((-1.0)*py*x756)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j35]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nIkReal x757=cj37*cj37;\nIkReal x758=(cj37*sj37);\nIkReal x759=((10000.0)*sj37);\nIkReal x760=((2617.0)*py*sj38);\nIkReal x761=((2617.0)*px*sj38);\nCheckValue<IkReal> x762=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp*x759))+((x759*(pz*pz))))),-1);\nif(!x762.valid){\ncontinue;\n}\nCheckValue<IkReal> x763 = IKatan2WithCheck(IkReal(((((-1.0)*x758*x760))+(((-1.0)*x757*x761))+x761)),(((x757*x760))+(((-1.0)*x758*x761))+(((-1.0)*x760))),IKFAST_ATAN2_MAGTHRESH);\nif(!x763.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(((1.5707963267949)*(x762.value)))+(x763.value));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[4];\nIkReal x764=IKsin(j35);\nIkReal x765=IKcos(j35);\nIkReal x766=((0.2617)*sj38);\nIkReal x767=((1.0)*cj37);\nIkReal x768=(py*x764);\nIkReal x769=(px*x765);\nIkReal x770=(px*x764);\nIkReal x771=((1.0)*py*x765);\nevalcond[0]=((((-1.0)*cj37*x766))+x768+x769);\nevalcond[1]=(((sj37*x766))+x770+(((-1.0)*x771)));\nevalcond[2]=((((-1.0)*py*x765*x767))+((sj37*x769))+((sj37*x768))+((cj37*x770)));\nevalcond[3]=(((sj37*x770))+(((-1.0)*x767*x769))+(((-1.0)*x767*x768))+(((-1.0)*sj37*x771))+x766);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nIkReal x772=cj37*cj37;\nIkReal x773=((10000.0)*cj37);\nIkReal x774=(cj37*sj37);\nIkReal x775=((2617.0)*py*sj38);\nIkReal x776=((2617.0)*px*sj38);\nCheckValue<IkReal> x777 = IKatan2WithCheck(IkReal((((x774*x776))+(((-1.0)*x772*x775)))),((((-1.0)*x774*x775))+(((-1.0)*x772*x776))),IKFAST_ATAN2_MAGTHRESH);\nif(!x777.valid){\ncontinue;\n}\nCheckValue<IkReal> x778=IKPowWithIntegerCheck(IKsign((((x773*(pz*pz)))+(((-1.0)*pp*x773)))),-1);\nif(!x778.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(x777.value)+(((1.5707963267949)*(x778.value))));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[4];\nIkReal x779=IKsin(j35);\nIkReal x780=IKcos(j35);\nIkReal x781=((0.2617)*sj38);\nIkReal x782=((1.0)*cj37);\nIkReal x783=(py*x779);\nIkReal x784=(px*x780);\nIkReal x785=(px*x779);\nIkReal x786=((1.0)*py*x780);\nevalcond[0]=((((-1.0)*cj37*x781))+x783+x784);\nevalcond[1]=((((-1.0)*x786))+((sj37*x781))+x785);\nevalcond[2]=(((cj37*x785))+(((-1.0)*py*x780*x782))+((sj37*x784))+((sj37*x783)));\nevalcond[3]=((((-1.0)*x782*x784))+(((-1.0)*x782*x783))+(((-1.0)*sj37*x786))+((sj37*x785))+x781);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nIkReal x787=((2617.0)*sj38);\nCheckValue<IkReal> x788 = IKatan2WithCheck(IkReal((((cj37*py*x787))+(((-1.0)*px*sj37*x787)))),(((cj37*px*x787))+((py*sj37*x787))),IKFAST_ATAN2_MAGTHRESH);\nif(!x788.valid){\ncontinue;\n}\nCheckValue<IkReal> x789=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x789.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(x788.value)+(((1.5707963267949)*(x789.value))));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[4];\nIkReal x790=IKsin(j35);\nIkReal x791=IKcos(j35);\nIkReal x792=((0.2617)*sj38);\nIkReal x793=((1.0)*cj37);\nIkReal x794=(py*x790);\nIkReal x795=(px*x791);\nIkReal x796=(px*x790);\nIkReal x797=((1.0)*py*x791);\nevalcond[0]=((((-1.0)*cj37*x792))+x795+x794);\nevalcond[1]=((((-1.0)*x797))+((sj37*x792))+x796);\nevalcond[2]=(((cj37*x796))+((sj37*x795))+((sj37*x794))+(((-1.0)*py*x791*x793)));\nevalcond[3]=((((-1.0)*x793*x794))+(((-1.0)*x793*x795))+(((-1.0)*sj37*x797))+((sj37*x796))+x792);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x798=((1.0)*pp);\nIkReal x799=((-0.3102)+(((-1.0)*pz))+(((-0.2617)*cj38)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j36)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((-1.0)*x798))+(((0.16235868)*cj38)));\nevalcond[2]=x799;\nevalcond[3]=x799;\nevalcond[4]=((-0.02773715)+(((-1.0)*x798))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[3];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nIkReal x800=pz*pz;\nIkReal x801=(cj37*sj38);\nIkReal x802=(sj37*sj38);\nj35eval[0]=((((-1.0)*x800))+pp);\nj35eval[1]=IKsign(((((-10000.0)*x800))+(((10000.0)*pp))));\nj35eval[2]=((IKabs((((px*x802))+((py*x801)))))+(IKabs(((((-1.0)*py*x802))+((px*x801))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[3];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nIkReal x803=pz*pz;\nIkReal x804=cj37*cj37;\nIkReal x805=(cj37*pp);\nIkReal x806=((1.0)*cj37);\nIkReal x807=(sj37*sj38);\nIkReal x808=(sj38*x804);\nj35eval[0]=((((-1.0)*x803*x806))+x805);\nj35eval[1]=IKsign(((((-10000.0)*cj37*x803))+(((10000.0)*x805))));\nj35eval[2]=((IKabs((((cj37*px*x807))+((py*x808)))))+(IKabs((((px*x808))+(((-1.0)*py*x806*x807))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[3];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nIkReal x809=cj37*cj37;\nIkReal x810=pz*pz;\nIkReal x811=(pp*sj37);\nIkReal x812=(px*sj38);\nIkReal x813=(py*sj38);\nIkReal x814=(cj37*sj37);\nIkReal x815=(sj37*x810);\nj35eval[0]=((((-1.0)*x815))+x811);\nj35eval[1]=((IKabs((((x813*x814))+(((-1.0)*x809*x812))+x812)))+(IKabs((((x809*x813))+((x812*x814))+(((-1.0)*x813))))));\nj35eval[2]=IKsign(((((10000.0)*x811))+(((-10000.0)*x815))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x816=((1.0)*pp);\nIkReal x817=x799;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j37))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((0.16235868)*cj38))+(((-1.0)*x816)));\nevalcond[2]=x817;\nevalcond[3]=x817;\nevalcond[4]=((-0.02773715)+(((-1.0)*x816))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[4];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj37=0;\ncj37=1.0;\nj37=0;\nIkReal x818=pz*pz;\nj35eval[0]=((((-1.0)*x818))+pp);\nj35eval[1]=IKsign(((((10000.0)*pp))+(((-10000.0)*x818))));\nj35eval[2]=6848689.0;\nj35eval[3]=sj38;\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  || IKabs(j35eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x819=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j38))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x819)));\nevalcond[2]=((-0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x819))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj37=0;\ncj37=1.0;\nj37=0;\nsj38=0;\ncj38=1.0;\nj38=0;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x821 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x821.valid){\ncontinue;\n}\nIkReal x820=x821.value;\nj35array[0]=((-1.0)*x820);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x820)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x822=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j38)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x822)));\nevalcond[2]=((-0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x822))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj37=0;\ncj37=1.0;\nj37=0;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x824 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x824.valid){\ncontinue;\n}\nIkReal x823=x824.value;\nj35array[0]=((-1.0)*x823);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x823)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j35]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nIkReal x825=((2617.0)*sj38);\nCheckValue<IkReal> x826 = IKatan2WithCheck(IkReal((py*x825)),(px*x825),IKFAST_ATAN2_MAGTHRESH);\nif(!x826.valid){\ncontinue;\n}\nCheckValue<IkReal> x827=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x827.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(x826.value)+(((1.5707963267949)*(x827.value))));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[2];\nIkReal x828=IKcos(j35);\nIkReal x829=IKsin(j35);\nevalcond[0]=(((px*x829))+(((-1.0)*py*x828)));\nevalcond[1]=(((py*x829))+((px*x828))+(((-0.2617)*sj38)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x830=((1.0)*pp);\nIkReal x831=x799;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j37)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((0.16235868)*cj38))+(((-1.0)*x830)));\nevalcond[2]=x831;\nevalcond[3]=x831;\nevalcond[4]=((-0.02773715)+(((-1.0)*x830))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[4];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj37=0;\ncj37=-1.0;\nj37=3.14159265358979;\nIkReal x832=pz*pz;\nj35eval[0]=((((-1.0)*pp))+x832);\nj35eval[1]=6848689.0;\nj35eval[2]=sj38;\nj35eval[3]=IKsign(((((10000.0)*x832))+(((-10000.0)*pp))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  || IKabs(j35eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x833=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j38))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x833)));\nevalcond[2]=((-0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x833))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj37=0;\ncj37=-1.0;\nj37=3.14159265358979;\nsj38=0;\ncj38=1.0;\nj38=0;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x835 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x835.valid){\ncontinue;\n}\nIkReal x834=x835.value;\nj35array[0]=((-1.0)*x834);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x834)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x836=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j38)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x836)));\nevalcond[2]=((-0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x836))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj37=0;\ncj37=-1.0;\nj37=3.14159265358979;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x838 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x838.valid){\ncontinue;\n}\nIkReal x837=x838.value;\nj35array[0]=((-1.0)*x837);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x837)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j35]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nIkReal x839=((2617.0)*sj38);\nCheckValue<IkReal> x840=IKPowWithIntegerCheck(IKsign(((((10000.0)*(pz*pz)))+(((-10000.0)*pp)))),-1);\nif(!x840.valid){\ncontinue;\n}\nCheckValue<IkReal> x841 = IKatan2WithCheck(IkReal((py*x839)),(px*x839),IKFAST_ATAN2_MAGTHRESH);\nif(!x841.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(((1.5707963267949)*(x840.value)))+(x841.value));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[2];\nIkReal x842=IKcos(j35);\nIkReal x843=IKsin(j35);\nevalcond[0]=((((-1.0)*py*x842))+((px*x843)));\nevalcond[1]=(((py*x843))+(((0.2617)*sj38))+((px*x842)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x844=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j38))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x844)));\nevalcond[2]=((-0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x844))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj38=0;\ncj38=1.0;\nj38=0;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj38=0;\ncj38=1.0;\nj38=0;\nj35eval[0]=((IKabs((((py*sj37))+(((-1.0)*cj37*px)))))+(IKabs((((px*sj37))+((cj37*py))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj38=0;\ncj38=1.0;\nj38=0;\nIkReal x845=((1.0)*cj37);\nj35eval[0]=((IKabs(((((-1.0)*py*x845))+(((-1.0)*px*sj37)))))+(IKabs((((py*sj37))+(((-1.0)*px*x845))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j35]\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nIkReal x846=((1.0)*cj37);\nCheckValue<IkReal> x848 = IKatan2WithCheck(IkReal((((py*sj37))+(((-1.0)*px*x846)))),((((-1.0)*py*x846))+(((-1.0)*px*sj37))),IKFAST_ATAN2_MAGTHRESH);\nif(!x848.valid){\ncontinue;\n}\nIkReal x847=x848.value;\nj35array[0]=((-1.0)*x847);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x847)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[3];\nIkReal x849=IKsin(j35);\nIkReal x850=IKcos(j35);\nIkReal x851=(py*x849);\nIkReal x852=(px*x850);\nIkReal x853=(px*x849);\nIkReal x854=(py*x850);\nevalcond[0]=(x852+x851);\nevalcond[1]=((((-1.0)*x854))+x853);\nevalcond[2]=(((sj37*x851))+((sj37*x852))+((cj37*x854))+(((-1.0)*cj37*x853)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x856 = IKatan2WithCheck(IkReal((((px*sj37))+((cj37*py)))),(((py*sj37))+(((-1.0)*cj37*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x856.valid){\ncontinue;\n}\nIkReal x855=x856.value;\nj35array[0]=((-1.0)*x855);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x855)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[3];\nIkReal x857=IKsin(j35);\nIkReal x858=IKcos(j35);\nIkReal x859=((1.0)*cj37);\nIkReal x860=(px*x858);\nIkReal x861=(py*x857);\nIkReal x862=(py*x858);\nIkReal x863=(px*x857);\nevalcond[0]=(x861+x860);\nevalcond[1]=((((-1.0)*x862))+x863);\nevalcond[2]=(((sj37*x862))+(((-1.0)*sj37*x863))+(((-1.0)*x859*x860))+(((-1.0)*x859*x861)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x865 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x865.valid){\ncontinue;\n}\nIkReal x864=x865.value;\nj35array[0]=((-1.0)*x864);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x864)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[3];\nIkReal x866=IKcos(j35);\nIkReal x867=IKsin(j35);\nIkReal x868=(py*sj37);\nIkReal x869=((1.0)*py);\nIkReal x870=(px*x866);\nIkReal x871=((1.0)*px*x867);\nevalcond[0]=((((-1.0)*x866*x869))+((px*x867)));\nevalcond[1]=(((x867*x868))+((cj37*py*x866))+((sj37*x870))+(((-1.0)*cj37*x871)));\nevalcond[2]=((((-1.0)*cj37*x867*x869))+(((-1.0)*sj37*x871))+((x866*x868))+(((-1.0)*cj37*x870)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x872=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j38)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x872)));\nevalcond[2]=((-0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-0.6204)*pz))+(((-1.0)*x872)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nj35eval[0]=((IKabs((((py*sj37))+(((-1.0)*cj37*px)))))+(IKabs((((px*sj37))+((cj37*py))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nIkReal x873=((1.0)*cj37);\nj35eval[0]=((IKabs((((py*sj37))+(((-1.0)*px*x873)))))+(IKabs(((((-1.0)*px*sj37))+(((-1.0)*py*x873))))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j35]\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nIkReal x874=((1.0)*cj37);\nCheckValue<IkReal> x876 = IKatan2WithCheck(IkReal((((py*sj37))+(((-1.0)*px*x874)))),((((-1.0)*px*sj37))+(((-1.0)*py*x874))),IKFAST_ATAN2_MAGTHRESH);\nif(!x876.valid){\ncontinue;\n}\nIkReal x875=x876.value;\nj35array[0]=((-1.0)*x875);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x875)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[3];\nIkReal x877=IKsin(j35);\nIkReal x878=IKcos(j35);\nIkReal x879=(py*x877);\nIkReal x880=(px*x878);\nIkReal x881=(px*x877);\nIkReal x882=(py*x878);\nevalcond[0]=(x879+x880);\nevalcond[1]=((((-1.0)*x882))+x881);\nevalcond[2]=(((sj37*x880))+(((-1.0)*cj37*x881))+((cj37*x882))+((sj37*x879)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x884 = IKatan2WithCheck(IkReal((((px*sj37))+((cj37*py)))),(((py*sj37))+(((-1.0)*cj37*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x884.valid){\ncontinue;\n}\nIkReal x883=x884.value;\nj35array[0]=((-1.0)*x883);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x883)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[3];\nIkReal x885=IKsin(j35);\nIkReal x886=IKcos(j35);\nIkReal x887=((1.0)*cj37);\nIkReal x888=(px*x886);\nIkReal x889=(py*x885);\nIkReal x890=(py*x886);\nIkReal x891=(px*x885);\nevalcond[0]=(x889+x888);\nevalcond[1]=((((-1.0)*x890))+x891);\nevalcond[2]=((((-1.0)*x887*x889))+(((-1.0)*x887*x888))+((sj37*x890))+(((-1.0)*sj37*x891)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x893 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x893.valid){\ncontinue;\n}\nIkReal x892=x893.value;\nj35array[0]=((-1.0)*x892);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x892)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[3];\nIkReal x894=IKcos(j35);\nIkReal x895=IKsin(j35);\nIkReal x896=(py*sj37);\nIkReal x897=((1.0)*py);\nIkReal x898=(px*x894);\nIkReal x899=((1.0)*px*x895);\nevalcond[0]=(((px*x895))+(((-1.0)*x894*x897)));\nevalcond[1]=(((sj37*x898))+(((-1.0)*cj37*x899))+((x895*x896))+((cj37*py*x894)));\nevalcond[2]=((((-1.0)*sj37*x899))+(((-1.0)*cj37*x898))+((x894*x896))+(((-1.0)*cj37*x895*x897)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x900=((1.0)*pp);\nIkReal x901=x799;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j37)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((-1.0)*x900))+(((0.16235868)*cj38)));\nevalcond[2]=x901;\nevalcond[3]=x901;\nevalcond[4]=((-0.02773715)+(((-1.0)*x900))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[4];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj37=1.0;\ncj37=0;\nj37=1.5707963267949;\nIkReal x902=pz*pz;\nj35eval[0]=(pp+(((-1.0)*x902)));\nj35eval[1]=IKsign(((((-10000.0)*x902))+(((10000.0)*pp))));\nj35eval[2]=6848689.0;\nj35eval[3]=sj38;\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  || IKabs(j35eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x903=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j38))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x903)));\nevalcond[2]=((-0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x903))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj37=1.0;\ncj37=0;\nj37=1.5707963267949;\nsj38=0;\ncj38=1.0;\nj38=0;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x905 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x905.valid){\ncontinue;\n}\nIkReal x904=x905.value;\nj35array[0]=((-1.0)*x904);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x904)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x906=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j38)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x906)));\nevalcond[2]=((-0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x906))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj37=1.0;\ncj37=0;\nj37=1.5707963267949;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x908 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x908.valid){\ncontinue;\n}\nIkReal x907=x908.value;\nj35array[0]=((-1.0)*x907);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x907)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j35]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nCheckValue<IkReal> x909 = IKatan2WithCheck(IkReal(((2617.0)*px*sj38)),((-2617.0)*py*sj38),IKFAST_ATAN2_MAGTHRESH);\nif(!x909.valid){\ncontinue;\n}\nCheckValue<IkReal> x910=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x910.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(x909.value)+(((1.5707963267949)*(x910.value))));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[2];\nIkReal x911=IKsin(j35);\nIkReal x912=IKcos(j35);\nevalcond[0]=(((px*x912))+((py*x911)));\nevalcond[1]=(((px*x911))+(((-0.2617)*sj38))+(((-1.0)*py*x912)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x913=((1.0)*pp);\nIkReal x914=x799;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j37)))), 6.28318530717959)));\nevalcond[1]=((0.16471093)+(((0.16235868)*cj38))+(((-1.0)*x913)));\nevalcond[2]=x914;\nevalcond[3]=x914;\nevalcond[4]=((-0.02773715)+(((-1.0)*x913))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[4];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj37=-1.0;\ncj37=0;\nj37=-1.5707963267949;\nIkReal x915=pz*pz;\nj35eval[0]=((((-1.0)*pp))+x915);\nj35eval[1]=6848689.0;\nj35eval[2]=sj38;\nj35eval[3]=IKsign(((((-10000.0)*pp))+(((10000.0)*x915))));\nif( IKabs(j35eval[0]) < 0.0000010000000000  || IKabs(j35eval[1]) < 0.0000010000000000  || IKabs(j35eval[2]) < 0.0000010000000000  || IKabs(j35eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x916=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j38))), 6.28318530717959)));\nevalcond[1]=((0.32706961)+(((-1.0)*x916)));\nevalcond[2]=((-0.5719)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x916))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj37=-1.0;\ncj37=0;\nj37=-1.5707963267949;\nsj38=0;\ncj38=1.0;\nj38=0;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x918 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x918.valid){\ncontinue;\n}\nIkReal x917=x918.value;\nj35array[0]=((-1.0)*x917);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x917)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x919=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j38)))), 6.28318530717959)));\nevalcond[1]=((0.00235225)+(((-1.0)*x919)));\nevalcond[2]=((-0.0485)+(((-1.0)*pz)));\nevalcond[3]=((-0.02773715)+(((-1.0)*x919))+(((-0.6204)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j35eval[1];\nsj36=-1.0;\ncj36=0;\nj36=-1.5707963267949;\nsj37=-1.0;\ncj37=0;\nj37=-1.5707963267949;\nsj38=0;\ncj38=-1.0;\nj38=3.14159265358979;\nj35eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j35eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x921 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x921.valid){\ncontinue;\n}\nIkReal x920=x921.value;\nj35array[0]=((-1.0)*x920);\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x920)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[1];\nevalcond[0]=(((px*(IKsin(j35))))+(((-1.0)*py*(IKcos(j35)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j35]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nCheckValue<IkReal> x922=IKPowWithIntegerCheck(IKsign(((((10000.0)*(pz*pz)))+(((-10000.0)*pp)))),-1);\nif(!x922.valid){\ncontinue;\n}\nCheckValue<IkReal> x923 = IKatan2WithCheck(IkReal(((2617.0)*px*sj38)),((-2617.0)*py*sj38),IKFAST_ATAN2_MAGTHRESH);\nif(!x923.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(((1.5707963267949)*(x922.value)))+(x923.value));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[2];\nIkReal x924=IKsin(j35);\nIkReal x925=IKcos(j35);\nevalcond[0]=(((py*x924))+((px*x925)));\nevalcond[1]=((((0.2617)*sj38))+(((-1.0)*py*x925))+((px*x924)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j35]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nIkReal x926=cj37*cj37;\nIkReal x927=(cj37*sj37);\nIkReal x928=((10000.0)*sj37);\nIkReal x929=((2617.0)*py*sj38);\nIkReal x930=((2617.0)*px*sj38);\nCheckValue<IkReal> x931=IKPowWithIntegerCheck(IKsign((((pp*x928))+(((-1.0)*x928*(pz*pz))))),-1);\nif(!x931.valid){\ncontinue;\n}\nCheckValue<IkReal> x932 = IKatan2WithCheck(IkReal((((x927*x929))+(((-1.0)*x926*x930))+x930)),((((-1.0)*x929))+((x927*x930))+((x926*x929))),IKFAST_ATAN2_MAGTHRESH);\nif(!x932.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(((1.5707963267949)*(x931.value)))+(x932.value));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[4];\nIkReal x933=IKsin(j35);\nIkReal x934=IKcos(j35);\nIkReal x935=((0.2617)*sj38);\nIkReal x936=((1.0)*cj37);\nIkReal x937=(py*x933);\nIkReal x938=(px*x934);\nIkReal x939=(py*x934);\nIkReal x940=((1.0)*px*x933);\nevalcond[0]=((((-1.0)*cj37*x935))+x938+x937);\nevalcond[1]=((((-1.0)*sj37*x935))+(((-1.0)*x939))+((px*x933)));\nevalcond[2]=(((cj37*x939))+(((-1.0)*px*x933*x936))+((sj37*x938))+((sj37*x937)));\nevalcond[3]=(((sj37*x939))+(((-1.0)*sj37*x940))+(((-1.0)*x936*x938))+(((-1.0)*x936*x937))+x935);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nIkReal x941=cj37*cj37;\nIkReal x942=((10000.0)*cj37);\nIkReal x943=(cj37*sj37);\nIkReal x944=((2617.0)*py*sj38);\nIkReal x945=((2617.0)*px*sj38);\nCheckValue<IkReal> x946=IKPowWithIntegerCheck(IKsign((((pp*x942))+(((-1.0)*x942*(pz*pz))))),-1);\nif(!x946.valid){\ncontinue;\n}\nCheckValue<IkReal> x947 = IKatan2WithCheck(IkReal((((x941*x944))+((x943*x945)))),(((x941*x945))+(((-1.0)*x943*x944))),IKFAST_ATAN2_MAGTHRESH);\nif(!x947.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(((1.5707963267949)*(x946.value)))+(x947.value));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[4];\nIkReal x948=IKsin(j35);\nIkReal x949=IKcos(j35);\nIkReal x950=((0.2617)*sj38);\nIkReal x951=((1.0)*cj37);\nIkReal x952=(py*x948);\nIkReal x953=(px*x949);\nIkReal x954=(py*x949);\nIkReal x955=((1.0)*px*x948);\nevalcond[0]=((((-1.0)*cj37*x950))+x953+x952);\nevalcond[1]=((((-1.0)*x954))+(((-1.0)*sj37*x950))+((px*x948)));\nevalcond[2]=(((cj37*x954))+((sj37*x952))+((sj37*x953))+(((-1.0)*px*x948*x951)));\nevalcond[3]=(((sj37*x954))+(((-1.0)*sj37*x955))+(((-1.0)*x951*x953))+(((-1.0)*x951*x952))+x950);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nIkReal x956=((2617.0)*sj38);\nCheckValue<IkReal> x957 = IKatan2WithCheck(IkReal((((px*sj37*x956))+((cj37*py*x956)))),((((-1.0)*py*sj37*x956))+((cj37*px*x956))),IKFAST_ATAN2_MAGTHRESH);\nif(!x957.valid){\ncontinue;\n}\nCheckValue<IkReal> x958=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x958.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(x957.value)+(((1.5707963267949)*(x958.value))));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[4];\nIkReal x959=IKsin(j35);\nIkReal x960=IKcos(j35);\nIkReal x961=((0.2617)*sj38);\nIkReal x962=((1.0)*cj37);\nIkReal x963=(py*x959);\nIkReal x964=(px*x960);\nIkReal x965=(py*x960);\nIkReal x966=((1.0)*px*x959);\nevalcond[0]=((((-1.0)*cj37*x961))+x963+x964);\nevalcond[1]=(((px*x959))+(((-1.0)*x965))+(((-1.0)*sj37*x961)));\nevalcond[2]=((((-1.0)*px*x959*x962))+((sj37*x964))+((sj37*x963))+((cj37*x965)));\nevalcond[3]=((((-1.0)*x962*x964))+(((-1.0)*x962*x963))+((sj37*x965))+(((-1.0)*sj37*x966))+x961);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j35]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nIkReal x967=((3102.0)*cj36);\nIkReal x968=(sj36*sj37);\nIkReal x969=((2617.0)*py*sj38);\nIkReal x970=((2617.0)*px*sj38);\nIkReal x971=((2617.0)*cj36*cj38);\nCheckValue<IkReal> x972 = IKatan2WithCheck(IkReal((((px*x967))+((px*x971))+(((-1.0)*x968*x970))+((cj37*x969)))),((((-1.0)*py*x967))+((cj37*x970))+(((-1.0)*py*x971))+((x968*x969))),IKFAST_ATAN2_MAGTHRESH);\nif(!x972.valid){\ncontinue;\n}\nCheckValue<IkReal> x973=IKPowWithIntegerCheck(IKsign(((((-10000.0)*(pz*pz)))+(((10000.0)*pp)))),-1);\nif(!x973.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(x972.value)+(((1.5707963267949)*(x973.value))));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[6];\nIkReal x974=IKsin(j35);\nIkReal x975=IKcos(j35);\nIkReal x976=((0.2617)*sj38);\nIkReal x977=((0.2617)*cj38);\nIkReal x978=((1.0)*cj36);\nIkReal x979=(px*sj36);\nIkReal x980=((1.0)*cj37);\nIkReal x981=(sj36*sj37);\nIkReal x982=(pz*sj36);\nIkReal x983=(py*x975);\nIkReal x984=(cj37*x974);\nIkReal x985=(px*x975);\nIkReal x986=(py*x974);\nIkReal x987=(cj36*px*x974);\nevalcond[0]=((((-1.0)*cj37*x976))+x985+x986);\nevalcond[1]=((-0.3102)+(((-1.0)*x978*x983))+x987+x982+(((-1.0)*x977)));\nevalcond[2]=((-0.02773715)+(((0.6204)*x982))+(((0.6204)*x987))+(((-0.6204)*cj36*x983))+(((-1.0)*pp)));\nevalcond[3]=((((-1.0)*x983))+(((-0.3102)*cj36))+((x976*x981))+(((-1.0)*cj36*x977))+((px*x974)));\nevalcond[4]=(((sj37*x986))+((sj37*x985))+((x979*x984))+(((-1.0)*cj37*pz*x978))+(((-1.0)*sj36*x980*x983)));\nevalcond[5]=(((sj37*x974*x979))+(((-1.0)*x980*x986))+(((-1.0)*x980*x985))+x976+(((-1.0)*x981*x983))+(((-1.0)*pz*sj37*x978)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nIkReal x988=((25000000.0)*pp);\nIkReal x989=((15510000.0)*cj36);\nIkReal x990=((15510000.0)*pz*sj36);\nIkReal x991=((4058967.0)*cj36*cj37*sj38);\nCheckValue<IkReal> x992 = IKatan2WithCheck(IkReal(((((-1.0)*px*x990))+((py*x991))+(((693428.75)*px))+((px*x988)))),(((py*x990))+(((-1.0)*py*x988))+((px*x991))+(((-693428.75)*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x992.valid){\ncontinue;\n}\nCheckValue<IkReal> x993=IKPowWithIntegerCheck(IKsign(((((-1.0)*x989*(pz*pz)))+((pp*x989)))),-1);\nif(!x993.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(x992.value)+(((1.5707963267949)*(x993.value))));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[6];\nIkReal x994=IKsin(j35);\nIkReal x995=IKcos(j35);\nIkReal x996=((0.2617)*sj38);\nIkReal x997=((0.2617)*cj38);\nIkReal x998=((1.0)*cj36);\nIkReal x999=(px*sj36);\nIkReal x1000=((1.0)*cj37);\nIkReal x1001=(sj36*sj37);\nIkReal x1002=(pz*sj36);\nIkReal x1003=(py*x995);\nIkReal x1004=(cj37*x994);\nIkReal x1005=(px*x995);\nIkReal x1006=(py*x994);\nIkReal x1007=(cj36*px*x994);\nevalcond[0]=(x1006+x1005+(((-1.0)*cj37*x996)));\nevalcond[1]=((-0.3102)+x1007+x1002+(((-1.0)*x1003*x998))+(((-1.0)*x997)));\nevalcond[2]=((-0.02773715)+(((-0.6204)*cj36*x1003))+(((0.6204)*x1007))+(((0.6204)*x1002))+(((-1.0)*pp)));\nevalcond[3]=((((-1.0)*x1003))+((px*x994))+(((-0.3102)*cj36))+((x1001*x996))+(((-1.0)*cj36*x997)));\nevalcond[4]=((((-1.0)*cj37*pz*x998))+((sj37*x1006))+((sj37*x1005))+(((-1.0)*sj36*x1000*x1003))+((x1004*x999)));\nevalcond[5]=((((-1.0)*x1001*x1003))+(((-1.0)*pz*sj37*x998))+((sj37*x994*x999))+(((-1.0)*x1000*x1006))+(((-1.0)*x1000*x1005))+x996);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[1], cj35array[1], sj35array[1];\nbool j35valid[1]={false};\n_nj35 = 1;\nIkReal x1008=((2617.0)*py);\nIkReal x1009=((10000.0)*cj36);\nIkReal x1010=((2617.0)*px);\nIkReal x1011=((10000.0)*pz*sj36);\nIkReal x1012=(cj36*cj37*sj38);\nCheckValue<IkReal> x1013 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1011))+(((3102.0)*px))+((cj38*x1010))+((x1008*x1012)))),((((-3102.0)*py))+((py*x1011))+(((-1.0)*cj38*x1008))+((x1010*x1012))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1013.valid){\ncontinue;\n}\nCheckValue<IkReal> x1014=IKPowWithIntegerCheck(IKsign((((pp*x1009))+(((-1.0)*x1009*(pz*pz))))),-1);\nif(!x1014.valid){\ncontinue;\n}\nj35array[0]=((-1.5707963267949)+(x1013.value)+(((1.5707963267949)*(x1014.value))));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nfor(int ij35 = 0; ij35 < 1; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 1; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n{\nIkReal evalcond[6];\nIkReal x1015=IKsin(j35);\nIkReal x1016=IKcos(j35);\nIkReal x1017=((0.2617)*sj38);\nIkReal x1018=((0.2617)*cj38);\nIkReal x1019=((1.0)*cj36);\nIkReal x1020=(px*sj36);\nIkReal x1021=((1.0)*cj37);\nIkReal x1022=(sj36*sj37);\nIkReal x1023=(pz*sj36);\nIkReal x1024=(py*x1016);\nIkReal x1025=(cj37*x1015);\nIkReal x1026=(px*x1016);\nIkReal x1027=(py*x1015);\nIkReal x1028=(cj36*px*x1015);\nevalcond[0]=((((-1.0)*cj37*x1017))+x1027+x1026);\nevalcond[1]=((-0.3102)+x1023+x1028+(((-1.0)*x1018))+(((-1.0)*x1019*x1024)));\nevalcond[2]=((-0.02773715)+(((0.6204)*x1023))+(((0.6204)*x1028))+(((-1.0)*pp))+(((-0.6204)*cj36*x1024)));\nevalcond[3]=(((x1017*x1022))+(((-1.0)*cj36*x1018))+(((-1.0)*x1024))+(((-0.3102)*cj36))+((px*x1015)));\nevalcond[4]=(((sj37*x1027))+((sj37*x1026))+(((-1.0)*sj36*x1021*x1024))+(((-1.0)*cj37*pz*x1019))+((x1020*x1025)));\nevalcond[5]=(((sj37*x1015*x1020))+(((-1.0)*pz*sj37*x1019))+x1017+(((-1.0)*x1021*x1027))+(((-1.0)*x1021*x1026))+(((-1.0)*x1022*x1024)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j35array[2], cj35array[2], sj35array[2];\nbool j35valid[2]={false};\n_nj35 = 2;\nCheckValue<IkReal> x1031 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1031.valid){\ncontinue;\n}\nIkReal x1029=((1.0)*(x1031.value));\nif((((px*px)+(py*py))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x1032=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);\nif(!x1032.valid){\ncontinue;\n}\nif( (((0.2617)*cj37*sj38*(x1032.value))) < -1-IKFAST_SINCOS_THRESH || (((0.2617)*cj37*sj38*(x1032.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x1030=IKasin(((0.2617)*cj37*sj38*(x1032.value)));\nj35array[0]=(x1030+(((-1.0)*x1029)));\nsj35array[0]=IKsin(j35array[0]);\ncj35array[0]=IKcos(j35array[0]);\nj35array[1]=((3.14159265358979)+(((-1.0)*x1030))+(((-1.0)*x1029)));\nsj35array[1]=IKsin(j35array[1]);\ncj35array[1]=IKcos(j35array[1]);\nif( j35array[0] > IKPI )\n{\n    j35array[0]-=IK2PI;\n}\nelse if( j35array[0] < -IKPI )\n{    j35array[0]+=IK2PI;\n}\nj35valid[0] = true;\nif( j35array[1] > IKPI )\n{\n    j35array[1]-=IK2PI;\n}\nelse if( j35array[1] < -IKPI )\n{    j35array[1]+=IK2PI;\n}\nj35valid[1] = true;\nfor(int ij35 = 0; ij35 < 2; ++ij35)\n{\nif( !j35valid[ij35] )\n{\n    continue;\n}\n_ij35[0] = ij35; _ij35[1] = -1;\nfor(int iij35 = ij35+1; iij35 < 2; ++iij35)\n{\nif( j35valid[iij35] && IKabs(cj35array[ij35]-cj35array[iij35]) < IKFAST_SOLUTION_THRESH && IKabs(sj35array[ij35]-sj35array[iij35]) < IKFAST_SOLUTION_THRESH )\n{\n    j35valid[iij35]=false; _ij35[1] = iij35; break; \n}\n}\nj35 = j35array[ij35]; cj35 = cj35array[ij35]; sj35 = sj35array[ij35];\n\n{\nIkReal j36eval[3];\nIkReal x1033=(sj37*sj38);\nIkReal x1034=(px*sj35);\nIkReal x1035=((10000.0)*pz);\nIkReal x1036=(cj35*py);\nIkReal x1037=((2617.0)*cj38);\nj36eval[0]=((((1.18532670997325)*x1034))+(((-1.18532670997325)*x1036))+(((-1.0)*pz*x1033))+(((-1.0)*cj38*x1036))+((cj38*x1034)));\nj36eval[1]=IKsign(((((-3102.0)*x1036))+(((-1.0)*x1036*x1037))+(((3102.0)*x1034))+(((-2617.0)*pz*x1033))+((x1034*x1037))));\nj36eval[2]=((IKabs(((962.2404)+(((-1.0)*pz*x1035))+(((684.8689)*(cj38*cj38)))+(((1623.5868)*cj38)))))+(IKabs(((((-1.0)*x1035*x1036))+(((-684.8689)*cj38*x1033))+((x1034*x1035))+(((-811.7934)*x1033))))));\nif( IKabs(j36eval[0]) < 0.0000010000000000  || IKabs(j36eval[1]) < 0.0000010000000000  || IKabs(j36eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j36eval[3];\nIkReal x1038=(px*sj35);\nIkReal x1039=((6542500.0)*pp);\nIkReal x1040=(sj37*sj38);\nIkReal x1041=(cj35*py);\nIkReal x1042=((15510000.0)*pz);\nIkReal x1043=((4058967.0)*cj38);\nj36eval[0]=((((-1.0)*pz*x1040))+(((1.18532670997325)*x1038))+(((-1.0)*cj38*x1041))+(((-1.18532670997325)*x1041))+((cj38*x1038)));\nj36eval[1]=((IKabs(((215101.59825)+(((181470.303875)*cj38))+(((-1.0)*pz*x1042))+(((7755000.0)*pp))+((cj38*x1039)))))+(IKabs((((x1038*x1042))+(((-1.0)*x1039*x1040))+(((-1.0)*x1041*x1042))+(((-181470.303875)*x1040))))));\nj36eval[2]=IKsign((((x1038*x1043))+(((-4811202.0)*x1041))+(((-1.0)*x1041*x1043))+(((-4058967.0)*pz*x1040))+(((4811202.0)*x1038))));\nif( IKabs(j36eval[0]) < 0.0000010000000000  || IKabs(j36eval[1]) < 0.0000010000000000  || IKabs(j36eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j36eval[3];\nIkReal x1044=cj37*cj37;\nIkReal x1045=cj38*cj38;\nIkReal x1046=(px*sj35);\nIkReal x1047=((26170000.0)*cj38);\nIkReal x1048=(cj35*py);\nIkReal x1049=((26170000.0)*sj37*sj38);\nIkReal x1050=(x1044*x1045);\nj36eval[0]=((-2.40499940937601)+x1044+(((-1.0)*x1050))+(((-2.3706534199465)*cj38)));\nj36eval[1]=IKsign(((-16471093.0)+(((6848689.0)*x1044))+(((-16235868.0)*cj38))+(((-6848689.0)*x1050))));\nj36eval[2]=((IKabs(((((-1.0)*x1046*x1047))+(((-31020000.0)*x1046))+(((31020000.0)*x1048))+(((-1.0)*pz*x1049))+((x1047*x1048)))))+(IKabs(((((-31020000.0)*pz))+(((-1.0)*pz*x1047))+(((-1.0)*x1048*x1049))+((x1046*x1049))))));\nif( IKabs(j36eval[0]) < 0.0000010000000000  || IKabs(j36eval[1]) < 0.0000010000000000  || IKabs(j36eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j36]\n\n} else\n{\n{\nIkReal j36array[1], cj36array[1], sj36array[1];\nbool j36valid[1]={false};\n_nj36 = 1;\nIkReal x1051=cj37*cj37;\nIkReal x1052=(cj35*py);\nIkReal x1053=(px*sj35);\nIkReal x1054=((26170000.0)*cj38);\nIkReal x1055=((6848689.0)*x1051);\nIkReal x1056=((26170000.0)*sj37*sj38);\nCheckValue<IkReal> x1057=IKPowWithIntegerCheck(IKsign(((-16471093.0)+x1055+(((-16235868.0)*cj38))+(((-1.0)*x1055*(cj38*cj38))))),-1);\nif(!x1057.valid){\ncontinue;\n}\nCheckValue<IkReal> x1058 = IKatan2WithCheck(IkReal(((((-1.0)*x1052*x1056))+((x1053*x1056))+(((-1.0)*pz*x1054))+(((-31020000.0)*pz)))),((((31020000.0)*x1052))+(((-31020000.0)*x1053))+((x1052*x1054))+(((-1.0)*pz*x1056))+(((-1.0)*x1053*x1054))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1058.valid){\ncontinue;\n}\nj36array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1057.value)))+(x1058.value));\nsj36array[0]=IKsin(j36array[0]);\ncj36array[0]=IKcos(j36array[0]);\nif( j36array[0] > IKPI )\n{\n    j36array[0]-=IK2PI;\n}\nelse if( j36array[0] < -IKPI )\n{    j36array[0]+=IK2PI;\n}\nj36valid[0] = true;\nfor(int ij36 = 0; ij36 < 1; ++ij36)\n{\nif( !j36valid[ij36] )\n{\n    continue;\n}\n_ij36[0] = ij36; _ij36[1] = -1;\nfor(int iij36 = ij36+1; iij36 < 1; ++iij36)\n{\nif( j36valid[iij36] && IKabs(cj36array[ij36]-cj36array[iij36]) < IKFAST_SOLUTION_THRESH && IKabs(sj36array[ij36]-sj36array[iij36]) < IKFAST_SOLUTION_THRESH )\n{\n    j36valid[iij36]=false; _ij36[1] = iij36; break; \n}\n}\nj36 = j36array[ij36]; cj36 = cj36array[ij36]; sj36 = sj36array[ij36];\n{\nIkReal evalcond[6];\nIkReal x1059=IKsin(j36);\nIkReal x1060=IKcos(j36);\nIkReal x1061=((0.2617)*sj38);\nIkReal x1062=((0.2617)*cj38);\nIkReal x1063=((1.0)*pz);\nIkReal x1064=(py*sj35);\nIkReal x1065=((1.0)*cj37);\nIkReal x1066=(px*sj35);\nIkReal x1067=(cj35*py);\nIkReal x1068=(cj35*px);\nIkReal x1069=(sj37*x1060);\nIkReal x1070=(pz*x1059);\nIkReal x1071=((0.6204)*x1060);\nIkReal x1072=(sj37*x1059);\nevalcond[0]=(((x1061*x1069))+(((0.3102)*x1059))+((x1059*x1062))+(((-1.0)*x1063)));\nevalcond[1]=((-0.3102)+x1070+((x1060*x1066))+(((-1.0)*x1060*x1067))+(((-1.0)*x1062)));\nevalcond[2]=((-0.02773715)+((x1066*x1071))+(((-1.0)*pp))+(((-1.0)*x1067*x1071))+(((0.6204)*x1070)));\nevalcond[3]=((((-1.0)*x1060*x1062))+x1066+((x1061*x1072))+(((-0.3102)*x1060))+(((-1.0)*x1067)));\nevalcond[4]=((((-1.0)*cj37*x1060*x1063))+((sj37*x1064))+((sj37*x1068))+((cj37*x1059*x1066))+(((-1.0)*x1059*x1065*x1067)));\nevalcond[5]=((((-1.0)*x1063*x1069))+x1061+(((-1.0)*x1067*x1072))+((x1066*x1072))+(((-1.0)*x1064*x1065))+(((-1.0)*x1065*x1068)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j36array[1], cj36array[1], sj36array[1];\nbool j36valid[1]={false};\n_nj36 = 1;\nIkReal x1073=(cj35*py);\nIkReal x1074=((4058967.0)*cj38);\nIkReal x1075=((6542500.0)*pp);\nIkReal x1076=(px*sj35);\nIkReal x1077=((15510000.0)*pz);\nIkReal x1078=(sj37*sj38);\nCheckValue<IkReal> x1079 = IKatan2WithCheck(IkReal(((((-1.0)*x1075*x1078))+(((-1.0)*x1073*x1077))+((x1076*x1077))+(((-181470.303875)*x1078)))),((215101.59825)+((cj38*x1075))+(((181470.303875)*cj38))+(((-1.0)*pz*x1077))+(((7755000.0)*pp))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1079.valid){\ncontinue;\n}\nCheckValue<IkReal> x1080=IKPowWithIntegerCheck(IKsign((((x1074*x1076))+(((-1.0)*x1073*x1074))+(((-4811202.0)*x1073))+(((-4058967.0)*pz*x1078))+(((4811202.0)*x1076)))),-1);\nif(!x1080.valid){\ncontinue;\n}\nj36array[0]=((-1.5707963267949)+(x1079.value)+(((1.5707963267949)*(x1080.value))));\nsj36array[0]=IKsin(j36array[0]);\ncj36array[0]=IKcos(j36array[0]);\nif( j36array[0] > IKPI )\n{\n    j36array[0]-=IK2PI;\n}\nelse if( j36array[0] < -IKPI )\n{    j36array[0]+=IK2PI;\n}\nj36valid[0] = true;\nfor(int ij36 = 0; ij36 < 1; ++ij36)\n{\nif( !j36valid[ij36] )\n{\n    continue;\n}\n_ij36[0] = ij36; _ij36[1] = -1;\nfor(int iij36 = ij36+1; iij36 < 1; ++iij36)\n{\nif( j36valid[iij36] && IKabs(cj36array[ij36]-cj36array[iij36]) < IKFAST_SOLUTION_THRESH && IKabs(sj36array[ij36]-sj36array[iij36]) < IKFAST_SOLUTION_THRESH )\n{\n    j36valid[iij36]=false; _ij36[1] = iij36; break; \n}\n}\nj36 = j36array[ij36]; cj36 = cj36array[ij36]; sj36 = sj36array[ij36];\n{\nIkReal evalcond[6];\nIkReal x1081=IKsin(j36);\nIkReal x1082=IKcos(j36);\nIkReal x1083=((0.2617)*sj38);\nIkReal x1084=((0.2617)*cj38);\nIkReal x1085=((1.0)*pz);\nIkReal x1086=(py*sj35);\nIkReal x1087=((1.0)*cj37);\nIkReal x1088=(px*sj35);\nIkReal x1089=(cj35*py);\nIkReal x1090=(cj35*px);\nIkReal x1091=(sj37*x1082);\nIkReal x1092=(pz*x1081);\nIkReal x1093=((0.6204)*x1082);\nIkReal x1094=(sj37*x1081);\nevalcond[0]=(((x1083*x1091))+((x1081*x1084))+(((0.3102)*x1081))+(((-1.0)*x1085)));\nevalcond[1]=((-0.3102)+((x1082*x1088))+(((-1.0)*x1082*x1089))+x1092+(((-1.0)*x1084)));\nevalcond[2]=((-0.02773715)+(((-1.0)*x1089*x1093))+((x1088*x1093))+(((0.6204)*x1092))+(((-1.0)*pp)));\nevalcond[3]=(((x1083*x1094))+x1088+(((-0.3102)*x1082))+(((-1.0)*x1089))+(((-1.0)*x1082*x1084)));\nevalcond[4]=(((sj37*x1090))+(((-1.0)*x1081*x1087*x1089))+(((-1.0)*cj37*x1082*x1085))+((sj37*x1086))+((cj37*x1081*x1088)));\nevalcond[5]=((((-1.0)*x1089*x1094))+x1083+((x1088*x1094))+(((-1.0)*x1085*x1091))+(((-1.0)*x1087*x1090))+(((-1.0)*x1086*x1087)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j36array[1], cj36array[1], sj36array[1];\nbool j36valid[1]={false};\n_nj36 = 1;\nIkReal x1095=(sj37*sj38);\nIkReal x1096=(cj35*py);\nIkReal x1097=((10000.0)*pz);\nIkReal x1098=(px*sj35);\nIkReal x1099=((2617.0)*cj38);\nCheckValue<IkReal> x1100 = IKatan2WithCheck(IkReal(((((-1.0)*x1096*x1097))+(((-811.7934)*x1095))+(((-684.8689)*cj38*x1095))+((x1097*x1098)))),((962.2404)+(((-1.0)*pz*x1097))+(((684.8689)*(cj38*cj38)))+(((1623.5868)*cj38))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1100.valid){\ncontinue;\n}\nCheckValue<IkReal> x1101=IKPowWithIntegerCheck(IKsign(((((-3102.0)*x1096))+(((-2617.0)*pz*x1095))+(((3102.0)*x1098))+(((-1.0)*x1096*x1099))+((x1098*x1099)))),-1);\nif(!x1101.valid){\ncontinue;\n}\nj36array[0]=((-1.5707963267949)+(x1100.value)+(((1.5707963267949)*(x1101.value))));\nsj36array[0]=IKsin(j36array[0]);\ncj36array[0]=IKcos(j36array[0]);\nif( j36array[0] > IKPI )\n{\n    j36array[0]-=IK2PI;\n}\nelse if( j36array[0] < -IKPI )\n{    j36array[0]+=IK2PI;\n}\nj36valid[0] = true;\nfor(int ij36 = 0; ij36 < 1; ++ij36)\n{\nif( !j36valid[ij36] )\n{\n    continue;\n}\n_ij36[0] = ij36; _ij36[1] = -1;\nfor(int iij36 = ij36+1; iij36 < 1; ++iij36)\n{\nif( j36valid[iij36] && IKabs(cj36array[ij36]-cj36array[iij36]) < IKFAST_SOLUTION_THRESH && IKabs(sj36array[ij36]-sj36array[iij36]) < IKFAST_SOLUTION_THRESH )\n{\n    j36valid[iij36]=false; _ij36[1] = iij36; break; \n}\n}\nj36 = j36array[ij36]; cj36 = cj36array[ij36]; sj36 = sj36array[ij36];\n{\nIkReal evalcond[6];\nIkReal x1102=IKsin(j36);\nIkReal x1103=IKcos(j36);\nIkReal x1104=((0.2617)*sj38);\nIkReal x1105=((0.2617)*cj38);\nIkReal x1106=((1.0)*pz);\nIkReal x1107=(py*sj35);\nIkReal x1108=((1.0)*cj37);\nIkReal x1109=(px*sj35);\nIkReal x1110=(cj35*py);\nIkReal x1111=(cj35*px);\nIkReal x1112=(sj37*x1103);\nIkReal x1113=(pz*x1102);\nIkReal x1114=((0.6204)*x1103);\nIkReal x1115=(sj37*x1102);\nevalcond[0]=(((x1102*x1105))+((x1104*x1112))+(((0.3102)*x1102))+(((-1.0)*x1106)));\nevalcond[1]=((-0.3102)+x1113+(((-1.0)*x1103*x1110))+(((-1.0)*x1105))+((x1103*x1109)));\nevalcond[2]=((-0.02773715)+((x1109*x1114))+(((0.6204)*x1113))+(((-1.0)*pp))+(((-1.0)*x1110*x1114)));\nevalcond[3]=((((-1.0)*x1103*x1105))+x1109+(((-0.3102)*x1103))+(((-1.0)*x1110))+((x1104*x1115)));\nevalcond[4]=(((sj37*x1111))+((sj37*x1107))+(((-1.0)*cj37*x1103*x1106))+(((-1.0)*x1102*x1108*x1110))+((cj37*x1102*x1109)));\nevalcond[5]=(((x1109*x1115))+(((-1.0)*x1110*x1115))+x1104+(((-1.0)*x1108*x1111))+(((-1.0)*x1107*x1108))+(((-1.0)*x1106*x1112)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\nreturn solutions.GetNumSolutions()>0;\n}\ninline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {\nfor(int rotationiter = 0; rotationiter < 1; ++rotationiter) {\nIkReal x126=((1.0)*sj37);\nIkReal x127=(sj36*sj38);\nIkReal x128=(cj36*cj38);\nIkReal x129=(cj37*sj35);\nIkReal x130=((1.0)*sj36);\nIkReal x131=(cj36*cj37);\nIkReal x132=((1.0)*sj38);\nIkReal x133=(cj35*cj37);\nIkReal x134=(cj36*sj38);\nIkReal x135=((1.0)*sj35);\nIkReal x136=((-1.0)*sj38);\nIkReal x137=((((-1.0)*sj35*x126))+((sj36*x133)));\nIkReal x138=(((cj38*sj36*sj37))+x134);\nIkReal x139=((((-1.0)*x127))+((sj37*x128)));\nIkReal x140=((((-1.0)*x126*x127))+x128);\nIkReal x141=(cj35*x140);\nIkReal x142=(sj35*x140);\nIkReal x143=((((-1.0)*x129*x130))+(((-1.0)*cj35*x126)));\nIkReal x144=((((-1.0)*x126*x134))+(((-1.0)*cj38*x130)));\nIkReal x145=(((cj38*x129))+((cj35*x138)));\nIkReal x146=((((-1.0)*x135*x138))+((cj38*x133)));\nIkReal x147=(x141+(((-1.0)*x129*x132)));\nIkReal x148=((((-1.0)*x142))+((x133*x136)));\nnew_r00=(((r00*x143))+((r20*x131))+((r10*x137)));\nnew_r01=(((r01*x143))+((r21*x131))+((r11*x137)));\nnew_r02=(((r22*x131))+((r12*x137))+((r02*x143)));\nnew_r10=(((r00*x146))+((r20*x139))+((r10*x145)));\nnew_r11=(((r01*x146))+((r21*x139))+((r11*x145)));\nnew_r12=(((r22*x139))+((r02*x146))+((r12*x145)));\nnew_r20=(((r20*x144))+((r00*x148))+((r10*x147)));\nnew_r21=(((r21*x144))+((r01*(((((-1.0)*x132*x133))+(((-1.0)*x135*x140))))))+((r11*((((x129*x136))+x141)))));\nnew_r22=(((r02*x148))+((r22*x144))+((r12*x147)));\n{\nIkReal j40array[2], cj40array[2], sj40array[2];\nbool j40valid[2]={false};\n_nj40 = 2;\nsj40array[0]=((-1.0)*new_r22);\nif( sj40array[0] >= -1-IKFAST_SINCOS_THRESH && sj40array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j40valid[0] = j40valid[1] = true;\n    j40array[0] = IKasin(sj40array[0]);\n    cj40array[0] = IKcos(j40array[0]);\n    sj40array[1] = sj40array[0];\n    j40array[1] = j40array[0] > 0 ? (IKPI-j40array[0]) : (-IKPI-j40array[0]);\n    cj40array[1] = -cj40array[0];\n}\nelse if( isnan(sj40array[0]) )\n{\n    // probably any value will work\n    j40valid[0] = true;\n    cj40array[0] = 1; sj40array[0] = 0; j40array[0] = 0;\n}\nfor(int ij40 = 0; ij40 < 2; ++ij40)\n{\nif( !j40valid[ij40] )\n{\n    continue;\n}\n_ij40[0] = ij40; _ij40[1] = -1;\nfor(int iij40 = ij40+1; iij40 < 2; ++iij40)\n{\nif( j40valid[iij40] && IKabs(cj40array[ij40]-cj40array[iij40]) < IKFAST_SOLUTION_THRESH && IKabs(sj40array[ij40]-sj40array[iij40]) < IKFAST_SOLUTION_THRESH )\n{\n    j40valid[iij40]=false; _ij40[1] = iij40; break; \n}\n}\nj40 = j40array[ij40]; cj40 = cj40array[ij40]; sj40 = sj40array[ij40];\n\n{\nIkReal j39eval[2];\nIkReal x149=((1.0)*sj37);\nIkReal x150=(sj36*sj38);\nIkReal x151=(cj36*cj38);\nIkReal x152=(cj37*sj35);\nIkReal x153=((1.0)*sj36);\nIkReal x154=(cj36*cj37);\nIkReal x155=((1.0)*sj38);\nIkReal x156=(cj35*cj37);\nIkReal x157=(cj36*sj38);\nIkReal x158=((1.0)*sj35);\nIkReal x159=((-1.0)*sj38);\nIkReal x160=x137;\nIkReal x161=x138;\nIkReal x162=x139;\nIkReal x163=(x151+(((-1.0)*x149*x150)));\nIkReal x164=(cj35*x163);\nIkReal x165=(sj35*x163);\nIkReal x166=x143;\nIkReal x167=x144;\nIkReal x168=(((cj35*x161))+((cj38*x152)));\nIkReal x169=((((-1.0)*x158*x161))+((cj38*x156)));\nIkReal x170=(x164+(((-1.0)*x152*x155)));\nIkReal x171=((((-1.0)*x165))+((x156*x159)));\nnew_r00=(((r00*x166))+((r20*x154))+((r10*x160)));\nnew_r01=(((r01*x166))+((r21*x154))+((r11*x160)));\nnew_r02=(((r12*x160))+((r22*x154))+((r02*x166)));\nnew_r10=(((r00*x169))+((r20*x162))+((r10*x168)));\nnew_r11=(((r01*x169))+((r21*x162))+((r11*x168)));\nnew_r12=(((r22*x162))+((r12*x168))+((r02*x169)));\nnew_r20=(((r00*x171))+((r20*x167))+((r10*x170)));\nnew_r21=(((r11*((((x152*x159))+x164))))+((r21*x167))+((r01*(((((-1.0)*x158*x163))+(((-1.0)*x155*x156)))))));\nnew_r22=(((r22*x167))+((r12*x170))+((r02*x171)));\nj39eval[0]=cj40;\nj39eval[1]=IKsign(cj40);\nif( IKabs(j39eval[0]) < 0.0000010000000000  || IKabs(j39eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j39eval[1];\nIkReal x172=((1.0)*sj37);\nIkReal x173=(sj36*sj38);\nIkReal x174=(cj36*cj38);\nIkReal x175=(cj37*sj35);\nIkReal x176=((1.0)*sj36);\nIkReal x177=(cj36*cj37);\nIkReal x178=((1.0)*sj38);\nIkReal x179=(cj35*cj37);\nIkReal x180=(cj36*sj38);\nIkReal x181=((1.0)*sj35);\nIkReal x182=((-1.0)*sj38);\nIkReal x183=x137;\nIkReal x184=x138;\nIkReal x185=x139;\nIkReal x186=(x174+(((-1.0)*x172*x173)));\nIkReal x187=(cj35*x186);\nIkReal x188=(sj35*x186);\nIkReal x189=x143;\nIkReal x190=x144;\nIkReal x191=(((cj38*x175))+((cj35*x184)));\nIkReal x192=(((cj38*x179))+(((-1.0)*x181*x184)));\nIkReal x193=((((-1.0)*x175*x178))+x187);\nIkReal x194=(((x179*x182))+(((-1.0)*x188)));\nnew_r00=(((r00*x189))+((r20*x177))+((r10*x183)));\nnew_r01=(((r01*x189))+((r21*x177))+((r11*x183)));\nnew_r02=(((r22*x177))+((r12*x183))+((r02*x189)));\nnew_r10=(((r00*x192))+((r20*x185))+((r10*x191)));\nnew_r11=(((r01*x192))+((r21*x185))+((r11*x191)));\nnew_r12=(((r12*x191))+((r02*x192))+((r22*x185)));\nnew_r20=(((r00*x194))+((r20*x190))+((r10*x193)));\nnew_r21=(((r21*x190))+((r11*((((x175*x182))+x187))))+((r01*(((((-1.0)*x178*x179))+(((-1.0)*x181*x186)))))));\nnew_r22=(((r12*x193))+((r22*x190))+((r02*x194)));\nj39eval[0]=cj40;\nif( IKabs(j39eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j40)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r20;\nevalcond[4]=new_r21;\nevalcond[5]=new_r12;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j39array[2], cj39array[2], sj39array[2];\nbool j39valid[2]={false};\n_nj39 = 2;\nCheckValue<IkReal> x196 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x196.valid){\ncontinue;\n}\nIkReal x195=x196.value;\nj39array[0]=((-1.0)*x195);\nsj39array[0]=IKsin(j39array[0]);\ncj39array[0]=IKcos(j39array[0]);\nj39array[1]=((3.14159265358979)+(((-1.0)*x195)));\nsj39array[1]=IKsin(j39array[1]);\ncj39array[1]=IKcos(j39array[1]);\nif( j39array[0] > IKPI )\n{\n    j39array[0]-=IK2PI;\n}\nelse if( j39array[0] < -IKPI )\n{    j39array[0]+=IK2PI;\n}\nj39valid[0] = true;\nif( j39array[1] > IKPI )\n{\n    j39array[1]-=IK2PI;\n}\nelse if( j39array[1] < -IKPI )\n{    j39array[1]+=IK2PI;\n}\nj39valid[1] = true;\nfor(int ij39 = 0; ij39 < 2; ++ij39)\n{\nif( !j39valid[ij39] )\n{\n    continue;\n}\n_ij39[0] = ij39; _ij39[1] = -1;\nfor(int iij39 = ij39+1; iij39 < 2; ++iij39)\n{\nif( j39valid[iij39] && IKabs(cj39array[ij39]-cj39array[iij39]) < IKFAST_SOLUTION_THRESH && IKabs(sj39array[ij39]-sj39array[iij39]) < IKFAST_SOLUTION_THRESH )\n{\n    j39valid[iij39]=false; _ij39[1] = iij39; break; \n}\n}\nj39 = j39array[ij39]; cj39 = cj39array[ij39]; sj39 = sj39array[ij39];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*new_r02*(IKsin(j39))))+((new_r12*(IKcos(j39)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nIkReal x197=((1.0)*cj39);\nif( IKabs(((((-1.0)*new_r11*sj39))+(((-1.0)*new_r01*x197)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj39))+(((-1.0)*new_r11*x197)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj39))+(((-1.0)*new_r01*x197))))+IKsqr((((new_r01*sj39))+(((-1.0)*new_r11*x197))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((((-1.0)*new_r11*sj39))+(((-1.0)*new_r01*x197))), (((new_r01*sj39))+(((-1.0)*new_r11*x197))));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x198=IKsin(j41);\nIkReal x199=IKcos(j41);\nIkReal x200=((1.0)*sj39);\nIkReal x201=(cj39*x198);\nIkReal x202=(cj39*x199);\nIkReal x203=(x199*x200);\nevalcond[0]=(((cj39*new_r01))+((new_r11*sj39))+x198);\nevalcond[1]=((((-1.0)*new_r00*x200))+x198+((cj39*new_r10)));\nevalcond[2]=(x199+(((-1.0)*new_r01*x200))+((cj39*new_r11)));\nevalcond[3]=(((cj39*new_r00))+(((-1.0)*x199))+((new_r10*sj39)));\nevalcond[4]=(x202+((sj39*x198))+new_r11);\nevalcond[5]=((((-1.0)*x203))+x201+new_r01);\nevalcond[6]=((((-1.0)*x203))+x201+new_r10);\nevalcond[7]=((((-1.0)*x198*x200))+new_r00+(((-1.0)*x202)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j40)))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r20;\nevalcond[4]=new_r21;\nevalcond[5]=new_r12;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j39array[2], cj39array[2], sj39array[2];\nbool j39valid[2]={false};\n_nj39 = 2;\nCheckValue<IkReal> x205 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x205.valid){\ncontinue;\n}\nIkReal x204=x205.value;\nj39array[0]=((-1.0)*x204);\nsj39array[0]=IKsin(j39array[0]);\ncj39array[0]=IKcos(j39array[0]);\nj39array[1]=((3.14159265358979)+(((-1.0)*x204)));\nsj39array[1]=IKsin(j39array[1]);\ncj39array[1]=IKcos(j39array[1]);\nif( j39array[0] > IKPI )\n{\n    j39array[0]-=IK2PI;\n}\nelse if( j39array[0] < -IKPI )\n{    j39array[0]+=IK2PI;\n}\nj39valid[0] = true;\nif( j39array[1] > IKPI )\n{\n    j39array[1]-=IK2PI;\n}\nelse if( j39array[1] < -IKPI )\n{    j39array[1]+=IK2PI;\n}\nj39valid[1] = true;\nfor(int ij39 = 0; ij39 < 2; ++ij39)\n{\nif( !j39valid[ij39] )\n{\n    continue;\n}\n_ij39[0] = ij39; _ij39[1] = -1;\nfor(int iij39 = ij39+1; iij39 < 2; ++iij39)\n{\nif( j39valid[iij39] && IKabs(cj39array[ij39]-cj39array[iij39]) < IKFAST_SOLUTION_THRESH && IKabs(sj39array[ij39]-sj39array[iij39]) < IKFAST_SOLUTION_THRESH )\n{\n    j39valid[iij39]=false; _ij39[1] = iij39; break; \n}\n}\nj39 = j39array[ij39]; cj39 = cj39array[ij39]; sj39 = sj39array[ij39];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*new_r02*(IKsin(j39))))+((new_r12*(IKcos(j39)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nIkReal x206=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj39*x206))+(((-1.0)*new_r11*sj39)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj39*x206))+((cj39*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj39*x206))+(((-1.0)*new_r11*sj39))))+IKsqr(((((-1.0)*sj39*x206))+((cj39*new_r11))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((((-1.0)*cj39*x206))+(((-1.0)*new_r11*sj39))), ((((-1.0)*sj39*x206))+((cj39*new_r11))));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x207=IKcos(j41);\nIkReal x208=IKsin(j41);\nIkReal x209=((1.0)*sj39);\nIkReal x210=((1.0)*x207);\nIkReal x211=(sj39*x208);\nIkReal x212=(cj39*x208);\nIkReal x213=(cj39*x210);\nevalcond[0]=(((cj39*new_r01))+((new_r11*sj39))+x208);\nevalcond[1]=(((cj39*new_r00))+((new_r10*sj39))+(((-1.0)*x210)));\nevalcond[2]=(((sj39*x207))+x212+new_r01);\nevalcond[3]=(x211+new_r11+(((-1.0)*x213)));\nevalcond[4]=((((-1.0)*new_r00*x209))+(((-1.0)*x208))+((cj39*new_r10)));\nevalcond[5]=((((-1.0)*x210))+(((-1.0)*new_r01*x209))+((cj39*new_r11)));\nevalcond[6]=(x211+new_r00+(((-1.0)*x213)));\nevalcond[7]=((((-1.0)*x207*x209))+(((-1.0)*x212))+new_r10);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j39, j41]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j39array[1], cj39array[1], sj39array[1];\nbool j39valid[1]={false};\n_nj39 = 1;\nCheckValue<IkReal> x215=IKPowWithIntegerCheck(cj40,-1);\nif(!x215.valid){\ncontinue;\n}\nIkReal x214=x215.value;\nCheckValue<IkReal> x216=IKPowWithIntegerCheck(new_r12,-1);\nif(!x216.valid){\ncontinue;\n}\nCheckValue<IkReal> x217=IKPowWithIntegerCheck(x214,-2);\nif(!x217.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r02*x214)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x214*(x216.value)*(((((-1.0)*(new_r02*new_r02)))+(x217.value))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r02*x214))+IKsqr((x214*(x216.value)*(((((-1.0)*(new_r02*new_r02)))+(x217.value)))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj39array[0]=IKatan2(((-1.0)*new_r02*x214), (x214*(x216.value)*(((((-1.0)*(new_r02*new_r02)))+(x217.value)))));\nsj39array[0]=IKsin(j39array[0]);\ncj39array[0]=IKcos(j39array[0]);\nif( j39array[0] > IKPI )\n{\n    j39array[0]-=IK2PI;\n}\nelse if( j39array[0] < -IKPI )\n{    j39array[0]+=IK2PI;\n}\nj39valid[0] = true;\nfor(int ij39 = 0; ij39 < 1; ++ij39)\n{\nif( !j39valid[ij39] )\n{\n    continue;\n}\n_ij39[0] = ij39; _ij39[1] = -1;\nfor(int iij39 = ij39+1; iij39 < 1; ++iij39)\n{\nif( j39valid[iij39] && IKabs(cj39array[ij39]-cj39array[iij39]) < IKFAST_SOLUTION_THRESH && IKabs(sj39array[ij39]-sj39array[iij39]) < IKFAST_SOLUTION_THRESH )\n{\n    j39valid[iij39]=false; _ij39[1] = iij39; break; \n}\n}\nj39 = j39array[ij39]; cj39 = cj39array[ij39]; sj39 = sj39array[ij39];\n{\nIkReal evalcond[8];\nIkReal x218=IKsin(j39);\nIkReal x219=IKcos(j39);\nIkReal x220=((1.0)*cj40);\nIkReal x221=(cj40*x218);\nIkReal x222=(new_r12*x219);\nIkReal x223=((1.0)*new_r02*x218);\nevalcond[0]=(x221+new_r02);\nevalcond[1]=((((-1.0)*x219*x220))+new_r12);\nevalcond[2]=(((new_r02*x219))+((new_r12*x218)));\nevalcond[3]=(x222+(((-1.0)*x223))+(((-1.0)*x220)));\nevalcond[4]=(((new_r20*sj40))+((new_r00*x221))+(((-1.0)*new_r10*x219*x220)));\nevalcond[5]=(((new_r01*x221))+(((-1.0)*new_r11*x219*x220))+((new_r21*sj40)));\nevalcond[6]=(((sj40*x222))+((cj40*new_r22))+(((-1.0)*sj40*x223)));\nevalcond[7]=((1.0)+((new_r02*x221))+(((-1.0)*x220*x222))+((new_r22*sj40)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j41eval[2];\nIkReal x224=((1.0)*sj37);\nIkReal x225=(sj36*sj38);\nIkReal x226=(cj36*cj38);\nIkReal x227=(cj37*sj35);\nIkReal x228=((1.0)*sj36);\nIkReal x229=(cj36*cj37);\nIkReal x230=((1.0)*sj38);\nIkReal x231=(cj35*cj37);\nIkReal x232=(cj36*sj38);\nIkReal x233=((1.0)*sj35);\nIkReal x234=((-1.0)*sj38);\nIkReal x235=x137;\nIkReal x236=x138;\nIkReal x237=x139;\nIkReal x238=((((-1.0)*x224*x225))+x226);\nIkReal x239=(cj35*x238);\nIkReal x240=(sj35*x238);\nIkReal x241=x143;\nIkReal x242=x144;\nIkReal x243=(((cj35*x236))+((cj38*x227)));\nIkReal x244=((((-1.0)*x233*x236))+((cj38*x231)));\nIkReal x245=((((-1.0)*x227*x230))+x239);\nIkReal x246=((((-1.0)*x240))+((x231*x234)));\nnew_r00=(((r20*x229))+((r10*x235))+((r00*x241)));\nnew_r01=(((r11*x235))+((r01*x241))+((r21*x229)));\nnew_r02=(((r02*x241))+((r22*x229))+((r12*x235)));\nnew_r10=(((r20*x237))+((r00*x244))+((r10*x243)));\nnew_r11=(((r01*x244))+((r11*x243))+((r21*x237)));\nnew_r12=(((r02*x244))+((r12*x243))+((r22*x237)));\nnew_r20=(((r00*x246))+((r10*x245))+((r20*x242)));\nnew_r21=(((r01*(((((-1.0)*x233*x238))+(((-1.0)*x230*x231))))))+((r21*x242))+((r11*((x239+((x227*x234)))))));\nnew_r22=(((r02*x246))+((r22*x242))+((r12*x245)));\nj41eval[0]=cj40;\nj41eval[1]=IKsign(cj40);\nif( IKabs(j41eval[0]) < 0.0000010000000000  || IKabs(j41eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j41eval[2];\nIkReal x247=((1.0)*sj37);\nIkReal x248=(sj36*sj38);\nIkReal x249=(cj36*cj38);\nIkReal x250=(cj37*sj35);\nIkReal x251=((1.0)*sj36);\nIkReal x252=(cj36*cj37);\nIkReal x253=((1.0)*sj38);\nIkReal x254=(cj35*cj37);\nIkReal x255=(cj36*sj38);\nIkReal x256=((1.0)*sj35);\nIkReal x257=((-1.0)*sj38);\nIkReal x258=x137;\nIkReal x259=x138;\nIkReal x260=x139;\nIkReal x261=(x249+(((-1.0)*x247*x248)));\nIkReal x262=(cj35*x261);\nIkReal x263=(sj35*x261);\nIkReal x264=x143;\nIkReal x265=x144;\nIkReal x266=(((cj38*x250))+((cj35*x259)));\nIkReal x267=(((cj38*x254))+(((-1.0)*x256*x259)));\nIkReal x268=((((-1.0)*x250*x253))+x262);\nIkReal x269=((((-1.0)*x263))+((x254*x257)));\nnew_r00=(((r20*x252))+((r10*x258))+((r00*x264)));\nnew_r01=(((r21*x252))+((r11*x258))+((r01*x264)));\nnew_r02=(((r02*x264))+((r12*x258))+((r22*x252)));\nnew_r10=(((r00*x267))+((r10*x266))+((r20*x260)));\nnew_r11=(((r21*x260))+((r11*x266))+((r01*x267)));\nnew_r12=(((r22*x260))+((r02*x267))+((r12*x266)));\nnew_r20=(((r00*x269))+((r10*x268))+((r20*x265)));\nnew_r21=(((r01*(((((-1.0)*x256*x261))+(((-1.0)*x253*x254))))))+((r21*x265))+((r11*((((x250*x257))+x262)))));\nnew_r22=(((r22*x265))+((r02*x269))+((r12*x268)));\nj41eval[0]=cj40;\nj41eval[1]=sj39;\nif( IKabs(j41eval[0]) < 0.0000010000000000  || IKabs(j41eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j41eval[3];\nIkReal x270=((1.0)*sj37);\nIkReal x271=(sj36*sj38);\nIkReal x272=(cj36*cj38);\nIkReal x273=(cj37*sj35);\nIkReal x274=((1.0)*sj36);\nIkReal x275=(cj36*cj37);\nIkReal x276=((1.0)*sj38);\nIkReal x277=(cj35*cj37);\nIkReal x278=(cj36*sj38);\nIkReal x279=((1.0)*sj35);\nIkReal x280=((-1.0)*sj38);\nIkReal x281=x137;\nIkReal x282=x138;\nIkReal x283=x139;\nIkReal x284=(x272+(((-1.0)*x270*x271)));\nIkReal x285=(cj35*x284);\nIkReal x286=(sj35*x284);\nIkReal x287=x143;\nIkReal x288=x144;\nIkReal x289=(((cj35*x282))+((cj38*x273)));\nIkReal x290=(((cj38*x277))+(((-1.0)*x279*x282)));\nIkReal x291=((((-1.0)*x273*x276))+x285);\nIkReal x292=((((-1.0)*x286))+((x277*x280)));\nnew_r00=(((r00*x287))+((r10*x281))+((r20*x275)));\nnew_r01=(((r01*x287))+((r11*x281))+((r21*x275)));\nnew_r02=(((r22*x275))+((r02*x287))+((r12*x281)));\nnew_r10=(((r10*x289))+((r00*x290))+((r20*x283)));\nnew_r11=(((r21*x283))+((r11*x289))+((r01*x290)));\nnew_r12=(((r22*x283))+((r12*x289))+((r02*x290)));\nnew_r20=(((r00*x292))+((r10*x291))+((r20*x288)));\nnew_r21=(((r21*x288))+((r01*(((((-1.0)*x279*x284))+(((-1.0)*x276*x277))))))+((r11*((x285+((x273*x280)))))));\nnew_r22=(((r12*x291))+((r22*x288))+((r02*x292)));\nj41eval[0]=cj40;\nj41eval[1]=cj39;\nj41eval[2]=sj40;\nif( IKabs(j41eval[0]) < 0.0000010000000000  || IKabs(j41eval[1]) < 0.0000010000000000  || IKabs(j41eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x293=(new_r12*sj39);\nIkReal x294=((1.0)*new_r02);\nIkReal x295=((((-1.0)*sj39*x294))+((cj39*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j40)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r20;\nevalcond[4]=new_r21;\nevalcond[5]=new_r12;\nevalcond[6]=(((cj39*new_r02))+x293);\nevalcond[7]=((((-1.0)*x293))+(((-1.0)*cj39*x294)));\nevalcond[8]=x295;\nevalcond[9]=x295;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nIkReal x296=((1.0)*cj39);\nif( IKabs(((((-1.0)*new_r01*x296))+(((-1.0)*new_r11*sj39)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x296))+((new_r01*sj39)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x296))+(((-1.0)*new_r11*sj39))))+IKsqr(((((-1.0)*new_r11*x296))+((new_r01*sj39))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((((-1.0)*new_r01*x296))+(((-1.0)*new_r11*sj39))), ((((-1.0)*new_r11*x296))+((new_r01*sj39))));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x297=IKsin(j41);\nIkReal x298=IKcos(j41);\nIkReal x299=((1.0)*sj39);\nIkReal x300=(cj39*x297);\nIkReal x301=(cj39*x298);\nIkReal x302=(x298*x299);\nevalcond[0]=(((cj39*new_r01))+((new_r11*sj39))+x297);\nevalcond[1]=(x297+(((-1.0)*new_r00*x299))+((cj39*new_r10)));\nevalcond[2]=((((-1.0)*new_r01*x299))+x298+((cj39*new_r11)));\nevalcond[3]=((((-1.0)*x298))+((cj39*new_r00))+((new_r10*sj39)));\nevalcond[4]=(((sj39*x297))+x301+new_r11);\nevalcond[5]=(x300+new_r01+(((-1.0)*x302)));\nevalcond[6]=(x300+new_r10+(((-1.0)*x302)));\nevalcond[7]=((((-1.0)*x297*x299))+(((-1.0)*x301))+new_r00);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x303=(new_r12*sj39);\nIkReal x304=(new_r02*sj39);\nIkReal x305=(cj39*new_r12);\nIkReal x306=(cj39*new_r02);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j40)))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r20;\nevalcond[4]=new_r21;\nevalcond[5]=new_r12;\nevalcond[6]=(x306+x303);\nevalcond[7]=((((-1.0)*x306))+(((-1.0)*x303)));\nevalcond[8]=((((-1.0)*x304))+x305);\nevalcond[9]=((((-1.0)*x305))+x304);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nIkReal x307=((1.0)*new_r01);\nif( IKabs(((((-1.0)*new_r11*sj39))+(((-1.0)*cj39*x307)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj39*x307))+((cj39*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj39))+(((-1.0)*cj39*x307))))+IKsqr(((((-1.0)*sj39*x307))+((cj39*new_r11))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((((-1.0)*new_r11*sj39))+(((-1.0)*cj39*x307))), ((((-1.0)*sj39*x307))+((cj39*new_r11))));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x308=IKcos(j41);\nIkReal x309=IKsin(j41);\nIkReal x310=((1.0)*sj39);\nIkReal x311=((1.0)*x308);\nIkReal x312=(sj39*x309);\nIkReal x313=(cj39*x309);\nIkReal x314=(cj39*x311);\nevalcond[0]=(((cj39*new_r01))+((new_r11*sj39))+x309);\nevalcond[1]=(((cj39*new_r00))+((new_r10*sj39))+(((-1.0)*x311)));\nevalcond[2]=(x313+((sj39*x308))+new_r01);\nevalcond[3]=(x312+(((-1.0)*x314))+new_r11);\nevalcond[4]=((((-1.0)*new_r00*x310))+(((-1.0)*x309))+((cj39*new_r10)));\nevalcond[5]=((((-1.0)*x311))+(((-1.0)*new_r01*x310))+((cj39*new_r11)));\nevalcond[6]=(x312+(((-1.0)*x314))+new_r00);\nevalcond[7]=((((-1.0)*x308*x310))+(((-1.0)*x313))+new_r10);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x315=(sj40+new_r22);\nIkReal x316=((1.0)*new_r02);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j39)))), 6.28318530717959)));\nevalcond[1]=x315;\nevalcond[2]=x315;\nevalcond[3]=(cj40+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x316))+(((-1.0)*cj40)));\nevalcond[6]=(((new_r20*sj40))+((cj40*new_r00)));\nevalcond[7]=(((new_r21*sj40))+((cj40*new_r01)));\nevalcond[8]=(((cj40*new_r22))+(((-1.0)*sj40*x316)));\nevalcond[9]=((1.0)+((new_r22*sj40))+((cj40*new_r02)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nif( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((-1.0)*new_r11), new_r10);\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x317=IKsin(j41);\nIkReal x318=IKcos(j41);\nIkReal x319=((1.0)*new_r02);\nIkReal x320=((1.0)*x318);\nevalcond[0]=(x317+new_r11);\nevalcond[1]=((((-1.0)*x320))+new_r10);\nevalcond[2]=(new_r20+(((-1.0)*x317*x319)));\nevalcond[3]=((((-1.0)*x318*x319))+new_r21);\nevalcond[4]=((((-1.0)*new_r22*x317))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*new_r22*x320))+(((-1.0)*new_r01)));\nevalcond[6]=((((-1.0)*new_r20*x319))+((new_r00*new_r22))+x317);\nevalcond[7]=((((-1.0)*new_r21*x319))+((new_r01*new_r22))+x318);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x321=(sj40+new_r22);\nIkReal x322=((((-1.0)*cj40))+new_r02);\nIkReal x323=((1.0)*cj40);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j39)))), 6.28318530717959)));\nevalcond[1]=x321;\nevalcond[2]=x321;\nevalcond[3]=x322;\nevalcond[4]=new_r12;\nevalcond[5]=x322;\nevalcond[6]=(((new_r20*sj40))+(((-1.0)*new_r00*x323)));\nevalcond[7]=(((new_r21*sj40))+(((-1.0)*new_r01*x323)));\nevalcond[8]=(((cj40*new_r22))+((new_r02*sj40)));\nevalcond[9]=((1.0)+(((-1.0)*new_r02*x323))+((new_r22*sj40)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nCheckValue<IkReal> x324=IKPowWithIntegerCheck(IKsign(new_r02),-1);\nif(!x324.valid){\ncontinue;\n}\nCheckValue<IkReal> x325 = IKatan2WithCheck(IkReal(((-1.0)*new_r20)),((-1.0)*new_r21),IKFAST_ATAN2_MAGTHRESH);\nif(!x325.valid){\ncontinue;\n}\nj41array[0]=((-1.5707963267949)+(((1.5707963267949)*(x324.value)))+(x325.value));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x326=IKsin(j41);\nIkReal x327=IKcos(j41);\nIkReal x328=((1.0)*new_r22);\nevalcond[0]=(new_r20+((new_r02*x326)));\nevalcond[1]=(new_r21+((new_r02*x327)));\nevalcond[2]=(x326+(((-1.0)*new_r11)));\nevalcond[3]=((((-1.0)*x326*x328))+new_r00);\nevalcond[4]=((((-1.0)*x327*x328))+new_r01);\nevalcond[5]=((((-1.0)*x327))+(((-1.0)*new_r10)));\nevalcond[6]=(x326+(((-1.0)*new_r00*x328))+((new_r02*new_r20)));\nevalcond[7]=(x327+(((-1.0)*new_r01*x328))+((new_r02*new_r21)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x329=(new_r12*sj39);\nIkReal x330=((1.0)*sj39);\nIkReal x331=((1.0)*cj39);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j40))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(sj39+new_r02);\nevalcond[3]=((((-1.0)*x331))+new_r12);\nevalcond[4]=(((cj39*new_r02))+x329);\nevalcond[5]=((((-1.0)*x329))+(((-1.0)*new_r02*x331)));\nevalcond[6]=((-1.0)+(((-1.0)*new_r02*x330))+((cj39*new_r12)));\nevalcond[7]=((((-1.0)*new_r00*x330))+((cj39*new_r10)));\nevalcond[8]=((((-1.0)*new_r01*x330))+((cj39*new_r11)));\nevalcond[9]=((((-1.0)*new_r10*x331))+((new_r00*sj39)));\nevalcond[10]=((((-1.0)*new_r11*x331))+((new_r01*sj39)));\nevalcond[11]=((1.0)+((new_r02*sj39))+(((-1.0)*new_r12*x331)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nif( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x332=IKsin(j41);\nIkReal x333=IKcos(j41);\nIkReal x334=((1.0)*new_r02);\nIkReal x335=((1.0)*x333);\nevalcond[0]=(x332+new_r20);\nevalcond[1]=(x333+new_r21);\nevalcond[2]=(((new_r12*x332))+new_r01);\nevalcond[3]=(((new_r02*x333))+new_r10);\nevalcond[4]=((((-1.0)*x332*x334))+new_r11);\nevalcond[5]=((((-1.0)*new_r12*x335))+new_r00);\nevalcond[6]=((((-1.0)*new_r11*x334))+((new_r01*new_r12))+x332);\nevalcond[7]=((((-1.0)*new_r10*x334))+((new_r00*new_r12))+(((-1.0)*x335)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x336=(new_r12*sj39);\nIkReal x337=((1.0)*sj39);\nIkReal x338=(cj39*new_r02);\nIkReal x339=((((-1.0)*new_r00*x337))+((cj39*new_r10)));\nIkReal x340=((((-1.0)*new_r01*x337))+((cj39*new_r11)));\nIkReal x341=((1.0)+(((-1.0)*new_r02*x337))+((cj39*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j40)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*x337))+new_r02);\nevalcond[3]=(cj39+new_r12);\nevalcond[4]=(x338+x336);\nevalcond[5]=((((-1.0)*x336))+(((-1.0)*x338)));\nevalcond[6]=x341;\nevalcond[7]=x339;\nevalcond[8]=x340;\nevalcond[9]=x339;\nevalcond[10]=x340;\nevalcond[11]=x341;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nif( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(new_r20, new_r21);\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x342=IKsin(j41);\nIkReal x343=IKcos(j41);\nIkReal x344=((1.0)*new_r12);\nIkReal x345=((1.0)*x343);\nevalcond[0]=(new_r20+(((-1.0)*x342)));\nevalcond[1]=(new_r21+(((-1.0)*x345)));\nevalcond[2]=(((new_r02*x342))+new_r11);\nevalcond[3]=(((new_r12*x343))+new_r00);\nevalcond[4]=(new_r01+(((-1.0)*x342*x344)));\nevalcond[5]=((((-1.0)*new_r02*x345))+new_r10);\nevalcond[6]=(x342+((new_r02*new_r11))+(((-1.0)*new_r01*x344)));\nevalcond[7]=((((-1.0)*new_r00*x344))+((new_r02*new_r10))+(((-1.0)*x345)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x346=(sj40+new_r22);\nIkReal x347=((((-1.0)*cj40))+new_r12);\nIkReal x348=((1.0)*cj40);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j39))), 6.28318530717959)));\nevalcond[1]=x346;\nevalcond[2]=x346;\nevalcond[3]=new_r02;\nevalcond[4]=x347;\nevalcond[5]=x347;\nevalcond[6]=(((new_r20*sj40))+(((-1.0)*new_r10*x348)));\nevalcond[7]=((((-1.0)*new_r11*x348))+((new_r21*sj40)));\nevalcond[8]=(((new_r12*sj40))+((cj40*new_r22)));\nevalcond[9]=((1.0)+(((-1.0)*new_r12*x348))+((new_r22*sj40)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nif( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((-1.0)*new_r01), new_r00);\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x349=IKsin(j41);\nIkReal x350=IKcos(j41);\nIkReal x351=((1.0)*new_r22);\nevalcond[0]=(x349+new_r01);\nevalcond[1]=(((new_r12*x349))+new_r20);\nevalcond[2]=(new_r21+((new_r12*x350)));\nevalcond[3]=((((-1.0)*x350))+new_r00);\nevalcond[4]=(new_r11+(((-1.0)*x350*x351)));\nevalcond[5]=((((-1.0)*x349*x351))+new_r10);\nevalcond[6]=(x349+((new_r12*new_r20))+(((-1.0)*new_r10*x351)));\nevalcond[7]=(x350+((new_r12*new_r21))+(((-1.0)*new_r11*x351)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x352=(sj40+new_r22);\nIkReal x353=((1.0)*new_r12);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j39)))), 6.28318530717959)));\nevalcond[1]=x352;\nevalcond[2]=x352;\nevalcond[3]=new_r02;\nevalcond[4]=(cj40+new_r12);\nevalcond[5]=((((-1.0)*x353))+(((-1.0)*cj40)));\nevalcond[6]=(((cj40*new_r10))+((new_r20*sj40)));\nevalcond[7]=(((cj40*new_r11))+((new_r21*sj40)));\nevalcond[8]=((((-1.0)*sj40*x353))+((cj40*new_r22)));\nevalcond[9]=((1.0)+((cj40*new_r12))+((new_r22*sj40)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nif( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(new_r01, ((-1.0)*new_r00));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x354=IKsin(j41);\nIkReal x355=IKcos(j41);\nIkReal x356=((1.0)*new_r12);\nevalcond[0]=(x354+(((-1.0)*new_r01)));\nevalcond[1]=(((new_r22*x355))+new_r11);\nevalcond[2]=(new_r20+(((-1.0)*x354*x356)));\nevalcond[3]=(new_r21+(((-1.0)*x355*x356)));\nevalcond[4]=((((-1.0)*x355))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*new_r22*x354))+(((-1.0)*new_r10)));\nevalcond[6]=(x354+((new_r10*new_r22))+(((-1.0)*new_r20*x356)));\nevalcond[7]=(x355+((new_r11*new_r22))+(((-1.0)*new_r21*x356)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j41]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nCheckValue<IkReal> x358=IKPowWithIntegerCheck(cj40,-1);\nif(!x358.valid){\ncontinue;\n}\nIkReal x357=x358.value;\nCheckValue<IkReal> x359=IKPowWithIntegerCheck(cj39,-1);\nif(!x359.valid){\ncontinue;\n}\nCheckValue<IkReal> x360=IKPowWithIntegerCheck(sj40,-1);\nif(!x360.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r20*x357)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x357*(x359.value)*(x360.value)*((((new_r20*sj39))+(((-1.0)*cj40*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20*x357))+IKsqr((x357*(x359.value)*(x360.value)*((((new_r20*sj39))+(((-1.0)*cj40*new_r11))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((-1.0)*new_r20*x357), (x357*(x359.value)*(x360.value)*((((new_r20*sj39))+(((-1.0)*cj40*new_r11))))));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[12];\nIkReal x361=IKsin(j41);\nIkReal x362=IKcos(j41);\nIkReal x363=((1.0)*sj39);\nIkReal x364=(cj39*new_r10);\nIkReal x365=(cj39*new_r11);\nIkReal x366=(sj40*x362);\nIkReal x367=(sj40*x361);\nIkReal x368=((1.0)*x362);\nevalcond[0]=(((cj40*x361))+new_r20);\nevalcond[1]=(((cj40*x362))+new_r21);\nevalcond[2]=(((cj39*new_r01))+((new_r11*sj39))+x361);\nevalcond[3]=(((cj39*new_r00))+(((-1.0)*x368))+((new_r10*sj39)));\nevalcond[4]=(((sj39*x361))+new_r11+((cj39*x366)));\nevalcond[5]=((((-1.0)*new_r00*x363))+x364+x367);\nevalcond[6]=(x365+x366+(((-1.0)*new_r01*x363)));\nevalcond[7]=((((-1.0)*x363*x366))+new_r01+((cj39*x361)));\nevalcond[8]=((((-1.0)*x362*x363))+new_r10+((cj39*x367)));\nevalcond[9]=((((-1.0)*x363*x367))+(((-1.0)*cj39*x368))+new_r00);\nevalcond[10]=((((-1.0)*new_r00*sj40*x363))+((sj40*x364))+((cj40*new_r20))+x361);\nevalcond[11]=(((sj40*x365))+((cj40*new_r21))+(((-1.0)*new_r01*sj40*x363))+x362);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nCheckValue<IkReal> x370=IKPowWithIntegerCheck(cj40,-1);\nif(!x370.valid){\ncontinue;\n}\nIkReal x369=x370.value;\nCheckValue<IkReal> x371=IKPowWithIntegerCheck(sj39,-1);\nif(!x371.valid){\ncontinue;\n}\nif( IKabs((x369*(x371.value)*((((cj39*new_r21*sj40))+(((-1.0)*cj40*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21*x369)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x369*(x371.value)*((((cj39*new_r21*sj40))+(((-1.0)*cj40*new_r11))))))+IKsqr(((-1.0)*new_r21*x369))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2((x369*(x371.value)*((((cj39*new_r21*sj40))+(((-1.0)*cj40*new_r11))))), ((-1.0)*new_r21*x369));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[12];\nIkReal x372=IKsin(j41);\nIkReal x373=IKcos(j41);\nIkReal x374=((1.0)*sj39);\nIkReal x375=(cj39*new_r10);\nIkReal x376=(cj39*new_r11);\nIkReal x377=(sj40*x373);\nIkReal x378=(sj40*x372);\nIkReal x379=((1.0)*x373);\nevalcond[0]=(((cj40*x372))+new_r20);\nevalcond[1]=(((cj40*x373))+new_r21);\nevalcond[2]=(((cj39*new_r01))+((new_r11*sj39))+x372);\nevalcond[3]=(((cj39*new_r00))+(((-1.0)*x379))+((new_r10*sj39)));\nevalcond[4]=(((sj39*x372))+new_r11+((cj39*x377)));\nevalcond[5]=((((-1.0)*new_r00*x374))+x378+x375);\nevalcond[6]=(x377+x376+(((-1.0)*new_r01*x374)));\nevalcond[7]=((((-1.0)*x374*x377))+new_r01+((cj39*x372)));\nevalcond[8]=((((-1.0)*x373*x374))+new_r10+((cj39*x378)));\nevalcond[9]=((((-1.0)*cj39*x379))+(((-1.0)*x374*x378))+new_r00);\nevalcond[10]=((((-1.0)*new_r00*sj40*x374))+((sj40*x375))+((cj40*new_r20))+x372);\nevalcond[11]=(((sj40*x376))+((cj40*new_r21))+x373+(((-1.0)*new_r01*sj40*x374)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nCheckValue<IkReal> x380=IKPowWithIntegerCheck(IKsign(cj40),-1);\nif(!x380.valid){\ncontinue;\n}\nCheckValue<IkReal> x381 = IKatan2WithCheck(IkReal(((-1.0)*new_r20)),((-1.0)*new_r21),IKFAST_ATAN2_MAGTHRESH);\nif(!x381.valid){\ncontinue;\n}\nj41array[0]=((-1.5707963267949)+(((1.5707963267949)*(x380.value)))+(x381.value));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[12];\nIkReal x382=IKsin(j41);\nIkReal x383=IKcos(j41);\nIkReal x384=((1.0)*sj39);\nIkReal x385=(cj39*new_r10);\nIkReal x386=(cj39*new_r11);\nIkReal x387=(sj40*x383);\nIkReal x388=(sj40*x382);\nIkReal x389=((1.0)*x383);\nevalcond[0]=(new_r20+((cj40*x382)));\nevalcond[1]=(new_r21+((cj40*x383)));\nevalcond[2]=(((cj39*new_r01))+((new_r11*sj39))+x382);\nevalcond[3]=(((cj39*new_r00))+((new_r10*sj39))+(((-1.0)*x389)));\nevalcond[4]=(((cj39*x387))+((sj39*x382))+new_r11);\nevalcond[5]=((((-1.0)*new_r00*x384))+x385+x388);\nevalcond[6]=((((-1.0)*new_r01*x384))+x386+x387);\nevalcond[7]=((((-1.0)*x384*x387))+((cj39*x382))+new_r01);\nevalcond[8]=(((cj39*x388))+new_r10+(((-1.0)*x383*x384)));\nevalcond[9]=((((-1.0)*cj39*x389))+(((-1.0)*x384*x388))+new_r00);\nevalcond[10]=(((cj40*new_r20))+x382+((sj40*x385))+(((-1.0)*new_r00*sj40*x384)));\nevalcond[11]=(((cj40*new_r21))+x383+((sj40*x386))+(((-1.0)*new_r01*sj40*x384)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j39array[1], cj39array[1], sj39array[1];\nbool j39valid[1]={false};\n_nj39 = 1;\nCheckValue<IkReal> x390=IKPowWithIntegerCheck(IKsign(cj40),-1);\nif(!x390.valid){\ncontinue;\n}\nCheckValue<IkReal> x391 = IKatan2WithCheck(IkReal(((-1.0)*new_r02)),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x391.valid){\ncontinue;\n}\nj39array[0]=((-1.5707963267949)+(((1.5707963267949)*(x390.value)))+(x391.value));\nsj39array[0]=IKsin(j39array[0]);\ncj39array[0]=IKcos(j39array[0]);\nif( j39array[0] > IKPI )\n{\n    j39array[0]-=IK2PI;\n}\nelse if( j39array[0] < -IKPI )\n{    j39array[0]+=IK2PI;\n}\nj39valid[0] = true;\nfor(int ij39 = 0; ij39 < 1; ++ij39)\n{\nif( !j39valid[ij39] )\n{\n    continue;\n}\n_ij39[0] = ij39; _ij39[1] = -1;\nfor(int iij39 = ij39+1; iij39 < 1; ++iij39)\n{\nif( j39valid[iij39] && IKabs(cj39array[ij39]-cj39array[iij39]) < IKFAST_SOLUTION_THRESH && IKabs(sj39array[ij39]-sj39array[iij39]) < IKFAST_SOLUTION_THRESH )\n{\n    j39valid[iij39]=false; _ij39[1] = iij39; break; \n}\n}\nj39 = j39array[ij39]; cj39 = cj39array[ij39]; sj39 = sj39array[ij39];\n{\nIkReal evalcond[8];\nIkReal x392=IKsin(j39);\nIkReal x393=IKcos(j39);\nIkReal x394=((1.0)*cj40);\nIkReal x395=(cj40*x392);\nIkReal x396=(new_r12*x393);\nIkReal x397=((1.0)*new_r02*x392);\nevalcond[0]=(x395+new_r02);\nevalcond[1]=(new_r12+(((-1.0)*x393*x394)));\nevalcond[2]=(((new_r02*x393))+((new_r12*x392)));\nevalcond[3]=((((-1.0)*x394))+(((-1.0)*x397))+x396);\nevalcond[4]=(((new_r20*sj40))+(((-1.0)*new_r10*x393*x394))+((new_r00*x395)));\nevalcond[5]=(((new_r21*sj40))+((new_r01*x395))+(((-1.0)*new_r11*x393*x394)));\nevalcond[6]=(((sj40*x396))+((cj40*new_r22))+(((-1.0)*sj40*x397)));\nevalcond[7]=((1.0)+(((-1.0)*x394*x396))+((new_r22*sj40))+((new_r02*x395)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j41eval[2];\nIkReal x398=((1.0)*sj37);\nIkReal x399=(sj36*sj38);\nIkReal x400=(cj36*cj38);\nIkReal x401=(cj37*sj35);\nIkReal x402=((1.0)*sj36);\nIkReal x403=(cj36*cj37);\nIkReal x404=((1.0)*sj38);\nIkReal x405=(cj35*cj37);\nIkReal x406=(cj36*sj38);\nIkReal x407=((1.0)*sj35);\nIkReal x408=((-1.0)*sj38);\nIkReal x409=x137;\nIkReal x410=x138;\nIkReal x411=x139;\nIkReal x412=((((-1.0)*x398*x399))+x400);\nIkReal x413=(cj35*x412);\nIkReal x414=(sj35*x412);\nIkReal x415=x143;\nIkReal x416=x144;\nIkReal x417=(((cj35*x410))+((cj38*x401)));\nIkReal x418=((((-1.0)*x407*x410))+((cj38*x405)));\nIkReal x419=((((-1.0)*x401*x404))+x413);\nIkReal x420=(((x405*x408))+(((-1.0)*x414)));\nnew_r00=(((r00*x415))+((r10*x409))+((r20*x403)));\nnew_r01=(((r11*x409))+((r01*x415))+((r21*x403)));\nnew_r02=(((r22*x403))+((r12*x409))+((r02*x415)));\nnew_r10=(((r00*x418))+((r20*x411))+((r10*x417)));\nnew_r11=(((r11*x417))+((r01*x418))+((r21*x411)));\nnew_r12=(((r12*x417))+((r22*x411))+((r02*x418)));\nnew_r20=(((r00*x420))+((r20*x416))+((r10*x419)));\nnew_r21=(((r21*x416))+((r11*((x413+((x401*x408))))))+((r01*(((((-1.0)*x404*x405))+(((-1.0)*x407*x412)))))));\nnew_r22=(((r12*x419))+((r22*x416))+((r02*x420)));\nj41eval[0]=cj40;\nj41eval[1]=IKsign(cj40);\nif( IKabs(j41eval[0]) < 0.0000010000000000  || IKabs(j41eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j41eval[2];\nIkReal x421=((1.0)*sj37);\nIkReal x422=(sj36*sj38);\nIkReal x423=(cj36*cj38);\nIkReal x424=(cj37*sj35);\nIkReal x425=((1.0)*sj36);\nIkReal x426=(cj36*cj37);\nIkReal x427=((1.0)*sj38);\nIkReal x428=(cj35*cj37);\nIkReal x429=(cj36*sj38);\nIkReal x430=((1.0)*sj35);\nIkReal x431=((-1.0)*sj38);\nIkReal x432=x137;\nIkReal x433=x138;\nIkReal x434=x139;\nIkReal x435=((((-1.0)*x421*x422))+x423);\nIkReal x436=(cj35*x435);\nIkReal x437=(sj35*x435);\nIkReal x438=x143;\nIkReal x439=x144;\nIkReal x440=(((cj35*x433))+((cj38*x424)));\nIkReal x441=((((-1.0)*x430*x433))+((cj38*x428)));\nIkReal x442=(x436+(((-1.0)*x424*x427)));\nIkReal x443=((((-1.0)*x437))+((x428*x431)));\nnew_r00=(((r20*x426))+((r00*x438))+((r10*x432)));\nnew_r01=(((r21*x426))+((r01*x438))+((r11*x432)));\nnew_r02=(((r12*x432))+((r02*x438))+((r22*x426)));\nnew_r10=(((r00*x441))+((r10*x440))+((r20*x434)));\nnew_r11=(((r21*x434))+((r01*x441))+((r11*x440)));\nnew_r12=(((r02*x441))+((r22*x434))+((r12*x440)));\nnew_r20=(((r00*x443))+((r10*x442))+((r20*x439)));\nnew_r21=(((r21*x439))+((r11*((((x424*x431))+x436))))+((r01*(((((-1.0)*x430*x435))+(((-1.0)*x427*x428)))))));\nnew_r22=(((r02*x443))+((r22*x439))+((r12*x442)));\nj41eval[0]=cj40;\nj41eval[1]=sj39;\nif( IKabs(j41eval[0]) < 0.0000010000000000  || IKabs(j41eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j41eval[3];\nIkReal x444=((1.0)*sj37);\nIkReal x445=(sj36*sj38);\nIkReal x446=(cj36*cj38);\nIkReal x447=(cj37*sj35);\nIkReal x448=((1.0)*sj36);\nIkReal x449=(cj36*cj37);\nIkReal x450=((1.0)*sj38);\nIkReal x451=(cj35*cj37);\nIkReal x452=(cj36*sj38);\nIkReal x453=((1.0)*sj35);\nIkReal x454=((-1.0)*sj38);\nIkReal x455=x137;\nIkReal x456=x138;\nIkReal x457=x139;\nIkReal x458=((((-1.0)*x444*x445))+x446);\nIkReal x459=(cj35*x458);\nIkReal x460=(sj35*x458);\nIkReal x461=x143;\nIkReal x462=x144;\nIkReal x463=(((cj35*x456))+((cj38*x447)));\nIkReal x464=(((cj38*x451))+(((-1.0)*x453*x456)));\nIkReal x465=((((-1.0)*x447*x450))+x459);\nIkReal x466=((((-1.0)*x460))+((x451*x454)));\nnew_r00=(((r00*x461))+((r20*x449))+((r10*x455)));\nnew_r01=(((r21*x449))+((r11*x455))+((r01*x461)));\nnew_r02=(((r22*x449))+((r02*x461))+((r12*x455)));\nnew_r10=(((r20*x457))+((r00*x464))+((r10*x463)));\nnew_r11=(((r11*x463))+((r01*x464))+((r21*x457)));\nnew_r12=(((r12*x463))+((r02*x464))+((r22*x457)));\nnew_r20=(((r20*x462))+((r00*x466))+((r10*x465)));\nnew_r21=(((r01*(((((-1.0)*x453*x458))+(((-1.0)*x450*x451))))))+((r21*x462))+((r11*((((x447*x454))+x459)))));\nnew_r22=(((r22*x462))+((r12*x465))+((r02*x466)));\nj41eval[0]=cj40;\nj41eval[1]=cj39;\nj41eval[2]=sj40;\nif( IKabs(j41eval[0]) < 0.0000010000000000  || IKabs(j41eval[1]) < 0.0000010000000000  || IKabs(j41eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x467=(new_r12*sj39);\nIkReal x468=((1.0)*new_r02);\nIkReal x469=((((-1.0)*sj39*x468))+((cj39*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j40)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r20;\nevalcond[4]=new_r21;\nevalcond[5]=new_r12;\nevalcond[6]=(((cj39*new_r02))+x467);\nevalcond[7]=((((-1.0)*x467))+(((-1.0)*cj39*x468)));\nevalcond[8]=x469;\nevalcond[9]=x469;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nIkReal x470=((1.0)*cj39);\nif( IKabs(((((-1.0)*new_r11*sj39))+(((-1.0)*new_r01*x470)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj39))+(((-1.0)*new_r11*x470)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj39))+(((-1.0)*new_r01*x470))))+IKsqr((((new_r01*sj39))+(((-1.0)*new_r11*x470))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((((-1.0)*new_r11*sj39))+(((-1.0)*new_r01*x470))), (((new_r01*sj39))+(((-1.0)*new_r11*x470))));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x471=IKsin(j41);\nIkReal x472=IKcos(j41);\nIkReal x473=((1.0)*sj39);\nIkReal x474=(cj39*x471);\nIkReal x475=(cj39*x472);\nIkReal x476=(x472*x473);\nevalcond[0]=(((cj39*new_r01))+((new_r11*sj39))+x471);\nevalcond[1]=((((-1.0)*new_r00*x473))+x471+((cj39*new_r10)));\nevalcond[2]=((((-1.0)*new_r01*x473))+x472+((cj39*new_r11)));\nevalcond[3]=(((cj39*new_r00))+(((-1.0)*x472))+((new_r10*sj39)));\nevalcond[4]=(((sj39*x471))+x475+new_r11);\nevalcond[5]=((((-1.0)*x476))+x474+new_r01);\nevalcond[6]=((((-1.0)*x476))+x474+new_r10);\nevalcond[7]=((((-1.0)*x475))+(((-1.0)*x471*x473))+new_r00);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x477=(new_r12*sj39);\nIkReal x478=(new_r02*sj39);\nIkReal x479=(cj39*new_r12);\nIkReal x480=(cj39*new_r02);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j40)))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r20;\nevalcond[4]=new_r21;\nevalcond[5]=new_r12;\nevalcond[6]=(x480+x477);\nevalcond[7]=((((-1.0)*x480))+(((-1.0)*x477)));\nevalcond[8]=((((-1.0)*x478))+x479);\nevalcond[9]=((((-1.0)*x479))+x478);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nIkReal x481=((1.0)*new_r01);\nif( IKabs(((((-1.0)*new_r11*sj39))+(((-1.0)*cj39*x481)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj39*x481))+((cj39*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj39))+(((-1.0)*cj39*x481))))+IKsqr(((((-1.0)*sj39*x481))+((cj39*new_r11))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((((-1.0)*new_r11*sj39))+(((-1.0)*cj39*x481))), ((((-1.0)*sj39*x481))+((cj39*new_r11))));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x482=IKcos(j41);\nIkReal x483=IKsin(j41);\nIkReal x484=((1.0)*sj39);\nIkReal x485=((1.0)*x482);\nIkReal x486=(sj39*x483);\nIkReal x487=(cj39*x483);\nIkReal x488=(cj39*x485);\nevalcond[0]=(((cj39*new_r01))+((new_r11*sj39))+x483);\nevalcond[1]=(((cj39*new_r00))+(((-1.0)*x485))+((new_r10*sj39)));\nevalcond[2]=(((sj39*x482))+x487+new_r01);\nevalcond[3]=((((-1.0)*x488))+x486+new_r11);\nevalcond[4]=((((-1.0)*new_r00*x484))+(((-1.0)*x483))+((cj39*new_r10)));\nevalcond[5]=((((-1.0)*new_r01*x484))+(((-1.0)*x485))+((cj39*new_r11)));\nevalcond[6]=((((-1.0)*x488))+x486+new_r00);\nevalcond[7]=((((-1.0)*x487))+(((-1.0)*x482*x484))+new_r10);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x489=(sj40+new_r22);\nIkReal x490=((1.0)*new_r02);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j39)))), 6.28318530717959)));\nevalcond[1]=x489;\nevalcond[2]=x489;\nevalcond[3]=(cj40+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x490))+(((-1.0)*cj40)));\nevalcond[6]=(((new_r20*sj40))+((cj40*new_r00)));\nevalcond[7]=(((new_r21*sj40))+((cj40*new_r01)));\nevalcond[8]=(((cj40*new_r22))+(((-1.0)*sj40*x490)));\nevalcond[9]=((1.0)+((new_r22*sj40))+((cj40*new_r02)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nif( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((-1.0)*new_r11), new_r10);\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x491=IKsin(j41);\nIkReal x492=IKcos(j41);\nIkReal x493=((1.0)*new_r02);\nIkReal x494=((1.0)*x492);\nevalcond[0]=(x491+new_r11);\nevalcond[1]=((((-1.0)*x494))+new_r10);\nevalcond[2]=((((-1.0)*x491*x493))+new_r20);\nevalcond[3]=(new_r21+(((-1.0)*x492*x493)));\nevalcond[4]=((((-1.0)*new_r22*x491))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*new_r22*x494))+(((-1.0)*new_r01)));\nevalcond[6]=((((-1.0)*new_r20*x493))+((new_r00*new_r22))+x491);\nevalcond[7]=((((-1.0)*new_r21*x493))+((new_r01*new_r22))+x492);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x495=(sj40+new_r22);\nIkReal x496=((((-1.0)*cj40))+new_r02);\nIkReal x497=((1.0)*cj40);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j39)))), 6.28318530717959)));\nevalcond[1]=x495;\nevalcond[2]=x495;\nevalcond[3]=x496;\nevalcond[4]=new_r12;\nevalcond[5]=x496;\nevalcond[6]=((((-1.0)*new_r00*x497))+((new_r20*sj40)));\nevalcond[7]=((((-1.0)*new_r01*x497))+((new_r21*sj40)));\nevalcond[8]=(((cj40*new_r22))+((new_r02*sj40)));\nevalcond[9]=((1.0)+(((-1.0)*new_r02*x497))+((new_r22*sj40)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nCheckValue<IkReal> x498=IKPowWithIntegerCheck(IKsign(new_r02),-1);\nif(!x498.valid){\ncontinue;\n}\nCheckValue<IkReal> x499 = IKatan2WithCheck(IkReal(((-1.0)*new_r20)),((-1.0)*new_r21),IKFAST_ATAN2_MAGTHRESH);\nif(!x499.valid){\ncontinue;\n}\nj41array[0]=((-1.5707963267949)+(((1.5707963267949)*(x498.value)))+(x499.value));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x500=IKsin(j41);\nIkReal x501=IKcos(j41);\nIkReal x502=((1.0)*new_r22);\nevalcond[0]=(((new_r02*x500))+new_r20);\nevalcond[1]=(((new_r02*x501))+new_r21);\nevalcond[2]=(x500+(((-1.0)*new_r11)));\nevalcond[3]=(new_r00+(((-1.0)*x500*x502)));\nevalcond[4]=((((-1.0)*x501*x502))+new_r01);\nevalcond[5]=((((-1.0)*new_r10))+(((-1.0)*x501)));\nevalcond[6]=((((-1.0)*new_r00*x502))+x500+((new_r02*new_r20)));\nevalcond[7]=((((-1.0)*new_r01*x502))+x501+((new_r02*new_r21)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x503=(new_r12*sj39);\nIkReal x504=((1.0)*sj39);\nIkReal x505=((1.0)*cj39);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j40))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(sj39+new_r02);\nevalcond[3]=((((-1.0)*x505))+new_r12);\nevalcond[4]=(((cj39*new_r02))+x503);\nevalcond[5]=((((-1.0)*new_r02*x505))+(((-1.0)*x503)));\nevalcond[6]=((-1.0)+(((-1.0)*new_r02*x504))+((cj39*new_r12)));\nevalcond[7]=((((-1.0)*new_r00*x504))+((cj39*new_r10)));\nevalcond[8]=((((-1.0)*new_r01*x504))+((cj39*new_r11)));\nevalcond[9]=(((new_r00*sj39))+(((-1.0)*new_r10*x505)));\nevalcond[10]=(((new_r01*sj39))+(((-1.0)*new_r11*x505)));\nevalcond[11]=((1.0)+((new_r02*sj39))+(((-1.0)*new_r12*x505)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nif( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x506=IKsin(j41);\nIkReal x507=IKcos(j41);\nIkReal x508=((1.0)*new_r02);\nIkReal x509=((1.0)*x507);\nevalcond[0]=(x506+new_r20);\nevalcond[1]=(x507+new_r21);\nevalcond[2]=(((new_r12*x506))+new_r01);\nevalcond[3]=(((new_r02*x507))+new_r10);\nevalcond[4]=((((-1.0)*x506*x508))+new_r11);\nevalcond[5]=(new_r00+(((-1.0)*new_r12*x509)));\nevalcond[6]=(((new_r01*new_r12))+(((-1.0)*new_r11*x508))+x506);\nevalcond[7]=((((-1.0)*x509))+((new_r00*new_r12))+(((-1.0)*new_r10*x508)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x510=(new_r12*sj39);\nIkReal x511=((1.0)*sj39);\nIkReal x512=(cj39*new_r02);\nIkReal x513=((((-1.0)*new_r00*x511))+((cj39*new_r10)));\nIkReal x514=((((-1.0)*new_r01*x511))+((cj39*new_r11)));\nIkReal x515=((1.0)+(((-1.0)*new_r02*x511))+((cj39*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j40)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(new_r02+(((-1.0)*x511)));\nevalcond[3]=(cj39+new_r12);\nevalcond[4]=(x512+x510);\nevalcond[5]=((((-1.0)*x510))+(((-1.0)*x512)));\nevalcond[6]=x515;\nevalcond[7]=x513;\nevalcond[8]=x514;\nevalcond[9]=x513;\nevalcond[10]=x514;\nevalcond[11]=x515;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nif( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(new_r20, new_r21);\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x516=IKsin(j41);\nIkReal x517=IKcos(j41);\nIkReal x518=((1.0)*new_r12);\nIkReal x519=((1.0)*x517);\nevalcond[0]=((((-1.0)*x516))+new_r20);\nevalcond[1]=(new_r21+(((-1.0)*x519)));\nevalcond[2]=(((new_r02*x516))+new_r11);\nevalcond[3]=(((new_r12*x517))+new_r00);\nevalcond[4]=((((-1.0)*x516*x518))+new_r01);\nevalcond[5]=((((-1.0)*new_r02*x519))+new_r10);\nevalcond[6]=((((-1.0)*new_r01*x518))+x516+((new_r02*new_r11)));\nevalcond[7]=(((new_r02*new_r10))+(((-1.0)*new_r00*x518))+(((-1.0)*x519)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x520=(sj40+new_r22);\nIkReal x521=((((-1.0)*cj40))+new_r12);\nIkReal x522=((1.0)*cj40);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j39))), 6.28318530717959)));\nevalcond[1]=x520;\nevalcond[2]=x520;\nevalcond[3]=new_r02;\nevalcond[4]=x521;\nevalcond[5]=x521;\nevalcond[6]=(((new_r20*sj40))+(((-1.0)*new_r10*x522)));\nevalcond[7]=((((-1.0)*new_r11*x522))+((new_r21*sj40)));\nevalcond[8]=(((new_r12*sj40))+((cj40*new_r22)));\nevalcond[9]=((1.0)+(((-1.0)*new_r12*x522))+((new_r22*sj40)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nif( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((-1.0)*new_r01), new_r00);\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x523=IKsin(j41);\nIkReal x524=IKcos(j41);\nIkReal x525=((1.0)*new_r22);\nevalcond[0]=(x523+new_r01);\nevalcond[1]=(((new_r12*x523))+new_r20);\nevalcond[2]=(((new_r12*x524))+new_r21);\nevalcond[3]=((((-1.0)*x524))+new_r00);\nevalcond[4]=((((-1.0)*x524*x525))+new_r11);\nevalcond[5]=((((-1.0)*x523*x525))+new_r10);\nevalcond[6]=(((new_r12*new_r20))+(((-1.0)*new_r10*x525))+x523);\nevalcond[7]=((((-1.0)*new_r11*x525))+((new_r12*new_r21))+x524);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x526=(sj40+new_r22);\nIkReal x527=((1.0)*new_r12);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j39)))), 6.28318530717959)));\nevalcond[1]=x526;\nevalcond[2]=x526;\nevalcond[3]=new_r02;\nevalcond[4]=(cj40+new_r12);\nevalcond[5]=((((-1.0)*x527))+(((-1.0)*cj40)));\nevalcond[6]=(((cj40*new_r10))+((new_r20*sj40)));\nevalcond[7]=(((cj40*new_r11))+((new_r21*sj40)));\nevalcond[8]=(((cj40*new_r22))+(((-1.0)*sj40*x527)));\nevalcond[9]=((1.0)+((cj40*new_r12))+((new_r22*sj40)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nif( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(new_r01, ((-1.0)*new_r00));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[8];\nIkReal x528=IKsin(j41);\nIkReal x529=IKcos(j41);\nIkReal x530=((1.0)*new_r12);\nevalcond[0]=(x528+(((-1.0)*new_r01)));\nevalcond[1]=(new_r11+((new_r22*x529)));\nevalcond[2]=((((-1.0)*x528*x530))+new_r20);\nevalcond[3]=((((-1.0)*x529*x530))+new_r21);\nevalcond[4]=((((-1.0)*x529))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*new_r10))+(((-1.0)*new_r22*x528)));\nevalcond[6]=((((-1.0)*new_r20*x530))+x528+((new_r10*new_r22)));\nevalcond[7]=((((-1.0)*new_r21*x530))+x529+((new_r11*new_r22)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j41]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nCheckValue<IkReal> x532=IKPowWithIntegerCheck(cj40,-1);\nif(!x532.valid){\ncontinue;\n}\nIkReal x531=x532.value;\nCheckValue<IkReal> x533=IKPowWithIntegerCheck(cj39,-1);\nif(!x533.valid){\ncontinue;\n}\nCheckValue<IkReal> x534=IKPowWithIntegerCheck(sj40,-1);\nif(!x534.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r20*x531)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x531*(x533.value)*(x534.value)*((((new_r20*sj39))+(((-1.0)*cj40*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20*x531))+IKsqr((x531*(x533.value)*(x534.value)*((((new_r20*sj39))+(((-1.0)*cj40*new_r11))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2(((-1.0)*new_r20*x531), (x531*(x533.value)*(x534.value)*((((new_r20*sj39))+(((-1.0)*cj40*new_r11))))));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[12];\nIkReal x535=IKsin(j41);\nIkReal x536=IKcos(j41);\nIkReal x537=((1.0)*sj39);\nIkReal x538=(cj39*new_r10);\nIkReal x539=(cj39*new_r11);\nIkReal x540=(sj40*x536);\nIkReal x541=(sj40*x535);\nIkReal x542=((1.0)*x536);\nevalcond[0]=(new_r20+((cj40*x535)));\nevalcond[1]=(new_r21+((cj40*x536)));\nevalcond[2]=(((cj39*new_r01))+((new_r11*sj39))+x535);\nevalcond[3]=(((cj39*new_r00))+(((-1.0)*x542))+((new_r10*sj39)));\nevalcond[4]=(((sj39*x535))+((cj39*x540))+new_r11);\nevalcond[5]=((((-1.0)*new_r00*x537))+x541+x538);\nevalcond[6]=((((-1.0)*new_r01*x537))+x540+x539);\nevalcond[7]=((((-1.0)*x537*x540))+((cj39*x535))+new_r01);\nevalcond[8]=(((cj39*x541))+new_r10+(((-1.0)*x536*x537)));\nevalcond[9]=((((-1.0)*cj39*x542))+(((-1.0)*x537*x541))+new_r00);\nevalcond[10]=(((sj40*x538))+(((-1.0)*new_r00*sj40*x537))+((cj40*new_r20))+x535);\nevalcond[11]=((((-1.0)*new_r01*sj40*x537))+((sj40*x539))+((cj40*new_r21))+x536);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nCheckValue<IkReal> x544=IKPowWithIntegerCheck(cj40,-1);\nif(!x544.valid){\ncontinue;\n}\nIkReal x543=x544.value;\nCheckValue<IkReal> x545=IKPowWithIntegerCheck(sj39,-1);\nif(!x545.valid){\ncontinue;\n}\nif( IKabs((x543*(x545.value)*((((cj39*new_r21*sj40))+(((-1.0)*cj40*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21*x543)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x543*(x545.value)*((((cj39*new_r21*sj40))+(((-1.0)*cj40*new_r11))))))+IKsqr(((-1.0)*new_r21*x543))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj41array[0]=IKatan2((x543*(x545.value)*((((cj39*new_r21*sj40))+(((-1.0)*cj40*new_r11))))), ((-1.0)*new_r21*x543));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[12];\nIkReal x546=IKsin(j41);\nIkReal x547=IKcos(j41);\nIkReal x548=((1.0)*sj39);\nIkReal x549=(cj39*new_r10);\nIkReal x550=(cj39*new_r11);\nIkReal x551=(sj40*x547);\nIkReal x552=(sj40*x546);\nIkReal x553=((1.0)*x547);\nevalcond[0]=(new_r20+((cj40*x546)));\nevalcond[1]=(new_r21+((cj40*x547)));\nevalcond[2]=(((cj39*new_r01))+((new_r11*sj39))+x546);\nevalcond[3]=(((cj39*new_r00))+((new_r10*sj39))+(((-1.0)*x553)));\nevalcond[4]=(((sj39*x546))+((cj39*x551))+new_r11);\nevalcond[5]=((((-1.0)*new_r00*x548))+x552+x549);\nevalcond[6]=((((-1.0)*new_r01*x548))+x551+x550);\nevalcond[7]=(((cj39*x546))+(((-1.0)*x548*x551))+new_r01);\nevalcond[8]=(((cj39*x552))+(((-1.0)*x547*x548))+new_r10);\nevalcond[9]=((((-1.0)*x548*x552))+new_r00+(((-1.0)*cj39*x553)));\nevalcond[10]=((((-1.0)*new_r00*sj40*x548))+((sj40*x549))+((cj40*new_r20))+x546);\nevalcond[11]=((((-1.0)*new_r01*sj40*x548))+((sj40*x550))+((cj40*new_r21))+x547);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j41array[1], cj41array[1], sj41array[1];\nbool j41valid[1]={false};\n_nj41 = 1;\nCheckValue<IkReal> x554=IKPowWithIntegerCheck(IKsign(cj40),-1);\nif(!x554.valid){\ncontinue;\n}\nCheckValue<IkReal> x555 = IKatan2WithCheck(IkReal(((-1.0)*new_r20)),((-1.0)*new_r21),IKFAST_ATAN2_MAGTHRESH);\nif(!x555.valid){\ncontinue;\n}\nj41array[0]=((-1.5707963267949)+(((1.5707963267949)*(x554.value)))+(x555.value));\nsj41array[0]=IKsin(j41array[0]);\ncj41array[0]=IKcos(j41array[0]);\nif( j41array[0] > IKPI )\n{\n    j41array[0]-=IK2PI;\n}\nelse if( j41array[0] < -IKPI )\n{    j41array[0]+=IK2PI;\n}\nj41valid[0] = true;\nfor(int ij41 = 0; ij41 < 1; ++ij41)\n{\nif( !j41valid[ij41] )\n{\n    continue;\n}\n_ij41[0] = ij41; _ij41[1] = -1;\nfor(int iij41 = ij41+1; iij41 < 1; ++iij41)\n{\nif( j41valid[iij41] && IKabs(cj41array[ij41]-cj41array[iij41]) < IKFAST_SOLUTION_THRESH && IKabs(sj41array[ij41]-sj41array[iij41]) < IKFAST_SOLUTION_THRESH )\n{\n    j41valid[iij41]=false; _ij41[1] = iij41; break; \n}\n}\nj41 = j41array[ij41]; cj41 = cj41array[ij41]; sj41 = sj41array[ij41];\n{\nIkReal evalcond[12];\nIkReal x556=IKsin(j41);\nIkReal x557=IKcos(j41);\nIkReal x558=((1.0)*sj39);\nIkReal x559=(cj39*new_r10);\nIkReal x560=(cj39*new_r11);\nIkReal x561=(sj40*x557);\nIkReal x562=(sj40*x556);\nIkReal x563=((1.0)*x557);\nevalcond[0]=(((cj40*x556))+new_r20);\nevalcond[1]=(((cj40*x557))+new_r21);\nevalcond[2]=(((cj39*new_r01))+((new_r11*sj39))+x556);\nevalcond[3]=(((cj39*new_r00))+((new_r10*sj39))+(((-1.0)*x563)));\nevalcond[4]=(((sj39*x556))+((cj39*x561))+new_r11);\nevalcond[5]=((((-1.0)*new_r00*x558))+x559+x562);\nevalcond[6]=((((-1.0)*new_r01*x558))+x560+x561);\nevalcond[7]=(((cj39*x556))+(((-1.0)*x558*x561))+new_r01);\nevalcond[8]=(((cj39*x562))+new_r10+(((-1.0)*x557*x558)));\nevalcond[9]=((((-1.0)*x558*x562))+(((-1.0)*cj39*x563))+new_r00);\nevalcond[10]=(((sj40*x559))+((cj40*new_r20))+x556+(((-1.0)*new_r00*sj40*x558)));\nevalcond[11]=((((-1.0)*new_r01*sj40*x558))+((cj40*new_r21))+x557+((sj40*x560)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j35;\nvinfos[0].indices[0] = _ij35[0];\nvinfos[0].indices[1] = _ij35[1];\nvinfos[0].maxsolutions = _nj35;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j36;\nvinfos[1].indices[0] = _ij36[0];\nvinfos[1].indices[1] = _ij36[1];\nvinfos[1].maxsolutions = _nj36;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j37;\nvinfos[2].indices[0] = _ij37[0];\nvinfos[2].indices[1] = _ij37[1];\nvinfos[2].maxsolutions = _nj37;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j38;\nvinfos[3].indices[0] = _ij38[0];\nvinfos[3].indices[1] = _ij38[1];\nvinfos[3].maxsolutions = _nj38;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j39;\nvinfos[4].indices[0] = _ij39[0];\nvinfos[4].indices[1] = _ij39[1];\nvinfos[4].maxsolutions = _nj39;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j40;\nvinfos[5].indices[0] = _ij40[0];\nvinfos[5].indices[1] = _ij40[1];\nvinfos[5].maxsolutions = _nj40;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j41;\nvinfos[6].indices[0] = _ij41[0];\nvinfos[6].indices[1] = _ij41[1];\nvinfos[6].maxsolutions = _nj41;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\n}};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"35fe0337ca3afc2d90bba8543ebceff2\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\nchar* ComputeFkWrapper(const IkReal* j) {\n    IkReal eetrans[3] = {0};\n    IkReal eerot[9] = {0};\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n\nstd::vector<IkReal> TrueComputeIk(int argc, char** argv)\n{\n    std::vector<IkReal> solvalues(GetNumJoints());\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return solvalues;\n}\n"]}