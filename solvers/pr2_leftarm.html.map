{"version":3,"file":"./solvers/pr2_leftarm.html","sources":["./solvers/pr2_leftarm.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAvMA;AAAA;AAAA;;;;;;;;AAFA;AAAA;AAAA;;;;;AA6MA;;;;;;;;;;;;;;;AA21QA;AACA;AACA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-05-22 19:38:57.795783\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56;\nx0=IKcos(j[0]);\nx1=IKcos(j[1]);\nx2=IKsin(j[3]);\nx3=IKcos(j[3]);\nx4=IKsin(j[1]);\nx5=IKsin(j[2]);\nx6=IKcos(j[2]);\nx7=IKsin(j[0]);\nx8=IKcos(j[4]);\nx9=IKsin(j[4]);\nx10=IKsin(j[5]);\nx11=IKcos(j[5]);\nx12=IKcos(j[6]);\nx13=IKsin(j[6]);\nx14=((1.0)*x10);\nx15=((1.0)*x9);\nx16=((0.321)*x6);\nx17=((1.0)*x7);\nx18=((1.0)*x11);\nx19=((1.0)*x6);\nx20=((0.4)*x1);\nx21=(x1*x2);\nx22=(x0*x6);\nx23=(x2*x4);\nx24=(x0*x5);\nx25=((-1.0)*x0);\nx26=(x3*x4);\nx27=((-1.0)*x3);\nx28=(x4*x7);\nx29=((-1.0)*x2);\nx30=(x1*x3);\nx31=(x30*x7);\nx32=(x1*x5*x8);\nx33=((1.0)*x0*x21);\nx34=(x17*x21);\nx35=(x19*x30);\nx36=((((-1.0)*x17*x6))+((x24*x4)));\nx37=((((-1.0)*x17*x4*x6))+x24);\nx38=(x22+((x28*x5)));\nx39=((((-1.0)*x23))+x35);\nx40=((1.0)*x37);\nx41=((((-1.0)*x17*x5))+(((-1.0)*x0*x19*x4)));\nx42=(x36*x9);\nx43=(x38*x9);\nx44=(x3*x37);\nx45=(((x19*x21))+(((1.0)*x26)));\nx46=(x36*x8);\nx47=(x2*x37);\nx48=(x38*x8);\nx49=(x3*x41);\nx50=((-1.0)*x41);\nx51=(((x1*x5*x9))+((x8*(((((-1.0)*x35))+x23)))));\nx52=(((x27*x41))+x33);\nx53=(x52*x9);\nx54=(x43+((x8*(((((-1.0)*x21*x7))+x44)))));\nx55=((((-1.0)*x18*x51))+(((-1.0)*x14*x45)));\nx56=((((-1.0)*x18*(((((1.0)*x8*(((((-1.0)*x33))+x49))))+(((1.0)*x42))))))+((x14*(((((-1.0)*x25*x30))+(((-1.0)*x29*x41)))))));\neerot[0]=(((x11*((((x2*x41))+((x0*x30))))))+((x10*((((x8*((((x21*x25))+x49))))+x42)))));\neerot[1]=(((x13*x56))+((x12*((x46+x53)))));\neerot[2]=(((x12*x56))+((x13*(((((-1.0)*x46))+(((-1.0)*x53)))))));\neetrans[0]=(((x0*x20))+(((0.1)*x0))+(((0.321)*x0*x30))+((x2*(((((-0.321)*x5*x7))+(((-1.0)*x0*x16*x4)))))));\neerot[3]=(((x11*((x31+x47))))+((x10*((((x8*(((((-1.0)*x34))+x44))))+x43)))));\neerot[4]=((((-1.0)*x13*((((x14*(((((-1.0)*x17*x30))+(((-1.0)*x2*x40))))))+((x18*x54))))))+((x12*((((x9*((((x27*x37))+x34))))+x48)))));\neerot[5]=(((x12*(((((-1.0)*x11*x54))+(((-1.0)*x10*((((x29*x37))+((x1*x27*x7))))))))))+(((-1.0)*x13*((((x15*(((((-1.0)*x3*x40))+x34))))+(((1.0)*x48)))))));\neetrans[1]=((0.188)+(((0.1)*x7))+(((0.321)*x31))+((x2*(((((-1.0)*x16*x28))+(((0.321)*x24))))))+((x20*x7)));\neerot[6]=(((x10*x51))+(((-1.0)*x11*x45)));\neerot[7]=(((x13*x55))+((x12*((x32+((x39*x9)))))));\neerot[8]=(((x12*x55))+((x13*(((((-1.0)*x32))+(((-1.0)*x15*x39)))))));\neetrans[2]=((((-1.0)*x16*x21))+(((-0.4)*x4))+(((-0.321)*x26)));\n}\n\nIKFAST_API int GetNumFreeParameters() { return 1; }\nIKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }\nIKFAST_API int GetNumJoints() { return 7; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j15,cj15,sj15,htj15,j15mul,j16,cj16,sj16,htj16,j16mul,j18,cj18,sj18,htj18,j18mul,j19,cj19,sj19,htj19,j19mul,j20,cj20,sj20,htj20,j20mul,j21,cj21,sj21,htj21,j21mul,j17,cj17,sj17,htj17,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij15[2], _nj15,_ij16[2], _nj16,_ij18[2], _nj18,_ij19[2], _nj19,_ij20[2], _nj20,_ij21[2], _nj21,_ij17[2], _nj17;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1; j16=numeric_limits<IkReal>::quiet_NaN(); _ij16[0] = -1; _ij16[1] = -1; _nj16 = -1; j18=numeric_limits<IkReal>::quiet_NaN(); _ij18[0] = -1; _ij18[1] = -1; _nj18 = -1; j19=numeric_limits<IkReal>::quiet_NaN(); _ij19[0] = -1; _ij19[1] = -1; _nj19 = -1; j20=numeric_limits<IkReal>::quiet_NaN(); _ij20[0] = -1; _ij20[1] = -1; _nj20 = -1; j21=numeric_limits<IkReal>::quiet_NaN(); _ij21[0] = -1; _ij21[1] = -1; _nj21 = -1;  _ij17[0] = -1; _ij17[1] = -1; _nj17 = 0; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nj17=pfree[0]; cj17=cos(pfree[0]); sj17=sin(pfree[0]), htj17=tan(pfree[0]*0.5);\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=((-1.0)*r02);\nnew_r01=r01;\nnew_r02=r00;\nnew_px=px;\nnew_r10=((-1.0)*r12);\nnew_r11=r11;\nnew_r12=r10;\nnew_py=((-0.188)+py);\nnew_r20=((-1.0)*r22);\nnew_r21=r21;\nnew_r22=r20;\nnew_pz=pz;\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x57=((1.0)*px);\nIkReal x58=((1.0)*pz);\nIkReal x59=((1.0)*py);\npp=((px*px)+(py*py)+(pz*pz));\nnpx=(((px*r00))+((py*r10))+((pz*r20)));\nnpy=(((px*r01))+((py*r11))+((pz*r21)));\nnpz=(((px*r02))+((py*r12))+((pz*r22)));\nrxp0_0=((((-1.0)*r20*x59))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x58)));\nrxp0_2=((((-1.0)*r10*x57))+((py*r00)));\nrxp1_0=((((-1.0)*r21*x59))+((pz*r11)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x58)));\nrxp1_2=((((-1.0)*r11*x57))+((py*r01)));\nrxp2_0=(((pz*r12))+(((-1.0)*r22*x59)));\nrxp2_1=(((px*r22))+(((-1.0)*r02*x58)));\nrxp2_2=((((-1.0)*r12*x57))+((py*r02)));\nIkReal op[8+1], zeror[8];\nint numroots;\nIkReal x60=((0.2)*px);\nIkReal x61=((1.0)*pp);\nIkReal x62=((0.509841)+x60+(((-1.0)*x61)));\nIkReal x63=((-0.003759)+x60+(((-1.0)*x61)));\nIkReal x64=(x60+x61);\nIkReal x65=((0.509841)+(((-1.0)*x64)));\nIkReal x66=((-0.003759)+(((-1.0)*x64)));\nIkReal gconst0=x62;\nIkReal gconst1=x63;\nIkReal gconst2=x62;\nIkReal gconst3=x63;\nIkReal gconst4=x65;\nIkReal gconst5=x66;\nIkReal gconst6=x65;\nIkReal gconst7=x66;\nIkReal x67=py*py;\nIkReal x68=sj17*sj17;\nIkReal x69=px*px;\nIkReal x70=((1.0)*gconst4);\nIkReal x71=(gconst5*py);\nIkReal x72=((4.0)*px);\nIkReal x73=(gconst0*gconst3);\nIkReal x74=(gconst1*gconst2);\nIkReal x75=((2.0)*gconst5);\nIkReal x76=((1.0)*gconst0);\nIkReal x77=(gconst1*gconst7);\nIkReal x78=(gconst0*gconst6);\nIkReal x79=(gconst1*gconst3);\nIkReal x80=(gconst4*gconst7);\nIkReal x81=(gconst6*py);\nIkReal x82=((2.0)*gconst0);\nIkReal x83=(gconst0*gconst7);\nIkReal x84=((2.0)*gconst4);\nIkReal x85=(gconst3*gconst5);\nIkReal x86=(gconst2*gconst5);\nIkReal x87=(gconst3*gconst4);\nIkReal x88=(gconst5*gconst6);\nIkReal x89=(gconst2*gconst4);\nIkReal x90=(gconst1*gconst6);\nIkReal x91=(px*py);\nIkReal x92=(gconst1*py);\nIkReal x93=(gconst2*py);\nIkReal x94=(gconst5*gconst7);\nIkReal x95=((1.05513984)*x91);\nIkReal x96=(gconst6*x67);\nIkReal x97=((0.3297312)*x68);\nIkReal x98=((4.0)*x69);\nIkReal x99=(gconst2*x67);\nIkReal x100=((2.0)*x67);\nIkReal x101=((1.0)*x67);\nIkReal x102=((0.824328)*x68);\nIkReal x103=((0.412164)*x68);\nIkReal x104=((0.1648656)*x68);\nIkReal x105=(x67*x80);\nIkReal x106=(x67*x88);\nIkReal x107=(x67*x86);\nIkReal x108=(x67*x87);\nIkReal x109=(x67*x83);\nIkReal x110=(x67*x90);\nIkReal x111=((0.0834355125792)*py*x68);\nIkReal x112=(x67*x74);\nIkReal x113=(x67*x73);\nIkReal x114=(x67*x68);\nIkReal x115=(x103*x88);\nIkReal x116=(x101*x94);\nIkReal x117=(x70*x96);\nIkReal x118=(py*x72*x89);\nIkReal x119=(py*x72*x77);\nIkReal x120=(gconst3*x71*x72);\nIkReal x121=(py*x72*x78);\nIkReal x122=(py*x72*x87);\nIkReal x123=(py*x72*x83);\nIkReal x124=(gconst2*x71*x72);\nIkReal x125=(gconst1*x72*x81);\nIkReal x126=(x101*x77);\nIkReal x127=(x70*x99);\nIkReal x128=(x103*x90);\nIkReal x129=((0.06594624)*x114);\nIkReal x130=(x76*x96);\nIkReal x131=(x103*x86);\nIkReal x132=(x101*x85);\nIkReal x133=(pp*py*x97);\nIkReal x134=((0.06594624)*x68*x91);\nIkReal x135=(x76*x99);\nIkReal x136=(x101*x79);\nIkReal x137=(x103*x74);\nIkReal x138=(x113+x112);\nIkReal x139=(x105+x106);\nIkReal x140=(x117+x116+x115);\nIkReal x141=(x135+x137+x136);\nIkReal x142=(x110+x108+x109+x107);\nIkReal x143=(x124+x125+x122+x123);\nIkReal x144=(x120+x121+x119+x118);\nIkReal x145=(x131+x130+x132+x126+x127+x128+x129);\nop[0]=((((-1.0)*x140))+x139);\nop[1]=((((-1.0)*x111))+x134+x133+(((-1.0)*x95)));\nop[2]=((((-1.0)*x145))+(((-1.0)*gconst4*gconst6*x98))+(((-1.0)*x94*x98))+(((-1.0)*x102*x88))+x142+((x88*x98))+((gconst7*x67*x75))+(((-1.0)*x100*x80))+(((-1.0)*x75*x96))+((x80*x98))+((x84*x96)));\nop[3]=((((-1.0)*x144))+((gconst7*x71*x72))+(((-1.0)*x71*x97))+(((-1.0)*py*x72*x80))+x143+(((-1.0)*gconst6*x71*x72))+((gconst4*x72*x81))+(((-1.0)*x81*x97))+(((-1.0)*x104*x93))+(((-1.0)*x104*x92)));\nop[4]=((((-1.0)*x141))+(((-1.0)*x140))+((x87*x98))+(((-1.0)*x102*x90))+(((-1.0)*x102*x86))+((x100*x78))+((x100*x77))+(((-1.0)*x77*x98))+(((-0.13189248)*x114))+((x86*x98))+x139+x138+(((-1.0)*x78*x98))+((gconst3*x67*x75))+((x90*x98))+(((-1.0)*gconst3*x67*x84))+(((-1.0)*x100*x90))+(((-1.0)*x75*x99))+((x83*x98))+((x84*x99))+(((-1.0)*x89*x98))+(((-1.0)*gconst7*x67*x82))+(((-1.0)*x85*x98)));\nop[5]=((((-1.0)*py*x72*x79))+(((-1.0)*x143))+((py*x72*x74))+((py*x72*x73))+x144+(((-1.0)*gconst0*x72*x93))+(((-1.0)*x92*x97))+(((-1.0)*x104*x71))+(((-1.0)*x104*x81))+(((-1.0)*x93*x97)));\nop[6]=((((-1.0)*x145))+(((-1.0)*gconst0*gconst2*x98))+((x82*x99))+((x100*x79))+((x73*x98))+x142+((x74*x98))+(((-1.0)*x79*x98))+(((-1.0)*x100*x73))+(((-1.0)*x100*x74))+(((-1.0)*x102*x74)));\nop[7]=((((-1.0)*x111))+x133+(((-1.0)*x134))+x95);\nop[8]=((((-1.0)*x141))+x138);\npolyroots8(op,zeror,numroots);\nIkReal j15array[8], cj15array[8], sj15array[8], tempj15array[1];\nint numsolutions = 0;\nfor(int ij15 = 0; ij15 < numroots; ++ij15)\n{\nIkReal htj15 = zeror[ij15];\ntempj15array[0]=((2.0)*(atan(htj15)));\nfor(int kj15 = 0; kj15 < 1; ++kj15)\n{\nj15array[numsolutions] = tempj15array[kj15];\nif( j15array[numsolutions] > IKPI )\n{\n    j15array[numsolutions]-=IK2PI;\n}\nelse if( j15array[numsolutions] < -IKPI )\n{\n    j15array[numsolutions]+=IK2PI;\n}\nsj15array[numsolutions] = IKsin(j15array[numsolutions]);\ncj15array[numsolutions] = IKcos(j15array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j15valid[8]={true,true,true,true,true,true,true,true};\n_nj15 = 8;\nfor(int ij15 = 0; ij15 < numsolutions; ++ij15)\n    {\nif( !j15valid[ij15] )\n{\n    continue;\n}\n    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];\nhtj15 = IKtan(j15/2);\n\n_ij15[0] = ij15; _ij15[1] = -1;\nfor(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)\n{\nif( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )\n{\n    j15valid[iij15]=false; _ij15[1] = iij15; break; \n}\n}\n{\nIkReal j16eval[2];\nIkReal x146=py*py;\nIkReal x147=cj15*cj15;\nIkReal x148=px*px;\nIkReal x149=pz*pz;\nIkReal x150=((4.0)*sj17);\nIkReal x151=((20.0)*sj17);\nIkReal x152=(py*sj15);\nIkReal x153=(cj15*px);\nIkReal x154=((100.0)*sj17);\nIkReal x155=((0.8)*sj17);\nIkReal x156=(x146*x147);\nIkReal x157=(x147*x148);\nj16eval[0]=((((-1.0)*x154*x157))+(((-200.0)*sj17*x152*x153))+((x151*x152))+((x151*x153))+((x154*x156))+(((-1.0)*sj17))+(((-1.0)*x146*x154))+(((-1.0)*x149*x154)));\nj16eval[1]=IKsign((((x153*x155))+((x150*x156))+((x152*x155))+(((-1.0)*x150*x157))+(((-1.0)*x146*x150))+(((-1.0)*x149*x150))+(((-8.0)*sj17*x152*x153))+(((-0.04)*sj17))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j18eval[1];\nj18eval[0]=sj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x158=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));\nevalcond[1]=x158;\nevalcond[2]=x158;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[2], cj18array[2], sj18array[2];\nbool j18valid[2]={false};\n_nj18 = 2;\ncj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));\nif( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j18valid[0] = j18valid[1] = true;\n    j18array[0] = IKacos(cj18array[0]);\n    sj18array[0] = IKsin(j18array[0]);\n    cj18array[1] = cj18array[0];\n    j18array[1] = -j18array[0];\n    sj18array[1] = -sj18array[0];\n}\nelse if( isnan(cj18array[0]) )\n{\n    // probably any value will work\n    j18valid[0] = true;\n    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;\n}\nfor(int ij18 = 0; ij18 < 2; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 2; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n\n{\nIkReal j16eval[3];\nsj17=0;\ncj17=1.0;\nj17=0;\nIkReal x159=((321000.0)*sj18);\nIkReal x160=(py*sj15);\nIkReal x161=((321000.0)*cj18);\nIkReal x162=(cj15*px);\nj16eval[0]=((1.02430295950156)+cj18);\nj16eval[1]=IKsign(((263041.0)+(((256800.0)*cj18))));\nj16eval[2]=((IKabs(((-40000.0)+((x161*x162))+(((400000.0)*x160))+(((400000.0)*x162))+(((-1.0)*pz*x159))+(((-32100.0)*cj18))+((x160*x161)))))+(IKabs(((((-1.0)*x159*x162))+(((-1.0)*x159*x160))+(((-1.0)*pz*x161))+(((-400000.0)*pz))+(((32100.0)*sj18))))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[3];\nsj17=0;\ncj17=1.0;\nj17=0;\nIkReal x163=(cj15*px);\nIkReal x164=((1000.0)*pz);\nIkReal x165=(py*sj15);\nIkReal x166=((10.0)*cj18);\nIkReal x167=((321.0)*cj18);\nIkReal x168=(pz*sj18);\nj16eval[0]=((1.24610591900312)+(((-1.0)*x163*x166))+cj18+(((-1.0)*x165*x166))+(((-10.0)*x168))+(((-12.4610591900312)*x165))+(((-12.4610591900312)*x163)));\nj16eval[1]=IKsign(((40.0)+(((-400.0)*x163))+(((-400.0)*x165))+(((-1.0)*x163*x167))+(((32.1)*cj18))+(((-321.0)*x168))+(((-1.0)*x165*x167))));\nj16eval[2]=((IKabs(((((-100.0)*pz))+(((103.041)*cj18*sj18))+((x164*x165))+(((128.4)*sj18))+((x163*x164)))))+(IKabs(((-160.0)+((pz*x164))+(((-256.8)*cj18))+(((-103.041)*(cj18*cj18)))))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[3];\nsj17=0;\ncj17=1.0;\nj17=0;\nIkReal x169=cj15*cj15;\nIkReal x170=py*py;\nIkReal x171=px*px;\nIkReal x172=pz*pz;\nIkReal x173=(py*sj15);\nIkReal x174=((321.0)*sj18);\nIkReal x175=(cj15*px);\nIkReal x176=((321.0)*cj18);\nIkReal x177=((100.0)*x169);\nIkReal x178=((1000.0)*x169);\nj16eval[0]=((-1.0)+(((-100.0)*x172))+(((-100.0)*x170))+(((20.0)*x175))+(((20.0)*x173))+(((-1.0)*x171*x177))+((x170*x177))+(((-200.0)*x173*x175)));\nj16eval[1]=IKsign(((-10.0)+(((-1000.0)*x170))+(((-1000.0)*x172))+(((-1.0)*x171*x178))+((x170*x178))+(((-2000.0)*x173*x175))+(((200.0)*x173))+(((200.0)*x175))));\nj16eval[2]=((IKabs(((40.0)+((pz*x174))+(((-1.0)*x175*x176))+(((-400.0)*x175))+(((-400.0)*x173))+(((32.1)*cj18))+(((-1.0)*x173*x176)))))+(IKabs((((pz*x176))+((x173*x174))+(((400.0)*pz))+((x174*x175))+(((-32.1)*sj18))))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j16]\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x179=py*py;\nIkReal x180=cj15*cj15;\nIkReal x181=(py*sj15);\nIkReal x182=((321.0)*sj18);\nIkReal x183=(cj15*px);\nIkReal x184=((321.0)*cj18);\nIkReal x185=((1000.0)*x180);\nCheckValue<IkReal> x186 = IKatan2WithCheck(IkReal((((pz*x184))+(((400.0)*pz))+(((-32.1)*sj18))+((x182*x183))+((x181*x182)))),((40.0)+((pz*x182))+(((-400.0)*x183))+(((-400.0)*x181))+(((32.1)*cj18))+(((-1.0)*x183*x184))+(((-1.0)*x181*x184))),IKFAST_ATAN2_MAGTHRESH);\nif(!x186.valid){\ncontinue;\n}\nCheckValue<IkReal> x187=IKPowWithIntegerCheck(IKsign(((-10.0)+(((-1000.0)*(pz*pz)))+((x179*x185))+(((-1000.0)*x179))+(((200.0)*x181))+(((200.0)*x183))+(((-2000.0)*x181*x183))+(((-1.0)*x185*(px*px))))),-1);\nif(!x187.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(x186.value)+(((1.5707963267949)*(x187.value))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x188=IKsin(j16);\nIkReal x189=IKcos(j16);\nIkReal x190=((0.321)*sj18);\nIkReal x191=((0.321)*cj18);\nIkReal x192=(py*sj15);\nIkReal x193=(cj15*px);\nIkReal x194=(pz*x188);\nIkReal x195=(x189*x193);\nevalcond[0]=((((0.4)*x188))+((x188*x191))+((x189*x190))+pz);\nevalcond[1]=(((pz*x189))+((x188*x193))+((x188*x192))+x190+(((-0.1)*x188)));\nevalcond[2]=((0.1)+(((0.4)*x189))+(((-1.0)*x188*x190))+(((-1.0)*x192))+(((-1.0)*x193))+((x189*x191)));\nevalcond[3]=((0.4)+(((0.1)*x189))+(((-1.0)*x195))+(((-1.0)*x189*x192))+x191+x194);\nevalcond[4]=((-0.066959)+(((0.2)*x193))+(((0.2)*x192))+(((0.8)*x189*x192))+(((-1.0)*pp))+(((0.8)*x195))+(((-0.08)*x189))+(((-0.8)*x194)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x661=(cj15*px);\nIkReal x662=((1000.0)*pz);\nIkReal x663=((321.0)*cj18);\nIkReal x664=(py*sj15);\nCheckValue<IkReal> x665=IKPowWithIntegerCheck(IKsign(((40.0)+(((-321.0)*pz*sj18))+(((-1.0)*x663*x664))+(((32.1)*cj18))+(((-1.0)*x661*x663))+(((-400.0)*x664))+(((-400.0)*x661)))),-1);\nif(!x665.valid){\ncontinue;\n}\nCheckValue<IkReal> x666 = IKatan2WithCheck(IkReal(((((-100.0)*pz))+(((103.041)*cj18*sj18))+((x662*x664))+((x661*x662))+(((128.4)*sj18)))),((-160.0)+(((-256.8)*cj18))+((pz*x662))+(((-103.041)*(cj18*cj18)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x666.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x665.value)))+(x666.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x667=IKsin(j16);\nIkReal x668=IKcos(j16);\nIkReal x669=((0.321)*sj18);\nIkReal x670=((0.321)*cj18);\nIkReal x671=(py*sj15);\nIkReal x672=(cj15*px);\nIkReal x673=(pz*x667);\nIkReal x674=(x668*x672);\nevalcond[0]=(((x668*x669))+(((0.4)*x667))+((x667*x670))+pz);\nevalcond[1]=(((x667*x671))+((x667*x672))+((pz*x668))+x669+(((-0.1)*x667)));\nevalcond[2]=((0.1)+(((0.4)*x668))+((x668*x670))+(((-1.0)*x671))+(((-1.0)*x672))+(((-1.0)*x667*x669)));\nevalcond[3]=((0.4)+(((0.1)*x668))+x673+x670+(((-1.0)*x674))+(((-1.0)*x668*x671)));\nevalcond[4]=((-0.066959)+(((-0.08)*x668))+(((0.8)*x674))+(((0.2)*x671))+(((0.2)*x672))+(((-1.0)*pp))+(((-0.8)*x673))+(((0.8)*x668*x671)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x675=((321000.0)*sj18);\nIkReal x676=(py*sj15);\nIkReal x677=((321000.0)*cj18);\nIkReal x678=(cj15*px);\nCheckValue<IkReal> x679=IKPowWithIntegerCheck(IKsign(((263041.0)+(((256800.0)*cj18)))),-1);\nif(!x679.valid){\ncontinue;\n}\nCheckValue<IkReal> x680 = IKatan2WithCheck(IkReal(((((-1.0)*x675*x676))+(((-1.0)*x675*x678))+(((-1.0)*pz*x677))+(((-400000.0)*pz))+(((32100.0)*sj18)))),((-40000.0)+((x676*x677))+((x677*x678))+(((-1.0)*pz*x675))+(((-32100.0)*cj18))+(((400000.0)*x676))+(((400000.0)*x678))),IKFAST_ATAN2_MAGTHRESH);\nif(!x680.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x679.value)))+(x680.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x681=IKsin(j16);\nIkReal x682=IKcos(j16);\nIkReal x683=((0.321)*sj18);\nIkReal x684=((0.321)*cj18);\nIkReal x685=(py*sj15);\nIkReal x686=(cj15*px);\nIkReal x687=(pz*x681);\nIkReal x688=(x682*x686);\nevalcond[0]=(((x682*x683))+pz+((x681*x684))+(((0.4)*x681)));\nevalcond[1]=((((-0.1)*x681))+((x681*x686))+((x681*x685))+x683+((pz*x682)));\nevalcond[2]=((0.1)+(((-1.0)*x681*x683))+((x682*x684))+(((0.4)*x682))+(((-1.0)*x685))+(((-1.0)*x686)));\nevalcond[3]=((0.4)+x687+x684+(((0.1)*x682))+(((-1.0)*x688))+(((-1.0)*x682*x685)));\nevalcond[4]=((-0.066959)+(((0.2)*x686))+(((0.2)*x685))+(((-0.08)*x682))+(((-1.0)*pp))+(((0.8)*x688))+(((0.8)*x682*x685))+(((-0.8)*x687)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x689=(cj15*py);\nIkReal x690=(px*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));\nevalcond[1]=(x690+(((-1.0)*x689)));\nevalcond[2]=(x689+(((-1.0)*x690)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[2], cj18array[2], sj18array[2];\nbool j18valid[2]={false};\n_nj18 = 2;\ncj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));\nif( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j18valid[0] = j18valid[1] = true;\n    j18array[0] = IKacos(cj18array[0]);\n    sj18array[0] = IKsin(j18array[0]);\n    cj18array[1] = cj18array[0];\n    j18array[1] = -j18array[0];\n    sj18array[1] = -sj18array[0];\n}\nelse if( isnan(cj18array[0]) )\n{\n    // probably any value will work\n    j18valid[0] = true;\n    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;\n}\nfor(int ij18 = 0; ij18 < 2; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 2; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n\n{\nIkReal j16eval[3];\nsj17=0;\ncj17=-1.0;\nj17=3.14159265358979;\nIkReal x691=((321000.0)*pz);\nIkReal x692=((321000.0)*py*sj15);\nIkReal x693=((321000.0)*cj15*px);\nj16eval[0]=((-1.02430295950156)+(((-1.0)*cj18)));\nj16eval[1]=IKsign(((-263041.0)+(((-256800.0)*cj18))));\nj16eval[2]=((IKabs(((40000.0)+(((-1.0)*sj18*x691))+(((32100.0)*cj18))+(((-400000.0)*cj15*px))+(((-400000.0)*py*sj15))+(((-1.0)*cj18*x692))+(((-1.0)*cj18*x693)))))+(IKabs((((cj18*x691))+(((-1.0)*sj18*x693))+(((-1.0)*sj18*x692))+(((400000.0)*pz))+(((32100.0)*sj18))))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[3];\nsj17=0;\ncj17=-1.0;\nj17=3.14159265358979;\nIkReal x694=(cj15*px);\nIkReal x695=((1000.0)*pz);\nIkReal x696=(py*sj15);\nIkReal x697=((10.0)*cj18);\nIkReal x698=((321.0)*cj18);\nIkReal x699=(pz*sj18);\nj16eval[0]=((-1.24610591900312)+(((12.4610591900312)*x696))+(((12.4610591900312)*x694))+((x694*x697))+(((-10.0)*x699))+((x696*x697))+(((-1.0)*cj18)));\nj16eval[1]=((IKabs(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((-1.0)*x695*x696))+(((-1.0)*x694*x695))+(((128.4)*sj18)))))+(IKabs(((160.0)+(((256.8)*cj18))+(((-1.0)*pz*x695))+(((103.041)*(cj18*cj18)))))));\nj16eval[2]=IKsign(((-40.0)+(((400.0)*x696))+(((400.0)*x694))+((x694*x698))+((x696*x698))+(((-32.1)*cj18))+(((-321.0)*x699))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[3];\nsj17=0;\ncj17=-1.0;\nj17=3.14159265358979;\nIkReal x700=cj15*cj15;\nIkReal x701=py*py;\nIkReal x702=px*px;\nIkReal x703=pz*pz;\nIkReal x704=(py*sj15);\nIkReal x705=((321.0)*cj18);\nIkReal x706=(cj15*px);\nIkReal x707=((321.0)*sj18);\nIkReal x708=(x700*x702);\nIkReal x709=(x700*x701);\nj16eval[0]=((-1.0)+(((20.0)*x704))+(((20.0)*x706))+(((-100.0)*x703))+(((-100.0)*x708))+(((-100.0)*x701))+(((100.0)*x709))+(((-200.0)*x704*x706)));\nj16eval[1]=IKsign(((-10.0)+(((1000.0)*x709))+(((-1000.0)*x708))+(((-1000.0)*x703))+(((-1000.0)*x701))+(((-2000.0)*x704*x706))+(((200.0)*x706))+(((200.0)*x704))));\nj16eval[2]=((IKabs(((((-1.0)*x706*x707))+(((32.1)*sj18))+(((400.0)*pz))+(((-1.0)*x704*x707))+((pz*x705)))))+(IKabs(((40.0)+(((-1.0)*pz*x707))+(((-400.0)*x706))+(((-400.0)*x704))+(((32.1)*cj18))+(((-1.0)*x704*x705))+(((-1.0)*x705*x706))))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j16]\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x710=py*py;\nIkReal x711=cj15*cj15;\nIkReal x712=(py*sj15);\nIkReal x713=((321.0)*sj18);\nIkReal x714=(cj15*px);\nIkReal x715=((321.0)*cj18);\nIkReal x716=((1000.0)*x711);\nCheckValue<IkReal> x717=IKPowWithIntegerCheck(IKsign(((-10.0)+(((-1.0)*x716*(px*px)))+(((-1000.0)*(pz*pz)))+((x710*x716))+(((-1000.0)*x710))+(((-2000.0)*x712*x714))+(((200.0)*x712))+(((200.0)*x714)))),-1);\nif(!x717.valid){\ncontinue;\n}\nCheckValue<IkReal> x718 = IKatan2WithCheck(IkReal(((((32.1)*sj18))+(((400.0)*pz))+(((-1.0)*x712*x713))+(((-1.0)*x713*x714))+((pz*x715)))),((40.0)+(((-1.0)*x714*x715))+(((-1.0)*pz*x713))+(((-400.0)*x714))+(((-400.0)*x712))+(((32.1)*cj18))+(((-1.0)*x712*x715))),IKFAST_ATAN2_MAGTHRESH);\nif(!x718.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x717.value)))+(x718.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x719=IKsin(j16);\nIkReal x720=IKcos(j16);\nIkReal x721=((0.321)*sj18);\nIkReal x722=((0.321)*cj18);\nIkReal x723=(cj15*px);\nIkReal x724=(py*sj15);\nIkReal x725=(pz*x719);\nIkReal x726=((1.0)*x719);\nIkReal x727=((1.0)*x720);\nIkReal x728=(x720*x723);\nevalcond[0]=((((0.4)*x719))+pz+(((-1.0)*x720*x721))+((x719*x722)));\nevalcond[1]=((0.1)+((x720*x722))+(((-1.0)*x723))+(((-1.0)*x724))+((x719*x721))+(((0.4)*x720)));\nevalcond[2]=((0.4)+(((-1.0)*x724*x727))+(((-1.0)*x723*x727))+(((0.1)*x720))+x722+x725);\nevalcond[3]=((((-1.0)*x724*x726))+(((-1.0)*x723*x726))+(((0.1)*x719))+x721+(((-1.0)*pz*x727)));\nevalcond[4]=((-0.066959)+(((0.8)*x728))+(((-0.08)*x720))+(((0.8)*x720*x724))+(((-1.0)*pp))+(((-0.8)*x725))+(((0.2)*x723))+(((0.2)*x724)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x729=(cj15*px);\nIkReal x730=((1000.0)*pz);\nIkReal x731=((321.0)*cj18);\nIkReal x732=(py*sj15);\nCheckValue<IkReal> x733=IKPowWithIntegerCheck(IKsign(((-40.0)+(((400.0)*x729))+((x731*x732))+(((-321.0)*pz*sj18))+(((400.0)*x732))+((x729*x731))+(((-32.1)*cj18)))),-1);\nif(!x733.valid){\ncontinue;\n}\nCheckValue<IkReal> x734 = IKatan2WithCheck(IkReal(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((-1.0)*x730*x732))+(((128.4)*sj18))+(((-1.0)*x729*x730)))),((160.0)+(((256.8)*cj18))+(((-1.0)*pz*x730))+(((103.041)*(cj18*cj18)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x734.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x733.value)))+(x734.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x735=IKsin(j16);\nIkReal x736=IKcos(j16);\nIkReal x737=((0.321)*sj18);\nIkReal x738=((0.321)*cj18);\nIkReal x739=(cj15*px);\nIkReal x740=(py*sj15);\nIkReal x741=(pz*x735);\nIkReal x742=((1.0)*x735);\nIkReal x743=((1.0)*x736);\nIkReal x744=(x736*x739);\nevalcond[0]=((((0.4)*x735))+(((-1.0)*x736*x737))+((x735*x738))+pz);\nevalcond[1]=((0.1)+(((0.4)*x736))+((x735*x737))+((x736*x738))+(((-1.0)*x739))+(((-1.0)*x740)));\nevalcond[2]=((0.4)+(((0.1)*x736))+(((-1.0)*x740*x743))+x738+x741+(((-1.0)*x739*x743)));\nevalcond[3]=((((-1.0)*pz*x743))+(((0.1)*x735))+(((-1.0)*x740*x742))+x737+(((-1.0)*x739*x742)));\nevalcond[4]=((-0.066959)+(((-0.08)*x736))+(((0.8)*x744))+(((-1.0)*pp))+(((0.8)*x736*x740))+(((0.2)*x740))+(((-0.8)*x741))+(((0.2)*x739)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x745=((321000.0)*pz);\nIkReal x746=((321000.0)*py*sj15);\nIkReal x747=((321000.0)*cj15*px);\nCheckValue<IkReal> x748=IKPowWithIntegerCheck(IKsign(((-263041.0)+(((-256800.0)*cj18)))),-1);\nif(!x748.valid){\ncontinue;\n}\nCheckValue<IkReal> x749 = IKatan2WithCheck(IkReal(((((400000.0)*pz))+(((-1.0)*sj18*x747))+(((-1.0)*sj18*x746))+(((32100.0)*sj18))+((cj18*x745)))),((40000.0)+(((32100.0)*cj18))+(((-1.0)*cj18*x746))+(((-1.0)*cj18*x747))+(((-1.0)*sj18*x745))+(((-400000.0)*cj15*px))+(((-400000.0)*py*sj15))),IKFAST_ATAN2_MAGTHRESH);\nif(!x749.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x748.value)))+(x749.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x750=IKsin(j16);\nIkReal x751=IKcos(j16);\nIkReal x752=((0.321)*sj18);\nIkReal x753=((0.321)*cj18);\nIkReal x754=(cj15*px);\nIkReal x755=(py*sj15);\nIkReal x756=(pz*x750);\nIkReal x757=((1.0)*x750);\nIkReal x758=((1.0)*x751);\nIkReal x759=(x751*x754);\nevalcond[0]=((((-1.0)*x751*x752))+pz+(((0.4)*x750))+((x750*x753)));\nevalcond[1]=((0.1)+((x751*x753))+(((-1.0)*x755))+(((-1.0)*x754))+(((0.4)*x751))+((x750*x752)));\nevalcond[2]=((0.4)+(((0.1)*x751))+(((-1.0)*x754*x758))+(((-1.0)*x755*x758))+x756+x753);\nevalcond[3]=((((0.1)*x750))+(((-1.0)*x754*x757))+(((-1.0)*x755*x757))+x752+(((-1.0)*pz*x758)));\nevalcond[4]=((-0.066959)+(((0.8)*x759))+(((-0.08)*x751))+(((0.2)*x754))+(((0.2)*x755))+(((-1.0)*pp))+(((-0.8)*x756))+(((0.8)*x751*x755)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j16, j18]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x760=IKPowWithIntegerCheck(sj17,-1);\nif(!x760.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x760.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x760.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x760.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[2];\nevalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*sj17*(IKsin(j18)))));\nevalcond[1]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*(IKcos(j18)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j16eval[3];\nIkReal x761=(cj15*px);\nIkReal x762=((1000.0)*pz);\nIkReal x763=(py*sj15);\nIkReal x764=((10.0)*cj18);\nIkReal x765=((321.0)*cj18);\nIkReal x766=(cj17*sj18);\nIkReal x767=(pz*x766);\nj16eval[0]=((-1.24610591900312)+(((12.4610591900312)*x763))+(((12.4610591900312)*x761))+((x761*x764))+((x763*x764))+(((-1.0)*cj18))+(((10.0)*x767)));\nj16eval[1]=((IKabs(((((-1.0)*x762*x763))+(((100.0)*pz))+(((-128.4)*x766))+(((-103.041)*cj18*x766))+(((-1.0)*x761*x762)))))+(IKabs(((160.0)+(((256.8)*cj18))+(((103.041)*(cj18*cj18)))+(((-1.0)*pz*x762))))));\nj16eval[2]=IKsign(((-40.0)+(((400.0)*x763))+(((400.0)*x761))+((x761*x765))+((x763*x765))+(((-32.1)*cj18))+(((321.0)*x767))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[3];\nIkReal x768=cj17*cj17;\nIkReal x769=cj18*cj18;\nIkReal x770=(cj15*px);\nIkReal x771=(py*sj15);\nIkReal x772=((321000.0)*cj18);\nIkReal x773=((321000.0)*cj17*sj18);\nIkReal x774=((103041.0)*x769);\nj16eval[0]=((1.5527799613746)+(((2.49221183800623)*cj18))+(((-1.0)*x768*x769))+x768+x769);\nj16eval[1]=((IKabs(((-40000.0)+((x771*x772))+((x770*x772))+(((-32100.0)*cj18))+(((-1.0)*pz*x773))+(((400000.0)*x771))+(((400000.0)*x770)))))+(IKabs(((((32100.0)*cj17*sj18))+(((-1.0)*x771*x773))+(((-400000.0)*pz))+(((-1.0)*pz*x772))+(((-1.0)*x770*x773))))));\nj16eval[2]=IKsign(((160000.0)+(((-1.0)*x768*x774))+(((256800.0)*cj18))+(((103041.0)*x768))+x774));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[2];\nIkReal x775=(cj17*sj18);\nIkReal x776=(py*sj15);\nIkReal x777=(cj18*pz);\nIkReal x778=(cj15*px);\nj16eval[0]=((((-10.0)*x775*x776))+(((-10.0)*x775*x778))+x775+(((10.0)*x777))+(((12.4610591900312)*pz)));\nj16eval[1]=IKsign(((((400.0)*pz))+(((32.1)*x775))+(((-321.0)*x775*x778))+(((-321.0)*x775*x776))+(((321.0)*x777))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x779=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*sj18)));\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j17), 6.28318530717959)))))+(IKabs(pz)));\nevalcond[1]=x779;\nevalcond[2]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*cj18)));\nevalcond[3]=x779;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16eval[1];\nIkReal x780=((-1.0)*py);\npz=0;\nj17=1.5707963267949;\nsj17=1.0;\ncj17=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x780);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x780);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x780);\nrxp2_1=(px*r22);\nj16eval[0]=((1.0)+(((-10.0)*cj15*px))+(((-10.0)*py*sj15)));\nif( IKabs(j16eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[1];\nIkReal x781=((-1.0)*py);\npz=0;\nj17=1.5707963267949;\nsj17=1.0;\ncj17=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x781);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x781);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x781);\nrxp2_1=(px*r22);\nj16eval[0]=((1.24610591900312)+cj18);\nif( IKabs(j16eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x782=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nif((x782) < -0.00001)\ncontinue;\nIkReal x783=IKabs(IKsqrt(x782));\nIkReal x789 = x782;\nif(IKabs(x789)==0){\ncontinue;\n}\nIkReal x784=pow(x789,-0.5);\nCheckValue<IkReal> x790=IKPowWithIntegerCheck(x783,-1);\nif(!x790.valid){\ncontinue;\n}\nIkReal x785=x790.value;\nIkReal x786=((10.0)*px*x784);\nIkReal x787=((10.0)*py*x784);\nif((((1.0)+(((-1.0)*(x785*x785))))) < -0.00001)\ncontinue;\nIkReal x788=IKsqrt(((1.0)+(((-1.0)*(x785*x785)))));\nif( (x785) < -1-IKFAST_SINCOS_THRESH || (x785) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x791 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x791.valid){\ncontinue;\n}\nIkReal gconst24=((((-1.0)*(IKasin(x785))))+(((-1.0)*(x791.value))));\nIkReal gconst25=(((x786*x788))+((x785*x787)));\nIkReal gconst26=(((x785*x786))+(((-1.0)*x787*x788)));\nIkReal x792=px*px;\nIkReal x793=py*py;\nIkReal x794=(((gconst25*px))+(((0.321)*sj18))+(((-1.0)*gconst26*py)));\nCheckValue<IkReal> x795 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x795.valid){\ncontinue;\n}\nif((((((100.0)*x793))+(((100.0)*x792)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x796=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x793))+(((100.0)*x792))))),-1);\nif(!x796.valid){\ncontinue;\n}\nif( (x796.value) < -1-IKFAST_SINCOS_THRESH || (x796.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j15+(x795.value)+(IKasin(x796.value)))))), 6.28318530717959)));\nevalcond[1]=x794;\nevalcond[2]=((0.253041)+(((0.2)*gconst25*py))+(((0.2)*gconst26*px))+(((-1.0)*x792))+(((-1.0)*x793))+(((0.2568)*cj18)));\nevalcond[3]=x794;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x798=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst25*py))+(((-1.0)*gconst26*px))),-1);\nif(!x798.valid){\ncontinue;\n}\nIkReal x797=x798.value;\ncj16array[0]=((((-0.321)*cj18*x797))+(((-0.4)*x797)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x799=IKsin(j16);\nIkReal x800=IKcos(j16);\nIkReal x801=(gconst26*px);\nIkReal x802=(gconst25*py);\nIkReal x803=((0.321)*cj18);\nIkReal x804=((0.8)*x800);\nIkReal x805=((1.0)*x799);\nevalcond[0]=(((x799*x803))+(((0.4)*x799)));\nevalcond[1]=((((0.1)*x799))+(((-1.0)*x801*x805))+(((-1.0)*x802*x805)));\nevalcond[2]=((0.1)+(((-1.0)*x802))+(((-1.0)*x801))+((x800*x803))+(((0.4)*x800)));\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((0.2)*x801))+(((0.2)*x802))+(((-0.08)*x800))+((x801*x804))+(((-1.0)*(py*py)))+((x802*x804)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x806=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nIkReal x813 = x806;\nif(IKabs(x813)==0){\ncontinue;\n}\nIkReal x807=pow(x813,-0.5);\nif((x806) < -0.00001)\ncontinue;\nIkReal x808=IKabs(IKsqrt(x806));\nCheckValue<IkReal> x814=IKPowWithIntegerCheck(x808,-1);\nif(!x814.valid){\ncontinue;\n}\nIkReal x809=x814.value;\nIkReal x810=((10.0)*px*x807);\nIkReal x811=((10.0)*py*x807);\nif((((1.0)+(((-1.0)*(x809*x809))))) < -0.00001)\ncontinue;\nIkReal x812=IKsqrt(((1.0)+(((-1.0)*(x809*x809)))));\nCheckValue<IkReal> x815 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x815.valid){\ncontinue;\n}\nif( (x809) < -1-IKFAST_SINCOS_THRESH || (x809) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal gconst27=((3.14159265358979)+(((-1.0)*(x815.value)))+(IKasin(x809)));\nIkReal gconst28=(((x809*x811))+(((-1.0)*x810*x812)));\nIkReal gconst29=(((x809*x810))+((x811*x812)));\nIkReal x816=px*px;\nIkReal x817=py*py;\nIkReal x818=((((-1.0)*gconst29*py))+(((0.321)*sj18))+((gconst28*px)));\nif((((((100.0)*x817))+(((100.0)*x816)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x819=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x817))+(((100.0)*x816))))),-1);\nif(!x819.valid){\ncontinue;\n}\nif( (x819.value) < -1-IKFAST_SINCOS_THRESH || (x819.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x820 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x820.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j15+(((-1.0)*(IKasin(x819.value))))+(x820.value))))), 6.28318530717959)));\nevalcond[1]=x818;\nevalcond[2]=((0.253041)+(((-1.0)*x817))+(((-1.0)*x816))+(((0.2)*gconst29*px))+(((0.2568)*cj18))+(((0.2)*gconst28*py)));\nevalcond[3]=x818;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x822=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst29*px))+(((-1.0)*gconst28*py))),-1);\nif(!x822.valid){\ncontinue;\n}\nIkReal x821=x822.value;\ncj16array[0]=((((-0.4)*x821))+(((-0.321)*cj18*x821)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x823=IKsin(j16);\nIkReal x824=IKcos(j16);\nIkReal x825=(gconst29*px);\nIkReal x826=((0.321)*cj18);\nIkReal x827=(gconst28*py);\nIkReal x828=((1.0)*x823);\nIkReal x829=((0.8)*x824);\nevalcond[0]=((((0.4)*x823))+((x823*x826)));\nevalcond[1]=((((0.1)*x823))+(((-1.0)*x827*x828))+(((-1.0)*x825*x828)));\nevalcond[2]=((0.1)+((x824*x826))+(((0.4)*x824))+(((-1.0)*x825))+(((-1.0)*x827)));\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((-0.08)*x824))+((x825*x829))+(((-1.0)*(py*py)))+((x827*x829))+(((0.2)*x827))+(((0.2)*x825)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j16]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x831=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj18))),-1);\nif(!x831.valid){\ncontinue;\n}\nIkReal x830=x831.value;\ncj16array[0]=(((cj15*px*x830))+((py*sj15*x830))+(((-0.1)*x830)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x832=IKsin(j16);\nIkReal x833=IKcos(j16);\nIkReal x834=(cj15*px);\nIkReal x835=((0.321)*cj18);\nIkReal x836=(py*sj15);\nIkReal x837=((1.0)*x836);\nIkReal x838=((0.8)*x833);\nevalcond[0]=(((x832*x835))+(((0.4)*x832)));\nevalcond[1]=((((-1.0)*x832*x837))+(((0.1)*x832))+(((-1.0)*x832*x834)));\nevalcond[2]=((0.4)+(((-1.0)*x833*x837))+(((0.1)*x833))+(((-1.0)*x833*x834))+x835);\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((-0.08)*x833))+((x836*x838))+(((0.2)*x836))+(((0.2)*x834))+((x834*x838))+(((-1.0)*(py*py))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x840=IKPowWithIntegerCheck(((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15))),-1);\nif(!x840.valid){\ncontinue;\n}\nIkReal x839=x840.value;\ncj16array[0]=((((-0.4)*x839))+(((-0.321)*cj18*x839)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x841=IKsin(j16);\nIkReal x842=IKcos(j16);\nIkReal x843=(py*sj15);\nIkReal x844=((0.321)*cj18);\nIkReal x845=(cj15*px);\nIkReal x846=((1.0)*x841);\nIkReal x847=((0.8)*x842);\nevalcond[0]=((((0.4)*x841))+((x841*x844)));\nevalcond[1]=((((-1.0)*x843*x846))+(((0.1)*x841))+(((-1.0)*x845*x846)));\nevalcond[2]=((0.1)+(((0.4)*x842))+((x842*x844))+(((-1.0)*x845))+(((-1.0)*x843)));\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((-0.08)*x842))+((x843*x847))+(((0.2)*x845))+(((0.2)*x843))+((x845*x847))+(((-1.0)*(py*py))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x848=((0.321)*sj18);\nIkReal x849=(cj15*py);\nIkReal x850=(px*sj15);\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j17), 6.28318530717959)))))+(IKabs(pz)));\nevalcond[1]=((((-1.0)*x848))+(((-1.0)*x849))+x850);\nevalcond[2]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*cj18)));\nevalcond[3]=((((-1.0)*x850))+x849+x848);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16eval[1];\nIkReal x851=((-1.0)*py);\npz=0;\nj17=-1.5707963267949;\nsj17=-1.0;\ncj17=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x851);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x851);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x851);\nrxp2_1=(px*r22);\nj16eval[0]=((1.0)+(((-10.0)*cj15*px))+(((-10.0)*py*sj15)));\nif( IKabs(j16eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[1];\nIkReal x852=((-1.0)*py);\npz=0;\nj17=-1.5707963267949;\nsj17=-1.0;\ncj17=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x852);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x852);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x852);\nrxp2_1=(px*r22);\nj16eval[0]=((1.24610591900312)+cj18);\nif( IKabs(j16eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x853=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nif((x853) < -0.00001)\ncontinue;\nIkReal x854=IKabs(IKsqrt(x853));\nIkReal x860 = x853;\nif(IKabs(x860)==0){\ncontinue;\n}\nIkReal x855=pow(x860,-0.5);\nCheckValue<IkReal> x861=IKPowWithIntegerCheck(x854,-1);\nif(!x861.valid){\ncontinue;\n}\nIkReal x856=x861.value;\nIkReal x857=((10.0)*px*x855);\nIkReal x858=((10.0)*py*x855);\nif((((1.0)+(((-1.0)*(x856*x856))))) < -0.00001)\ncontinue;\nIkReal x859=IKsqrt(((1.0)+(((-1.0)*(x856*x856)))));\nif( (x856) < -1-IKFAST_SINCOS_THRESH || (x856) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x862 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x862.valid){\ncontinue;\n}\nIkReal gconst30=((((-1.0)*(IKasin(x856))))+(((-1.0)*(x862.value))));\nIkReal gconst31=(((x856*x858))+((x857*x859)));\nIkReal gconst32=(((x856*x857))+(((-1.0)*x858*x859)));\nIkReal x863=px*px;\nIkReal x864=py*py;\nIkReal x865=((0.321)*sj18);\nIkReal x866=(gconst32*py);\nIkReal x867=(gconst31*px);\nif((((((100.0)*x863))+(((100.0)*x864)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x868=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x863))+(((100.0)*x864))))),-1);\nif(!x868.valid){\ncontinue;\n}\nif( (x868.value) < -1-IKFAST_SINCOS_THRESH || (x868.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x869 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x869.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x868.value))+j15+(x869.value))))), 6.28318530717959)));\nevalcond[1]=((((-1.0)*x865))+(((-1.0)*x866))+x867);\nevalcond[2]=((0.253041)+(((-1.0)*x863))+(((-1.0)*x864))+(((0.2)*gconst32*px))+(((0.2)*gconst31*py))+(((0.2568)*cj18)));\nevalcond[3]=((((-1.0)*x867))+x866+x865);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x871=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst32*px))+(((-1.0)*gconst31*py))),-1);\nif(!x871.valid){\ncontinue;\n}\nIkReal x870=x871.value;\ncj16array[0]=((((-0.4)*x870))+(((-0.321)*cj18*x870)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x872=IKsin(j16);\nIkReal x873=IKcos(j16);\nIkReal x874=(gconst32*px);\nIkReal x875=(gconst31*py);\nIkReal x876=((0.321)*cj18);\nIkReal x877=((0.8)*x873);\nevalcond[0]=(((x872*x876))+(((0.4)*x872)));\nevalcond[1]=(((x872*x874))+((x872*x875))+(((-0.1)*x872)));\nevalcond[2]=((0.1)+(((-1.0)*x874))+(((-1.0)*x875))+((x873*x876))+(((0.4)*x873)));\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((0.2)*x875))+(((0.2)*x874))+((x874*x877))+((x875*x877))+(((-0.08)*x873))+(((-1.0)*(py*py))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x878=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nIkReal x885 = x878;\nif(IKabs(x885)==0){\ncontinue;\n}\nIkReal x879=pow(x885,-0.5);\nif((x878) < -0.00001)\ncontinue;\nIkReal x880=IKabs(IKsqrt(x878));\nCheckValue<IkReal> x886=IKPowWithIntegerCheck(x880,-1);\nif(!x886.valid){\ncontinue;\n}\nIkReal x881=x886.value;\nIkReal x882=((10.0)*px*x879);\nIkReal x883=((10.0)*py*x879);\nif((((1.0)+(((-1.0)*(x881*x881))))) < -0.00001)\ncontinue;\nIkReal x884=IKsqrt(((1.0)+(((-1.0)*(x881*x881)))));\nif( (x881) < -1-IKFAST_SINCOS_THRESH || (x881) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x887 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x887.valid){\ncontinue;\n}\nIkReal gconst33=((3.14159265358979)+(IKasin(x881))+(((-1.0)*(x887.value))));\nIkReal gconst34=(((x881*x883))+(((-1.0)*x882*x884)));\nIkReal gconst35=(((x881*x882))+((x883*x884)));\nIkReal x888=px*px;\nIkReal x889=py*py;\nIkReal x890=((0.321)*sj18);\nIkReal x891=(gconst35*py);\nIkReal x892=(gconst34*px);\nif((((((100.0)*x888))+(((100.0)*x889)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x893=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x888))+(((100.0)*x889))))),-1);\nif(!x893.valid){\ncontinue;\n}\nif( (x893.value) < -1-IKFAST_SINCOS_THRESH || (x893.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x894 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x894.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(((-1.0)*(IKasin(x893.value))))+j15+(x894.value))))), 6.28318530717959)));\nevalcond[1]=((((-1.0)*x890))+(((-1.0)*x891))+x892);\nevalcond[2]=((0.253041)+(((-1.0)*x889))+(((-1.0)*x888))+(((0.2)*gconst35*px))+(((0.2)*gconst34*py))+(((0.2568)*cj18)));\nevalcond[3]=((((-1.0)*x892))+x890+x891);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x896=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst34*py))+(((-1.0)*gconst35*px))),-1);\nif(!x896.valid){\ncontinue;\n}\nIkReal x895=x896.value;\ncj16array[0]=((((-0.321)*cj18*x895))+(((-0.4)*x895)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x897=IKsin(j16);\nIkReal x898=IKcos(j16);\nIkReal x899=(gconst34*py);\nIkReal x900=(gconst35*px);\nIkReal x901=((0.321)*cj18);\nIkReal x902=((0.8)*x898);\nevalcond[0]=(((x897*x901))+(((0.4)*x897)));\nevalcond[1]=((((-0.1)*x897))+((x897*x900))+((x897*x899)));\nevalcond[2]=((0.1)+(((0.4)*x898))+(((-1.0)*x899))+(((-1.0)*x900))+((x898*x901)));\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((0.2)*x900))+((x900*x902))+((x899*x902))+(((0.2)*x899))+(((-1.0)*(py*py)))+(((-0.08)*x898)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j16]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x904=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj18))),-1);\nif(!x904.valid){\ncontinue;\n}\nIkReal x903=x904.value;\ncj16array[0]=(((py*sj15*x903))+((cj15*px*x903))+(((-0.1)*x903)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x905=IKsin(j16);\nIkReal x906=IKcos(j16);\nIkReal x907=(cj15*px);\nIkReal x908=(py*sj15);\nIkReal x909=((0.321)*cj18);\nIkReal x910=((1.0)*x906);\nIkReal x911=((0.8)*x906);\nevalcond[0]=(((x905*x909))+(((0.4)*x905)));\nevalcond[1]=(((x905*x907))+((x905*x908))+(((-0.1)*x905)));\nevalcond[2]=((0.4)+(((-1.0)*x908*x910))+(((-1.0)*x907*x910))+x909+(((0.1)*x906)));\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((0.2)*x907))+(((0.2)*x908))+(((-0.08)*x906))+((x907*x911))+((x908*x911))+(((-1.0)*(py*py))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x913=IKPowWithIntegerCheck(((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15))),-1);\nif(!x913.valid){\ncontinue;\n}\nIkReal x912=x913.value;\ncj16array[0]=((((-0.4)*x912))+(((-0.321)*cj18*x912)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x914=IKsin(j16);\nIkReal x915=IKcos(j16);\nIkReal x916=(py*sj15);\nIkReal x917=((0.321)*cj18);\nIkReal x918=(cj15*px);\nIkReal x919=((0.8)*x915);\nevalcond[0]=(((x914*x917))+(((0.4)*x914)));\nevalcond[1]=(((x914*x916))+((x914*x918))+(((-0.1)*x914)));\nevalcond[2]=((0.1)+(((0.4)*x915))+(((-1.0)*x916))+(((-1.0)*x918))+((x915*x917)));\nevalcond[3]=((-0.066959)+(((0.2)*x918))+(((0.2)*x916))+(((-1.0)*(px*px)))+(((-0.08)*x915))+((x918*x919))+((x916*x919))+(((-1.0)*(py*py))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j18), 6.28318530717959))))));\nevalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[2]=((0.509841)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\ncj16array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj15))+(((1.3869625520111)*cj15*px)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x920=IKcos(j16);\nIkReal x921=IKsin(j16);\nCheckValue<IkReal> x931=IKPowWithIntegerCheck(px,-1);\nif(!x931.valid){\ncontinue;\n}\nIkReal x922=x931.value;\nIkReal x923=py*py;\nIkReal x924=((1.0)*cj15);\nIkReal x925=(cj15*cj17);\nIkReal x926=((0.8)*cj15);\nIkReal x927=(px*x920);\nIkReal x928=(px*x921);\nIkReal x929=((0.1)*x921);\nIkReal x930=(x921*x922*x923);\nevalcond[0]=((0.721)*x921);\nevalcond[1]=((0.721)+(((0.1)*x920))+(((-1.0)*py*sj15*x920))+(((-1.0)*x924*x927)));\nevalcond[2]=((-0.5768)+(((-0.08)*x920))+((x926*x927))+((x920*x922*x923*x926)));\nevalcond[3]=((((-1.0)*cj17*x929))+((x925*x930))+((x925*x928)));\nevalcond[4]=((((-1.0)*sj17*x924*x928))+(((-1.0)*sj17*x924*x930))+((sj17*x929)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j18, 6.28318530717959)))))+(IKabs(pz)));\nevalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[2]=((-0.003759)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\ncj16array[0]=((-1.26582278481013)+(((12.6582278481013)*cj15*px))+(((12.6582278481013)*py*sj15)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x932=IKcos(j16);\nIkReal x933=IKsin(j16);\nCheckValue<IkReal> x943=IKPowWithIntegerCheck(px,-1);\nif(!x943.valid){\ncontinue;\n}\nIkReal x934=x943.value;\nIkReal x935=py*py;\nIkReal x936=((1.0)*cj15);\nIkReal x937=(cj15*cj17);\nIkReal x938=((0.8)*cj15);\nIkReal x939=(px*x932);\nIkReal x940=(px*x933);\nIkReal x941=((0.1)*x933);\nIkReal x942=(x933*x934*x935);\nevalcond[0]=((0.079)*x933);\nevalcond[1]=((0.079)+(((0.1)*x932))+(((-1.0)*py*sj15*x932))+(((-1.0)*x936*x939)));\nevalcond[2]=((-0.0632)+((x932*x934*x935*x938))+(((-0.08)*x932))+((x938*x939)));\nevalcond[3]=(((x937*x942))+((x937*x940))+(((-1.0)*cj17*x941)));\nevalcond[4]=((((-1.0)*sj17*x936*x940))+(((-1.0)*sj17*x936*x942))+((sj17*x941)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j16]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x944=cj15*cj15;\nIkReal x945=py*py;\nIkReal x946=(py*sj15);\nIkReal x947=(cj15*px);\nIkReal x948=((1000.0)*pz);\nIkReal x949=(cj17*sj18);\nIkReal x950=((1000.0)*x944);\nCheckValue<IkReal> x951=IKPowWithIntegerCheck(IKsign(((((321.0)*cj18*pz))+(((400.0)*pz))+(((-321.0)*x947*x949))+(((-321.0)*x946*x949))+(((32.1)*x949)))),-1);\nif(!x951.valid){\ncontinue;\n}\nCheckValue<IkReal> x952 = IKatan2WithCheck(IkReal(((-150.0)+(((-200.0)*x946))+(((-200.0)*x947))+(((2000.0)*x946*x947))+(((-256.8)*cj18))+(((1000.0)*x945))+((x950*(px*px)))+(((-1.0)*x945*x950))+(((-103.041)*(cj18*cj18))))),((((-100.0)*pz))+((x946*x948))+((x947*x948))+(((-128.4)*x949))+(((-103.041)*cj18*x949))),IKFAST_ATAN2_MAGTHRESH);\nif(!x952.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x951.value)))+(x952.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[6];\nIkReal x953=IKsin(j16);\nIkReal x954=IKcos(j16);\nIkReal x955=((0.321)*sj18);\nIkReal x956=(cj15*px);\nIkReal x957=(py*sj15);\nIkReal x958=(px*sj15);\nIkReal x959=((1.0)*sj17);\nIkReal x960=(cj15*py);\nIkReal x961=((0.321)*cj18);\nIkReal x962=(pz*x954);\nIkReal x963=((1.0)*x956);\nIkReal x964=((0.321)*x954);\nIkReal x965=(sj17*x953);\nIkReal x966=(pz*x953);\nIkReal x967=((0.8)*x954);\nIkReal x968=(cj17*x953);\nevalcond[0]=(((cj17*x954*x955))+pz+(((0.4)*x953))+((x953*x961)));\nevalcond[1]=((0.1)+((x954*x961))+(((-1.0)*x957))+(((-1.0)*x955*x968))+(((0.4)*x954))+(((-1.0)*x963)));\nevalcond[2]=((0.4)+(((0.1)*x954))+(((-1.0)*x954*x957))+x961+x966+(((-1.0)*x954*x963)));\nevalcond[3]=((-0.066959)+(((-0.8)*x966))+(((-1.0)*pp))+((x957*x967))+(((0.2)*x956))+(((0.2)*x957))+((x956*x967))+(((-0.08)*x954)));\nevalcond[4]=((((-1.0)*x953*x957*x959))+(((0.1)*x965))+((cj17*x958))+(((-1.0)*x959*x962))+(((-1.0)*cj17*x960))+(((-1.0)*x953*x956*x959)));\nevalcond[5]=(((sj17*x958))+(((-0.1)*x968))+((cj17*x962))+(((-1.0)*x959*x960))+((x957*x968))+((x956*x968))+x955);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x969=cj17*cj17;\nIkReal x970=cj18*cj18;\nIkReal x971=(cj15*px);\nIkReal x972=(py*sj15);\nIkReal x973=((321000.0)*cj18);\nIkReal x974=((321000.0)*cj17*sj18);\nIkReal x975=((103041.0)*x970);\nCheckValue<IkReal> x976=IKPowWithIntegerCheck(IKsign(((160000.0)+(((-1.0)*x969*x975))+(((256800.0)*cj18))+x975+(((103041.0)*x969)))),-1);\nif(!x976.valid){\ncontinue;\n}\nCheckValue<IkReal> x977 = IKatan2WithCheck(IkReal(((((32100.0)*cj17*sj18))+(((-1.0)*pz*x973))+(((-1.0)*x971*x974))+(((-400000.0)*pz))+(((-1.0)*x972*x974)))),((-40000.0)+(((-1.0)*pz*x974))+(((-32100.0)*cj18))+(((400000.0)*x971))+(((400000.0)*x972))+((x971*x973))+((x972*x973))),IKFAST_ATAN2_MAGTHRESH);\nif(!x977.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x976.value)))+(x977.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[6];\nIkReal x978=IKsin(j16);\nIkReal x979=IKcos(j16);\nIkReal x980=((0.321)*sj18);\nIkReal x981=(cj15*px);\nIkReal x982=(py*sj15);\nIkReal x983=(px*sj15);\nIkReal x984=((1.0)*sj17);\nIkReal x985=(cj15*py);\nIkReal x986=((0.321)*cj18);\nIkReal x987=(pz*x979);\nIkReal x988=((1.0)*x981);\nIkReal x989=((0.321)*x979);\nIkReal x990=(sj17*x978);\nIkReal x991=(pz*x978);\nIkReal x992=((0.8)*x979);\nIkReal x993=(cj17*x978);\nevalcond[0]=(pz+((cj17*x979*x980))+(((0.4)*x978))+((x978*x986)));\nevalcond[1]=((0.1)+(((-1.0)*x988))+(((-1.0)*x982))+((x979*x986))+(((-1.0)*x980*x993))+(((0.4)*x979)));\nevalcond[2]=((0.4)+(((0.1)*x979))+(((-1.0)*x979*x982))+(((-1.0)*x979*x988))+x991+x986);\nevalcond[3]=((-0.066959)+(((-0.8)*x991))+(((-1.0)*pp))+((x981*x992))+(((0.2)*x982))+(((0.2)*x981))+(((-0.08)*x979))+((x982*x992)));\nevalcond[4]=((((-1.0)*x978*x982*x984))+((cj17*x983))+(((-1.0)*cj17*x985))+(((0.1)*x990))+(((-1.0)*x984*x987))+(((-1.0)*x978*x981*x984)));\nevalcond[5]=(((sj17*x983))+((cj17*x987))+((x981*x993))+(((-0.1)*x993))+(((-1.0)*x984*x985))+x980+((x982*x993)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x994=(cj15*px);\nIkReal x995=((1000.0)*pz);\nIkReal x996=(cj17*sj18);\nIkReal x997=((321.0)*cj18);\nIkReal x998=(py*sj15);\nCheckValue<IkReal> x999 = IKatan2WithCheck(IkReal(((((-1.0)*x994*x995))+(((100.0)*pz))+(((-1.0)*x995*x998))+(((-128.4)*x996))+(((-103.041)*cj18*x996)))),((160.0)+(((-1.0)*pz*x995))+(((256.8)*cj18))+(((103.041)*(cj18*cj18)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x999.valid){\ncontinue;\n}\nCheckValue<IkReal> x1000=IKPowWithIntegerCheck(IKsign(((-40.0)+(((400.0)*x994))+(((400.0)*x998))+((x994*x997))+(((321.0)*pz*x996))+((x997*x998))+(((-32.1)*cj18)))),-1);\nif(!x1000.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(x999.value)+(((1.5707963267949)*(x1000.value))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[6];\nIkReal x1001=IKsin(j16);\nIkReal x1002=IKcos(j16);\nIkReal x1003=((0.321)*sj18);\nIkReal x1004=(cj15*px);\nIkReal x1005=(py*sj15);\nIkReal x1006=(px*sj15);\nIkReal x1007=((1.0)*sj17);\nIkReal x1008=(cj15*py);\nIkReal x1009=((0.321)*cj18);\nIkReal x1010=(pz*x1002);\nIkReal x1011=((1.0)*x1004);\nIkReal x1012=((0.321)*x1002);\nIkReal x1013=(sj17*x1001);\nIkReal x1014=(pz*x1001);\nIkReal x1015=((0.8)*x1002);\nIkReal x1016=(cj17*x1001);\nevalcond[0]=((((0.4)*x1001))+((cj17*x1002*x1003))+pz+((x1001*x1009)));\nevalcond[1]=((0.1)+(((-1.0)*x1005))+(((0.4)*x1002))+(((-1.0)*x1011))+(((-1.0)*x1003*x1016))+((x1002*x1009)));\nevalcond[2]=((0.4)+(((-1.0)*x1002*x1005))+(((0.1)*x1002))+x1014+x1009+(((-1.0)*x1002*x1011)));\nevalcond[3]=((-0.066959)+(((0.2)*x1004))+(((0.2)*x1005))+(((-0.08)*x1002))+(((-1.0)*pp))+((x1005*x1015))+((x1004*x1015))+(((-0.8)*x1014)));\nevalcond[4]=((((-1.0)*cj17*x1008))+(((-1.0)*x1001*x1005*x1007))+(((-1.0)*x1001*x1004*x1007))+(((-1.0)*x1007*x1010))+((cj17*x1006))+(((0.1)*x1013)));\nevalcond[5]=(x1003+((x1005*x1016))+(((-1.0)*x1007*x1008))+((x1004*x1016))+((sj17*x1006))+((cj17*x1010))+(((-0.1)*x1016)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x1017=py*py;\nIkReal x1018=cj15*cj15;\nIkReal x1019=px*px;\nIkReal x1020=((5.0)*pp);\nIkReal x1021=(py*sj15);\nIkReal x1022=(pz*sj17);\nIkReal x1023=(cj17*py);\nIkReal x1024=(cj15*px*sj17);\nIkReal x1025=((4.0)*x1017);\nIkReal x1026=(cj15*cj17*sj15);\nIkReal x1027=(sj17*x1018);\nIkReal x1028=((4.0)*x1019);\nIkReal x1029=((4.0)*x1023);\nIkReal x1030=(cj17*px*sj15);\nCheckValue<IkReal> x1031 = IKatan2WithCheck(IkReal(((((0.4)*x1030))+(((-1.0)*x1026*x1028))+(((-0.4)*cj15*x1023))+(((0.334795)*x1022))+(((-1.0)*x1021*x1022))+((x1020*x1022))+(((8.0)*px*x1018*x1023))+((x1025*x1026))+(((-1.0)*cj15*px*x1022))+(((-1.0)*px*x1029)))),((((-4.0)*pz*x1030))+(((0.5)*pp*sj17))+(((-1.0)*x1020*x1024))+((sj17*x1017))+((x1019*x1027))+(((-0.434795)*sj17*x1021))+(((-0.434795)*x1024))+(((2.0)*x1021*x1024))+(((0.0334795)*sj17))+(((-1.0)*x1017*x1027))+((cj15*pz*x1029))+(((-1.0)*sj17*x1020*x1021))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1031.valid){\ncontinue;\n}\nCheckValue<IkReal> x1032=IKPowWithIntegerCheck(IKsign(((((0.8)*sj17*x1021))+(((-8.0)*x1021*x1024))+((x1025*x1027))+(((0.8)*x1024))+(((-4.0)*pz*x1022))+(((-1.0)*x1027*x1028))+(((-0.04)*sj17))+(((-1.0)*sj17*x1025)))),-1);\nif(!x1032.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(x1031.value)+(((1.5707963267949)*(x1032.value))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[2];\nIkReal x1033=IKcos(j16);\nIkReal x1034=IKsin(j16);\nIkReal x1035=((1.0)*py);\nIkReal x1036=(cj15*px);\nIkReal x1037=(py*sj15);\nIkReal x1038=(sj17*x1034);\nIkReal x1039=((0.8)*x1033);\nevalcond[0]=((-0.066959)+((x1036*x1039))+(((-0.8)*pz*x1034))+(((-0.08)*x1033))+(((-1.0)*pp))+((x1037*x1039))+(((0.2)*x1036))+(((0.2)*x1037)));\nevalcond[1]=((((0.1)*x1038))+(((-1.0)*pz*sj17*x1033))+(((-1.0)*cj15*cj17*x1035))+((cj17*px*sj15))+(((-1.0)*sj15*x1035*x1038))+(((-1.0)*x1036*x1038)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j18eval[1];\nj18eval[0]=sj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j18eval[2];\nj18eval[0]=cj16;\nj18eval[1]=cj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j18eval[2];\nj18eval[0]=sj17;\nj18eval[1]=sj16;\nif( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1040=(py*sj15);\nIkReal x1041=((0.8)*cj16);\nIkReal x1042=(cj15*px);\nIkReal x1043=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));\nevalcond[1]=x1043;\nevalcond[2]=((-0.066959)+(((0.2)*x1042))+(((0.2)*x1040))+((x1040*x1041))+((x1041*x1042))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16)));\nevalcond[3]=x1043;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1044=((3.11526479750779)*cj16);\nIkReal x1045=(py*sj15);\nIkReal x1046=((3.11526479750779)*sj16);\nIkReal x1047=(cj15*px);\nif( IKabs(((((-1.0)*x1046*x1047))+(((-1.0)*x1045*x1046))+(((0.311526479750779)*sj16))+(((-1.0)*pz*x1044)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-1.0)*pz*x1046))+(((-0.311526479750779)*cj16))+((x1044*x1045))+((x1044*x1047)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1046*x1047))+(((-1.0)*x1045*x1046))+(((0.311526479750779)*sj16))+(((-1.0)*pz*x1044))))+IKsqr(((-1.24610591900312)+(((-1.0)*pz*x1046))+(((-0.311526479750779)*cj16))+((x1044*x1045))+((x1044*x1047))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((-1.0)*x1046*x1047))+(((-1.0)*x1045*x1046))+(((0.311526479750779)*sj16))+(((-1.0)*pz*x1044))), ((-1.24610591900312)+(((-1.0)*pz*x1046))+(((-0.311526479750779)*cj16))+((x1044*x1045))+((x1044*x1047))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1048=IKcos(j18);\nIkReal x1049=IKsin(j18);\nIkReal x1050=(py*sj15);\nIkReal x1051=(cj15*px);\nIkReal x1052=((1.0)*cj16);\nIkReal x1053=((0.321)*x1048);\nIkReal x1054=((0.321)*x1049);\nevalcond[0]=(((cj16*x1054))+(((0.4)*sj16))+pz+((sj16*x1053)));\nevalcond[1]=((0.253041)+(((0.2)*x1051))+(((0.2)*x1050))+(((-1.0)*pp))+(((0.2568)*x1048)));\nevalcond[2]=((((-0.1)*sj16))+x1054+((cj16*pz))+((sj16*x1051))+((sj16*x1050)));\nevalcond[3]=((0.4)+x1053+((pz*sj16))+(((-1.0)*x1050*x1052))+(((0.1)*cj16))+(((-1.0)*x1051*x1052)));\nevalcond[4]=((0.1)+((cj16*x1053))+(((-1.0)*sj16*x1054))+(((0.4)*cj16))+(((-1.0)*x1050))+(((-1.0)*x1051)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1055=(py*sj15);\nIkReal x1056=(cj15*py);\nIkReal x1057=((0.8)*cj16);\nIkReal x1058=(cj15*px);\nIkReal x1059=(px*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));\nevalcond[1]=(x1059+(((-1.0)*x1056)));\nevalcond[2]=((-0.066959)+((x1055*x1057))+(((0.2)*x1055))+(((0.2)*x1058))+((x1057*x1058))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16)));\nevalcond[3]=(x1056+(((-1.0)*x1059)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1060=((3.11526479750779)*cj16);\nIkReal x1061=((3.11526479750779)*sj16);\nIkReal x1062=(py*sj15);\nIkReal x1063=(cj15*px);\nif( IKabs((((x1061*x1062))+((x1061*x1063))+((pz*x1060))+(((-0.311526479750779)*sj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+((x1060*x1063))+((x1060*x1062))+(((-1.0)*pz*x1061))+(((-0.311526479750779)*cj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1061*x1062))+((x1061*x1063))+((pz*x1060))+(((-0.311526479750779)*sj16))))+IKsqr(((-1.24610591900312)+((x1060*x1063))+((x1060*x1062))+(((-1.0)*pz*x1061))+(((-0.311526479750779)*cj16))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2((((x1061*x1062))+((x1061*x1063))+((pz*x1060))+(((-0.311526479750779)*sj16))), ((-1.24610591900312)+((x1060*x1063))+((x1060*x1062))+(((-1.0)*pz*x1061))+(((-0.311526479750779)*cj16))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1064=IKcos(j18);\nIkReal x1065=IKsin(j18);\nIkReal x1066=((1.0)*cj16);\nIkReal x1067=(py*sj15);\nIkReal x1068=(cj15*px);\nIkReal x1069=((0.321)*x1064);\nIkReal x1070=((1.0)*x1068);\nIkReal x1071=((0.321)*x1065);\nevalcond[0]=((((0.4)*sj16))+pz+(((-1.0)*cj16*x1071))+((sj16*x1069)));\nevalcond[1]=((0.253041)+(((0.2)*x1068))+(((0.2)*x1067))+(((-1.0)*pp))+(((0.2568)*x1064)));\nevalcond[2]=((0.4)+x1069+((pz*sj16))+(((-1.0)*x1066*x1067))+(((-1.0)*x1066*x1068))+(((0.1)*cj16)));\nevalcond[3]=(x1071+(((-1.0)*pz*x1066))+(((-1.0)*sj16*x1070))+(((-1.0)*sj16*x1067))+(((0.1)*sj16)));\nevalcond[4]=((0.1)+((cj16*x1069))+(((0.4)*cj16))+((sj16*x1071))+(((-1.0)*x1067))+(((-1.0)*x1070)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j16))), 6.28318530717959)));\nevalcond[1]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));\nevalcond[2]=((((-1.0)*cj15*cj17*py))+(((-1.0)*pz*sj17))+((cj17*px*sj15)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18eval[1];\nsj16=0;\ncj16=1.0;\nj16=0;\nj18eval[0]=cj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j18eval[1];\nsj16=0;\ncj16=1.0;\nj16=0;\nj18eval[0]=sj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1072=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));\nevalcond[1]=x1072;\nevalcond[2]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));\nevalcond[3]=x1072;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1073=IKcos(j18);\nIkReal x1074=(py*sj15);\nIkReal x1075=(cj15*px);\nevalcond[0]=(pz+(((0.321)*(IKsin(j18)))));\nevalcond[1]=((0.4)+(((-0.8)*x1074))+(((-0.8)*x1075))+(((0.2568)*x1073)));\nevalcond[2]=((0.5)+(((0.321)*x1073))+(((-1.0)*x1075))+(((-1.0)*x1074)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1076=(cj15*py);\nIkReal x1077=(px*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));\nevalcond[1]=(x1077+(((-1.0)*x1076)));\nevalcond[2]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));\nevalcond[3]=(x1076+(((-1.0)*x1077)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1078=IKcos(j18);\nIkReal x1079=(py*sj15);\nIkReal x1080=(cj15*px);\nevalcond[0]=((((-0.321)*(IKsin(j18))))+pz);\nevalcond[1]=((0.4)+(((-0.8)*x1080))+(((-0.8)*x1079))+(((0.2568)*x1078)));\nevalcond[2]=((0.5)+(((0.321)*x1078))+(((-1.0)*x1080))+(((-1.0)*x1079)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1081=((3.11526479750779)*cj15);\nIkReal x1082=((3.11526479750779)*sj15);\nif( IKabs((((py*x1081))+(((-1.0)*px*x1082)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+((py*x1082))+((px*x1081)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((py*x1081))+(((-1.0)*px*x1082))))+IKsqr(((-1.55763239875389)+((py*x1082))+((px*x1081))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2((((py*x1081))+(((-1.0)*px*x1082))), ((-1.55763239875389)+((py*x1082))+((px*x1081))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1083=IKcos(j18);\nIkReal x1084=(py*sj15);\nIkReal x1085=(cj15*px);\nevalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));\nevalcond[1]=((0.4)+(((-0.8)*x1085))+(((-0.8)*x1084))+(((0.2568)*x1083)));\nevalcond[2]=((0.5)+(((-1.0)*x1085))+(((-1.0)*x1084))+(((0.321)*x1083)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1086=((3.11526479750779)*cj15);\nIkReal x1087=((3.11526479750779)*sj15);\nif( IKabs(((((-1.0)*py*x1086))+((px*x1087)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+((py*x1087))+((px*x1086)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*py*x1086))+((px*x1087))))+IKsqr(((-1.55763239875389)+((py*x1087))+((px*x1086))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((-1.0)*py*x1086))+((px*x1087))), ((-1.55763239875389)+((py*x1087))+((px*x1086))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1088=IKcos(j18);\nIkReal x1089=(py*sj15);\nIkReal x1090=(cj15*px);\nevalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));\nevalcond[1]=((0.4)+(((-0.8)*x1090))+(((-0.8)*x1089))+(((0.2568)*x1088)));\nevalcond[2]=((0.5)+(((-1.0)*x1090))+(((-1.0)*x1089))+(((0.321)*x1088)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j18]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1091=IKPowWithIntegerCheck(sj17,-1);\nif(!x1091.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1091.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1091.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x1091.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1092=IKsin(j18);\nIkReal x1093=IKcos(j18);\nIkReal x1094=(py*sj15);\nIkReal x1095=(cj15*px);\nIkReal x1096=(px*sj15);\nIkReal x1097=((0.321)*x1092);\nIkReal x1098=((1.0)*cj15*py);\nevalcond[0]=(pz+((cj17*x1097)));\nevalcond[1]=(x1096+(((-1.0)*x1098))+((sj17*x1097)));\nevalcond[2]=((0.4)+(((0.2568)*x1093))+(((-0.8)*x1094))+(((-0.8)*x1095)));\nevalcond[3]=((0.5)+(((-1.0)*x1094))+(((-1.0)*x1095))+(((0.321)*x1093)));\nevalcond[4]=(x1097+((sj17*x1096))+(((-1.0)*sj17*x1098))+((cj17*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1099=IKPowWithIntegerCheck(cj17,-1);\nif(!x1099.valid){\ncontinue;\n}\nif( IKabs(((-3.11526479750779)*pz*(x1099.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz*(x1099.value)))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((-3.11526479750779)*pz*(x1099.value)), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1100=IKsin(j18);\nIkReal x1101=IKcos(j18);\nIkReal x1102=(py*sj15);\nIkReal x1103=(cj15*px);\nIkReal x1104=(px*sj15);\nIkReal x1105=((0.321)*x1100);\nIkReal x1106=((1.0)*cj15*py);\nevalcond[0]=(pz+((cj17*x1105)));\nevalcond[1]=(x1104+((sj17*x1105))+(((-1.0)*x1106)));\nevalcond[2]=((0.4)+(((-0.8)*x1102))+(((-0.8)*x1103))+(((0.2568)*x1101)));\nevalcond[3]=((0.5)+(((0.321)*x1101))+(((-1.0)*x1102))+(((-1.0)*x1103)));\nevalcond[4]=(x1105+(((-1.0)*sj17*x1106))+((sj17*x1104))+((cj17*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j16)))), 6.28318530717959)));\nevalcond[1]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));\nevalcond[2]=((((-1.0)*cj15*cj17*py))+((pz*sj17))+((cj17*px*sj15)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18eval[1];\nsj16=0;\ncj16=-1.0;\nj16=3.14159265358979;\nj18eval[0]=cj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j18eval[1];\nsj16=0;\ncj16=-1.0;\nj16=3.14159265358979;\nj18eval[0]=sj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1107=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));\nevalcond[1]=x1107;\nevalcond[2]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));\nevalcond[3]=x1107;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1108=IKcos(j18);\nIkReal x1109=(py*sj15);\nIkReal x1110=(cj15*px);\nevalcond[0]=((((-0.321)*(IKsin(j18))))+pz);\nevalcond[1]=((0.3)+x1109+x1110+(((0.321)*x1108)));\nevalcond[2]=((0.24)+(((0.8)*x1110))+(((0.8)*x1109))+(((0.2568)*x1108)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1111=(cj15*py);\nIkReal x1112=(px*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));\nevalcond[1]=(x1112+(((-1.0)*x1111)));\nevalcond[2]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));\nevalcond[3]=(x1111+(((-1.0)*x1112)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((-3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1113=IKcos(j18);\nIkReal x1114=(py*sj15);\nIkReal x1115=(cj15*px);\nevalcond[0]=(pz+(((0.321)*(IKsin(j18)))));\nevalcond[1]=((0.3)+x1115+x1114+(((0.321)*x1113)));\nevalcond[2]=((0.24)+(((0.8)*x1114))+(((0.8)*x1115))+(((0.2568)*x1113)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1116=((3.11526479750779)*cj15);\nIkReal x1117=((3.11526479750779)*sj15);\nif( IKabs(((((-1.0)*px*x1117))+((py*x1116)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-1.0)*px*x1116))+(((-1.0)*py*x1117)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*px*x1117))+((py*x1116))))+IKsqr(((-0.934579439252336)+(((-1.0)*px*x1116))+(((-1.0)*py*x1117))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((-1.0)*px*x1117))+((py*x1116))), ((-0.934579439252336)+(((-1.0)*px*x1116))+(((-1.0)*py*x1117))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1118=IKcos(j18);\nIkReal x1119=(py*sj15);\nIkReal x1120=(cj15*px);\nevalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));\nevalcond[1]=((0.3)+x1119+x1120+(((0.321)*x1118)));\nevalcond[2]=((0.24)+(((0.8)*x1120))+(((0.8)*x1119))+(((0.2568)*x1118)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1121=((3.11526479750779)*cj15);\nIkReal x1122=((3.11526479750779)*sj15);\nif( IKabs((((px*x1122))+(((-1.0)*py*x1121)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-1.0)*py*x1122))+(((-1.0)*px*x1121)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((px*x1122))+(((-1.0)*py*x1121))))+IKsqr(((-0.934579439252336)+(((-1.0)*py*x1122))+(((-1.0)*px*x1121))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2((((px*x1122))+(((-1.0)*py*x1121))), ((-0.934579439252336)+(((-1.0)*py*x1122))+(((-1.0)*px*x1121))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1123=IKcos(j18);\nIkReal x1124=(py*sj15);\nIkReal x1125=(cj15*px);\nevalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));\nevalcond[1]=((0.3)+x1124+x1125+(((0.321)*x1123)));\nevalcond[2]=((0.24)+(((0.8)*x1125))+(((0.8)*x1124))+(((0.2568)*x1123)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j18]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1126=IKPowWithIntegerCheck(sj17,-1);\nif(!x1126.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1126.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1126.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x1126.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1127=IKsin(j18);\nIkReal x1128=IKcos(j18);\nIkReal x1129=(py*sj15);\nIkReal x1130=(cj15*px);\nIkReal x1131=(px*sj15);\nIkReal x1132=((0.321)*x1127);\nIkReal x1133=((1.0)*cj15*py);\nevalcond[0]=((((-1.0)*cj17*x1132))+pz);\nevalcond[1]=((0.3)+x1129+x1130+(((0.321)*x1128)));\nevalcond[2]=(x1131+((sj17*x1132))+(((-1.0)*x1133)));\nevalcond[3]=((0.24)+(((0.8)*x1129))+(((0.2568)*x1128))+(((0.8)*x1130)));\nevalcond[4]=(x1132+(((-1.0)*sj17*x1133))+((sj17*x1131))+(((-1.0)*cj17*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1134=IKPowWithIntegerCheck(cj17,-1);\nif(!x1134.valid){\ncontinue;\n}\nif( IKabs(((3.11526479750779)*pz*(x1134.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz*(x1134.value)))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((3.11526479750779)*pz*(x1134.value)), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1135=IKsin(j18);\nIkReal x1136=IKcos(j18);\nIkReal x1137=(py*sj15);\nIkReal x1138=(cj15*px);\nIkReal x1139=(px*sj15);\nIkReal x1140=((0.321)*x1135);\nIkReal x1141=((1.0)*cj15*py);\nevalcond[0]=(pz+(((-1.0)*cj17*x1140)));\nevalcond[1]=((0.3)+x1138+x1137+(((0.321)*x1136)));\nevalcond[2]=(x1139+(((-1.0)*x1141))+((sj17*x1140)));\nevalcond[3]=((0.24)+(((0.2568)*x1136))+(((0.8)*x1137))+(((0.8)*x1138)));\nevalcond[4]=(x1140+((sj17*x1139))+(((-1.0)*sj17*x1141))+(((-1.0)*cj17*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1142=((1.0)*py);\nIkReal x1143=(cj15*px);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+(((-0.8)*pz))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2)*x1143)));\nevalcond[2]=((((-1.0)*sj15*sj17*x1142))+(((-1.0)*sj17*x1143))+((cj17*px*sj15))+(((-1.0)*cj15*cj17*x1142))+(((0.1)*sj17)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1144=((3.11526479750779)*cj15);\nIkReal x1145=((3.11526479750779)*sj15);\nif( IKabs(((((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x1145))+(((-1.0)*cj17*py*x1145))+((py*sj17*x1144))+(((-1.0)*cj17*px*x1144)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x1145))+(((-1.0)*cj17*py*x1145))+((py*sj17*x1144))+(((-1.0)*cj17*px*x1144))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x1145))+(((-1.0)*cj17*py*x1145))+((py*sj17*x1144))+(((-1.0)*cj17*px*x1144))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1146=IKsin(j18);\nIkReal x1147=IKcos(j18);\nIkReal x1148=(py*sj15);\nIkReal x1149=(px*sj15);\nIkReal x1150=(cj15*px);\nIkReal x1151=((0.321)*x1146);\nIkReal x1152=((1.0)*cj15*py);\nevalcond[0]=((0.4)+(((0.321)*x1147))+pz);\nevalcond[1]=(x1149+(((-1.0)*x1152))+((sj17*x1151)));\nevalcond[2]=((0.1)+(((-1.0)*x1148))+(((-1.0)*x1150))+(((-1.0)*cj17*x1151)));\nevalcond[3]=((0.253041)+(((0.2)*x1150))+(((-1.0)*pp))+(((0.2)*x1148))+(((0.2568)*x1147)));\nevalcond[4]=(x1151+(((-0.1)*cj17))+(((-1.0)*sj17*x1152))+((cj17*x1148))+((sj17*x1149))+((cj17*x1150)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1153=(cj15*px);\nIkReal x1154=(py*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j16)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+(((0.2)*x1154))+(((0.2)*x1153))+(((0.8)*pz))+(((-1.0)*pp)));\nevalcond[2]=((((-1.0)*cj15*cj17*py))+(((-0.1)*sj17))+((cj17*px*sj15))+((sj17*x1154))+((sj17*x1153)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18eval[1];\nsj16=-1.0;\ncj16=0;\nj16=-1.5707963267949;\nj18eval[0]=sj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j18eval[1];\nsj16=-1.0;\ncj16=0;\nj16=-1.5707963267949;\nj18eval[0]=cj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1155=(cj15*px);\nIkReal x1156=(py*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=((0.1)+(((-1.0)*x1155))+(((-1.0)*x1156)));\nevalcond[2]=((-0.066959)+(((0.2)*x1155))+(((0.2)*x1156))+(((0.8)*pz))+(((-1.0)*pp)));\nevalcond[3]=((-0.1)+x1155+x1156);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1157=IKcos(j18);\nevalcond[0]=((-0.4)+(((-0.321)*x1157))+pz);\nevalcond[1]=((0.273041)+(((0.2568)*x1157))+(((-1.0)*pp)));\nevalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1158=(py*sj15);\nIkReal x1159=(cj15*px);\nIkReal x1160=((0.1)+(((-1.0)*x1158))+(((-1.0)*x1159)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=x1160;\nevalcond[2]=((-0.066959)+(((0.2)*x1159))+(((0.2)*x1158))+(((0.8)*pz))+(((-1.0)*pp)));\nevalcond[3]=x1160;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1161=IKcos(j18);\nevalcond[0]=((-0.4)+(((-0.321)*x1161))+pz);\nevalcond[1]=((0.273041)+(((0.2568)*x1161))+(((-1.0)*pp)));\nevalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1162=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));\nevalcond[1]=x1162;\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));\nevalcond[3]=x1162;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1163=IKcos(j18);\nIkReal x1164=(cj15*px);\nIkReal x1165=(py*sj15);\nevalcond[0]=((-0.4)+(((-0.321)*x1163))+pz);\nevalcond[1]=((0.1)+(((-1.0)*x1164))+(((-1.0)*x1165))+(((0.321)*(IKsin(j18)))));\nevalcond[2]=((0.253041)+(((0.2568)*x1163))+(((-1.0)*pp))+(((0.2)*x1164))+(((0.2)*x1165)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1166=(cj15*py);\nIkReal x1167=(px*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));\nevalcond[1]=(x1167+(((-1.0)*x1166)));\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));\nevalcond[3]=(x1166+(((-1.0)*x1167)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1168=IKcos(j18);\nIkReal x1169=(cj15*px);\nIkReal x1170=(py*sj15);\nevalcond[0]=((-0.4)+(((-0.321)*x1168))+pz);\nevalcond[1]=((0.1)+(((-0.321)*(IKsin(j18))))+(((-1.0)*x1169))+(((-1.0)*x1170)));\nevalcond[2]=((0.253041)+(((0.2568)*x1168))+(((0.2)*x1170))+(((-1.0)*pp))+(((0.2)*x1169)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j18]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1171=IKPowWithIntegerCheck(cj17,-1);\nif(!x1171.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1171.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1171.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x1171.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1172=IKsin(j18);\nIkReal x1173=IKcos(j18);\nIkReal x1174=(py*sj15);\nIkReal x1175=((1.0)*cj15);\nIkReal x1176=(px*sj15);\nIkReal x1177=((0.321)*x1172);\nevalcond[0]=((-0.4)+(((-0.321)*x1173))+pz);\nevalcond[1]=(x1176+((sj17*x1177))+(((-1.0)*py*x1175)));\nevalcond[2]=((0.1)+((cj17*x1177))+(((-1.0)*px*x1175))+(((-1.0)*x1174)));\nevalcond[3]=((0.253041)+(((0.2568)*x1173))+(((0.2)*cj15*px))+(((0.2)*x1174))+(((-1.0)*pp)));\nevalcond[4]=(x1177+((sj17*x1176))+(((-1.0)*cj17*px*x1175))+(((-1.0)*py*sj17*x1175))+(((-1.0)*cj17*x1174))+(((0.1)*cj17)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1178=IKPowWithIntegerCheck(sj17,-1);\nif(!x1178.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1178.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1178.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x1178.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1179=IKsin(j18);\nIkReal x1180=IKcos(j18);\nIkReal x1181=(py*sj15);\nIkReal x1182=((1.0)*cj15);\nIkReal x1183=(px*sj15);\nIkReal x1184=((0.321)*x1179);\nevalcond[0]=((-0.4)+(((-0.321)*x1180))+pz);\nevalcond[1]=(x1183+(((-1.0)*py*x1182))+((sj17*x1184)));\nevalcond[2]=((0.1)+((cj17*x1184))+(((-1.0)*x1181))+(((-1.0)*px*x1182)));\nevalcond[3]=((0.253041)+(((0.2)*cj15*px))+(((-1.0)*pp))+(((0.2)*x1181))+(((0.2568)*x1180)));\nevalcond[4]=((((-1.0)*cj17*x1181))+x1184+(((-1.0)*cj17*px*x1182))+((sj17*x1183))+(((-1.0)*py*sj17*x1182))+(((0.1)*cj17)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1185=((1.0)*sj16);\nIkReal x1186=(cj15*px);\nIkReal x1187=(py*sj15);\nIkReal x1188=((0.8)*cj16);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+((x1187*x1188))+((x1186*x1188))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+(((0.2)*x1186))+(((0.2)*x1187)));\nevalcond[2]=((((-1.0)*x1185*x1186))+(((-1.0)*x1185*x1187))+(((-1.0)*cj16*pz))+(((0.1)*sj16)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1189=IKcos(j18);\nIkReal x1190=(py*sj15);\nIkReal x1191=((1.0)*cj16);\nIkReal x1192=((1.0)*cj15);\nIkReal x1193=(cj15*px);\nIkReal x1194=((0.321)*x1189);\nevalcond[0]=((((0.4)*sj16))+((sj16*x1194))+pz);\nevalcond[1]=(((px*sj15))+(((-1.0)*py*x1192))+(((0.321)*(IKsin(j18)))));\nevalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1190))+(((0.2)*x1193))+(((0.2568)*x1189)));\nevalcond[3]=((0.1)+((cj16*x1194))+(((0.4)*cj16))+(((-1.0)*px*x1192))+(((-1.0)*x1190)));\nevalcond[4]=((0.4)+x1194+(((-1.0)*x1191*x1193))+(((-1.0)*x1190*x1191))+((pz*sj16))+(((0.1)*cj16)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1195=(cj15*px);\nIkReal x1196=((0.8)*cj16);\nIkReal x1197=(py*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+((x1195*x1196))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1196*x1197))+(((0.2)*x1195))+(((0.2)*x1197)));\nevalcond[2]=((((-0.1)*sj16))+((sj16*x1195))+((sj16*x1197))+((cj16*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1198=IKcos(j18);\nIkReal x1199=(py*sj15);\nIkReal x1200=((1.0)*cj16);\nIkReal x1201=((1.0)*cj15);\nIkReal x1202=(cj15*px);\nIkReal x1203=((0.321)*x1198);\nevalcond[0]=(((sj16*x1203))+(((0.4)*sj16))+pz);\nevalcond[1]=(((px*sj15))+(((-0.321)*(IKsin(j18))))+(((-1.0)*py*x1201)));\nevalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1199))+(((0.2568)*x1198))+(((0.2)*x1202)));\nevalcond[3]=((0.1)+(((0.4)*cj16))+(((-1.0)*px*x1201))+((cj16*x1203))+(((-1.0)*x1199)));\nevalcond[4]=((0.4)+(((-1.0)*x1199*x1200))+x1203+((pz*sj16))+(((-1.0)*x1200*x1202))+(((0.1)*cj16)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j18]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1209=IKPowWithIntegerCheck(sj17,-1);\nif(!x1209.valid){\ncontinue;\n}\nIkReal x1204=x1209.value;\nIkReal x1205=((0.00311526479750779)*x1204);\nIkReal x1206=(px*sj15);\nIkReal x1207=(cj15*py);\nIkReal x1208=((1000.0)*cj16*cj17);\nCheckValue<IkReal> x1210=IKPowWithIntegerCheck(sj16,-1);\nif(!x1210.valid){\ncontinue;\n}\nif( IKabs((x1205*(((((1000.0)*x1207))+(((-1000.0)*x1206)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1205*(x1210.value)*(((((-1000.0)*pz*sj17))+(((-400.0)*sj16*sj17))+((x1206*x1208))+(((-1.0)*x1207*x1208)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1205*(((((1000.0)*x1207))+(((-1000.0)*x1206))))))+IKsqr((x1205*(x1210.value)*(((((-1000.0)*pz*sj17))+(((-400.0)*sj16*sj17))+((x1206*x1208))+(((-1.0)*x1207*x1208))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2((x1205*(((((1000.0)*x1207))+(((-1000.0)*x1206))))), (x1205*(x1210.value)*(((((-1000.0)*pz*sj17))+(((-400.0)*sj16*sj17))+((x1206*x1208))+(((-1.0)*x1207*x1208))))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[6];\nIkReal x1211=IKcos(j18);\nIkReal x1212=IKsin(j18);\nIkReal x1213=(cj17*sj16);\nIkReal x1214=(cj16*cj17);\nIkReal x1215=(cj15*px);\nIkReal x1216=((1.0)*cj16);\nIkReal x1217=(py*sj15);\nIkReal x1218=(px*sj15);\nIkReal x1219=((0.321)*x1212);\nIkReal x1220=((0.321)*x1211);\nIkReal x1221=((1.0)*cj15*py);\nevalcond[0]=(x1218+(((-1.0)*x1221))+((sj17*x1219)));\nevalcond[1]=((0.253041)+(((0.2)*x1215))+(((0.2)*x1217))+(((0.2568)*x1211))+(((-1.0)*pp)));\nevalcond[2]=(((x1214*x1219))+(((0.4)*sj16))+pz+((sj16*x1220)));\nevalcond[3]=((0.4)+x1220+(((-1.0)*x1215*x1216))+(((-1.0)*x1216*x1217))+((pz*sj16))+(((0.1)*cj16)));\nevalcond[4]=((0.1)+((cj16*x1220))+(((-1.0)*x1213*x1219))+(((0.4)*cj16))+(((-1.0)*x1217))+(((-1.0)*x1215)));\nevalcond[5]=(x1219+(((-0.1)*x1213))+((x1213*x1215))+((x1213*x1217))+(((-1.0)*sj17*x1221))+((sj17*x1218))+((pz*x1214)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1222=((250.0)*sj16);\nIkReal x1223=(py*sj15);\nIkReal x1224=(cj15*px);\nCheckValue<IkReal> x1225=IKPowWithIntegerCheck(cj16,-1);\nif(!x1225.valid){\ncontinue;\n}\nCheckValue<IkReal> x1226=IKPowWithIntegerCheck(cj17,-1);\nif(!x1226.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1225.value)*(x1226.value)*(((((-1000.0)*pz))+((x1222*x1224))+((x1222*x1223))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((-0.778816199376947)*x1224))+(((-0.778816199376947)*x1223))+(((3.89408099688474)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1225.value)*(x1226.value)*(((((-1000.0)*pz))+((x1222*x1224))+((x1222*x1223))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))))+IKsqr(((-0.98536214953271)+(((-0.778816199376947)*x1224))+(((-0.778816199376947)*x1223))+(((3.89408099688474)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x1225.value)*(x1226.value)*(((((-1000.0)*pz))+((x1222*x1224))+((x1222*x1223))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))), ((-0.98536214953271)+(((-0.778816199376947)*x1224))+(((-0.778816199376947)*x1223))+(((3.89408099688474)*pp))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[6];\nIkReal x1227=IKcos(j18);\nIkReal x1228=IKsin(j18);\nIkReal x1229=(cj17*sj16);\nIkReal x1230=(cj16*cj17);\nIkReal x1231=(cj15*px);\nIkReal x1232=((1.0)*cj16);\nIkReal x1233=(py*sj15);\nIkReal x1234=(px*sj15);\nIkReal x1235=((0.321)*x1228);\nIkReal x1236=((0.321)*x1227);\nIkReal x1237=((1.0)*cj15*py);\nevalcond[0]=(x1234+(((-1.0)*x1237))+((sj17*x1235)));\nevalcond[1]=((0.253041)+(((0.2568)*x1227))+(((-1.0)*pp))+(((0.2)*x1231))+(((0.2)*x1233)));\nevalcond[2]=((((0.4)*sj16))+((sj16*x1236))+pz+((x1230*x1235)));\nevalcond[3]=((0.4)+x1236+((pz*sj16))+(((-1.0)*x1231*x1232))+(((-1.0)*x1232*x1233))+(((0.1)*cj16)));\nevalcond[4]=((0.1)+(((-1.0)*x1231))+(((-1.0)*x1233))+((cj16*x1236))+(((0.4)*cj16))+(((-1.0)*x1229*x1235)));\nevalcond[5]=(x1235+(((-1.0)*sj17*x1237))+((pz*x1230))+(((-0.1)*x1229))+((sj17*x1234))+((x1229*x1233))+((x1229*x1231)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1238=IKPowWithIntegerCheck(sj17,-1);\nif(!x1238.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1238.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1238.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x1238.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[6];\nIkReal x1239=IKcos(j18);\nIkReal x1240=IKsin(j18);\nIkReal x1241=(cj17*sj16);\nIkReal x1242=(cj16*cj17);\nIkReal x1243=(cj15*px);\nIkReal x1244=((1.0)*cj16);\nIkReal x1245=(py*sj15);\nIkReal x1246=(px*sj15);\nIkReal x1247=((0.321)*x1240);\nIkReal x1248=((0.321)*x1239);\nIkReal x1249=((1.0)*cj15*py);\nevalcond[0]=(x1246+(((-1.0)*x1249))+((sj17*x1247)));\nevalcond[1]=((0.253041)+(((0.2)*x1243))+(((0.2)*x1245))+(((0.2568)*x1239))+(((-1.0)*pp)));\nevalcond[2]=((((0.4)*sj16))+((sj16*x1248))+pz+((x1242*x1247)));\nevalcond[3]=((0.4)+x1248+(((-1.0)*x1244*x1245))+(((-1.0)*x1243*x1244))+((pz*sj16))+(((0.1)*cj16)));\nevalcond[4]=((0.1)+((cj16*x1248))+(((-1.0)*x1243))+(((-1.0)*x1245))+(((0.4)*cj16))+(((-1.0)*x1241*x1247)));\nevalcond[5]=(x1247+((pz*x1242))+(((-0.1)*x1241))+((sj17*x1246))+((x1241*x1245))+((x1241*x1243))+(((-1.0)*sj17*x1249)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n    }\n}\nreturn solutions.GetNumSolutions()>0;\n}\ninline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {\nfor(int rotationiter = 0; rotationiter < 1; ++rotationiter) {\nIkReal x196=((1.0)*cj17);\nIkReal x197=(cj18*sj16);\nIkReal x198=(cj16*sj17);\nIkReal x199=(sj16*sj18);\nIkReal x200=(sj16*sj17);\nIkReal x201=(cj16*cj18);\nIkReal x202=(sj17*sj18);\nIkReal x203=(cj16*sj18);\nIkReal x204=(cj18*sj15*sj17);\nIkReal x205=(x199+(((-1.0)*x196*x201)));\nIkReal x206=(((sj15*x200))+((cj15*cj17)));\nIkReal x207=(((cj15*x200))+(((-1.0)*sj15*x196)));\nIkReal x208=((((-1.0)*x196*x199))+x201);\nIkReal x209=(cj15*x208);\nIkReal x210=((((-1.0)*x196*x197))+(((-1.0)*x203)));\nIkReal x211=((((-1.0)*x197))+(((-1.0)*x196*x203)));\nIkReal x212=(cj15*x210);\nIkReal x213=(((cj15*x202))+((sj15*x208)));\nIkReal x214=((((-1.0)*sj15*x202))+x209);\nIkReal x215=(((cj15*cj18*sj17))+((sj15*x210)));\nIkReal x216=(x212+(((-1.0)*x204)));\nnew_r00=(((r20*x205))+((r00*x216))+((r10*x215)));\nnew_r01=(((r11*x215))+((r21*x205))+((r01*x216)));\nnew_r02=(((r22*x205))+((r02*((x212+(((-1.0)*x204))))))+((r12*x215)));\nnew_r10=(((r20*x198))+((r00*x207))+((r10*x206)));\nnew_r11=(((r11*x206))+((r01*x207))+((r21*x198)));\nnew_r12=(((r22*x198))+((r12*x206))+((r02*x207)));\nnew_r20=(((r00*(((((-1.0)*sj15*x202))+x209))))+((r10*x213))+((r20*x211)));\nnew_r21=(((r21*x211))+((r11*x213))+((r01*x214)));\nnew_r22=(((r12*x213))+((r02*x214))+((r22*x211)));\n{\nIkReal j20array[2], cj20array[2], sj20array[2];\nbool j20valid[2]={false};\n_nj20 = 2;\ncj20array[0]=new_r22;\nif( cj20array[0] >= -1-IKFAST_SINCOS_THRESH && cj20array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j20valid[0] = j20valid[1] = true;\n    j20array[0] = IKacos(cj20array[0]);\n    sj20array[0] = IKsin(j20array[0]);\n    cj20array[1] = cj20array[0];\n    j20array[1] = -j20array[0];\n    sj20array[1] = -sj20array[0];\n}\nelse if( isnan(cj20array[0]) )\n{\n    // probably any value will work\n    j20valid[0] = true;\n    cj20array[0] = 1; sj20array[0] = 0; j20array[0] = 0;\n}\nfor(int ij20 = 0; ij20 < 2; ++ij20)\n{\nif( !j20valid[ij20] )\n{\n    continue;\n}\n_ij20[0] = ij20; _ij20[1] = -1;\nfor(int iij20 = ij20+1; iij20 < 2; ++iij20)\n{\nif( j20valid[iij20] && IKabs(cj20array[ij20]-cj20array[iij20]) < IKFAST_SOLUTION_THRESH && IKabs(sj20array[ij20]-sj20array[iij20]) < IKFAST_SOLUTION_THRESH )\n{\n    j20valid[iij20]=false; _ij20[1] = iij20; break; \n}\n}\nj20 = j20array[ij20]; cj20 = cj20array[ij20]; sj20 = sj20array[ij20];\n\n{\nIkReal j19eval[2];\nIkReal x217=((1.0)*cj17);\nIkReal x218=(cj18*sj16);\nIkReal x219=(cj16*sj17);\nIkReal x220=(sj16*sj18);\nIkReal x221=(sj16*sj17);\nIkReal x222=(cj16*cj18);\nIkReal x223=(sj17*sj18);\nIkReal x224=(cj16*sj18);\nIkReal x225=(cj18*sj15*sj17);\nIkReal x226=(x220+(((-1.0)*x217*x222)));\nIkReal x227=x206;\nIkReal x228=x207;\nIkReal x229=(x222+(((-1.0)*x217*x220)));\nIkReal x230=(cj15*x229);\nIkReal x231=x210;\nIkReal x232=x211;\nIkReal x233=(cj15*x231);\nIkReal x234=(((cj15*x223))+((sj15*x229)));\nIkReal x235=(x230+(((-1.0)*sj15*x223)));\nIkReal x236=(((cj15*cj18*sj17))+((sj15*x231)));\nIkReal x237=(x233+(((-1.0)*x225)));\nnew_r00=(((r20*x226))+((r10*x236))+((r00*x237)));\nnew_r01=(((r11*x236))+((r01*x237))+((r21*x226)));\nnew_r02=(((r02*((x233+(((-1.0)*x225))))))+((r22*x226))+((r12*x236)));\nnew_r10=(((r00*x228))+((r10*x227))+((r20*x219)));\nnew_r11=(((r21*x219))+((r01*x228))+((r11*x227)));\nnew_r12=(((r12*x227))+((r22*x219))+((r02*x228)));\nnew_r20=(((r10*x234))+((r00*((x230+(((-1.0)*sj15*x223))))))+((r20*x232)));\nnew_r21=(((r11*x234))+((r01*x235))+((r21*x232)));\nnew_r22=(((r02*x235))+((r12*x234))+((r22*x232)));\nj19eval[0]=sj20;\nj19eval[1]=IKsign(sj20);\nif( IKabs(j19eval[0]) < 0.0000010000000000  || IKabs(j19eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j19eval[1];\nIkReal x238=((1.0)*cj17);\nIkReal x239=(cj18*sj16);\nIkReal x240=(cj16*sj17);\nIkReal x241=(sj16*sj18);\nIkReal x242=(sj16*sj17);\nIkReal x243=(cj16*cj18);\nIkReal x244=(sj17*sj18);\nIkReal x245=(cj16*sj18);\nIkReal x246=(cj18*sj15*sj17);\nIkReal x247=(x241+(((-1.0)*x238*x243)));\nIkReal x248=x206;\nIkReal x249=x207;\nIkReal x250=(x243+(((-1.0)*x238*x241)));\nIkReal x251=(cj15*x250);\nIkReal x252=x210;\nIkReal x253=x211;\nIkReal x254=(cj15*x252);\nIkReal x255=(((cj15*x244))+((sj15*x250)));\nIkReal x256=(x251+(((-1.0)*sj15*x244)));\nIkReal x257=(((cj15*cj18*sj17))+((sj15*x252)));\nIkReal x258=((((-1.0)*x246))+x254);\nnew_r00=(((r00*x258))+((r10*x257))+((r20*x247)));\nnew_r01=(((r11*x257))+((r01*x258))+((r21*x247)));\nnew_r02=(((r22*x247))+((r12*x257))+((r02*(((((-1.0)*x246))+x254)))));\nnew_r10=(((r00*x249))+((r10*x248))+((r20*x240)));\nnew_r11=(((r21*x240))+((r01*x249))+((r11*x248)));\nnew_r12=(((r02*x249))+((r22*x240))+((r12*x248)));\nnew_r20=(((r20*x253))+((r10*x255))+((r00*((x251+(((-1.0)*sj15*x244)))))));\nnew_r21=(((r21*x253))+((r11*x255))+((r01*x256)));\nnew_r22=(((r12*x255))+((r22*x253))+((r02*x256)));\nj19eval[0]=sj20;\nif( IKabs(j19eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j19array[2], cj19array[2], sj19array[2];\nbool j19valid[2]={false};\n_nj19 = 2;\nCheckValue<IkReal> x260 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x260.valid){\ncontinue;\n}\nIkReal x259=x260.value;\nj19array[0]=((-1.0)*x259);\nsj19array[0]=IKsin(j19array[0]);\ncj19array[0]=IKcos(j19array[0]);\nj19array[1]=((3.14159265358979)+(((-1.0)*x259)));\nsj19array[1]=IKsin(j19array[1]);\ncj19array[1]=IKcos(j19array[1]);\nif( j19array[0] > IKPI )\n{\n    j19array[0]-=IK2PI;\n}\nelse if( j19array[0] < -IKPI )\n{    j19array[0]+=IK2PI;\n}\nj19valid[0] = true;\nif( j19array[1] > IKPI )\n{\n    j19array[1]-=IK2PI;\n}\nelse if( j19array[1] < -IKPI )\n{    j19array[1]+=IK2PI;\n}\nj19valid[1] = true;\nfor(int ij19 = 0; ij19 < 2; ++ij19)\n{\nif( !j19valid[ij19] )\n{\n    continue;\n}\n_ij19[0] = ij19; _ij19[1] = -1;\nfor(int iij19 = ij19+1; iij19 < 2; ++iij19)\n{\nif( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )\n{\n    j19valid[iij19]=false; _ij19[1] = iij19; break; \n}\n}\nj19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*new_r02*(IKsin(j19))))+((new_r12*(IKcos(j19)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nIkReal x261=((1.0)*sj19);\nif( IKabs(((((-1.0)*new_r00*x261))+(((-1.0)*cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x261))+((cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x261))+(((-1.0)*cj19*new_r01))))+IKsqr(((((-1.0)*new_r01*x261))+((cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((((-1.0)*new_r00*x261))+(((-1.0)*cj19*new_r01))), ((((-1.0)*new_r01*x261))+((cj19*new_r00))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x262=IKsin(j21);\nIkReal x263=IKcos(j21);\nIkReal x264=((1.0)*sj19);\nIkReal x265=((1.0)*x263);\nIkReal x266=(sj19*x262);\nIkReal x267=((1.0)*x262);\nIkReal x268=(cj19*x265);\nevalcond[0]=(x262+((cj19*new_r01))+((new_r11*sj19)));\nevalcond[1]=(((cj19*x262))+((sj19*x263))+new_r01);\nevalcond[2]=((((-1.0)*x265))+((new_r10*sj19))+((cj19*new_r00)));\nevalcond[3]=((((-1.0)*new_r00*x264))+((cj19*new_r10))+(((-1.0)*x267)));\nevalcond[4]=((((-1.0)*new_r01*x264))+((cj19*new_r11))+(((-1.0)*x265)));\nevalcond[5]=(x266+new_r00+(((-1.0)*x268)));\nevalcond[6]=(x266+new_r11+(((-1.0)*x268)));\nevalcond[7]=((((-1.0)*x263*x264))+new_r10+(((-1.0)*cj19*x267)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j19array[2], cj19array[2], sj19array[2];\nbool j19valid[2]={false};\n_nj19 = 2;\nCheckValue<IkReal> x270 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x270.valid){\ncontinue;\n}\nIkReal x269=x270.value;\nj19array[0]=((-1.0)*x269);\nsj19array[0]=IKsin(j19array[0]);\ncj19array[0]=IKcos(j19array[0]);\nj19array[1]=((3.14159265358979)+(((-1.0)*x269)));\nsj19array[1]=IKsin(j19array[1]);\ncj19array[1]=IKcos(j19array[1]);\nif( j19array[0] > IKPI )\n{\n    j19array[0]-=IK2PI;\n}\nelse if( j19array[0] < -IKPI )\n{    j19array[0]+=IK2PI;\n}\nj19valid[0] = true;\nif( j19array[1] > IKPI )\n{\n    j19array[1]-=IK2PI;\n}\nelse if( j19array[1] < -IKPI )\n{    j19array[1]+=IK2PI;\n}\nj19valid[1] = true;\nfor(int ij19 = 0; ij19 < 2; ++ij19)\n{\nif( !j19valid[ij19] )\n{\n    continue;\n}\n_ij19[0] = ij19; _ij19[1] = -1;\nfor(int iij19 = ij19+1; iij19 < 2; ++iij19)\n{\nif( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )\n{\n    j19valid[iij19]=false; _ij19[1] = iij19; break; \n}\n}\nj19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*new_r02*(IKsin(j19))))+((new_r12*(IKcos(j19)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nIkReal x271=((1.0)*sj19);\nif( IKabs(((((-1.0)*new_r00*x271))+((cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x271))+(((-1.0)*cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x271))+((cj19*new_r01))))+IKsqr(((((-1.0)*new_r01*x271))+(((-1.0)*cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((((-1.0)*new_r00*x271))+((cj19*new_r01))), ((((-1.0)*new_r01*x271))+(((-1.0)*cj19*new_r00))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x272=IKsin(j21);\nIkReal x273=IKcos(j21);\nIkReal x274=((1.0)*cj19);\nIkReal x275=((1.0)*sj19);\nIkReal x276=((1.0)*x272);\nIkReal x277=(sj19*x273);\nIkReal x278=(sj19*x272);\nIkReal x279=(x272*x274);\nevalcond[0]=(x273+((new_r10*sj19))+((cj19*new_r00)));\nevalcond[1]=((((-1.0)*x276))+((cj19*new_r01))+((new_r11*sj19)));\nevalcond[2]=(x278+((cj19*x273))+new_r00);\nevalcond[3]=((((-1.0)*new_r00*x275))+(((-1.0)*x276))+((cj19*new_r10)));\nevalcond[4]=((((-1.0)*new_r01*x275))+(((-1.0)*x273))+((cj19*new_r11)));\nevalcond[5]=(x277+(((-1.0)*x279))+new_r01);\nevalcond[6]=(x277+(((-1.0)*x279))+new_r10);\nevalcond[7]=((((-1.0)*x272*x275))+(((-1.0)*x273*x274))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j19, j21]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j19array[1], cj19array[1], sj19array[1];\nbool j19valid[1]={false};\n_nj19 = 1;\nCheckValue<IkReal> x281=IKPowWithIntegerCheck(sj20,-1);\nif(!x281.valid){\ncontinue;\n}\nIkReal x280=x281.value;\nCheckValue<IkReal> x282=IKPowWithIntegerCheck(new_r12,-1);\nif(!x282.valid){\ncontinue;\n}\nif( IKabs((x280*(x282.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj20*cj20))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x280)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x280*(x282.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj20*cj20)))))))+IKsqr((new_r02*x280))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj19array[0]=IKatan2((x280*(x282.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj20*cj20)))))), (new_r02*x280));\nsj19array[0]=IKsin(j19array[0]);\ncj19array[0]=IKcos(j19array[0]);\nif( j19array[0] > IKPI )\n{\n    j19array[0]-=IK2PI;\n}\nelse if( j19array[0] < -IKPI )\n{    j19array[0]+=IK2PI;\n}\nj19valid[0] = true;\nfor(int ij19 = 0; ij19 < 1; ++ij19)\n{\nif( !j19valid[ij19] )\n{\n    continue;\n}\n_ij19[0] = ij19; _ij19[1] = -1;\nfor(int iij19 = ij19+1; iij19 < 1; ++iij19)\n{\nif( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )\n{\n    j19valid[iij19]=false; _ij19[1] = iij19; break; \n}\n}\nj19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];\n{\nIkReal evalcond[8];\nIkReal x283=IKcos(j19);\nIkReal x284=IKsin(j19);\nIkReal x285=((1.0)*sj20);\nIkReal x286=(new_r02*x283);\nIkReal x287=(new_r12*x284);\nIkReal x288=(sj20*x283);\nIkReal x289=(sj20*x284);\nevalcond[0]=(new_r02+(((-1.0)*x283*x285)));\nevalcond[1]=((((-1.0)*x284*x285))+new_r12);\nevalcond[2]=(((new_r12*x283))+(((-1.0)*new_r02*x284)));\nevalcond[3]=(x287+x286+(((-1.0)*x285)));\nevalcond[4]=(((cj20*new_r20))+((new_r00*x288))+((new_r10*x289)));\nevalcond[5]=(((cj20*new_r21))+((new_r11*x289))+((new_r01*x288)));\nevalcond[6]=((-1.0)+((sj20*x286))+((sj20*x287))+((cj20*new_r22)));\nevalcond[7]=(((cj20*x287))+((cj20*x286))+(((-1.0)*new_r22*x285)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j21eval[2];\nIkReal x290=((1.0)*cj17);\nIkReal x291=(cj18*sj16);\nIkReal x292=(cj16*sj17);\nIkReal x293=(sj16*sj18);\nIkReal x294=(sj16*sj17);\nIkReal x295=(cj16*cj18);\nIkReal x296=(sj17*sj18);\nIkReal x297=(cj16*sj18);\nIkReal x298=(cj18*sj15*sj17);\nIkReal x299=((((-1.0)*x290*x295))+x293);\nIkReal x300=x206;\nIkReal x301=x207;\nIkReal x302=((((-1.0)*x290*x293))+x295);\nIkReal x303=(cj15*x302);\nIkReal x304=x210;\nIkReal x305=x211;\nIkReal x306=(cj15*x304);\nIkReal x307=(((sj15*x302))+((cj15*x296)));\nIkReal x308=((((-1.0)*sj15*x296))+x303);\nIkReal x309=(((cj15*cj18*sj17))+((sj15*x304)));\nIkReal x310=((((-1.0)*x298))+x306);\nnew_r00=(((r20*x299))+((r00*x310))+((r10*x309)));\nnew_r01=(((r11*x309))+((r01*x310))+((r21*x299)));\nnew_r02=(((r02*(((((-1.0)*x298))+x306))))+((r22*x299))+((r12*x309)));\nnew_r10=(((r20*x292))+((r10*x300))+((r00*x301)));\nnew_r11=(((r11*x300))+((r01*x301))+((r21*x292)));\nnew_r12=(((r02*x301))+((r22*x292))+((r12*x300)));\nnew_r20=(((r00*(((((-1.0)*sj15*x296))+x303))))+((r20*x305))+((r10*x307)));\nnew_r21=(((r11*x307))+((r21*x305))+((r01*x308)));\nnew_r22=(((r22*x305))+((r02*x308))+((r12*x307)));\nj21eval[0]=sj20;\nj21eval[1]=IKsign(sj20);\nif( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j21eval[2];\nIkReal x311=((1.0)*cj17);\nIkReal x312=(cj18*sj16);\nIkReal x313=(cj16*sj17);\nIkReal x314=(sj16*sj18);\nIkReal x315=(sj16*sj17);\nIkReal x316=(cj16*cj18);\nIkReal x317=(sj17*sj18);\nIkReal x318=(cj16*sj18);\nIkReal x319=(cj18*sj15*sj17);\nIkReal x320=(x314+(((-1.0)*x311*x316)));\nIkReal x321=x206;\nIkReal x322=x207;\nIkReal x323=(x316+(((-1.0)*x311*x314)));\nIkReal x324=(cj15*x323);\nIkReal x325=x210;\nIkReal x326=x211;\nIkReal x327=(cj15*x325);\nIkReal x328=(((cj15*x317))+((sj15*x323)));\nIkReal x329=(x324+(((-1.0)*sj15*x317)));\nIkReal x330=(((cj15*cj18*sj17))+((sj15*x325)));\nIkReal x331=(x327+(((-1.0)*x319)));\nnew_r00=(((r00*x331))+((r20*x320))+((r10*x330)));\nnew_r01=(((r01*x331))+((r11*x330))+((r21*x320)));\nnew_r02=(((r12*x330))+((r02*((x327+(((-1.0)*x319))))))+((r22*x320)));\nnew_r10=(((r00*x322))+((r20*x313))+((r10*x321)));\nnew_r11=(((r11*x321))+((r01*x322))+((r21*x313)));\nnew_r12=(((r02*x322))+((r12*x321))+((r22*x313)));\nnew_r20=(((r20*x326))+((r00*((x324+(((-1.0)*sj15*x317))))))+((r10*x328)));\nnew_r21=(((r21*x326))+((r11*x328))+((r01*x329)));\nnew_r22=(((r02*x329))+((r12*x328))+((r22*x326)));\nj21eval[0]=sj19;\nj21eval[1]=sj20;\nif( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j21eval[3];\nIkReal x332=((1.0)*cj17);\nIkReal x333=(cj18*sj16);\nIkReal x334=(cj16*sj17);\nIkReal x335=(sj16*sj18);\nIkReal x336=(sj16*sj17);\nIkReal x337=(cj16*cj18);\nIkReal x338=(sj17*sj18);\nIkReal x339=(cj16*sj18);\nIkReal x340=(cj18*sj15*sj17);\nIkReal x341=(x335+(((-1.0)*x332*x337)));\nIkReal x342=x206;\nIkReal x343=x207;\nIkReal x344=(x337+(((-1.0)*x332*x335)));\nIkReal x345=(cj15*x344);\nIkReal x346=x210;\nIkReal x347=x211;\nIkReal x348=(cj15*x346);\nIkReal x349=(((sj15*x344))+((cj15*x338)));\nIkReal x350=(x345+(((-1.0)*sj15*x338)));\nIkReal x351=(((cj15*cj18*sj17))+((sj15*x346)));\nIkReal x352=(x348+(((-1.0)*x340)));\nnew_r00=(((r00*x352))+((r10*x351))+((r20*x341)));\nnew_r01=(((r21*x341))+((r01*x352))+((r11*x351)));\nnew_r02=(((r12*x351))+((r22*x341))+((r02*((x348+(((-1.0)*x340)))))));\nnew_r10=(((r00*x343))+((r20*x334))+((r10*x342)));\nnew_r11=(((r01*x343))+((r21*x334))+((r11*x342)));\nnew_r12=(((r22*x334))+((r02*x343))+((r12*x342)));\nnew_r20=(((r00*((x345+(((-1.0)*sj15*x338))))))+((r20*x347))+((r10*x349)));\nnew_r21=(((r21*x347))+((r01*x350))+((r11*x349)));\nnew_r22=(((r22*x347))+((r12*x349))+((r02*x350)));\nj21eval[0]=cj19;\nj21eval[1]=cj20;\nj21eval[2]=sj20;\nif( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x353=((((-1.0)*cj20))+new_r22);\nIkReal x354=((((-1.0)*sj20))+new_r12);\nIkReal x355=((1.0)*sj20);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j19)))), 6.28318530717959)));\nevalcond[1]=x353;\nevalcond[2]=x353;\nevalcond[3]=new_r02;\nevalcond[4]=x354;\nevalcond[5]=x354;\nevalcond[6]=(((new_r10*sj20))+((cj20*new_r20)));\nevalcond[7]=(((new_r11*sj20))+((cj20*new_r21)));\nevalcond[8]=((-1.0)+((new_r12*sj20))+((cj20*new_r22)));\nevalcond[9]=((((-1.0)*new_r22*x355))+((cj20*new_r12)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x356 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x356.valid){\ncontinue;\n}\nCheckValue<IkReal> x357=IKPowWithIntegerCheck(IKsign(new_r12),-1);\nif(!x357.valid){\ncontinue;\n}\nj21array[0]=((-1.5707963267949)+(x356.value)+(((1.5707963267949)*(x357.value))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x358=IKsin(j21);\nIkReal x359=IKcos(j21);\nIkReal x360=((1.0)*new_r12);\nIkReal x361=((1.0)*x359);\nIkReal x362=((1.0)*x358);\nevalcond[0]=(new_r20+((new_r12*x359)));\nevalcond[1]=(((new_r22*x358))+new_r11);\nevalcond[2]=((((-1.0)*x358*x360))+new_r21);\nevalcond[3]=((((-1.0)*new_r22*x361))+new_r10);\nevalcond[4]=((((-1.0)*x362))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*x361))+(((-1.0)*new_r01)));\nevalcond[6]=(x358+((new_r11*new_r22))+(((-1.0)*new_r21*x360)));\nevalcond[7]=((((-1.0)*new_r20*x360))+(((-1.0)*x361))+((new_r10*new_r22)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x363=((((-1.0)*cj20))+new_r22);\nIkReal x364=((1.0)*new_r12);\nIkReal x365=((1.0)*sj20);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j19)))), 6.28318530717959)));\nevalcond[1]=x363;\nevalcond[2]=x363;\nevalcond[3]=new_r02;\nevalcond[4]=(sj20+new_r12);\nevalcond[5]=((((-1.0)*x365))+(((-1.0)*x364)));\nevalcond[6]=((((-1.0)*new_r10*x365))+((cj20*new_r20)));\nevalcond[7]=((((-1.0)*new_r11*x365))+((cj20*new_r21)));\nevalcond[8]=((-1.0)+(((-1.0)*sj20*x364))+((cj20*new_r22)));\nevalcond[9]=((((-1.0)*new_r22*x365))+(((-1.0)*cj20*x364)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(new_r00, new_r01);\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x366=IKsin(j21);\nIkReal x367=IKcos(j21);\nIkReal x368=((1.0)*new_r10);\nIkReal x369=((1.0)*new_r11);\nIkReal x370=((1.0)*x367);\nevalcond[0]=(new_r21+((new_r12*x366)));\nevalcond[1]=((((-1.0)*x366))+new_r00);\nevalcond[2]=((((-1.0)*x370))+new_r01);\nevalcond[3]=((((-1.0)*new_r12*x370))+new_r20);\nevalcond[4]=(((new_r22*x366))+(((-1.0)*x369)));\nevalcond[5]=((((-1.0)*x368))+(((-1.0)*new_r22*x370)));\nevalcond[6]=((((-1.0)*new_r22*x369))+x366+((new_r12*new_r21)));\nevalcond[7]=((((-1.0)*x370))+(((-1.0)*new_r22*x368))+((new_r12*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x371=((1.0)*sj19);\nIkReal x372=(((cj19*new_r12))+(((-1.0)*new_r02*x371)));\nIkReal x373=(((new_r10*sj19))+((cj19*new_r00)));\nIkReal x374=(((cj19*new_r01))+((new_r11*sj19)));\nIkReal x375=((-1.0)+((cj19*new_r02))+((new_r12*sj19)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*cj19))+new_r02);\nevalcond[3]=((((-1.0)*x371))+new_r12);\nevalcond[4]=x372;\nevalcond[5]=x372;\nevalcond[6]=x375;\nevalcond[7]=x374;\nevalcond[8]=x373;\nevalcond[9]=x373;\nevalcond[10]=x374;\nevalcond[11]=x375;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x376=IKcos(j21);\nIkReal x377=IKsin(j21);\nIkReal x378=((1.0)*new_r12);\nIkReal x379=((1.0)*x377);\nIkReal x380=((1.0)*x376);\nevalcond[0]=(x376+new_r20);\nevalcond[1]=((((-1.0)*x379))+new_r21);\nevalcond[2]=(((new_r12*x376))+new_r01);\nevalcond[3]=(((new_r12*x377))+new_r00);\nevalcond[4]=((((-1.0)*new_r02*x380))+new_r11);\nevalcond[5]=(new_r10+(((-1.0)*new_r02*x379)));\nevalcond[6]=((((-1.0)*new_r00*x378))+(((-1.0)*x379))+((new_r02*new_r10)));\nevalcond[7]=((((-1.0)*x380))+((new_r02*new_r11))+(((-1.0)*new_r01*x378)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x381=(new_r12*sj19);\nIkReal x382=((1.0)*sj19);\nIkReal x383=(cj19*new_r00);\nIkReal x384=((1.0)*cj19);\nIkReal x385=((((-1.0)*new_r02*x382))+((cj19*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(cj19+new_r02);\nevalcond[3]=(sj19+new_r12);\nevalcond[4]=x385;\nevalcond[5]=x385;\nevalcond[6]=((1.0)+x381+((cj19*new_r02)));\nevalcond[7]=(((cj19*new_r01))+((new_r11*sj19)));\nevalcond[8]=(x383+((new_r10*sj19)));\nevalcond[9]=((((-1.0)*new_r10*x382))+(((-1.0)*x383)));\nevalcond[10]=((((-1.0)*new_r11*x382))+(((-1.0)*new_r01*x384)));\nevalcond[11]=((-1.0)+(((-1.0)*new_r02*x384))+(((-1.0)*x381)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((-1.0)*new_r21), new_r20);\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x386=IKcos(j21);\nIkReal x387=IKsin(j21);\nIkReal x388=((1.0)*new_r02);\nIkReal x389=((1.0)*x386);\nIkReal x390=((1.0)*x387);\nevalcond[0]=(x387+new_r21);\nevalcond[1]=((((-1.0)*x389))+new_r20);\nevalcond[2]=(((new_r02*x386))+new_r11);\nevalcond[3]=(((new_r02*x387))+new_r10);\nevalcond[4]=((((-1.0)*new_r12*x389))+new_r01);\nevalcond[5]=((((-1.0)*new_r12*x390))+new_r00);\nevalcond[6]=((((-1.0)*new_r10*x388))+(((-1.0)*x390))+((new_r00*new_r12)));\nevalcond[7]=((((-1.0)*new_r11*x388))+((new_r01*new_r12))+(((-1.0)*x389)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x391=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));\nIkReal x392=(((cj19*new_r02))+((new_r12*sj19)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x391;\nevalcond[7]=x391;\nevalcond[8]=x392;\nevalcond[9]=x392;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nIkReal x393=((1.0)*sj19);\nif( IKabs(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x393)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x393))+((cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x393))))+IKsqr(((((-1.0)*new_r01*x393))+((cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x393))), ((((-1.0)*new_r01*x393))+((cj19*new_r00))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x394=IKsin(j21);\nIkReal x395=IKcos(j21);\nIkReal x396=((1.0)*sj19);\nIkReal x397=((1.0)*x395);\nIkReal x398=(sj19*x394);\nIkReal x399=((1.0)*x394);\nIkReal x400=(cj19*x397);\nevalcond[0]=(x394+((cj19*new_r01))+((new_r11*sj19)));\nevalcond[1]=(((sj19*x395))+((cj19*x394))+new_r01);\nevalcond[2]=((((-1.0)*x397))+((new_r10*sj19))+((cj19*new_r00)));\nevalcond[3]=((((-1.0)*x399))+((cj19*new_r10))+(((-1.0)*new_r00*x396)));\nevalcond[4]=((((-1.0)*new_r01*x396))+(((-1.0)*x397))+((cj19*new_r11)));\nevalcond[5]=(x398+new_r00+(((-1.0)*x400)));\nevalcond[6]=(x398+new_r11+(((-1.0)*x400)));\nevalcond[7]=((((-1.0)*cj19*x399))+(((-1.0)*x395*x396))+new_r10);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x401=(new_r12*sj19);\nIkReal x402=((1.0)*new_r02);\nIkReal x403=((((-1.0)*sj19*x402))+((cj19*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x403;\nevalcond[7]=x403;\nevalcond[8]=(x401+((cj19*new_r02)));\nevalcond[9]=((((-1.0)*cj19*x402))+(((-1.0)*x401)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nIkReal x404=((1.0)*sj19);\nif( IKabs(((((-1.0)*new_r00*x404))+((cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x404)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x404))+((cj19*new_r01))))+IKsqr(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x404))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((((-1.0)*new_r00*x404))+((cj19*new_r01))), ((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x404))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x405=IKsin(j21);\nIkReal x406=IKcos(j21);\nIkReal x407=((1.0)*cj19);\nIkReal x408=((1.0)*sj19);\nIkReal x409=((1.0)*x405);\nIkReal x410=(sj19*x406);\nIkReal x411=(sj19*x405);\nIkReal x412=(x405*x407);\nevalcond[0]=(x406+((new_r10*sj19))+((cj19*new_r00)));\nevalcond[1]=(((cj19*new_r01))+((new_r11*sj19))+(((-1.0)*x409)));\nevalcond[2]=(x411+new_r00+((cj19*x406)));\nevalcond[3]=((((-1.0)*new_r00*x408))+((cj19*new_r10))+(((-1.0)*x409)));\nevalcond[4]=(((cj19*new_r11))+(((-1.0)*new_r01*x408))+(((-1.0)*x406)));\nevalcond[5]=(x410+new_r01+(((-1.0)*x412)));\nevalcond[6]=(x410+new_r10+(((-1.0)*x412)));\nevalcond[7]=((((-1.0)*x406*x407))+new_r11+(((-1.0)*x405*x408)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x413=((((-1.0)*cj20))+new_r22);\nIkReal x414=((((-1.0)*sj20))+new_r02);\nIkReal x415=((1.0)*sj20);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)));\nevalcond[1]=x413;\nevalcond[2]=x413;\nevalcond[3]=x414;\nevalcond[4]=new_r12;\nevalcond[5]=x414;\nevalcond[6]=(((new_r00*sj20))+((cj20*new_r20)));\nevalcond[7]=(((new_r01*sj20))+((cj20*new_r21)));\nevalcond[8]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));\nevalcond[9]=(((cj20*new_r02))+(((-1.0)*new_r22*x415)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(new_r10, new_r11);\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x416=IKcos(j21);\nIkReal x417=IKsin(j21);\nIkReal x418=((1.0)*new_r02);\nIkReal x419=((1.0)*x416);\nevalcond[0]=(new_r20+((new_r02*x416)));\nevalcond[1]=(new_r10+(((-1.0)*x417)));\nevalcond[2]=(new_r11+(((-1.0)*x419)));\nevalcond[3]=(((new_r22*x417))+new_r01);\nevalcond[4]=((((-1.0)*x417*x418))+new_r21);\nevalcond[5]=(new_r00+(((-1.0)*new_r22*x419)));\nevalcond[6]=(((new_r01*new_r22))+x417+(((-1.0)*new_r21*x418)));\nevalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x418))+(((-1.0)*x419)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x420=((((-1.0)*cj20))+new_r22);\nIkReal x421=((1.0)*sj20);\nIkReal x422=((1.0)*cj20);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));\nevalcond[1]=x420;\nevalcond[2]=x420;\nevalcond[3]=(sj20+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x421))+(((-1.0)*new_r02)));\nevalcond[6]=((((-1.0)*new_r00*x421))+((cj20*new_r20)));\nevalcond[7]=(((cj20*new_r21))+(((-1.0)*new_r01*x421)));\nevalcond[8]=((-1.0)+(((-1.0)*new_r02*x421))+((cj20*new_r22)));\nevalcond[9]=((((-1.0)*new_r22*x421))+(((-1.0)*new_r02*x422)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x423 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x423.valid){\ncontinue;\n}\nCheckValue<IkReal> x424=IKPowWithIntegerCheck(IKsign(new_r02),-1);\nif(!x424.valid){\ncontinue;\n}\nj21array[0]=((-1.5707963267949)+(x423.value)+(((1.5707963267949)*(x424.value))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x425=IKsin(j21);\nIkReal x426=IKcos(j21);\nIkReal x427=((1.0)*new_r22);\nIkReal x428=((1.0)*x426);\nevalcond[0]=(new_r21+((new_r02*x425)));\nevalcond[1]=((((-1.0)*new_r02*x428))+new_r20);\nevalcond[2]=((((-1.0)*x425))+(((-1.0)*new_r10)));\nevalcond[3]=((((-1.0)*x428))+(((-1.0)*new_r11)));\nevalcond[4]=(((new_r22*x425))+(((-1.0)*new_r01)));\nevalcond[5]=((((-1.0)*x426*x427))+(((-1.0)*new_r00)));\nevalcond[6]=(x425+((new_r02*new_r21))+(((-1.0)*new_r01*x427)));\nevalcond[7]=((((-1.0)*new_r00*x427))+(((-1.0)*x428))+((new_r02*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j21]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x430=IKPowWithIntegerCheck(sj20,-1);\nif(!x430.valid){\ncontinue;\n}\nIkReal x429=x430.value;\nCheckValue<IkReal> x431=IKPowWithIntegerCheck(cj19,-1);\nif(!x431.valid){\ncontinue;\n}\nCheckValue<IkReal> x432=IKPowWithIntegerCheck(cj20,-1);\nif(!x432.valid){\ncontinue;\n}\nif( IKabs((x429*(x431.value)*(x432.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x429)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x429*(x431.value)*(x432.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19))))))+IKsqr(((-1.0)*new_r20*x429))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2((x429*(x431.value)*(x432.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19))))), ((-1.0)*new_r20*x429));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[12];\nIkReal x433=IKsin(j21);\nIkReal x434=IKcos(j21);\nIkReal x435=(cj20*sj19);\nIkReal x436=(cj19*new_r01);\nIkReal x437=((1.0)*sj20);\nIkReal x438=(cj19*new_r00);\nIkReal x439=((1.0)*sj19);\nIkReal x440=((1.0)*x434);\nIkReal x441=(cj20*x433);\nIkReal x442=((1.0)*x433);\nIkReal x443=(cj19*x440);\nevalcond[0]=(((sj20*x434))+new_r20);\nevalcond[1]=((((-1.0)*x433*x437))+new_r21);\nevalcond[2]=(x436+x441+((new_r11*sj19)));\nevalcond[3]=((((-1.0)*new_r00*x439))+(((-1.0)*x442))+((cj19*new_r10)));\nevalcond[4]=((((-1.0)*x440))+(((-1.0)*new_r01*x439))+((cj19*new_r11)));\nevalcond[5]=(((cj19*x441))+((sj19*x434))+new_r01);\nevalcond[6]=((((-1.0)*cj20*x440))+x438+((new_r10*sj19)));\nevalcond[7]=(((sj19*x433))+(((-1.0)*cj20*x443))+new_r00);\nevalcond[8]=((((-1.0)*x443))+((x433*x435))+new_r11);\nevalcond[9]=((((-1.0)*x435*x440))+(((-1.0)*cj19*x442))+new_r10);\nevalcond[10]=(((new_r11*x435))+x433+((cj20*x436))+(((-1.0)*new_r21*x437)));\nevalcond[11]=((((-1.0)*x440))+((new_r10*x435))+(((-1.0)*new_r20*x437))+((cj20*x438)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x445=IKPowWithIntegerCheck(sj20,-1);\nif(!x445.valid){\ncontinue;\n}\nIkReal x444=x445.value;\nCheckValue<IkReal> x446=IKPowWithIntegerCheck(sj19,-1);\nif(!x446.valid){\ncontinue;\n}\nif( IKabs((x444*(x446.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x444)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x444*(x446.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))))+IKsqr(((-1.0)*new_r20*x444))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2((x444*(x446.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))), ((-1.0)*new_r20*x444));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[12];\nIkReal x447=IKsin(j21);\nIkReal x448=IKcos(j21);\nIkReal x449=(cj20*sj19);\nIkReal x450=(cj19*new_r01);\nIkReal x451=((1.0)*sj20);\nIkReal x452=(cj19*new_r00);\nIkReal x453=((1.0)*sj19);\nIkReal x454=((1.0)*x448);\nIkReal x455=(cj20*x447);\nIkReal x456=((1.0)*x447);\nIkReal x457=(cj19*x454);\nevalcond[0]=(((sj20*x448))+new_r20);\nevalcond[1]=((((-1.0)*x447*x451))+new_r21);\nevalcond[2]=(x455+x450+((new_r11*sj19)));\nevalcond[3]=((((-1.0)*new_r00*x453))+(((-1.0)*x456))+((cj19*new_r10)));\nevalcond[4]=((((-1.0)*new_r01*x453))+(((-1.0)*x454))+((cj19*new_r11)));\nevalcond[5]=(((sj19*x448))+((cj19*x455))+new_r01);\nevalcond[6]=(x452+((new_r10*sj19))+(((-1.0)*cj20*x454)));\nevalcond[7]=(((sj19*x447))+new_r00+(((-1.0)*cj20*x457)));\nevalcond[8]=(((x447*x449))+(((-1.0)*x457))+new_r11);\nevalcond[9]=((((-1.0)*cj19*x456))+new_r10+(((-1.0)*x449*x454)));\nevalcond[10]=((((-1.0)*new_r21*x451))+((cj20*x450))+((new_r11*x449))+x447);\nevalcond[11]=((((-1.0)*new_r20*x451))+((cj20*x452))+(((-1.0)*x454))+((new_r10*x449)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x458=IKPowWithIntegerCheck(IKsign(sj20),-1);\nif(!x458.valid){\ncontinue;\n}\nCheckValue<IkReal> x459 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x459.valid){\ncontinue;\n}\nj21array[0]=((-1.5707963267949)+(((1.5707963267949)*(x458.value)))+(x459.value));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[12];\nIkReal x460=IKsin(j21);\nIkReal x461=IKcos(j21);\nIkReal x462=(cj20*sj19);\nIkReal x463=(cj19*new_r01);\nIkReal x464=((1.0)*sj20);\nIkReal x465=(cj19*new_r00);\nIkReal x466=((1.0)*sj19);\nIkReal x467=((1.0)*x461);\nIkReal x468=(cj20*x460);\nIkReal x469=((1.0)*x460);\nIkReal x470=(cj19*x467);\nevalcond[0]=(new_r20+((sj20*x461)));\nevalcond[1]=((((-1.0)*x460*x464))+new_r21);\nevalcond[2]=(x468+x463+((new_r11*sj19)));\nevalcond[3]=((((-1.0)*x469))+(((-1.0)*new_r00*x466))+((cj19*new_r10)));\nevalcond[4]=((((-1.0)*new_r01*x466))+(((-1.0)*x467))+((cj19*new_r11)));\nevalcond[5]=(((cj19*x468))+((sj19*x461))+new_r01);\nevalcond[6]=(x465+((new_r10*sj19))+(((-1.0)*cj20*x467)));\nevalcond[7]=(((sj19*x460))+new_r00+(((-1.0)*cj20*x470)));\nevalcond[8]=((((-1.0)*x470))+((x460*x462))+new_r11);\nevalcond[9]=((((-1.0)*x462*x467))+(((-1.0)*cj19*x469))+new_r10);\nevalcond[10]=((((-1.0)*new_r21*x464))+((new_r11*x462))+((cj20*x463))+x460);\nevalcond[11]=(((new_r10*x462))+((cj20*x465))+(((-1.0)*new_r20*x464))+(((-1.0)*x467)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j19array[1], cj19array[1], sj19array[1];\nbool j19valid[1]={false};\n_nj19 = 1;\nCheckValue<IkReal> x471=IKPowWithIntegerCheck(IKsign(sj20),-1);\nif(!x471.valid){\ncontinue;\n}\nCheckValue<IkReal> x472 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);\nif(!x472.valid){\ncontinue;\n}\nj19array[0]=((-1.5707963267949)+(((1.5707963267949)*(x471.value)))+(x472.value));\nsj19array[0]=IKsin(j19array[0]);\ncj19array[0]=IKcos(j19array[0]);\nif( j19array[0] > IKPI )\n{\n    j19array[0]-=IK2PI;\n}\nelse if( j19array[0] < -IKPI )\n{    j19array[0]+=IK2PI;\n}\nj19valid[0] = true;\nfor(int ij19 = 0; ij19 < 1; ++ij19)\n{\nif( !j19valid[ij19] )\n{\n    continue;\n}\n_ij19[0] = ij19; _ij19[1] = -1;\nfor(int iij19 = ij19+1; iij19 < 1; ++iij19)\n{\nif( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )\n{\n    j19valid[iij19]=false; _ij19[1] = iij19; break; \n}\n}\nj19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];\n{\nIkReal evalcond[8];\nIkReal x473=IKcos(j19);\nIkReal x474=IKsin(j19);\nIkReal x475=((1.0)*sj20);\nIkReal x476=(new_r02*x473);\nIkReal x477=(new_r12*x474);\nIkReal x478=(sj20*x473);\nIkReal x479=(sj20*x474);\nevalcond[0]=((((-1.0)*x473*x475))+new_r02);\nevalcond[1]=(new_r12+(((-1.0)*x474*x475)));\nevalcond[2]=(((new_r12*x473))+(((-1.0)*new_r02*x474)));\nevalcond[3]=((((-1.0)*x475))+x476+x477);\nevalcond[4]=(((new_r10*x479))+((new_r00*x478))+((cj20*new_r20)));\nevalcond[5]=(((new_r01*x478))+((new_r11*x479))+((cj20*new_r21)));\nevalcond[6]=((-1.0)+((cj20*new_r22))+((sj20*x476))+((sj20*x477)));\nevalcond[7]=(((cj20*x477))+((cj20*x476))+(((-1.0)*new_r22*x475)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j21eval[2];\nIkReal x480=((1.0)*cj17);\nIkReal x481=(cj18*sj16);\nIkReal x482=(cj16*sj17);\nIkReal x483=(sj16*sj18);\nIkReal x484=(sj16*sj17);\nIkReal x485=(cj16*cj18);\nIkReal x486=(sj17*sj18);\nIkReal x487=(cj16*sj18);\nIkReal x488=(cj18*sj15*sj17);\nIkReal x489=(x483+(((-1.0)*x480*x485)));\nIkReal x490=x206;\nIkReal x491=x207;\nIkReal x492=(x485+(((-1.0)*x480*x483)));\nIkReal x493=(cj15*x492);\nIkReal x494=x210;\nIkReal x495=x211;\nIkReal x496=(cj15*x494);\nIkReal x497=(((cj15*x486))+((sj15*x492)));\nIkReal x498=((((-1.0)*sj15*x486))+x493);\nIkReal x499=(((cj15*cj18*sj17))+((sj15*x494)));\nIkReal x500=((((-1.0)*x488))+x496);\nnew_r00=(((r20*x489))+((r00*x500))+((r10*x499)));\nnew_r01=(((r11*x499))+((r01*x500))+((r21*x489)));\nnew_r02=(((r12*x499))+((r22*x489))+((r02*(((((-1.0)*x488))+x496)))));\nnew_r10=(((r20*x482))+((r10*x490))+((r00*x491)));\nnew_r11=(((r11*x490))+((r21*x482))+((r01*x491)));\nnew_r12=(((r02*x491))+((r12*x490))+((r22*x482)));\nnew_r20=(((r00*(((((-1.0)*sj15*x486))+x493))))+((r10*x497))+((r20*x495)));\nnew_r21=(((r11*x497))+((r21*x495))+((r01*x498)));\nnew_r22=(((r02*x498))+((r22*x495))+((r12*x497)));\nj21eval[0]=sj20;\nj21eval[1]=IKsign(sj20);\nif( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j21eval[2];\nIkReal x501=((1.0)*cj17);\nIkReal x502=(cj18*sj16);\nIkReal x503=(cj16*sj17);\nIkReal x504=(sj16*sj18);\nIkReal x505=(sj16*sj17);\nIkReal x506=(cj16*cj18);\nIkReal x507=(sj17*sj18);\nIkReal x508=(cj16*sj18);\nIkReal x509=(cj18*sj15*sj17);\nIkReal x510=((((-1.0)*x501*x506))+x504);\nIkReal x511=x206;\nIkReal x512=x207;\nIkReal x513=((((-1.0)*x501*x504))+x506);\nIkReal x514=(cj15*x513);\nIkReal x515=x210;\nIkReal x516=x211;\nIkReal x517=(cj15*x515);\nIkReal x518=(((cj15*x507))+((sj15*x513)));\nIkReal x519=((((-1.0)*sj15*x507))+x514);\nIkReal x520=(((cj15*cj18*sj17))+((sj15*x515)));\nIkReal x521=(x517+(((-1.0)*x509)));\nnew_r00=(((r20*x510))+((r10*x520))+((r00*x521)));\nnew_r01=(((r11*x520))+((r21*x510))+((r01*x521)));\nnew_r02=(((r12*x520))+((r22*x510))+((r02*((x517+(((-1.0)*x509)))))));\nnew_r10=(((r20*x503))+((r10*x511))+((r00*x512)));\nnew_r11=(((r01*x512))+((r11*x511))+((r21*x503)));\nnew_r12=(((r22*x503))+((r02*x512))+((r12*x511)));\nnew_r20=(((r00*(((((-1.0)*sj15*x507))+x514))))+((r20*x516))+((r10*x518)));\nnew_r21=(((r01*x519))+((r11*x518))+((r21*x516)));\nnew_r22=(((r02*x519))+((r22*x516))+((r12*x518)));\nj21eval[0]=sj19;\nj21eval[1]=sj20;\nif( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j21eval[3];\nIkReal x522=((1.0)*cj17);\nIkReal x523=(cj18*sj16);\nIkReal x524=(cj16*sj17);\nIkReal x525=(sj16*sj18);\nIkReal x526=(sj16*sj17);\nIkReal x527=(cj16*cj18);\nIkReal x528=(sj17*sj18);\nIkReal x529=(cj16*sj18);\nIkReal x530=(cj18*sj15*sj17);\nIkReal x531=(x525+(((-1.0)*x522*x527)));\nIkReal x532=x206;\nIkReal x533=x207;\nIkReal x534=(x527+(((-1.0)*x522*x525)));\nIkReal x535=(cj15*x534);\nIkReal x536=x210;\nIkReal x537=x211;\nIkReal x538=(cj15*x536);\nIkReal x539=(((sj15*x534))+((cj15*x528)));\nIkReal x540=(x535+(((-1.0)*sj15*x528)));\nIkReal x541=(((cj15*cj18*sj17))+((sj15*x536)));\nIkReal x542=((((-1.0)*x530))+x538);\nnew_r00=(((r20*x531))+((r10*x541))+((r00*x542)));\nnew_r01=(((r11*x541))+((r21*x531))+((r01*x542)));\nnew_r02=(((r02*(((((-1.0)*x530))+x538))))+((r12*x541))+((r22*x531)));\nnew_r10=(((r20*x524))+((r10*x532))+((r00*x533)));\nnew_r11=(((r21*x524))+((r11*x532))+((r01*x533)));\nnew_r12=(((r02*x533))+((r12*x532))+((r22*x524)));\nnew_r20=(((r20*x537))+((r10*x539))+((r00*((x535+(((-1.0)*sj15*x528)))))));\nnew_r21=(((r11*x539))+((r21*x537))+((r01*x540)));\nnew_r22=(((r02*x540))+((r12*x539))+((r22*x537)));\nj21eval[0]=cj19;\nj21eval[1]=cj20;\nj21eval[2]=sj20;\nif( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x543=((((-1.0)*cj20))+new_r22);\nIkReal x544=((((-1.0)*sj20))+new_r12);\nIkReal x545=((1.0)*sj20);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j19)))), 6.28318530717959)));\nevalcond[1]=x543;\nevalcond[2]=x543;\nevalcond[3]=new_r02;\nevalcond[4]=x544;\nevalcond[5]=x544;\nevalcond[6]=(((new_r10*sj20))+((cj20*new_r20)));\nevalcond[7]=(((new_r11*sj20))+((cj20*new_r21)));\nevalcond[8]=((-1.0)+((new_r12*sj20))+((cj20*new_r22)));\nevalcond[9]=((((-1.0)*new_r22*x545))+((cj20*new_r12)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x546 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x546.valid){\ncontinue;\n}\nCheckValue<IkReal> x547=IKPowWithIntegerCheck(IKsign(new_r12),-1);\nif(!x547.valid){\ncontinue;\n}\nj21array[0]=((-1.5707963267949)+(x546.value)+(((1.5707963267949)*(x547.value))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x548=IKsin(j21);\nIkReal x549=IKcos(j21);\nIkReal x550=((1.0)*new_r12);\nIkReal x551=((1.0)*x549);\nIkReal x552=((1.0)*x548);\nevalcond[0]=(((new_r12*x549))+new_r20);\nevalcond[1]=(((new_r22*x548))+new_r11);\nevalcond[2]=((((-1.0)*x548*x550))+new_r21);\nevalcond[3]=((((-1.0)*new_r22*x551))+new_r10);\nevalcond[4]=((((-1.0)*x552))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*x551))+(((-1.0)*new_r01)));\nevalcond[6]=((((-1.0)*new_r21*x550))+x548+((new_r11*new_r22)));\nevalcond[7]=((((-1.0)*x551))+(((-1.0)*new_r20*x550))+((new_r10*new_r22)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x553=((((-1.0)*cj20))+new_r22);\nIkReal x554=((1.0)*new_r12);\nIkReal x555=((1.0)*sj20);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j19)))), 6.28318530717959)));\nevalcond[1]=x553;\nevalcond[2]=x553;\nevalcond[3]=new_r02;\nevalcond[4]=(sj20+new_r12);\nevalcond[5]=((((-1.0)*x554))+(((-1.0)*x555)));\nevalcond[6]=((((-1.0)*new_r10*x555))+((cj20*new_r20)));\nevalcond[7]=((((-1.0)*new_r11*x555))+((cj20*new_r21)));\nevalcond[8]=((-1.0)+(((-1.0)*sj20*x554))+((cj20*new_r22)));\nevalcond[9]=((((-1.0)*new_r22*x555))+(((-1.0)*cj20*x554)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(new_r00, new_r01);\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x556=IKsin(j21);\nIkReal x557=IKcos(j21);\nIkReal x558=((1.0)*new_r10);\nIkReal x559=((1.0)*new_r11);\nIkReal x560=((1.0)*x557);\nevalcond[0]=(((new_r12*x556))+new_r21);\nevalcond[1]=((((-1.0)*x556))+new_r00);\nevalcond[2]=(new_r01+(((-1.0)*x560)));\nevalcond[3]=((((-1.0)*new_r12*x560))+new_r20);\nevalcond[4]=((((-1.0)*x559))+((new_r22*x556)));\nevalcond[5]=((((-1.0)*x558))+(((-1.0)*new_r22*x560)));\nevalcond[6]=((((-1.0)*new_r22*x559))+((new_r12*new_r21))+x556);\nevalcond[7]=((((-1.0)*new_r22*x558))+((new_r12*new_r20))+(((-1.0)*x560)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x561=((1.0)*sj19);\nIkReal x562=((((-1.0)*new_r02*x561))+((cj19*new_r12)));\nIkReal x563=(((new_r10*sj19))+((cj19*new_r00)));\nIkReal x564=(((cj19*new_r01))+((new_r11*sj19)));\nIkReal x565=((-1.0)+((cj19*new_r02))+((new_r12*sj19)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*cj19))+new_r02);\nevalcond[3]=(new_r12+(((-1.0)*x561)));\nevalcond[4]=x562;\nevalcond[5]=x562;\nevalcond[6]=x565;\nevalcond[7]=x564;\nevalcond[8]=x563;\nevalcond[9]=x563;\nevalcond[10]=x564;\nevalcond[11]=x565;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x566=IKcos(j21);\nIkReal x567=IKsin(j21);\nIkReal x568=((1.0)*new_r12);\nIkReal x569=((1.0)*x567);\nIkReal x570=((1.0)*x566);\nevalcond[0]=(x566+new_r20);\nevalcond[1]=(new_r21+(((-1.0)*x569)));\nevalcond[2]=(new_r01+((new_r12*x566)));\nevalcond[3]=(new_r00+((new_r12*x567)));\nevalcond[4]=((((-1.0)*new_r02*x570))+new_r11);\nevalcond[5]=((((-1.0)*new_r02*x569))+new_r10);\nevalcond[6]=((((-1.0)*new_r00*x568))+((new_r02*new_r10))+(((-1.0)*x569)));\nevalcond[7]=((((-1.0)*x570))+((new_r02*new_r11))+(((-1.0)*new_r01*x568)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x571=(new_r12*sj19);\nIkReal x572=((1.0)*sj19);\nIkReal x573=(cj19*new_r00);\nIkReal x574=((1.0)*cj19);\nIkReal x575=((((-1.0)*new_r02*x572))+((cj19*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(cj19+new_r02);\nevalcond[3]=(sj19+new_r12);\nevalcond[4]=x575;\nevalcond[5]=x575;\nevalcond[6]=((1.0)+x571+((cj19*new_r02)));\nevalcond[7]=(((cj19*new_r01))+((new_r11*sj19)));\nevalcond[8]=(x573+((new_r10*sj19)));\nevalcond[9]=((((-1.0)*new_r10*x572))+(((-1.0)*x573)));\nevalcond[10]=((((-1.0)*new_r11*x572))+(((-1.0)*new_r01*x574)));\nevalcond[11]=((-1.0)+(((-1.0)*new_r02*x574))+(((-1.0)*x571)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((-1.0)*new_r21), new_r20);\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x576=IKcos(j21);\nIkReal x577=IKsin(j21);\nIkReal x578=((1.0)*new_r02);\nIkReal x579=((1.0)*x576);\nIkReal x580=((1.0)*x577);\nevalcond[0]=(x577+new_r21);\nevalcond[1]=((((-1.0)*x579))+new_r20);\nevalcond[2]=(new_r11+((new_r02*x576)));\nevalcond[3]=(new_r10+((new_r02*x577)));\nevalcond[4]=((((-1.0)*new_r12*x579))+new_r01);\nevalcond[5]=((((-1.0)*new_r12*x580))+new_r00);\nevalcond[6]=((((-1.0)*new_r10*x578))+((new_r00*new_r12))+(((-1.0)*x580)));\nevalcond[7]=((((-1.0)*new_r11*x578))+((new_r01*new_r12))+(((-1.0)*x579)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x581=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));\nIkReal x582=(((cj19*new_r02))+((new_r12*sj19)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x581;\nevalcond[7]=x581;\nevalcond[8]=x582;\nevalcond[9]=x582;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nIkReal x583=((1.0)*sj19);\nif( IKabs(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x583)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x583))+((cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x583))))+IKsqr(((((-1.0)*new_r01*x583))+((cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x583))), ((((-1.0)*new_r01*x583))+((cj19*new_r00))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x584=IKsin(j21);\nIkReal x585=IKcos(j21);\nIkReal x586=((1.0)*sj19);\nIkReal x587=((1.0)*x585);\nIkReal x588=(sj19*x584);\nIkReal x589=((1.0)*x584);\nIkReal x590=(cj19*x587);\nevalcond[0]=(x584+((cj19*new_r01))+((new_r11*sj19)));\nevalcond[1]=(((sj19*x585))+((cj19*x584))+new_r01);\nevalcond[2]=(((new_r10*sj19))+((cj19*new_r00))+(((-1.0)*x587)));\nevalcond[3]=(((cj19*new_r10))+(((-1.0)*x589))+(((-1.0)*new_r00*x586)));\nevalcond[4]=((((-1.0)*new_r01*x586))+((cj19*new_r11))+(((-1.0)*x587)));\nevalcond[5]=((((-1.0)*x590))+x588+new_r00);\nevalcond[6]=((((-1.0)*x590))+x588+new_r11);\nevalcond[7]=((((-1.0)*x585*x586))+(((-1.0)*cj19*x589))+new_r10);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x591=(new_r12*sj19);\nIkReal x592=((1.0)*new_r02);\nIkReal x593=((((-1.0)*sj19*x592))+((cj19*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x593;\nevalcond[7]=x593;\nevalcond[8]=(x591+((cj19*new_r02)));\nevalcond[9]=((((-1.0)*cj19*x592))+(((-1.0)*x591)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nIkReal x594=((1.0)*sj19);\nif( IKabs(((((-1.0)*new_r00*x594))+((cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x594)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x594))+((cj19*new_r01))))+IKsqr(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x594))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((((-1.0)*new_r00*x594))+((cj19*new_r01))), ((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x594))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x595=IKsin(j21);\nIkReal x596=IKcos(j21);\nIkReal x597=((1.0)*cj19);\nIkReal x598=((1.0)*sj19);\nIkReal x599=((1.0)*x595);\nIkReal x600=(sj19*x596);\nIkReal x601=(sj19*x595);\nIkReal x602=(x595*x597);\nevalcond[0]=(x596+((new_r10*sj19))+((cj19*new_r00)));\nevalcond[1]=((((-1.0)*x599))+((cj19*new_r01))+((new_r11*sj19)));\nevalcond[2]=(((cj19*x596))+x601+new_r00);\nevalcond[3]=((((-1.0)*new_r00*x598))+(((-1.0)*x599))+((cj19*new_r10)));\nevalcond[4]=((((-1.0)*new_r01*x598))+(((-1.0)*x596))+((cj19*new_r11)));\nevalcond[5]=(x600+(((-1.0)*x602))+new_r01);\nevalcond[6]=(x600+(((-1.0)*x602))+new_r10);\nevalcond[7]=((((-1.0)*x596*x597))+(((-1.0)*x595*x598))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x603=((((-1.0)*cj20))+new_r22);\nIkReal x604=((((-1.0)*sj20))+new_r02);\nIkReal x605=((1.0)*sj20);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)));\nevalcond[1]=x603;\nevalcond[2]=x603;\nevalcond[3]=x604;\nevalcond[4]=new_r12;\nevalcond[5]=x604;\nevalcond[6]=(((new_r00*sj20))+((cj20*new_r20)));\nevalcond[7]=(((new_r01*sj20))+((cj20*new_r21)));\nevalcond[8]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));\nevalcond[9]=((((-1.0)*new_r22*x605))+((cj20*new_r02)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(new_r10, new_r11);\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x606=IKcos(j21);\nIkReal x607=IKsin(j21);\nIkReal x608=((1.0)*new_r02);\nIkReal x609=((1.0)*x606);\nevalcond[0]=(((new_r02*x606))+new_r20);\nevalcond[1]=((((-1.0)*x607))+new_r10);\nevalcond[2]=((((-1.0)*x609))+new_r11);\nevalcond[3]=(((new_r22*x607))+new_r01);\nevalcond[4]=(new_r21+(((-1.0)*x607*x608)));\nevalcond[5]=((((-1.0)*new_r22*x609))+new_r00);\nevalcond[6]=(((new_r01*new_r22))+x607+(((-1.0)*new_r21*x608)));\nevalcond[7]=((((-1.0)*new_r20*x608))+((new_r00*new_r22))+(((-1.0)*x609)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x610=((((-1.0)*cj20))+new_r22);\nIkReal x611=((1.0)*sj20);\nIkReal x612=((1.0)*cj20);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));\nevalcond[1]=x610;\nevalcond[2]=x610;\nevalcond[3]=(sj20+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x611))+(((-1.0)*new_r02)));\nevalcond[6]=((((-1.0)*new_r00*x611))+((cj20*new_r20)));\nevalcond[7]=(((cj20*new_r21))+(((-1.0)*new_r01*x611)));\nevalcond[8]=((-1.0)+(((-1.0)*new_r02*x611))+((cj20*new_r22)));\nevalcond[9]=((((-1.0)*new_r02*x612))+(((-1.0)*new_r22*x611)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x613 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x613.valid){\ncontinue;\n}\nCheckValue<IkReal> x614=IKPowWithIntegerCheck(IKsign(new_r02),-1);\nif(!x614.valid){\ncontinue;\n}\nj21array[0]=((-1.5707963267949)+(x613.value)+(((1.5707963267949)*(x614.value))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x615=IKsin(j21);\nIkReal x616=IKcos(j21);\nIkReal x617=((1.0)*new_r22);\nIkReal x618=((1.0)*x616);\nevalcond[0]=(((new_r02*x615))+new_r21);\nevalcond[1]=((((-1.0)*new_r02*x618))+new_r20);\nevalcond[2]=((((-1.0)*x615))+(((-1.0)*new_r10)));\nevalcond[3]=((((-1.0)*x618))+(((-1.0)*new_r11)));\nevalcond[4]=((((-1.0)*new_r01))+((new_r22*x615)));\nevalcond[5]=((((-1.0)*new_r00))+(((-1.0)*x616*x617)));\nevalcond[6]=(x615+((new_r02*new_r21))+(((-1.0)*new_r01*x617)));\nevalcond[7]=((((-1.0)*x618))+(((-1.0)*new_r00*x617))+((new_r02*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j21]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x620=IKPowWithIntegerCheck(sj20,-1);\nif(!x620.valid){\ncontinue;\n}\nIkReal x619=x620.value;\nCheckValue<IkReal> x621=IKPowWithIntegerCheck(cj19,-1);\nif(!x621.valid){\ncontinue;\n}\nCheckValue<IkReal> x622=IKPowWithIntegerCheck(cj20,-1);\nif(!x622.valid){\ncontinue;\n}\nif( IKabs((x619*(x621.value)*(x622.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x619)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x619*(x621.value)*(x622.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19))))))+IKsqr(((-1.0)*new_r20*x619))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2((x619*(x621.value)*(x622.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19))))), ((-1.0)*new_r20*x619));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[12];\nIkReal x623=IKsin(j21);\nIkReal x624=IKcos(j21);\nIkReal x625=(cj20*sj19);\nIkReal x626=(cj19*new_r01);\nIkReal x627=((1.0)*sj20);\nIkReal x628=(cj19*new_r00);\nIkReal x629=((1.0)*sj19);\nIkReal x630=((1.0)*x624);\nIkReal x631=(cj20*x623);\nIkReal x632=((1.0)*x623);\nIkReal x633=(cj19*x630);\nevalcond[0]=(new_r20+((sj20*x624)));\nevalcond[1]=((((-1.0)*x623*x627))+new_r21);\nevalcond[2]=(x626+x631+((new_r11*sj19)));\nevalcond[3]=((((-1.0)*new_r00*x629))+(((-1.0)*x632))+((cj19*new_r10)));\nevalcond[4]=((((-1.0)*new_r01*x629))+(((-1.0)*x630))+((cj19*new_r11)));\nevalcond[5]=(((cj19*x631))+((sj19*x624))+new_r01);\nevalcond[6]=((((-1.0)*cj20*x630))+x628+((new_r10*sj19)));\nevalcond[7]=((((-1.0)*cj20*x633))+((sj19*x623))+new_r00);\nevalcond[8]=((((-1.0)*x633))+new_r11+((x623*x625)));\nevalcond[9]=((((-1.0)*x625*x630))+new_r10+(((-1.0)*cj19*x632)));\nevalcond[10]=(((cj20*x626))+(((-1.0)*new_r21*x627))+((new_r11*x625))+x623);\nevalcond[11]=(((cj20*x628))+(((-1.0)*x630))+((new_r10*x625))+(((-1.0)*new_r20*x627)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x635=IKPowWithIntegerCheck(sj20,-1);\nif(!x635.valid){\ncontinue;\n}\nIkReal x634=x635.value;\nCheckValue<IkReal> x636=IKPowWithIntegerCheck(sj19,-1);\nif(!x636.valid){\ncontinue;\n}\nif( IKabs((x634*(x636.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x634)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x634*(x636.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))))+IKsqr(((-1.0)*new_r20*x634))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2((x634*(x636.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))), ((-1.0)*new_r20*x634));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[12];\nIkReal x637=IKsin(j21);\nIkReal x638=IKcos(j21);\nIkReal x639=(cj20*sj19);\nIkReal x640=(cj19*new_r01);\nIkReal x641=((1.0)*sj20);\nIkReal x642=(cj19*new_r00);\nIkReal x643=((1.0)*sj19);\nIkReal x644=((1.0)*x638);\nIkReal x645=(cj20*x637);\nIkReal x646=((1.0)*x637);\nIkReal x647=(cj19*x644);\nevalcond[0]=(new_r20+((sj20*x638)));\nevalcond[1]=((((-1.0)*x637*x641))+new_r21);\nevalcond[2]=(x645+x640+((new_r11*sj19)));\nevalcond[3]=((((-1.0)*x646))+(((-1.0)*new_r00*x643))+((cj19*new_r10)));\nevalcond[4]=((((-1.0)*x644))+(((-1.0)*new_r01*x643))+((cj19*new_r11)));\nevalcond[5]=(((cj19*x645))+((sj19*x638))+new_r01);\nevalcond[6]=((((-1.0)*cj20*x644))+x642+((new_r10*sj19)));\nevalcond[7]=((((-1.0)*cj20*x647))+((sj19*x637))+new_r00);\nevalcond[8]=((((-1.0)*x647))+new_r11+((x637*x639)));\nevalcond[9]=((((-1.0)*x639*x644))+(((-1.0)*cj19*x646))+new_r10);\nevalcond[10]=(((cj20*x640))+(((-1.0)*new_r21*x641))+((new_r11*x639))+x637);\nevalcond[11]=(((cj20*x642))+(((-1.0)*x644))+((new_r10*x639))+(((-1.0)*new_r20*x641)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x648=IKPowWithIntegerCheck(IKsign(sj20),-1);\nif(!x648.valid){\ncontinue;\n}\nCheckValue<IkReal> x649 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x649.valid){\ncontinue;\n}\nj21array[0]=((-1.5707963267949)+(((1.5707963267949)*(x648.value)))+(x649.value));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[12];\nIkReal x650=IKsin(j21);\nIkReal x651=IKcos(j21);\nIkReal x652=(cj20*sj19);\nIkReal x653=(cj19*new_r01);\nIkReal x654=((1.0)*sj20);\nIkReal x655=(cj19*new_r00);\nIkReal x656=((1.0)*sj19);\nIkReal x657=((1.0)*x651);\nIkReal x658=(cj20*x650);\nIkReal x659=((1.0)*x650);\nIkReal x660=(cj19*x657);\nevalcond[0]=(((sj20*x651))+new_r20);\nevalcond[1]=((((-1.0)*x650*x654))+new_r21);\nevalcond[2]=(x653+x658+((new_r11*sj19)));\nevalcond[3]=((((-1.0)*new_r00*x656))+(((-1.0)*x659))+((cj19*new_r10)));\nevalcond[4]=((((-1.0)*x657))+(((-1.0)*new_r01*x656))+((cj19*new_r11)));\nevalcond[5]=(((cj19*x658))+new_r01+((sj19*x651)));\nevalcond[6]=((((-1.0)*cj20*x657))+x655+((new_r10*sj19)));\nevalcond[7]=((((-1.0)*cj20*x660))+new_r00+((sj19*x650)));\nevalcond[8]=((((-1.0)*x660))+new_r11+((x650*x652)));\nevalcond[9]=((((-1.0)*cj19*x659))+new_r10+(((-1.0)*x652*x657)));\nevalcond[10]=(((cj20*x653))+x650+((new_r11*x652))+(((-1.0)*new_r21*x654)));\nevalcond[11]=(((cj20*x655))+(((-1.0)*x657))+(((-1.0)*new_r20*x654))+((new_r10*x652)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j15;\nvinfos[0].indices[0] = _ij15[0];\nvinfos[0].indices[1] = _ij15[1];\nvinfos[0].maxsolutions = _nj15;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j16;\nvinfos[1].indices[0] = _ij16[0];\nvinfos[1].indices[1] = _ij16[1];\nvinfos[1].maxsolutions = _nj16;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j17;\nvinfos[2].indices[0] = _ij17[0];\nvinfos[2].indices[1] = _ij17[1];\nvinfos[2].maxsolutions = _nj17;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j18;\nvinfos[3].indices[0] = _ij18[0];\nvinfos[3].indices[1] = _ij18[1];\nvinfos[3].maxsolutions = _nj18;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j19;\nvinfos[4].indices[0] = _ij19[0];\nvinfos[4].indices[1] = _ij19[1];\nvinfos[4].maxsolutions = _nj19;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j20;\nvinfos[5].indices[0] = _ij20[0];\nvinfos[5].indices[1] = _ij20[1];\nvinfos[5].maxsolutions = _nj20;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j21;\nvinfos[6].indices[0] = _ij21[0];\nvinfos[6].indices[1] = _ij21[1];\nvinfos[6].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\n}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[3];\n    const int maxsteps = 110;\n    for(int i = 0; i < 3; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[3];\n    IkReal err[3];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 3; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 3; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 3; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 3; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[3] = {false};\n    for(int i = 0; i < 3; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 3; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {\n    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];\n    if( det < 0 ) {\n        numroots=0;\n    }\n    else if( det == 0 ) {\n        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];\n        numroots = 1;\n    }\n    else {\n        det = IKsqrt(det);\n        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);\n        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);\n        numroots = 2;\n    }\n}\nstatic inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[5];\n    const int maxsteps = 110;\n    for(int i = 0; i < 5; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[5];\n    IkReal err[5];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 5; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 5; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 5; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 5; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[5] = {false};\n    for(int i = 0; i < 5; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 5; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[4];\n    const int maxsteps = 110;\n    for(int i = 0; i < 4; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[4];\n    IkReal err[4];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 4; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 4; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 4; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 4; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[4] = {false};\n    for(int i = 0; i < 4; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 4; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[7];\n    const int maxsteps = 110;\n    for(int i = 0; i < 7; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[7];\n    IkReal err[7];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 7; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 7; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 7; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 7; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[7] = {false};\n    for(int i = 0; i < 7; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 7; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[6];\n    const int maxsteps = 110;\n    for(int i = 0; i < 6; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[6];\n    IkReal err[6];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 6; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 6; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 6; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 6; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[6] = {false};\n    for(int i = 0; i < 6; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 6; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[8];\n    const int maxsteps = 110;\n    for(int i = 0; i < 8; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[8];\n    IkReal err[8];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 8; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 8; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 8; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 8; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[8] = {false};\n    for(int i = 0; i < 8; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 8; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\n};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"9ff4f1d77a61494bbd09f843fedb0314\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\nchar* ComputeFkWrapper(const IkReal* j) {\n    IkReal eetrans[3] = {0};\n    IkReal eerot[9] = {0};\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n\nstd::vector<IkReal> TrueComputeIk(int argc, char** argv)\n{\n    std::vector<IkReal> solvalues(GetNumJoints());\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return solvalues;\n}\n"]}