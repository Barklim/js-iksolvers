{"version":3,"file":"./solvers/pr2_leftarm_torso.html","sources":["./solvers/pr2_leftarm_torso.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAIA;;;;;;;;;;;;;;;AAw8PA;AACA;AACA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;AA1pQA;AAAA;AAAA;;;;;;;;AAFA;AAAA;AAAA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-05-22 19:29:10.531261\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54;\nx0=IKcos(j[1]);\nx1=IKcos(j[4]);\nx2=IKcos(j[2]);\nx3=IKsin(j[4]);\nx4=IKsin(j[2]);\nx5=IKsin(j[3]);\nx6=IKcos(j[3]);\nx7=IKsin(j[1]);\nx8=IKcos(j[5]);\nx9=IKsin(j[5]);\nx10=IKsin(j[6]);\nx11=IKcos(j[6]);\nx12=IKsin(j[7]);\nx13=IKcos(j[7]);\nx14=((1.0)*x1);\nx15=((1.0)*x3);\nx16=((0.321)*x1);\nx17=((1.0)*x6);\nx18=((0.321)*x5);\nx19=((1.0)*x8);\nx20=((1.0)*x9);\nx21=((1.0)*x10);\nx22=((0.321)*x6);\nx23=((1.0)*x11);\nx24=(x2*x7);\nx25=((-1.0)*x3);\nx26=(x2*x5);\nx27=((-1.0)*x10);\nx28=(x0*x2);\nx29=((-1.0)*x1);\nx30=(x0*x4);\nx31=((-1.0)*x11);\nx32=(x2*x6);\nx33=(x5*x7);\nx34=(x4*x7);\nx35=(x15*x28);\nx36=(x14*x32);\nx37=(((x30*x5))+(((-1.0)*x17*x7)));\nx38=(((x0*x5))+(((-1.0)*x17*x34)));\nx39=(((x0*x6))+((x33*x4)));\nx40=(x36+(((-1.0)*x15*x4)));\nx41=((((-1.0)*x33))+(((-1.0)*x17*x30)));\nx42=(x37*x9);\nx43=(((x14*x4))+((x15*x32)));\nx44=(x39*x8);\nx45=((1.0)*x41);\nx46=(x40*x9);\nx47=(x1*x41);\nx48=(((x26*x9))+((x8*(((((-1.0)*x36))+((x3*x4)))))));\nx49=((((-1.0)*x14*x38))+((x15*x24)));\nx50=(x49*x9);\nx51=(((x8*((((x1*x38))+((x24*x25))))))+((x39*x9)));\nx52=(((x8*((x47+((x25*x28))))))+x42);\nx53=((((-1.0)*x21*x43))+(((-1.0)*x23*x48)));\nx54=(((x31*x51))+((x27*((((x24*x29))+((x25*x38)))))));\neerot[0]=(((x10*((x42+((x8*(((((-1.0)*x35))+x47))))))))+((x11*((((x1*x28))+((x3*x41)))))));\neerot[1]=((((-1.0)*x12*((((x21*(((((-1.0)*x15*x41))+(((-1.0)*x14*x28))))))+((x23*x52))))))+((x13*((((x9*((((x29*x41))+x35))))+((x37*x8)))))));\neerot[2]=((((-1.0)*x12*((((x19*x37))+((x20*(((((-1.0)*x14*x41))+x35))))))))+((x13*((((x27*((((x28*x29))+((x25*x41))))))+((x31*x52)))))));\neetrans[0]=((-0.05)+(((0.1)*x0))+((x16*x28))+((x3*(((((-1.0)*x18*x7))+(((-1.0)*x22*x30))))))+(((0.4)*x28)));\neerot[3]=(((x10*x51))+((x11*((((x1*x24))+((x3*x38)))))));\neerot[4]=(((x13*((x44+x50))))+((x12*x54)));\neerot[5]=(((x13*x54))+((x12*(((((-1.0)*x20*x49))+(((-1.0)*x19*x39)))))));\neetrans[1]=((0.188)+(((0.1)*x7))+((x16*x24))+(((0.4)*x24))+((x3*((((x0*x18))+(((-1.0)*x22*x34)))))));\neerot[6]=(((x10*x48))+(((-1.0)*x11*x43)));\neerot[7]=(((x12*x53))+((x13*((x46+((x26*x8)))))));\neerot[8]=(((x13*x53))+((x12*(((((-1.0)*x20*x40))+(((-1.0)*x19*x26)))))));\neetrans[2]=((0.739675)+(((-1.0)*x2*x22*x3))+(((-1.0)*x16*x4))+(((-0.4)*x4))+j[0]);\n}\n\nIKFAST_API int GetNumFreeParameters() { return 2; }\nIKFAST_API int* GetFreeParameters() { static int freeparams[] = {0, 3}; return freeparams; }\nIKFAST_API int GetNumJoints() { return 8; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j15,cj15,sj15,htj15,j15mul,j16,cj16,sj16,htj16,j16mul,j18,cj18,sj18,htj18,j18mul,j19,cj19,sj19,htj19,j19mul,j20,cj20,sj20,htj20,j20mul,j21,cj21,sj21,htj21,j21mul,j12,cj12,sj12,htj12,j17,cj17,sj17,htj17,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij15[2], _nj15,_ij16[2], _nj16,_ij18[2], _nj18,_ij19[2], _nj19,_ij20[2], _nj20,_ij21[2], _nj21,_ij12[2], _nj12,_ij17[2], _nj17;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1; j16=numeric_limits<IkReal>::quiet_NaN(); _ij16[0] = -1; _ij16[1] = -1; _nj16 = -1; j18=numeric_limits<IkReal>::quiet_NaN(); _ij18[0] = -1; _ij18[1] = -1; _nj18 = -1; j19=numeric_limits<IkReal>::quiet_NaN(); _ij19[0] = -1; _ij19[1] = -1; _nj19 = -1; j20=numeric_limits<IkReal>::quiet_NaN(); _ij20[0] = -1; _ij20[1] = -1; _nj20 = -1; j21=numeric_limits<IkReal>::quiet_NaN(); _ij21[0] = -1; _ij21[1] = -1; _nj21 = -1;  _ij12[0] = -1; _ij12[1] = -1; _nj12 = 0;  _ij17[0] = -1; _ij17[1] = -1; _nj17 = 0; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nj12=pfree[0]; cj12=cos(pfree[0]); sj12=sin(pfree[0]), htj12=tan(pfree[0]*0.5);\nj17=pfree[1]; cj17=cos(pfree[1]); sj17=sin(pfree[1]), htj17=tan(pfree[1]*0.5);\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=((-1.0)*r02);\nnew_r01=r01;\nnew_r02=r00;\nnew_px=((0.05)+px);\nnew_r10=((-1.0)*r12);\nnew_r11=r11;\nnew_r12=r10;\nnew_py=((-0.188)+py);\nnew_r20=((-1.0)*r22);\nnew_r21=r21;\nnew_r22=r20;\nnew_pz=((-0.739675)+(((-1.0)*j12))+pz);\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x55=((1.0)*px);\nIkReal x56=((1.0)*pz);\nIkReal x57=((1.0)*py);\npp=((px*px)+(py*py)+(pz*pz));\nnpx=(((px*r00))+((py*r10))+((pz*r20)));\nnpy=(((px*r01))+((py*r11))+((pz*r21)));\nnpz=(((px*r02))+((py*r12))+((pz*r22)));\nrxp0_0=((((-1.0)*r20*x57))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x56)));\nrxp0_2=((((-1.0)*r10*x55))+((py*r00)));\nrxp1_0=((((-1.0)*r21*x57))+((pz*r11)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x56)));\nrxp1_2=((((-1.0)*r11*x55))+((py*r01)));\nrxp2_0=(((pz*r12))+(((-1.0)*r22*x57)));\nrxp2_1=(((px*r22))+(((-1.0)*r02*x56)));\nrxp2_2=((((-1.0)*r12*x55))+((py*r02)));\nIkReal op[8+1], zeror[8];\nint numroots;\nIkReal x58=((0.2)*px);\nIkReal x59=((1.0)*pp);\nIkReal x60=((0.509841)+x58+(((-1.0)*x59)));\nIkReal x61=((-0.003759)+x58+(((-1.0)*x59)));\nIkReal x62=(x59+x58);\nIkReal x63=((0.509841)+(((-1.0)*x62)));\nIkReal x64=((-0.003759)+(((-1.0)*x62)));\nIkReal gconst0=x60;\nIkReal gconst1=x61;\nIkReal gconst2=x60;\nIkReal gconst3=x61;\nIkReal gconst4=x63;\nIkReal gconst5=x64;\nIkReal gconst6=x63;\nIkReal gconst7=x64;\nIkReal x65=py*py;\nIkReal x66=sj17*sj17;\nIkReal x67=px*px;\nIkReal x68=((1.0)*gconst4);\nIkReal x69=(gconst5*py);\nIkReal x70=((4.0)*px);\nIkReal x71=(gconst0*gconst3);\nIkReal x72=(gconst1*gconst2);\nIkReal x73=((2.0)*gconst5);\nIkReal x74=((1.0)*gconst0);\nIkReal x75=(gconst1*gconst7);\nIkReal x76=(gconst0*gconst6);\nIkReal x77=(gconst1*gconst3);\nIkReal x78=(gconst4*gconst7);\nIkReal x79=(gconst6*py);\nIkReal x80=((2.0)*gconst0);\nIkReal x81=(gconst0*gconst7);\nIkReal x82=((2.0)*gconst4);\nIkReal x83=(gconst3*gconst5);\nIkReal x84=(gconst2*gconst5);\nIkReal x85=(gconst3*gconst4);\nIkReal x86=(gconst5*gconst6);\nIkReal x87=(gconst2*gconst4);\nIkReal x88=(gconst1*gconst6);\nIkReal x89=(px*py);\nIkReal x90=(gconst1*py);\nIkReal x91=(gconst2*py);\nIkReal x92=(gconst5*gconst7);\nIkReal x93=((1.05513984)*x89);\nIkReal x94=(gconst6*x65);\nIkReal x95=((0.3297312)*x66);\nIkReal x96=((4.0)*x67);\nIkReal x97=(gconst2*x65);\nIkReal x98=((2.0)*x65);\nIkReal x99=((1.0)*x65);\nIkReal x100=((0.824328)*x66);\nIkReal x101=((0.412164)*x66);\nIkReal x102=((0.1648656)*x66);\nIkReal x103=(x65*x78);\nIkReal x104=(x65*x86);\nIkReal x105=(x65*x84);\nIkReal x106=(x65*x85);\nIkReal x107=(x65*x81);\nIkReal x108=(x65*x88);\nIkReal x109=((0.0834355125792)*py*x66);\nIkReal x110=(x65*x72);\nIkReal x111=(x65*x71);\nIkReal x112=(x65*x66);\nIkReal x113=(x101*x86);\nIkReal x114=(x92*x99);\nIkReal x115=(x68*x94);\nIkReal x116=(py*x70*x87);\nIkReal x117=(py*x70*x75);\nIkReal x118=(gconst3*x69*x70);\nIkReal x119=(py*x70*x76);\nIkReal x120=(py*x70*x85);\nIkReal x121=(py*x70*x81);\nIkReal x122=(gconst2*x69*x70);\nIkReal x123=(gconst1*x70*x79);\nIkReal x124=(x75*x99);\nIkReal x125=(x68*x97);\nIkReal x126=(x101*x88);\nIkReal x127=((0.06594624)*x112);\nIkReal x128=(x74*x94);\nIkReal x129=(x101*x84);\nIkReal x130=(x83*x99);\nIkReal x131=(pp*py*x95);\nIkReal x132=((0.06594624)*x66*x89);\nIkReal x133=(x74*x97);\nIkReal x134=(x77*x99);\nIkReal x135=(x101*x72);\nIkReal x136=(x111+x110);\nIkReal x137=(x104+x103);\nIkReal x138=(x113+x115+x114);\nIkReal x139=(x135+x134+x133);\nIkReal x140=(x108+x105+x106+x107);\nIkReal x141=(x122+x123+x120+x121);\nIkReal x142=(x117+x116+x119+x118);\nIkReal x143=(x130+x126+x127+x124+x125+x128+x129);\nop[0]=(x137+(((-1.0)*x138)));\nop[1]=((((-1.0)*x109))+x131+x132+(((-1.0)*x93)));\nop[2]=((((-1.0)*x143))+(((-1.0)*gconst4*gconst6*x96))+((x82*x94))+(((-1.0)*x73*x94))+((x78*x96))+((x86*x96))+x140+(((-1.0)*x78*x98))+(((-1.0)*x92*x96))+(((-1.0)*x100*x86))+((gconst7*x65*x73)));\nop[3]=((((-1.0)*x142))+(((-1.0)*x102*x91))+(((-1.0)*x102*x90))+(((-1.0)*gconst6*x69*x70))+(((-1.0)*py*x70*x78))+x141+((gconst7*x69*x70))+(((-1.0)*x79*x95))+(((-1.0)*x69*x95))+((gconst4*x70*x79)));\nop[4]=(((x82*x97))+((x81*x96))+(((-1.0)*x73*x97))+((gconst3*x65*x73))+(((-1.0)*x83*x96))+(((-0.13189248)*x112))+((x85*x96))+x137+x136+(((-1.0)*x87*x96))+(((-1.0)*x138))+(((-1.0)*x139))+((x75*x98))+((x88*x96))+((x76*x98))+(((-1.0)*x76*x96))+(((-1.0)*x100*x84))+(((-1.0)*x100*x88))+(((-1.0)*x75*x96))+(((-1.0)*gconst3*x65*x82))+(((-1.0)*x88*x98))+(((-1.0)*gconst7*x65*x80))+((x84*x96)));\nop[5]=((((-1.0)*x141))+(((-1.0)*x90*x95))+(((-1.0)*gconst0*x70*x91))+(((-1.0)*x91*x95))+(((-1.0)*py*x70*x77))+x142+((py*x70*x72))+((py*x70*x71))+(((-1.0)*x102*x69))+(((-1.0)*x102*x79)));\nop[6]=((((-1.0)*x143))+((x71*x96))+(((-1.0)*gconst0*gconst2*x96))+(((-1.0)*x71*x98))+(((-1.0)*x72*x98))+(((-1.0)*x77*x96))+((x72*x96))+x140+(((-1.0)*x100*x72))+((x80*x97))+((x77*x98)));\nop[7]=((((-1.0)*x109))+x131+(((-1.0)*x132))+x93);\nop[8]=(x136+(((-1.0)*x139)));\npolyroots8(op,zeror,numroots);\nIkReal j15array[8], cj15array[8], sj15array[8], tempj15array[1];\nint numsolutions = 0;\nfor(int ij15 = 0; ij15 < numroots; ++ij15)\n{\nIkReal htj15 = zeror[ij15];\ntempj15array[0]=((2.0)*(atan(htj15)));\nfor(int kj15 = 0; kj15 < 1; ++kj15)\n{\nj15array[numsolutions] = tempj15array[kj15];\nif( j15array[numsolutions] > IKPI )\n{\n    j15array[numsolutions]-=IK2PI;\n}\nelse if( j15array[numsolutions] < -IKPI )\n{\n    j15array[numsolutions]+=IK2PI;\n}\nsj15array[numsolutions] = IKsin(j15array[numsolutions]);\ncj15array[numsolutions] = IKcos(j15array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j15valid[8]={true,true,true,true,true,true,true,true};\n_nj15 = 8;\nfor(int ij15 = 0; ij15 < numsolutions; ++ij15)\n    {\nif( !j15valid[ij15] )\n{\n    continue;\n}\n    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];\nhtj15 = IKtan(j15/2);\n\n_ij15[0] = ij15; _ij15[1] = -1;\nfor(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)\n{\nif( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )\n{\n    j15valid[iij15]=false; _ij15[1] = iij15; break; \n}\n}\n{\nIkReal j16eval[2];\nIkReal x144=py*py;\nIkReal x145=cj15*cj15;\nIkReal x146=px*px;\nIkReal x147=pz*pz;\nIkReal x148=((4.0)*sj17);\nIkReal x149=((20.0)*sj17);\nIkReal x150=(py*sj15);\nIkReal x151=(cj15*px);\nIkReal x152=((100.0)*sj17);\nIkReal x153=((0.8)*sj17);\nIkReal x154=(x144*x145);\nIkReal x155=(x145*x146);\nj16eval[0]=(((x149*x150))+((x149*x151))+(((-1.0)*x144*x152))+((x152*x154))+(((-1.0)*x152*x155))+(((-1.0)*sj17))+(((-1.0)*x147*x152))+(((-200.0)*sj17*x150*x151)));\nj16eval[1]=IKsign((((x150*x153))+(((-1.0)*x144*x148))+((x151*x153))+(((-1.0)*x147*x148))+(((-1.0)*x148*x155))+(((-8.0)*sj17*x150*x151))+((x148*x154))+(((-0.04)*sj17))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j18eval[1];\nj18eval[0]=sj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x156=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));\nevalcond[1]=x156;\nevalcond[2]=x156;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[2], cj18array[2], sj18array[2];\nbool j18valid[2]={false};\n_nj18 = 2;\ncj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));\nif( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j18valid[0] = j18valid[1] = true;\n    j18array[0] = IKacos(cj18array[0]);\n    sj18array[0] = IKsin(j18array[0]);\n    cj18array[1] = cj18array[0];\n    j18array[1] = -j18array[0];\n    sj18array[1] = -sj18array[0];\n}\nelse if( isnan(cj18array[0]) )\n{\n    // probably any value will work\n    j18valid[0] = true;\n    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;\n}\nfor(int ij18 = 0; ij18 < 2; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 2; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n\n{\nIkReal j16eval[3];\nsj17=0;\ncj17=1.0;\nj17=0;\nIkReal x157=((321000.0)*sj18);\nIkReal x158=(py*sj15);\nIkReal x159=((321000.0)*cj18);\nIkReal x160=(cj15*px);\nj16eval[0]=((1.02430295950156)+cj18);\nj16eval[1]=IKsign(((263041.0)+(((256800.0)*cj18))));\nj16eval[2]=((IKabs(((-40000.0)+(((400000.0)*x160))+(((-1.0)*pz*x157))+(((400000.0)*x158))+(((-32100.0)*cj18))+((x158*x159))+((x159*x160)))))+(IKabs(((((-1.0)*x157*x160))+(((-1.0)*x157*x158))+(((-1.0)*pz*x159))+(((-400000.0)*pz))+(((32100.0)*sj18))))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[3];\nsj17=0;\ncj17=1.0;\nj17=0;\nIkReal x161=(cj15*px);\nIkReal x162=((1000.0)*pz);\nIkReal x163=(py*sj15);\nIkReal x164=((10.0)*cj18);\nIkReal x165=((321.0)*cj18);\nIkReal x166=(pz*sj18);\nj16eval[0]=((1.24610591900312)+(((-1.0)*x163*x164))+(((-1.0)*x161*x164))+cj18+(((-10.0)*x166))+(((-12.4610591900312)*x161))+(((-12.4610591900312)*x163)));\nj16eval[1]=IKsign(((40.0)+(((-400.0)*x161))+(((-400.0)*x163))+(((-1.0)*x163*x165))+(((32.1)*cj18))+(((-1.0)*x161*x165))+(((-321.0)*x166))));\nj16eval[2]=((IKabs(((-160.0)+((pz*x162))+(((-256.8)*cj18))+(((-103.041)*(cj18*cj18))))))+(IKabs((((x161*x162))+(((-100.0)*pz))+(((103.041)*cj18*sj18))+((x162*x163))+(((128.4)*sj18))))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[3];\nsj17=0;\ncj17=1.0;\nj17=0;\nIkReal x167=cj15*cj15;\nIkReal x168=py*py;\nIkReal x169=px*px;\nIkReal x170=pz*pz;\nIkReal x171=(py*sj15);\nIkReal x172=((321.0)*sj18);\nIkReal x173=(cj15*px);\nIkReal x174=((321.0)*cj18);\nIkReal x175=((100.0)*x167);\nIkReal x176=((1000.0)*x167);\nj16eval[0]=((-1.0)+(((-100.0)*x168))+(((-100.0)*x170))+((x168*x175))+(((20.0)*x171))+(((20.0)*x173))+(((-200.0)*x171*x173))+(((-1.0)*x169*x175)));\nj16eval[1]=IKsign(((-10.0)+(((-2000.0)*x171*x173))+((x168*x176))+(((-1000.0)*x168))+(((-1000.0)*x170))+(((-1.0)*x169*x176))+(((200.0)*x173))+(((200.0)*x171))));\nj16eval[2]=((IKabs((((pz*x174))+((x172*x173))+(((400.0)*pz))+((x171*x172))+(((-32.1)*sj18)))))+(IKabs(((40.0)+((pz*x172))+(((-400.0)*x173))+(((-400.0)*x171))+(((32.1)*cj18))+(((-1.0)*x171*x174))+(((-1.0)*x173*x174))))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j16]\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x177=py*py;\nIkReal x178=cj15*cj15;\nIkReal x179=(py*sj15);\nIkReal x180=((321.0)*sj18);\nIkReal x181=(cj15*px);\nIkReal x182=((321.0)*cj18);\nIkReal x183=((1000.0)*x178);\nCheckValue<IkReal> x184=IKPowWithIntegerCheck(IKsign(((-10.0)+((x177*x183))+(((-1.0)*x183*(px*px)))+(((-2000.0)*x179*x181))+(((-1000.0)*(pz*pz)))+(((-1000.0)*x177))+(((200.0)*x181))+(((200.0)*x179)))),-1);\nif(!x184.valid){\ncontinue;\n}\nCheckValue<IkReal> x185 = IKatan2WithCheck(IkReal((((pz*x182))+((x180*x181))+((x179*x180))+(((400.0)*pz))+(((-32.1)*sj18)))),((40.0)+((pz*x180))+(((-400.0)*x181))+(((-400.0)*x179))+(((32.1)*cj18))+(((-1.0)*x179*x182))+(((-1.0)*x181*x182))),IKFAST_ATAN2_MAGTHRESH);\nif(!x185.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x184.value)))+(x185.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x186=IKsin(j16);\nIkReal x187=IKcos(j16);\nIkReal x188=((0.321)*sj18);\nIkReal x189=((0.321)*cj18);\nIkReal x190=(py*sj15);\nIkReal x191=(cj15*px);\nIkReal x192=(pz*x186);\nIkReal x193=(x187*x191);\nevalcond[0]=(((x186*x189))+(((0.4)*x186))+((x187*x188))+pz);\nevalcond[1]=(((pz*x187))+((x186*x190))+((x186*x191))+x188+(((-0.1)*x186)));\nevalcond[2]=((0.1)+(((0.4)*x187))+(((-1.0)*x186*x188))+((x187*x189))+(((-1.0)*x191))+(((-1.0)*x190)));\nevalcond[3]=((0.4)+(((0.1)*x187))+(((-1.0)*x193))+x192+x189+(((-1.0)*x187*x190)));\nevalcond[4]=((-0.066959)+(((0.2)*x191))+(((0.2)*x190))+(((-1.0)*pp))+(((0.8)*x187*x190))+(((0.8)*x193))+(((-0.08)*x187))+(((-0.8)*x192)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x619=(cj15*px);\nIkReal x620=((1000.0)*pz);\nIkReal x621=((321.0)*cj18);\nIkReal x622=(py*sj15);\nCheckValue<IkReal> x623 = IKatan2WithCheck(IkReal(((((-100.0)*pz))+(((103.041)*cj18*sj18))+((x619*x620))+(((128.4)*sj18))+((x620*x622)))),((-160.0)+((pz*x620))+(((-256.8)*cj18))+(((-103.041)*(cj18*cj18)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x623.valid){\ncontinue;\n}\nCheckValue<IkReal> x624=IKPowWithIntegerCheck(IKsign(((40.0)+(((-1.0)*x621*x622))+(((-400.0)*x622))+(((-321.0)*pz*sj18))+(((32.1)*cj18))+(((-1.0)*x619*x621))+(((-400.0)*x619)))),-1);\nif(!x624.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(x623.value)+(((1.5707963267949)*(x624.value))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x625=IKsin(j16);\nIkReal x626=IKcos(j16);\nIkReal x627=((0.321)*sj18);\nIkReal x628=((0.321)*cj18);\nIkReal x629=(py*sj15);\nIkReal x630=(cj15*px);\nIkReal x631=(pz*x625);\nIkReal x632=(x626*x630);\nevalcond[0]=(((x625*x628))+pz+(((0.4)*x625))+((x626*x627)));\nevalcond[1]=(((pz*x626))+(((-0.1)*x625))+((x625*x630))+((x625*x629))+x627);\nevalcond[2]=((0.1)+(((-1.0)*x625*x627))+(((-1.0)*x629))+(((-1.0)*x630))+(((0.4)*x626))+((x626*x628)));\nevalcond[3]=((0.4)+x628+x631+(((0.1)*x626))+(((-1.0)*x632))+(((-1.0)*x626*x629)));\nevalcond[4]=((-0.066959)+(((0.2)*x630))+(((0.2)*x629))+(((-0.08)*x626))+(((-1.0)*pp))+(((0.8)*x632))+(((-0.8)*x631))+(((0.8)*x626*x629)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x633=((321000.0)*sj18);\nIkReal x634=(py*sj15);\nIkReal x635=((321000.0)*cj18);\nIkReal x636=(cj15*px);\nCheckValue<IkReal> x637=IKPowWithIntegerCheck(IKsign(((263041.0)+(((256800.0)*cj18)))),-1);\nif(!x637.valid){\ncontinue;\n}\nCheckValue<IkReal> x638 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x635))+(((-1.0)*x633*x634))+(((-1.0)*x633*x636))+(((-400000.0)*pz))+(((32100.0)*sj18)))),((-40000.0)+(((-1.0)*pz*x633))+((x634*x635))+((x635*x636))+(((-32100.0)*cj18))+(((400000.0)*x636))+(((400000.0)*x634))),IKFAST_ATAN2_MAGTHRESH);\nif(!x638.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x637.value)))+(x638.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x639=IKsin(j16);\nIkReal x640=IKcos(j16);\nIkReal x641=((0.321)*sj18);\nIkReal x642=((0.321)*cj18);\nIkReal x643=(py*sj15);\nIkReal x644=(cj15*px);\nIkReal x645=(pz*x639);\nIkReal x646=(x640*x644);\nevalcond[0]=(((x639*x642))+((x640*x641))+pz+(((0.4)*x639)));\nevalcond[1]=((((-0.1)*x639))+((x639*x644))+((x639*x643))+((pz*x640))+x641);\nevalcond[2]=((0.1)+(((-1.0)*x644))+(((-1.0)*x643))+(((-1.0)*x639*x641))+((x640*x642))+(((0.4)*x640)));\nevalcond[3]=((0.4)+(((-1.0)*x646))+(((-1.0)*x640*x643))+(((0.1)*x640))+x645+x642);\nevalcond[4]=((-0.066959)+(((-0.8)*x645))+(((-1.0)*pp))+(((-0.08)*x640))+(((0.2)*x643))+(((0.2)*x644))+(((0.8)*x646))+(((0.8)*x640*x643)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x647=(cj15*py);\nIkReal x648=(px*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));\nevalcond[1]=((((-1.0)*x647))+x648);\nevalcond[2]=((((-1.0)*x648))+x647);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[2], cj18array[2], sj18array[2];\nbool j18valid[2]={false};\n_nj18 = 2;\ncj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));\nif( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j18valid[0] = j18valid[1] = true;\n    j18array[0] = IKacos(cj18array[0]);\n    sj18array[0] = IKsin(j18array[0]);\n    cj18array[1] = cj18array[0];\n    j18array[1] = -j18array[0];\n    sj18array[1] = -sj18array[0];\n}\nelse if( isnan(cj18array[0]) )\n{\n    // probably any value will work\n    j18valid[0] = true;\n    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;\n}\nfor(int ij18 = 0; ij18 < 2; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 2; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n\n{\nIkReal j16eval[3];\nsj17=0;\ncj17=-1.0;\nj17=3.14159265358979;\nIkReal x649=((321000.0)*pz);\nIkReal x650=((321000.0)*py*sj15);\nIkReal x651=((321000.0)*cj15*px);\nj16eval[0]=((-1.02430295950156)+(((-1.0)*cj18)));\nj16eval[1]=IKsign(((-263041.0)+(((-256800.0)*cj18))));\nj16eval[2]=((IKabs(((40000.0)+(((32100.0)*cj18))+(((-1.0)*sj18*x649))+(((-400000.0)*cj15*px))+(((-400000.0)*py*sj15))+(((-1.0)*cj18*x650))+(((-1.0)*cj18*x651)))))+(IKabs((((cj18*x649))+(((-1.0)*sj18*x651))+(((-1.0)*sj18*x650))+(((400000.0)*pz))+(((32100.0)*sj18))))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[3];\nsj17=0;\ncj17=-1.0;\nj17=3.14159265358979;\nIkReal x652=(cj15*px);\nIkReal x653=((1000.0)*pz);\nIkReal x654=(py*sj15);\nIkReal x655=((10.0)*cj18);\nIkReal x656=((321.0)*cj18);\nIkReal x657=(pz*sj18);\nj16eval[0]=((-1.24610591900312)+(((-10.0)*x657))+(((12.4610591900312)*x654))+(((12.4610591900312)*x652))+((x652*x655))+((x654*x655))+(((-1.0)*cj18)));\nj16eval[1]=((IKabs(((160.0)+(((256.8)*cj18))+(((-1.0)*pz*x653))+(((103.041)*(cj18*cj18))))))+(IKabs(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))+(((-1.0)*x653*x654))+(((-1.0)*x652*x653))))));\nj16eval[2]=IKsign(((-40.0)+(((400.0)*x654))+(((400.0)*x652))+(((-321.0)*x657))+((x652*x656))+((x654*x656))+(((-32.1)*cj18))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[3];\nsj17=0;\ncj17=-1.0;\nj17=3.14159265358979;\nIkReal x658=cj15*cj15;\nIkReal x659=py*py;\nIkReal x660=px*px;\nIkReal x661=pz*pz;\nIkReal x662=(py*sj15);\nIkReal x663=((321.0)*cj18);\nIkReal x664=(cj15*px);\nIkReal x665=((321.0)*sj18);\nIkReal x666=(x658*x660);\nIkReal x667=(x658*x659);\nj16eval[0]=((-1.0)+(((-200.0)*x662*x664))+(((100.0)*x667))+(((20.0)*x662))+(((20.0)*x664))+(((-100.0)*x659))+(((-100.0)*x666))+(((-100.0)*x661)));\nj16eval[1]=IKsign(((-10.0)+(((-1000.0)*x661))+(((-1000.0)*x666))+(((1000.0)*x667))+(((200.0)*x664))+(((200.0)*x662))+(((-1000.0)*x659))+(((-2000.0)*x662*x664))));\nj16eval[2]=((IKabs(((((32.1)*sj18))+(((-1.0)*x662*x665))+(((400.0)*pz))+((pz*x663))+(((-1.0)*x664*x665)))))+(IKabs(((40.0)+(((-1.0)*x662*x663))+(((-1.0)*x663*x664))+(((32.1)*cj18))+(((-1.0)*pz*x665))+(((-400.0)*x664))+(((-400.0)*x662))))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j16]\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x668=py*py;\nIkReal x669=cj15*cj15;\nIkReal x670=(py*sj15);\nIkReal x671=((321.0)*sj18);\nIkReal x672=(cj15*px);\nIkReal x673=((321.0)*cj18);\nIkReal x674=((1000.0)*x669);\nCheckValue<IkReal> x675 = IKatan2WithCheck(IkReal((((pz*x673))+(((32.1)*sj18))+(((400.0)*pz))+(((-1.0)*x670*x671))+(((-1.0)*x671*x672)))),((40.0)+(((32.1)*cj18))+(((-1.0)*pz*x671))+(((-1.0)*x670*x673))+(((-1.0)*x672*x673))+(((-400.0)*x670))+(((-400.0)*x672))),IKFAST_ATAN2_MAGTHRESH);\nif(!x675.valid){\ncontinue;\n}\nCheckValue<IkReal> x676=IKPowWithIntegerCheck(IKsign(((-10.0)+(((-1000.0)*x668))+(((-1000.0)*(pz*pz)))+(((-2000.0)*x670*x672))+(((200.0)*x672))+(((200.0)*x670))+(((-1.0)*x674*(px*px)))+((x668*x674)))),-1);\nif(!x676.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(x675.value)+(((1.5707963267949)*(x676.value))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x677=IKsin(j16);\nIkReal x678=IKcos(j16);\nIkReal x679=((0.321)*sj18);\nIkReal x680=((0.321)*cj18);\nIkReal x681=(cj15*px);\nIkReal x682=(py*sj15);\nIkReal x683=(pz*x677);\nIkReal x684=((1.0)*x677);\nIkReal x685=((1.0)*x678);\nIkReal x686=(x678*x681);\nevalcond[0]=((((-1.0)*x678*x679))+(((0.4)*x677))+((x677*x680))+pz);\nevalcond[1]=((0.1)+((x678*x680))+(((0.4)*x678))+((x677*x679))+(((-1.0)*x681))+(((-1.0)*x682)));\nevalcond[2]=((0.4)+(((0.1)*x678))+(((-1.0)*x681*x685))+x683+x680+(((-1.0)*x682*x685)));\nevalcond[3]=((((0.1)*x677))+(((-1.0)*x681*x684))+x679+(((-1.0)*x682*x684))+(((-1.0)*pz*x685)));\nevalcond[4]=((-0.066959)+(((-0.08)*x678))+(((0.2)*x681))+(((0.2)*x682))+(((-1.0)*pp))+(((0.8)*x686))+(((0.8)*x678*x682))+(((-0.8)*x683)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x687=(cj15*px);\nIkReal x688=((1000.0)*pz);\nIkReal x689=((321.0)*cj18);\nIkReal x690=(py*sj15);\nCheckValue<IkReal> x691=IKPowWithIntegerCheck(IKsign(((-40.0)+(((400.0)*x690))+((x687*x689))+(((-321.0)*pz*sj18))+((x689*x690))+(((-32.1)*cj18))+(((400.0)*x687)))),-1);\nif(!x691.valid){\ncontinue;\n}\nCheckValue<IkReal> x692 = IKatan2WithCheck(IkReal(((((-1.0)*x687*x688))+(((100.0)*pz))+(((103.041)*cj18*sj18))+(((-1.0)*x688*x690))+(((128.4)*sj18)))),((160.0)+(((256.8)*cj18))+(((-1.0)*pz*x688))+(((103.041)*(cj18*cj18)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x692.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x691.value)))+(x692.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x693=IKsin(j16);\nIkReal x694=IKcos(j16);\nIkReal x695=((0.321)*sj18);\nIkReal x696=((0.321)*cj18);\nIkReal x697=(cj15*px);\nIkReal x698=(py*sj15);\nIkReal x699=(pz*x693);\nIkReal x700=((1.0)*x693);\nIkReal x701=((1.0)*x694);\nIkReal x702=(x694*x697);\nevalcond[0]=(((x693*x696))+(((0.4)*x693))+pz+(((-1.0)*x694*x695)));\nevalcond[1]=((0.1)+((x694*x696))+((x693*x695))+(((0.4)*x694))+(((-1.0)*x698))+(((-1.0)*x697)));\nevalcond[2]=((0.4)+(((0.1)*x694))+x696+x699+(((-1.0)*x698*x701))+(((-1.0)*x697*x701)));\nevalcond[3]=((((-1.0)*pz*x701))+(((0.1)*x693))+x695+(((-1.0)*x698*x700))+(((-1.0)*x697*x700)));\nevalcond[4]=((-0.066959)+(((0.8)*x694*x698))+(((-1.0)*pp))+(((-0.08)*x694))+(((-0.8)*x699))+(((0.8)*x702))+(((0.2)*x697))+(((0.2)*x698)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x703=((321000.0)*pz);\nIkReal x704=((321000.0)*py*sj15);\nIkReal x705=((321000.0)*cj15*px);\nCheckValue<IkReal> x706=IKPowWithIntegerCheck(IKsign(((-263041.0)+(((-256800.0)*cj18)))),-1);\nif(!x706.valid){\ncontinue;\n}\nCheckValue<IkReal> x707 = IKatan2WithCheck(IkReal(((((-1.0)*sj18*x704))+(((-1.0)*sj18*x705))+((cj18*x703))+(((400000.0)*pz))+(((32100.0)*sj18)))),((40000.0)+(((32100.0)*cj18))+(((-1.0)*sj18*x703))+(((-400000.0)*cj15*px))+(((-400000.0)*py*sj15))+(((-1.0)*cj18*x704))+(((-1.0)*cj18*x705))),IKFAST_ATAN2_MAGTHRESH);\nif(!x707.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x706.value)))+(x707.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x708=IKsin(j16);\nIkReal x709=IKcos(j16);\nIkReal x710=((0.321)*sj18);\nIkReal x711=((0.321)*cj18);\nIkReal x712=(cj15*px);\nIkReal x713=(py*sj15);\nIkReal x714=(pz*x708);\nIkReal x715=((1.0)*x708);\nIkReal x716=((1.0)*x709);\nIkReal x717=(x709*x712);\nevalcond[0]=((((0.4)*x708))+(((-1.0)*x709*x710))+pz+((x708*x711)));\nevalcond[1]=((0.1)+(((0.4)*x709))+(((-1.0)*x713))+(((-1.0)*x712))+((x709*x711))+((x708*x710)));\nevalcond[2]=((0.4)+(((0.1)*x709))+(((-1.0)*x712*x716))+x711+x714+(((-1.0)*x713*x716)));\nevalcond[3]=((((-1.0)*pz*x716))+(((0.1)*x708))+(((-1.0)*x712*x715))+x710+(((-1.0)*x713*x715)));\nevalcond[4]=((-0.066959)+(((0.8)*x709*x713))+(((-1.0)*pp))+(((-0.8)*x714))+(((0.2)*x712))+(((0.2)*x713))+(((0.8)*x717))+(((-0.08)*x709)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j16, j18]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x718=IKPowWithIntegerCheck(sj17,-1);\nif(!x718.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x718.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x718.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x718.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[2];\nevalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*sj17*(IKsin(j18)))));\nevalcond[1]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*(IKcos(j18)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j16eval[3];\nIkReal x719=(cj15*px);\nIkReal x720=((1000.0)*pz);\nIkReal x721=(py*sj15);\nIkReal x722=((10.0)*cj18);\nIkReal x723=((321.0)*cj18);\nIkReal x724=(cj17*sj18);\nIkReal x725=(pz*x724);\nj16eval[0]=((-1.24610591900312)+((x721*x722))+(((12.4610591900312)*x719))+(((12.4610591900312)*x721))+(((10.0)*x725))+((x719*x722))+(((-1.0)*cj18)));\nj16eval[1]=((IKabs(((160.0)+(((256.8)*cj18))+(((-1.0)*pz*x720))+(((103.041)*(cj18*cj18))))))+(IKabs(((((-103.041)*cj18*x724))+(((100.0)*pz))+(((-1.0)*x720*x721))+(((-1.0)*x719*x720))+(((-128.4)*x724))))));\nj16eval[2]=IKsign(((-40.0)+((x721*x723))+(((400.0)*x721))+(((321.0)*x725))+(((400.0)*x719))+(((-32.1)*cj18))+((x719*x723))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[3];\nIkReal x726=cj17*cj17;\nIkReal x727=cj18*cj18;\nIkReal x728=(cj15*px);\nIkReal x729=(py*sj15);\nIkReal x730=((321000.0)*cj18);\nIkReal x731=((321000.0)*cj17*sj18);\nIkReal x732=((103041.0)*x727);\nj16eval[0]=((1.5527799613746)+(((2.49221183800623)*cj18))+x726+x727+(((-1.0)*x726*x727)));\nj16eval[1]=((IKabs(((-40000.0)+((x728*x730))+((x729*x730))+(((400000.0)*x729))+(((400000.0)*x728))+(((-32100.0)*cj18))+(((-1.0)*pz*x731)))))+(IKabs(((((32100.0)*cj17*sj18))+(((-400000.0)*pz))+(((-1.0)*pz*x730))+(((-1.0)*x728*x731))+(((-1.0)*x729*x731))))));\nj16eval[2]=IKsign(((160000.0)+(((103041.0)*x726))+(((256800.0)*cj18))+x732+(((-1.0)*x726*x732))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[2];\nIkReal x733=(cj17*sj18);\nIkReal x734=(py*sj15);\nIkReal x735=(cj18*pz);\nIkReal x736=(cj15*px);\nj16eval[0]=((((-10.0)*x733*x736))+(((-10.0)*x733*x734))+(((10.0)*x735))+x733+(((12.4610591900312)*pz)));\nj16eval[1]=IKsign(((((321.0)*x735))+(((400.0)*pz))+(((-321.0)*x733*x734))+(((-321.0)*x733*x736))+(((32.1)*x733))));\nif( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x737=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*sj18)));\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j17), 6.28318530717959)))))+(IKabs(pz)));\nevalcond[1]=x737;\nevalcond[2]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*cj18)));\nevalcond[3]=x737;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16eval[1];\nIkReal x738=((-1.0)*py);\npz=0;\nj17=1.5707963267949;\nsj17=1.0;\ncj17=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x738);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x738);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x738);\nrxp2_1=(px*r22);\nj16eval[0]=((1.0)+(((-10.0)*cj15*px))+(((-10.0)*py*sj15)));\nif( IKabs(j16eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[1];\nIkReal x739=((-1.0)*py);\npz=0;\nj17=1.5707963267949;\nsj17=1.0;\ncj17=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x739);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x739);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x739);\nrxp2_1=(px*r22);\nj16eval[0]=((1.24610591900312)+cj18);\nif( IKabs(j16eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x740=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nif((x740) < -0.00001)\ncontinue;\nIkReal x741=IKabs(IKsqrt(x740));\nIkReal x747 = x740;\nif(IKabs(x747)==0){\ncontinue;\n}\nIkReal x742=pow(x747,-0.5);\nCheckValue<IkReal> x748=IKPowWithIntegerCheck(x741,-1);\nif(!x748.valid){\ncontinue;\n}\nIkReal x743=x748.value;\nIkReal x744=((10.0)*px*x742);\nIkReal x745=((10.0)*py*x742);\nif((((1.0)+(((-1.0)*(x743*x743))))) < -0.00001)\ncontinue;\nIkReal x746=IKsqrt(((1.0)+(((-1.0)*(x743*x743)))));\nCheckValue<IkReal> x749 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x749.valid){\ncontinue;\n}\nif( (x743) < -1-IKFAST_SINCOS_THRESH || (x743) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal gconst24=((((-1.0)*(x749.value)))+(((-1.0)*(IKasin(x743)))));\nIkReal gconst25=(((x744*x746))+((x743*x745)));\nIkReal gconst26=((((-1.0)*x745*x746))+((x743*x744)));\nIkReal x750=px*px;\nIkReal x751=py*py;\nIkReal x752=(((gconst25*px))+(((0.321)*sj18))+(((-1.0)*gconst26*py)));\nif((((((100.0)*x750))+(((100.0)*x751)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x753=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x750))+(((100.0)*x751))))),-1);\nif(!x753.valid){\ncontinue;\n}\nif( (x753.value) < -1-IKFAST_SINCOS_THRESH || (x753.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x754 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x754.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x753.value))+j15+(x754.value))))), 6.28318530717959)));\nevalcond[1]=x752;\nevalcond[2]=((0.253041)+(((0.2)*gconst25*py))+(((0.2)*gconst26*px))+(((-1.0)*x751))+(((-1.0)*x750))+(((0.2568)*cj18)));\nevalcond[3]=x752;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x756=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst25*py))+(((-1.0)*gconst26*px))),-1);\nif(!x756.valid){\ncontinue;\n}\nIkReal x755=x756.value;\ncj16array[0]=((((-0.4)*x755))+(((-0.321)*cj18*x755)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x757=IKsin(j16);\nIkReal x758=IKcos(j16);\nIkReal x759=(gconst26*px);\nIkReal x760=(gconst25*py);\nIkReal x761=((0.321)*cj18);\nIkReal x762=((0.8)*x758);\nIkReal x763=((1.0)*x757);\nevalcond[0]=(((x757*x761))+(((0.4)*x757)));\nevalcond[1]=((((0.1)*x757))+(((-1.0)*x760*x763))+(((-1.0)*x759*x763)));\nevalcond[2]=((0.1)+((x758*x761))+(((-1.0)*x760))+(((-1.0)*x759))+(((0.4)*x758)));\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((-0.08)*x758))+(((0.2)*x760))+((x760*x762))+((x759*x762))+(((0.2)*x759))+(((-1.0)*(py*py))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x764=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nIkReal x771 = x764;\nif(IKabs(x771)==0){\ncontinue;\n}\nIkReal x765=pow(x771,-0.5);\nif((x764) < -0.00001)\ncontinue;\nIkReal x766=IKabs(IKsqrt(x764));\nCheckValue<IkReal> x772=IKPowWithIntegerCheck(x766,-1);\nif(!x772.valid){\ncontinue;\n}\nIkReal x767=x772.value;\nIkReal x768=((10.0)*px*x765);\nIkReal x769=((10.0)*py*x765);\nif((((1.0)+(((-1.0)*(x767*x767))))) < -0.00001)\ncontinue;\nIkReal x770=IKsqrt(((1.0)+(((-1.0)*(x767*x767)))));\nif( (x767) < -1-IKFAST_SINCOS_THRESH || (x767) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x773 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x773.valid){\ncontinue;\n}\nIkReal gconst27=((3.14159265358979)+(IKasin(x767))+(((-1.0)*(x773.value))));\nIkReal gconst28=((((-1.0)*x768*x770))+((x767*x769)));\nIkReal gconst29=(((x769*x770))+((x767*x768)));\nIkReal x774=px*px;\nIkReal x775=py*py;\nIkReal x776=((((-1.0)*gconst29*py))+(((0.321)*sj18))+((gconst28*px)));\nif((((((100.0)*x775))+(((100.0)*x774)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x777=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x775))+(((100.0)*x774))))),-1);\nif(!x777.valid){\ncontinue;\n}\nif( (x777.value) < -1-IKFAST_SINCOS_THRESH || (x777.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x778 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x778.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j15+(((-1.0)*(IKasin(x777.value))))+(x778.value))))), 6.28318530717959)));\nevalcond[1]=x776;\nevalcond[2]=((0.253041)+(((0.2)*gconst29*px))+(((-1.0)*x774))+(((-1.0)*x775))+(((0.2568)*cj18))+(((0.2)*gconst28*py)));\nevalcond[3]=x776;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x780=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst29*px))+(((-1.0)*gconst28*py))),-1);\nif(!x780.valid){\ncontinue;\n}\nIkReal x779=x780.value;\ncj16array[0]=((((-0.4)*x779))+(((-0.321)*cj18*x779)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x781=IKsin(j16);\nIkReal x782=IKcos(j16);\nIkReal x783=(gconst29*px);\nIkReal x784=((0.321)*cj18);\nIkReal x785=(gconst28*py);\nIkReal x786=((1.0)*x781);\nIkReal x787=((0.8)*x782);\nevalcond[0]=(((x781*x784))+(((0.4)*x781)));\nevalcond[1]=((((0.1)*x781))+(((-1.0)*x785*x786))+(((-1.0)*x783*x786)));\nevalcond[2]=((0.1)+((x782*x784))+(((-1.0)*x783))+(((-1.0)*x785))+(((0.4)*x782)));\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+((x785*x787))+((x783*x787))+(((-0.08)*x782))+(((0.2)*x783))+(((0.2)*x785))+(((-1.0)*(py*py))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j16]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x789=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj18))),-1);\nif(!x789.valid){\ncontinue;\n}\nIkReal x788=x789.value;\ncj16array[0]=(((cj15*px*x788))+(((-0.1)*x788))+((py*sj15*x788)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x790=IKsin(j16);\nIkReal x791=IKcos(j16);\nIkReal x792=(cj15*px);\nIkReal x793=((0.321)*cj18);\nIkReal x794=(py*sj15);\nIkReal x795=((1.0)*x794);\nIkReal x796=((0.8)*x791);\nevalcond[0]=(((x790*x793))+(((0.4)*x790)));\nevalcond[1]=((((-1.0)*x790*x795))+(((0.1)*x790))+(((-1.0)*x790*x792)));\nevalcond[2]=((0.4)+(((-1.0)*x791*x795))+(((0.1)*x791))+(((-1.0)*x791*x792))+x793);\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((-0.08)*x791))+(((0.2)*x792))+(((0.2)*x794))+((x792*x796))+((x794*x796))+(((-1.0)*(py*py))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x798=IKPowWithIntegerCheck(((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15))),-1);\nif(!x798.valid){\ncontinue;\n}\nIkReal x797=x798.value;\ncj16array[0]=((((-0.321)*cj18*x797))+(((-0.4)*x797)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x799=IKsin(j16);\nIkReal x800=IKcos(j16);\nIkReal x801=(py*sj15);\nIkReal x802=((0.321)*cj18);\nIkReal x803=(cj15*px);\nIkReal x804=((1.0)*x799);\nIkReal x805=((0.8)*x800);\nevalcond[0]=(((x799*x802))+(((0.4)*x799)));\nevalcond[1]=((((0.1)*x799))+(((-1.0)*x803*x804))+(((-1.0)*x801*x804)));\nevalcond[2]=((0.1)+(((-1.0)*x801))+(((-1.0)*x803))+((x800*x802))+(((0.4)*x800)));\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((0.2)*x801))+(((0.2)*x803))+(((-0.08)*x800))+((x803*x805))+((x801*x805))+(((-1.0)*(py*py))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x806=((0.321)*sj18);\nIkReal x807=(cj15*py);\nIkReal x808=(px*sj15);\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j17), 6.28318530717959)))))+(IKabs(pz)));\nevalcond[1]=((((-1.0)*x807))+x808+(((-1.0)*x806)));\nevalcond[2]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*cj18)));\nevalcond[3]=((((-1.0)*x808))+x807+x806);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16eval[1];\nIkReal x809=((-1.0)*py);\npz=0;\nj17=-1.5707963267949;\nsj17=-1.0;\ncj17=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x809);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x809);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x809);\nrxp2_1=(px*r22);\nj16eval[0]=((1.0)+(((-10.0)*cj15*px))+(((-10.0)*py*sj15)));\nif( IKabs(j16eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j16eval[1];\nIkReal x810=((-1.0)*py);\npz=0;\nj17=-1.5707963267949;\nsj17=-1.0;\ncj17=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x810);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x810);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x810);\nrxp2_1=(px*r22);\nj16eval[0]=((1.24610591900312)+cj18);\nif( IKabs(j16eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x811=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nif((x811) < -0.00001)\ncontinue;\nIkReal x812=IKabs(IKsqrt(x811));\nIkReal x818 = x811;\nif(IKabs(x818)==0){\ncontinue;\n}\nIkReal x813=pow(x818,-0.5);\nCheckValue<IkReal> x819=IKPowWithIntegerCheck(x812,-1);\nif(!x819.valid){\ncontinue;\n}\nIkReal x814=x819.value;\nIkReal x815=((10.0)*px*x813);\nIkReal x816=((10.0)*py*x813);\nif((((1.0)+(((-1.0)*(x814*x814))))) < -0.00001)\ncontinue;\nIkReal x817=IKsqrt(((1.0)+(((-1.0)*(x814*x814)))));\nCheckValue<IkReal> x820 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x820.valid){\ncontinue;\n}\nif( (x814) < -1-IKFAST_SINCOS_THRESH || (x814) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal gconst30=((((-1.0)*(x820.value)))+(((-1.0)*(IKasin(x814)))));\nIkReal gconst31=(((x815*x817))+((x814*x816)));\nIkReal gconst32=((((-1.0)*x816*x817))+((x814*x815)));\nIkReal x821=px*px;\nIkReal x822=py*py;\nIkReal x823=((0.321)*sj18);\nIkReal x824=(gconst32*py);\nIkReal x825=(gconst31*px);\nCheckValue<IkReal> x826 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x826.valid){\ncontinue;\n}\nif((((((100.0)*x822))+(((100.0)*x821)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x827=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x822))+(((100.0)*x821))))),-1);\nif(!x827.valid){\ncontinue;\n}\nif( (x827.value) < -1-IKFAST_SINCOS_THRESH || (x827.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j15+(x826.value)+(IKasin(x827.value)))))), 6.28318530717959)));\nevalcond[1]=((((-1.0)*x823))+(((-1.0)*x824))+x825);\nevalcond[2]=((0.253041)+(((0.2)*gconst32*px))+(((-1.0)*x821))+(((-1.0)*x822))+(((0.2)*gconst31*py))+(((0.2568)*cj18)));\nevalcond[3]=((((-1.0)*x825))+x823+x824);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x829=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst32*px))+(((-1.0)*gconst31*py))),-1);\nif(!x829.valid){\ncontinue;\n}\nIkReal x828=x829.value;\ncj16array[0]=((((-0.4)*x828))+(((-0.321)*cj18*x828)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x830=IKsin(j16);\nIkReal x831=IKcos(j16);\nIkReal x832=(gconst32*px);\nIkReal x833=(gconst31*py);\nIkReal x834=((0.321)*cj18);\nIkReal x835=((0.8)*x831);\nevalcond[0]=((((0.4)*x830))+((x830*x834)));\nevalcond[1]=(((x830*x832))+((x830*x833))+(((-0.1)*x830)));\nevalcond[2]=((0.1)+((x831*x834))+(((0.4)*x831))+(((-1.0)*x832))+(((-1.0)*x833)));\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((-0.08)*x831))+((x832*x835))+((x833*x835))+(((0.2)*x832))+(((0.2)*x833))+(((-1.0)*(py*py))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x836=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nIkReal x843 = x836;\nif(IKabs(x843)==0){\ncontinue;\n}\nIkReal x837=pow(x843,-0.5);\nif((x836) < -0.00001)\ncontinue;\nIkReal x838=IKabs(IKsqrt(x836));\nCheckValue<IkReal> x844=IKPowWithIntegerCheck(x838,-1);\nif(!x844.valid){\ncontinue;\n}\nIkReal x839=x844.value;\nIkReal x840=((10.0)*px*x837);\nIkReal x841=((10.0)*py*x837);\nif((((1.0)+(((-1.0)*(x839*x839))))) < -0.00001)\ncontinue;\nIkReal x842=IKsqrt(((1.0)+(((-1.0)*(x839*x839)))));\nif( (x839) < -1-IKFAST_SINCOS_THRESH || (x839) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x845 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x845.valid){\ncontinue;\n}\nIkReal gconst33=((3.14159265358979)+(IKasin(x839))+(((-1.0)*(x845.value))));\nIkReal gconst34=(((x839*x841))+(((-1.0)*x840*x842)));\nIkReal gconst35=(((x839*x840))+((x841*x842)));\nIkReal x846=px*px;\nIkReal x847=py*py;\nIkReal x848=((0.321)*sj18);\nIkReal x849=(gconst35*py);\nIkReal x850=(gconst34*px);\nCheckValue<IkReal> x851 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x851.valid){\ncontinue;\n}\nif((((((100.0)*x846))+(((100.0)*x847)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x852=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x846))+(((100.0)*x847))))),-1);\nif(!x852.valid){\ncontinue;\n}\nif( (x852.value) < -1-IKFAST_SINCOS_THRESH || (x852.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j15+(x851.value)+(((-1.0)*(IKasin(x852.value)))))))), 6.28318530717959)));\nevalcond[1]=((((-1.0)*x848))+(((-1.0)*x849))+x850);\nevalcond[2]=((0.253041)+(((0.2)*gconst35*px))+(((0.2)*gconst34*py))+(((-1.0)*x846))+(((-1.0)*x847))+(((0.2568)*cj18)));\nevalcond[3]=((((-1.0)*x850))+x849+x848);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x854=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst34*py))+(((-1.0)*gconst35*px))),-1);\nif(!x854.valid){\ncontinue;\n}\nIkReal x853=x854.value;\ncj16array[0]=((((-0.321)*cj18*x853))+(((-0.4)*x853)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x855=IKsin(j16);\nIkReal x856=IKcos(j16);\nIkReal x857=(gconst34*py);\nIkReal x858=(gconst35*px);\nIkReal x859=((0.321)*cj18);\nIkReal x860=((0.8)*x856);\nevalcond[0]=(((x855*x859))+(((0.4)*x855)));\nevalcond[1]=(((x855*x858))+((x855*x857))+(((-0.1)*x855)));\nevalcond[2]=((0.1)+(((-1.0)*x858))+(((-1.0)*x857))+((x856*x859))+(((0.4)*x856)));\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+((x858*x860))+(((-0.08)*x856))+(((-1.0)*(py*py)))+((x857*x860))+(((0.2)*x858))+(((0.2)*x857)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j16]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x862=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj18))),-1);\nif(!x862.valid){\ncontinue;\n}\nIkReal x861=x862.value;\ncj16array[0]=((((-0.1)*x861))+((cj15*px*x861))+((py*sj15*x861)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x863=IKsin(j16);\nIkReal x864=IKcos(j16);\nIkReal x865=(cj15*px);\nIkReal x866=(py*sj15);\nIkReal x867=((0.321)*cj18);\nIkReal x868=((1.0)*x864);\nIkReal x869=((0.8)*x864);\nevalcond[0]=(((x863*x867))+(((0.4)*x863)));\nevalcond[1]=(((x863*x865))+((x863*x866))+(((-0.1)*x863)));\nevalcond[2]=((0.4)+(((-1.0)*x865*x868))+(((-1.0)*x866*x868))+(((0.1)*x864))+x867);\nevalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((0.2)*x866))+(((0.2)*x865))+((x866*x869))+((x865*x869))+(((-1.0)*(py*py)))+(((-0.08)*x864)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\nCheckValue<IkReal> x871=IKPowWithIntegerCheck(((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15))),-1);\nif(!x871.valid){\ncontinue;\n}\nIkReal x870=x871.value;\ncj16array[0]=((((-0.4)*x870))+(((-0.321)*cj18*x870)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[4];\nIkReal x872=IKsin(j16);\nIkReal x873=IKcos(j16);\nIkReal x874=(py*sj15);\nIkReal x875=((0.321)*cj18);\nIkReal x876=(cj15*px);\nIkReal x877=((0.8)*x873);\nevalcond[0]=(((x872*x875))+(((0.4)*x872)));\nevalcond[1]=(((x872*x874))+((x872*x876))+(((-0.1)*x872)));\nevalcond[2]=((0.1)+(((-1.0)*x876))+(((-1.0)*x874))+((x873*x875))+(((0.4)*x873)));\nevalcond[3]=((-0.066959)+((x876*x877))+(((-1.0)*(px*px)))+(((0.2)*x876))+(((0.2)*x874))+((x874*x877))+(((-0.08)*x873))+(((-1.0)*(py*py))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j18), 6.28318530717959))))));\nevalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[2]=((0.509841)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\ncj16array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj15))+(((1.3869625520111)*cj15*px)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x878=IKcos(j16);\nIkReal x879=IKsin(j16);\nCheckValue<IkReal> x889=IKPowWithIntegerCheck(px,-1);\nif(!x889.valid){\ncontinue;\n}\nIkReal x880=x889.value;\nIkReal x881=py*py;\nIkReal x882=((1.0)*cj15);\nIkReal x883=(cj15*cj17);\nIkReal x884=((0.8)*cj15);\nIkReal x885=(px*x878);\nIkReal x886=(px*x879);\nIkReal x887=((0.1)*x879);\nIkReal x888=(x879*x880*x881);\nevalcond[0]=((0.721)*x879);\nevalcond[1]=((0.721)+(((-1.0)*x882*x885))+(((0.1)*x878))+(((-1.0)*py*sj15*x878)));\nevalcond[2]=((-0.5768)+((x878*x880*x881*x884))+(((-0.08)*x878))+((x884*x885)));\nevalcond[3]=(((x883*x886))+((x883*x888))+(((-1.0)*cj17*x887)));\nevalcond[4]=(((sj17*x887))+(((-1.0)*sj17*x882*x888))+(((-1.0)*sj17*x882*x886)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j18, 6.28318530717959)))))+(IKabs(pz)));\nevalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[2]=((-0.003759)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j16array[2], cj16array[2], sj16array[2];\nbool j16valid[2]={false};\n_nj16 = 2;\ncj16array[0]=((-1.26582278481013)+(((12.6582278481013)*cj15*px))+(((12.6582278481013)*py*sj15)));\nif( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j16valid[0] = j16valid[1] = true;\n    j16array[0] = IKacos(cj16array[0]);\n    sj16array[0] = IKsin(j16array[0]);\n    cj16array[1] = cj16array[0];\n    j16array[1] = -j16array[0];\n    sj16array[1] = -sj16array[0];\n}\nelse if( isnan(cj16array[0]) )\n{\n    // probably any value will work\n    j16valid[0] = true;\n    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;\n}\nfor(int ij16 = 0; ij16 < 2; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 2; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[5];\nIkReal x890=IKcos(j16);\nIkReal x891=IKsin(j16);\nCheckValue<IkReal> x901=IKPowWithIntegerCheck(px,-1);\nif(!x901.valid){\ncontinue;\n}\nIkReal x892=x901.value;\nIkReal x893=py*py;\nIkReal x894=((1.0)*cj15);\nIkReal x895=(cj15*cj17);\nIkReal x896=((0.8)*cj15);\nIkReal x897=(px*x890);\nIkReal x898=(px*x891);\nIkReal x899=((0.1)*x891);\nIkReal x900=(x891*x892*x893);\nevalcond[0]=((0.079)*x891);\nevalcond[1]=((0.079)+(((-1.0)*py*sj15*x890))+(((-1.0)*x894*x897))+(((0.1)*x890)));\nevalcond[2]=((-0.0632)+((x896*x897))+((x890*x892*x893*x896))+(((-0.08)*x890)));\nevalcond[3]=(((x895*x900))+((x895*x898))+(((-1.0)*cj17*x899)));\nevalcond[4]=((((-1.0)*sj17*x894*x898))+(((-1.0)*sj17*x894*x900))+((sj17*x899)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j16]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x902=cj15*cj15;\nIkReal x903=py*py;\nIkReal x904=(py*sj15);\nIkReal x905=(cj15*px);\nIkReal x906=((1000.0)*pz);\nIkReal x907=(cj17*sj18);\nIkReal x908=((1000.0)*x902);\nCheckValue<IkReal> x909=IKPowWithIntegerCheck(IKsign(((((-321.0)*x904*x907))+(((-321.0)*x905*x907))+(((321.0)*cj18*pz))+(((400.0)*pz))+(((32.1)*x907)))),-1);\nif(!x909.valid){\ncontinue;\n}\nCheckValue<IkReal> x910 = IKatan2WithCheck(IkReal(((-150.0)+(((-1.0)*x903*x908))+((x908*(px*px)))+(((-256.8)*cj18))+(((-200.0)*x904))+(((-200.0)*x905))+(((2000.0)*x904*x905))+(((-103.041)*(cj18*cj18)))+(((1000.0)*x903)))),((((-100.0)*pz))+((x905*x906))+(((-128.4)*x907))+(((-103.041)*cj18*x907))+((x904*x906))),IKFAST_ATAN2_MAGTHRESH);\nif(!x910.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x909.value)))+(x910.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[6];\nIkReal x911=IKsin(j16);\nIkReal x912=IKcos(j16);\nIkReal x913=((0.321)*sj18);\nIkReal x914=(cj15*px);\nIkReal x915=(py*sj15);\nIkReal x916=(px*sj15);\nIkReal x917=((1.0)*sj17);\nIkReal x918=(cj15*py);\nIkReal x919=((0.321)*cj18);\nIkReal x920=(pz*x912);\nIkReal x921=((1.0)*x914);\nIkReal x922=((0.321)*x912);\nIkReal x923=(sj17*x911);\nIkReal x924=(pz*x911);\nIkReal x925=((0.8)*x912);\nIkReal x926=(cj17*x911);\nevalcond[0]=(((cj17*x912*x913))+((x911*x919))+pz+(((0.4)*x911)));\nevalcond[1]=((0.1)+(((-1.0)*x921))+(((0.4)*x912))+(((-1.0)*x915))+(((-1.0)*x913*x926))+((x912*x919)));\nevalcond[2]=((0.4)+(((-1.0)*x912*x921))+(((-1.0)*x912*x915))+(((0.1)*x912))+x924+x919);\nevalcond[3]=((-0.066959)+(((0.2)*x915))+(((0.2)*x914))+((x915*x925))+(((-0.08)*x912))+(((-0.8)*x924))+(((-1.0)*pp))+((x914*x925)));\nevalcond[4]=((((0.1)*x923))+(((-1.0)*x911*x914*x917))+(((-1.0)*cj17*x918))+((cj17*x916))+(((-1.0)*x911*x915*x917))+(((-1.0)*x917*x920)));\nevalcond[5]=(((x915*x926))+((cj17*x920))+(((-0.1)*x926))+((sj17*x916))+((x914*x926))+x913+(((-1.0)*x917*x918)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x927=cj17*cj17;\nIkReal x928=cj18*cj18;\nIkReal x929=(cj15*px);\nIkReal x930=(py*sj15);\nIkReal x931=((321000.0)*cj18);\nIkReal x932=((321000.0)*cj17*sj18);\nIkReal x933=((103041.0)*x928);\nCheckValue<IkReal> x934 = IKatan2WithCheck(IkReal(((((32100.0)*cj17*sj18))+(((-1.0)*x930*x932))+(((-400000.0)*pz))+(((-1.0)*x929*x932))+(((-1.0)*pz*x931)))),((-40000.0)+((x930*x931))+(((-32100.0)*cj18))+(((-1.0)*pz*x932))+(((400000.0)*x930))+(((400000.0)*x929))+((x929*x931))),IKFAST_ATAN2_MAGTHRESH);\nif(!x934.valid){\ncontinue;\n}\nCheckValue<IkReal> x935=IKPowWithIntegerCheck(IKsign(((160000.0)+(((-1.0)*x927*x933))+(((256800.0)*cj18))+(((103041.0)*x927))+x933)),-1);\nif(!x935.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(x934.value)+(((1.5707963267949)*(x935.value))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[6];\nIkReal x936=IKsin(j16);\nIkReal x937=IKcos(j16);\nIkReal x938=((0.321)*sj18);\nIkReal x939=(cj15*px);\nIkReal x940=(py*sj15);\nIkReal x941=(px*sj15);\nIkReal x942=((1.0)*sj17);\nIkReal x943=(cj15*py);\nIkReal x944=((0.321)*cj18);\nIkReal x945=(pz*x937);\nIkReal x946=((1.0)*x939);\nIkReal x947=((0.321)*x937);\nIkReal x948=(sj17*x936);\nIkReal x949=(pz*x936);\nIkReal x950=((0.8)*x937);\nIkReal x951=(cj17*x936);\nevalcond[0]=(((x936*x944))+((cj17*x937*x938))+pz+(((0.4)*x936)));\nevalcond[1]=((0.1)+(((-1.0)*x946))+(((-1.0)*x938*x951))+((x937*x944))+(((-1.0)*x940))+(((0.4)*x937)));\nevalcond[2]=((0.4)+(((0.1)*x937))+(((-1.0)*x937*x940))+(((-1.0)*x937*x946))+x949+x944);\nevalcond[3]=((-0.066959)+(((-0.08)*x937))+((x940*x950))+(((-0.8)*x949))+(((0.2)*x939))+(((0.2)*x940))+(((-1.0)*pp))+((x939*x950)));\nevalcond[4]=(((cj17*x941))+(((-1.0)*cj17*x943))+(((-1.0)*x942*x945))+(((-1.0)*x936*x940*x942))+(((0.1)*x948))+(((-1.0)*x936*x939*x942)));\nevalcond[5]=(((cj17*x945))+((x940*x951))+(((-0.1)*x951))+(((-1.0)*x942*x943))+((sj17*x941))+((x939*x951))+x938);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x952=(cj15*px);\nIkReal x953=((1000.0)*pz);\nIkReal x954=(cj17*sj18);\nIkReal x955=((321.0)*cj18);\nIkReal x956=(py*sj15);\nCheckValue<IkReal> x957=IKPowWithIntegerCheck(IKsign(((-40.0)+(((321.0)*pz*x954))+((x955*x956))+((x952*x955))+(((400.0)*x956))+(((400.0)*x952))+(((-32.1)*cj18)))),-1);\nif(!x957.valid){\ncontinue;\n}\nCheckValue<IkReal> x958 = IKatan2WithCheck(IkReal(((((100.0)*pz))+(((-128.4)*x954))+(((-103.041)*cj18*x954))+(((-1.0)*x953*x956))+(((-1.0)*x952*x953)))),((160.0)+(((-1.0)*pz*x953))+(((256.8)*cj18))+(((103.041)*(cj18*cj18)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x958.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x957.value)))+(x958.value));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[6];\nIkReal x959=IKsin(j16);\nIkReal x960=IKcos(j16);\nIkReal x961=((0.321)*sj18);\nIkReal x962=(cj15*px);\nIkReal x963=(py*sj15);\nIkReal x964=(px*sj15);\nIkReal x965=((1.0)*sj17);\nIkReal x966=(cj15*py);\nIkReal x967=((0.321)*cj18);\nIkReal x968=(pz*x960);\nIkReal x969=((1.0)*x962);\nIkReal x970=((0.321)*x960);\nIkReal x971=(sj17*x959);\nIkReal x972=(pz*x959);\nIkReal x973=((0.8)*x960);\nIkReal x974=(cj17*x959);\nevalcond[0]=(((cj17*x960*x961))+pz+((x959*x967))+(((0.4)*x959)));\nevalcond[1]=((0.1)+(((-1.0)*x963))+((x960*x967))+(((-1.0)*x961*x974))+(((-1.0)*x969))+(((0.4)*x960)));\nevalcond[2]=((0.4)+(((-1.0)*x960*x969))+(((-1.0)*x960*x963))+(((0.1)*x960))+x972+x967);\nevalcond[3]=((-0.066959)+(((-0.8)*x972))+((x963*x973))+((x962*x973))+(((-1.0)*pp))+(((0.2)*x962))+(((0.2)*x963))+(((-0.08)*x960)));\nevalcond[4]=((((0.1)*x971))+(((-1.0)*x959*x962*x965))+(((-1.0)*x965*x968))+((cj17*x964))+(((-1.0)*cj17*x966))+(((-1.0)*x959*x963*x965)));\nevalcond[5]=((((-0.1)*x974))+((sj17*x964))+(((-1.0)*x965*x966))+((cj17*x968))+((x963*x974))+((x962*x974))+x961);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j16array[1], cj16array[1], sj16array[1];\nbool j16valid[1]={false};\n_nj16 = 1;\nIkReal x975=py*py;\nIkReal x976=cj15*cj15;\nIkReal x977=px*px;\nIkReal x978=((5.0)*pp);\nIkReal x979=(py*sj15);\nIkReal x980=(pz*sj17);\nIkReal x981=(cj17*py);\nIkReal x982=(cj15*px*sj17);\nIkReal x983=((4.0)*x975);\nIkReal x984=(cj15*cj17*sj15);\nIkReal x985=(sj17*x976);\nIkReal x986=((4.0)*x977);\nIkReal x987=((4.0)*x981);\nIkReal x988=(cj17*px*sj15);\nCheckValue<IkReal> x989 = IKatan2WithCheck(IkReal(((((-1.0)*px*x987))+((x983*x984))+(((0.4)*x988))+(((8.0)*px*x976*x981))+(((-1.0)*cj15*px*x980))+(((-1.0)*x979*x980))+(((-1.0)*x984*x986))+(((-0.4)*cj15*x981))+(((0.334795)*x980))+((x978*x980)))),((((2.0)*x979*x982))+(((-4.0)*pz*x988))+((cj15*pz*x987))+((x977*x985))+(((-1.0)*sj17*x978*x979))+(((0.5)*pp*sj17))+(((-1.0)*x978*x982))+(((-1.0)*x975*x985))+(((-0.434795)*x982))+(((0.0334795)*sj17))+((sj17*x975))+(((-0.434795)*sj17*x979))),IKFAST_ATAN2_MAGTHRESH);\nif(!x989.valid){\ncontinue;\n}\nCheckValue<IkReal> x990=IKPowWithIntegerCheck(IKsign((((x983*x985))+(((-4.0)*pz*x980))+(((0.8)*sj17*x979))+(((-8.0)*x979*x982))+(((-1.0)*x985*x986))+(((0.8)*x982))+(((-0.04)*sj17))+(((-1.0)*sj17*x983)))),-1);\nif(!x990.valid){\ncontinue;\n}\nj16array[0]=((-1.5707963267949)+(x989.value)+(((1.5707963267949)*(x990.value))));\nsj16array[0]=IKsin(j16array[0]);\ncj16array[0]=IKcos(j16array[0]);\nif( j16array[0] > IKPI )\n{\n    j16array[0]-=IK2PI;\n}\nelse if( j16array[0] < -IKPI )\n{    j16array[0]+=IK2PI;\n}\nj16valid[0] = true;\nfor(int ij16 = 0; ij16 < 1; ++ij16)\n{\nif( !j16valid[ij16] )\n{\n    continue;\n}\n_ij16[0] = ij16; _ij16[1] = -1;\nfor(int iij16 = ij16+1; iij16 < 1; ++iij16)\n{\nif( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )\n{\n    j16valid[iij16]=false; _ij16[1] = iij16; break; \n}\n}\nj16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];\n{\nIkReal evalcond[2];\nIkReal x991=IKcos(j16);\nIkReal x992=IKsin(j16);\nIkReal x993=((1.0)*py);\nIkReal x994=(cj15*px);\nIkReal x995=(py*sj15);\nIkReal x996=(sj17*x992);\nIkReal x997=((0.8)*x991);\nevalcond[0]=((-0.066959)+((x994*x997))+(((-1.0)*pp))+(((-0.08)*x991))+(((-0.8)*pz*x992))+((x995*x997))+(((0.2)*x994))+(((0.2)*x995)));\nevalcond[1]=((((-1.0)*cj15*cj17*x993))+(((-1.0)*pz*sj17*x991))+(((0.1)*x996))+((cj17*px*sj15))+(((-1.0)*sj15*x993*x996))+(((-1.0)*x994*x996)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j18eval[1];\nj18eval[0]=sj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j18eval[2];\nj18eval[0]=cj16;\nj18eval[1]=cj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j18eval[2];\nj18eval[0]=sj17;\nj18eval[1]=sj16;\nif( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x998=(py*sj15);\nIkReal x999=((0.8)*cj16);\nIkReal x1000=(cj15*px);\nIkReal x1001=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));\nevalcond[1]=x1001;\nevalcond[2]=((-0.066959)+(((0.2)*x1000))+((x1000*x999))+((x998*x999))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+(((0.2)*x998)));\nevalcond[3]=x1001;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1002=((3.11526479750779)*cj16);\nIkReal x1003=(py*sj15);\nIkReal x1004=((3.11526479750779)*sj16);\nIkReal x1005=(cj15*px);\nif( IKabs(((((-1.0)*pz*x1002))+(((0.311526479750779)*sj16))+(((-1.0)*x1004*x1005))+(((-1.0)*x1003*x1004)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-1.0)*pz*x1004))+((x1002*x1005))+((x1002*x1003))+(((-0.311526479750779)*cj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*pz*x1002))+(((0.311526479750779)*sj16))+(((-1.0)*x1004*x1005))+(((-1.0)*x1003*x1004))))+IKsqr(((-1.24610591900312)+(((-1.0)*pz*x1004))+((x1002*x1005))+((x1002*x1003))+(((-0.311526479750779)*cj16))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((-1.0)*pz*x1002))+(((0.311526479750779)*sj16))+(((-1.0)*x1004*x1005))+(((-1.0)*x1003*x1004))), ((-1.24610591900312)+(((-1.0)*pz*x1004))+((x1002*x1005))+((x1002*x1003))+(((-0.311526479750779)*cj16))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1006=IKcos(j18);\nIkReal x1007=IKsin(j18);\nIkReal x1008=(py*sj15);\nIkReal x1009=(cj15*px);\nIkReal x1010=((1.0)*cj16);\nIkReal x1011=((0.321)*x1006);\nIkReal x1012=((0.321)*x1007);\nevalcond[0]=((((0.4)*sj16))+pz+((cj16*x1012))+((sj16*x1011)));\nevalcond[1]=((0.253041)+(((0.2)*x1008))+(((0.2)*x1009))+(((-1.0)*pp))+(((0.2568)*x1006)));\nevalcond[2]=((((-0.1)*sj16))+x1012+((sj16*x1008))+((sj16*x1009))+((cj16*pz)));\nevalcond[3]=((0.4)+x1011+(((-1.0)*x1009*x1010))+(((-1.0)*x1008*x1010))+((pz*sj16))+(((0.1)*cj16)));\nevalcond[4]=((0.1)+(((-1.0)*x1009))+(((-1.0)*x1008))+(((0.4)*cj16))+((cj16*x1011))+(((-1.0)*sj16*x1012)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1013=(py*sj15);\nIkReal x1014=(cj15*py);\nIkReal x1015=((0.8)*cj16);\nIkReal x1016=(cj15*px);\nIkReal x1017=(px*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));\nevalcond[1]=(x1017+(((-1.0)*x1014)));\nevalcond[2]=((-0.066959)+((x1013*x1015))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1015*x1016))+(((0.2)*x1016))+(((0.2)*x1013)));\nevalcond[3]=(x1014+(((-1.0)*x1017)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1018=((3.11526479750779)*cj16);\nIkReal x1019=((3.11526479750779)*sj16);\nIkReal x1020=(py*sj15);\nIkReal x1021=(cj15*px);\nif( IKabs(((((-0.311526479750779)*sj16))+((x1019*x1021))+((x1019*x1020))+((pz*x1018)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-1.0)*pz*x1019))+((x1018*x1021))+((x1018*x1020))+(((-0.311526479750779)*cj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-0.311526479750779)*sj16))+((x1019*x1021))+((x1019*x1020))+((pz*x1018))))+IKsqr(((-1.24610591900312)+(((-1.0)*pz*x1019))+((x1018*x1021))+((x1018*x1020))+(((-0.311526479750779)*cj16))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((-0.311526479750779)*sj16))+((x1019*x1021))+((x1019*x1020))+((pz*x1018))), ((-1.24610591900312)+(((-1.0)*pz*x1019))+((x1018*x1021))+((x1018*x1020))+(((-0.311526479750779)*cj16))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1022=IKcos(j18);\nIkReal x1023=IKsin(j18);\nIkReal x1024=((1.0)*cj16);\nIkReal x1025=(py*sj15);\nIkReal x1026=(cj15*px);\nIkReal x1027=((0.321)*x1022);\nIkReal x1028=((1.0)*x1026);\nIkReal x1029=((0.321)*x1023);\nevalcond[0]=(((sj16*x1027))+(((0.4)*sj16))+pz+(((-1.0)*cj16*x1029)));\nevalcond[1]=((0.253041)+(((0.2568)*x1022))+(((-1.0)*pp))+(((0.2)*x1025))+(((0.2)*x1026)));\nevalcond[2]=((0.4)+x1027+((pz*sj16))+(((-1.0)*x1024*x1026))+(((-1.0)*x1024*x1025))+(((0.1)*cj16)));\nevalcond[3]=((((-1.0)*pz*x1024))+x1029+(((0.1)*sj16))+(((-1.0)*sj16*x1028))+(((-1.0)*sj16*x1025)));\nevalcond[4]=((0.1)+(((-1.0)*x1025))+((sj16*x1029))+(((-1.0)*x1028))+(((0.4)*cj16))+((cj16*x1027)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j16))), 6.28318530717959)));\nevalcond[1]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));\nevalcond[2]=((((-1.0)*cj15*cj17*py))+(((-1.0)*pz*sj17))+((cj17*px*sj15)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18eval[1];\nsj16=0;\ncj16=1.0;\nj16=0;\nj18eval[0]=cj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j18eval[1];\nsj16=0;\ncj16=1.0;\nj16=0;\nj18eval[0]=sj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1030=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));\nevalcond[1]=x1030;\nevalcond[2]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));\nevalcond[3]=x1030;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1031=IKcos(j18);\nIkReal x1032=(py*sj15);\nIkReal x1033=(cj15*px);\nevalcond[0]=(pz+(((0.321)*(IKsin(j18)))));\nevalcond[1]=((0.4)+(((0.2568)*x1031))+(((-0.8)*x1032))+(((-0.8)*x1033)));\nevalcond[2]=((0.5)+(((0.321)*x1031))+(((-1.0)*x1032))+(((-1.0)*x1033)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1034=(cj15*py);\nIkReal x1035=(px*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));\nevalcond[1]=(x1035+(((-1.0)*x1034)));\nevalcond[2]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));\nevalcond[3]=(x1034+(((-1.0)*x1035)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1036=IKcos(j18);\nIkReal x1037=(py*sj15);\nIkReal x1038=(cj15*px);\nevalcond[0]=((((-0.321)*(IKsin(j18))))+pz);\nevalcond[1]=((0.4)+(((0.2568)*x1036))+(((-0.8)*x1038))+(((-0.8)*x1037)));\nevalcond[2]=((0.5)+(((0.321)*x1036))+(((-1.0)*x1037))+(((-1.0)*x1038)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1039=((3.11526479750779)*cj15);\nIkReal x1040=((3.11526479750779)*sj15);\nif( IKabs(((((-1.0)*px*x1040))+((py*x1039)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+((px*x1039))+((py*x1040)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*px*x1040))+((py*x1039))))+IKsqr(((-1.55763239875389)+((px*x1039))+((py*x1040))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((-1.0)*px*x1040))+((py*x1039))), ((-1.55763239875389)+((px*x1039))+((py*x1040))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1041=IKcos(j18);\nIkReal x1042=(py*sj15);\nIkReal x1043=(cj15*px);\nevalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));\nevalcond[1]=((0.4)+(((0.2568)*x1041))+(((-0.8)*x1043))+(((-0.8)*x1042)));\nevalcond[2]=((0.5)+(((0.321)*x1041))+(((-1.0)*x1043))+(((-1.0)*x1042)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1044=((3.11526479750779)*cj15);\nIkReal x1045=((3.11526479750779)*sj15);\nif( IKabs((((px*x1045))+(((-1.0)*py*x1044)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+((px*x1044))+((py*x1045)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((px*x1045))+(((-1.0)*py*x1044))))+IKsqr(((-1.55763239875389)+((px*x1044))+((py*x1045))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2((((px*x1045))+(((-1.0)*py*x1044))), ((-1.55763239875389)+((px*x1044))+((py*x1045))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1046=IKcos(j18);\nIkReal x1047=(py*sj15);\nIkReal x1048=(cj15*px);\nevalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));\nevalcond[1]=((0.4)+(((0.2568)*x1046))+(((-0.8)*x1047))+(((-0.8)*x1048)));\nevalcond[2]=((0.5)+(((0.321)*x1046))+(((-1.0)*x1048))+(((-1.0)*x1047)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j18]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1049=IKPowWithIntegerCheck(sj17,-1);\nif(!x1049.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1049.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1049.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x1049.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1050=IKsin(j18);\nIkReal x1051=IKcos(j18);\nIkReal x1052=(py*sj15);\nIkReal x1053=(cj15*px);\nIkReal x1054=(px*sj15);\nIkReal x1055=((0.321)*x1050);\nIkReal x1056=((1.0)*cj15*py);\nevalcond[0]=(((cj17*x1055))+pz);\nevalcond[1]=((((-1.0)*x1056))+x1054+((sj17*x1055)));\nevalcond[2]=((0.4)+(((-0.8)*x1052))+(((-0.8)*x1053))+(((0.2568)*x1051)));\nevalcond[3]=((0.5)+(((0.321)*x1051))+(((-1.0)*x1052))+(((-1.0)*x1053)));\nevalcond[4]=(x1055+(((-1.0)*sj17*x1056))+((cj17*pz))+((sj17*x1054)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1057=IKPowWithIntegerCheck(cj17,-1);\nif(!x1057.valid){\ncontinue;\n}\nif( IKabs(((-3.11526479750779)*pz*(x1057.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz*(x1057.value)))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((-3.11526479750779)*pz*(x1057.value)), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1058=IKsin(j18);\nIkReal x1059=IKcos(j18);\nIkReal x1060=(py*sj15);\nIkReal x1061=(cj15*px);\nIkReal x1062=(px*sj15);\nIkReal x1063=((0.321)*x1058);\nIkReal x1064=((1.0)*cj15*py);\nevalcond[0]=(((cj17*x1063))+pz);\nevalcond[1]=(x1062+(((-1.0)*x1064))+((sj17*x1063)));\nevalcond[2]=((0.4)+(((0.2568)*x1059))+(((-0.8)*x1061))+(((-0.8)*x1060)));\nevalcond[3]=((0.5)+(((0.321)*x1059))+(((-1.0)*x1060))+(((-1.0)*x1061)));\nevalcond[4]=(x1063+(((-1.0)*sj17*x1064))+((cj17*pz))+((sj17*x1062)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j16)))), 6.28318530717959)));\nevalcond[1]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));\nevalcond[2]=((((-1.0)*cj15*cj17*py))+((pz*sj17))+((cj17*px*sj15)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18eval[1];\nsj16=0;\ncj16=-1.0;\nj16=3.14159265358979;\nj18eval[0]=cj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j18eval[1];\nsj16=0;\ncj16=-1.0;\nj16=3.14159265358979;\nj18eval[0]=sj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1065=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));\nevalcond[1]=x1065;\nevalcond[2]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));\nevalcond[3]=x1065;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1066=IKcos(j18);\nIkReal x1067=(py*sj15);\nIkReal x1068=(cj15*px);\nevalcond[0]=((((-0.321)*(IKsin(j18))))+pz);\nevalcond[1]=((0.3)+x1068+x1067+(((0.321)*x1066)));\nevalcond[2]=((0.24)+(((0.8)*x1067))+(((0.8)*x1068))+(((0.2568)*x1066)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1069=(cj15*py);\nIkReal x1070=(px*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));\nevalcond[1]=(x1070+(((-1.0)*x1069)));\nevalcond[2]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));\nevalcond[3]=(x1069+(((-1.0)*x1070)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((-3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1071=IKcos(j18);\nIkReal x1072=(py*sj15);\nIkReal x1073=(cj15*px);\nevalcond[0]=(pz+(((0.321)*(IKsin(j18)))));\nevalcond[1]=((0.3)+x1072+x1073+(((0.321)*x1071)));\nevalcond[2]=((0.24)+(((0.8)*x1073))+(((0.8)*x1072))+(((0.2568)*x1071)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1074=((3.11526479750779)*cj15);\nIkReal x1075=((3.11526479750779)*sj15);\nif( IKabs(((((-1.0)*px*x1075))+((py*x1074)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-1.0)*px*x1074))+(((-1.0)*py*x1075)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*px*x1075))+((py*x1074))))+IKsqr(((-0.934579439252336)+(((-1.0)*px*x1074))+(((-1.0)*py*x1075))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((-1.0)*px*x1075))+((py*x1074))), ((-0.934579439252336)+(((-1.0)*px*x1074))+(((-1.0)*py*x1075))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1076=IKcos(j18);\nIkReal x1077=(py*sj15);\nIkReal x1078=(cj15*px);\nevalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));\nevalcond[1]=((0.3)+x1078+x1077+(((0.321)*x1076)));\nevalcond[2]=((0.24)+(((0.8)*x1078))+(((0.8)*x1077))+(((0.2568)*x1076)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1079=((3.11526479750779)*cj15);\nIkReal x1080=((3.11526479750779)*sj15);\nif( IKabs((((px*x1080))+(((-1.0)*py*x1079)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-1.0)*py*x1080))+(((-1.0)*px*x1079)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((px*x1080))+(((-1.0)*py*x1079))))+IKsqr(((-0.934579439252336)+(((-1.0)*py*x1080))+(((-1.0)*px*x1079))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2((((px*x1080))+(((-1.0)*py*x1079))), ((-0.934579439252336)+(((-1.0)*py*x1080))+(((-1.0)*px*x1079))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1081=IKcos(j18);\nIkReal x1082=(py*sj15);\nIkReal x1083=(cj15*px);\nevalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));\nevalcond[1]=((0.3)+x1083+x1082+(((0.321)*x1081)));\nevalcond[2]=((0.24)+(((0.8)*x1082))+(((0.8)*x1083))+(((0.2568)*x1081)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j18]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1084=IKPowWithIntegerCheck(sj17,-1);\nif(!x1084.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1084.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1084.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x1084.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1085=IKsin(j18);\nIkReal x1086=IKcos(j18);\nIkReal x1087=(py*sj15);\nIkReal x1088=(cj15*px);\nIkReal x1089=(px*sj15);\nIkReal x1090=((0.321)*x1085);\nIkReal x1091=((1.0)*cj15*py);\nevalcond[0]=(pz+(((-1.0)*cj17*x1090)));\nevalcond[1]=((0.3)+x1087+x1088+(((0.321)*x1086)));\nevalcond[2]=(x1089+(((-1.0)*x1091))+((sj17*x1090)));\nevalcond[3]=((0.24)+(((0.8)*x1087))+(((0.8)*x1088))+(((0.2568)*x1086)));\nevalcond[4]=(((sj17*x1089))+x1090+(((-1.0)*sj17*x1091))+(((-1.0)*cj17*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1092=IKPowWithIntegerCheck(cj17,-1);\nif(!x1092.valid){\ncontinue;\n}\nif( IKabs(((3.11526479750779)*pz*(x1092.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz*(x1092.value)))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((3.11526479750779)*pz*(x1092.value)), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1093=IKsin(j18);\nIkReal x1094=IKcos(j18);\nIkReal x1095=(py*sj15);\nIkReal x1096=(cj15*px);\nIkReal x1097=(px*sj15);\nIkReal x1098=((0.321)*x1093);\nIkReal x1099=((1.0)*cj15*py);\nevalcond[0]=(pz+(((-1.0)*cj17*x1098)));\nevalcond[1]=((0.3)+x1095+x1096+(((0.321)*x1094)));\nevalcond[2]=(x1097+(((-1.0)*x1099))+((sj17*x1098)));\nevalcond[3]=((0.24)+(((0.2568)*x1094))+(((0.8)*x1095))+(((0.8)*x1096)));\nevalcond[4]=(x1098+((sj17*x1097))+(((-1.0)*sj17*x1099))+(((-1.0)*cj17*pz)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1100=((1.0)*py);\nIkReal x1101=(cj15*px);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+(((-0.8)*pz))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2)*x1101)));\nevalcond[2]=((((-1.0)*cj15*cj17*x1100))+((cj17*px*sj15))+(((-1.0)*sj17*x1101))+(((0.1)*sj17))+(((-1.0)*sj15*sj17*x1100)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1102=((3.11526479750779)*cj15);\nIkReal x1103=((3.11526479750779)*sj15);\nif( IKabs(((((-1.0)*cj17*py*x1103))+((py*sj17*x1102))+(((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x1103))+(((-1.0)*cj17*px*x1102)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj17*py*x1103))+((py*sj17*x1102))+(((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x1103))+(((-1.0)*cj17*px*x1102))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((-1.0)*cj17*py*x1103))+((py*sj17*x1102))+(((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x1103))+(((-1.0)*cj17*px*x1102))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1104=IKsin(j18);\nIkReal x1105=IKcos(j18);\nIkReal x1106=(py*sj15);\nIkReal x1107=(px*sj15);\nIkReal x1108=(cj15*px);\nIkReal x1109=((0.321)*x1104);\nIkReal x1110=((1.0)*cj15*py);\nevalcond[0]=((0.4)+(((0.321)*x1105))+pz);\nevalcond[1]=(x1107+((sj17*x1109))+(((-1.0)*x1110)));\nevalcond[2]=((0.1)+(((-1.0)*cj17*x1109))+(((-1.0)*x1108))+(((-1.0)*x1106)));\nevalcond[3]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1106))+(((0.2)*x1108))+(((0.2568)*x1105)));\nevalcond[4]=(x1109+(((-1.0)*sj17*x1110))+(((-0.1)*cj17))+((sj17*x1107))+((cj17*x1106))+((cj17*x1108)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1111=(cj15*px);\nIkReal x1112=(py*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j16)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1111))+(((0.2)*x1112)));\nevalcond[2]=((((-1.0)*cj15*cj17*py))+(((-0.1)*sj17))+((cj17*px*sj15))+((sj17*x1112))+((sj17*x1111)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18eval[1];\nsj16=-1.0;\ncj16=0;\nj16=-1.5707963267949;\nj18eval[0]=sj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j18eval[1];\nsj16=-1.0;\ncj16=0;\nj16=-1.5707963267949;\nj18eval[0]=cj17;\nif( IKabs(j18eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1113=(cj15*px);\nIkReal x1114=(py*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=((0.1)+(((-1.0)*x1113))+(((-1.0)*x1114)));\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1114))+(((0.2)*x1113)));\nevalcond[3]=((-0.1)+x1113+x1114);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1115=IKcos(j18);\nevalcond[0]=((-0.4)+(((-0.321)*x1115))+pz);\nevalcond[1]=((0.273041)+(((-1.0)*pp))+(((0.2568)*x1115)));\nevalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1116=(py*sj15);\nIkReal x1117=(cj15*px);\nIkReal x1118=((0.1)+(((-1.0)*x1117))+(((-1.0)*x1116)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=x1118;\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1116))+(((0.2)*x1117)));\nevalcond[3]=x1118;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1119=IKcos(j18);\nevalcond[0]=((-0.4)+(((-0.321)*x1119))+pz);\nevalcond[1]=((0.273041)+(((-1.0)*pp))+(((0.2568)*x1119)));\nevalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1120=(((px*sj15))+(((-1.0)*cj15*py)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));\nevalcond[1]=x1120;\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));\nevalcond[3]=x1120;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1121=IKcos(j18);\nIkReal x1122=(cj15*px);\nIkReal x1123=(py*sj15);\nevalcond[0]=((-0.4)+(((-0.321)*x1121))+pz);\nevalcond[1]=((0.1)+(((-1.0)*x1122))+(((-1.0)*x1123))+(((0.321)*(IKsin(j18)))));\nevalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1123))+(((0.2)*x1122))+(((0.2568)*x1121)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1124=(cj15*py);\nIkReal x1125=(px*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));\nevalcond[1]=(x1125+(((-1.0)*x1124)));\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));\nevalcond[3]=(x1124+(((-1.0)*x1125)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[3];\nIkReal x1126=IKcos(j18);\nIkReal x1127=(cj15*px);\nIkReal x1128=(py*sj15);\nevalcond[0]=((-0.4)+(((-0.321)*x1126))+pz);\nevalcond[1]=((0.1)+(((-0.321)*(IKsin(j18))))+(((-1.0)*x1128))+(((-1.0)*x1127)));\nevalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1127))+(((0.2)*x1128))+(((0.2568)*x1126)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j18]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1129=IKPowWithIntegerCheck(cj17,-1);\nif(!x1129.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1129.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1129.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x1129.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1130=IKsin(j18);\nIkReal x1131=IKcos(j18);\nIkReal x1132=(py*sj15);\nIkReal x1133=((1.0)*cj15);\nIkReal x1134=(px*sj15);\nIkReal x1135=((0.321)*x1130);\nevalcond[0]=((-0.4)+(((-0.321)*x1131))+pz);\nevalcond[1]=(x1134+(((-1.0)*py*x1133))+((sj17*x1135)));\nevalcond[2]=((0.1)+((cj17*x1135))+(((-1.0)*x1132))+(((-1.0)*px*x1133)));\nevalcond[3]=((0.253041)+(((0.2)*cj15*px))+(((-1.0)*pp))+(((0.2)*x1132))+(((0.2568)*x1131)));\nevalcond[4]=(x1135+(((-1.0)*cj17*px*x1133))+((sj17*x1134))+(((-1.0)*py*sj17*x1133))+(((-1.0)*cj17*x1132))+(((0.1)*cj17)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1136=IKPowWithIntegerCheck(sj17,-1);\nif(!x1136.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1136.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1136.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x1136.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1137=IKsin(j18);\nIkReal x1138=IKcos(j18);\nIkReal x1139=(py*sj15);\nIkReal x1140=((1.0)*cj15);\nIkReal x1141=(px*sj15);\nIkReal x1142=((0.321)*x1137);\nevalcond[0]=((-0.4)+(((-0.321)*x1138))+pz);\nevalcond[1]=(x1141+((sj17*x1142))+(((-1.0)*py*x1140)));\nevalcond[2]=((0.1)+(((-1.0)*px*x1140))+(((-1.0)*x1139))+((cj17*x1142)));\nevalcond[3]=((0.253041)+(((0.2)*cj15*px))+(((-1.0)*pp))+(((0.2)*x1139))+(((0.2568)*x1138)));\nevalcond[4]=(x1142+((sj17*x1141))+(((-1.0)*cj17*px*x1140))+(((-1.0)*cj17*x1139))+(((0.1)*cj17))+(((-1.0)*py*sj17*x1140)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1143=((1.0)*sj16);\nIkReal x1144=(cj15*px);\nIkReal x1145=(py*sj15);\nIkReal x1146=((0.8)*cj16);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+((x1145*x1146))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1144*x1146))+(((0.2)*x1144))+(((0.2)*x1145)));\nevalcond[2]=((((-1.0)*x1143*x1144))+(((-1.0)*x1143*x1145))+(((-1.0)*cj16*pz))+(((0.1)*sj16)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1147=IKcos(j18);\nIkReal x1148=(py*sj15);\nIkReal x1149=((1.0)*cj16);\nIkReal x1150=((1.0)*cj15);\nIkReal x1151=(cj15*px);\nIkReal x1152=((0.321)*x1147);\nevalcond[0]=((((0.4)*sj16))+pz+((sj16*x1152)));\nevalcond[1]=(((px*sj15))+(((-1.0)*py*x1150))+(((0.321)*(IKsin(j18)))));\nevalcond[2]=((0.253041)+(((0.2)*x1151))+(((-1.0)*pp))+(((0.2)*x1148))+(((0.2568)*x1147)));\nevalcond[3]=((0.1)+(((-1.0)*px*x1150))+(((-1.0)*x1148))+(((0.4)*cj16))+((cj16*x1152)));\nevalcond[4]=((0.4)+x1152+(((-1.0)*x1149*x1151))+((pz*sj16))+(((-1.0)*x1148*x1149))+(((0.1)*cj16)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1153=(cj15*px);\nIkReal x1154=((0.8)*cj16);\nIkReal x1155=(py*sj15);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+(((0.2)*x1155))+(((0.2)*x1153))+((x1153*x1154))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1154*x1155)));\nevalcond[2]=((((-0.1)*sj16))+((cj16*pz))+((sj16*x1155))+((sj16*x1153)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nif( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[5];\nIkReal x1156=IKcos(j18);\nIkReal x1157=(py*sj15);\nIkReal x1158=((1.0)*cj16);\nIkReal x1159=((1.0)*cj15);\nIkReal x1160=(cj15*px);\nIkReal x1161=((0.321)*x1156);\nevalcond[0]=(((sj16*x1161))+(((0.4)*sj16))+pz);\nevalcond[1]=(((px*sj15))+(((-0.321)*(IKsin(j18))))+(((-1.0)*py*x1159)));\nevalcond[2]=((0.253041)+(((0.2)*x1157))+(((0.2568)*x1156))+(((-1.0)*pp))+(((0.2)*x1160)));\nevalcond[3]=((0.1)+(((-1.0)*px*x1159))+((cj16*x1161))+(((-1.0)*x1157))+(((0.4)*cj16)));\nevalcond[4]=((0.4)+x1161+(((-1.0)*x1157*x1158))+(((-1.0)*x1158*x1160))+((pz*sj16))+(((0.1)*cj16)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j18]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1167=IKPowWithIntegerCheck(sj17,-1);\nif(!x1167.valid){\ncontinue;\n}\nIkReal x1162=x1167.value;\nIkReal x1163=((0.00311526479750779)*x1162);\nIkReal x1164=(px*sj15);\nIkReal x1165=(cj15*py);\nIkReal x1166=((1000.0)*cj16*cj17);\nCheckValue<IkReal> x1168=IKPowWithIntegerCheck(sj16,-1);\nif(!x1168.valid){\ncontinue;\n}\nif( IKabs((x1163*(((((-1000.0)*x1164))+(((1000.0)*x1165)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1163*(x1168.value)*(((((-1000.0)*pz*sj17))+((x1164*x1166))+(((-400.0)*sj16*sj17))+(((-1.0)*x1165*x1166)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1163*(((((-1000.0)*x1164))+(((1000.0)*x1165))))))+IKsqr((x1163*(x1168.value)*(((((-1000.0)*pz*sj17))+((x1164*x1166))+(((-400.0)*sj16*sj17))+(((-1.0)*x1165*x1166))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2((x1163*(((((-1000.0)*x1164))+(((1000.0)*x1165))))), (x1163*(x1168.value)*(((((-1000.0)*pz*sj17))+((x1164*x1166))+(((-400.0)*sj16*sj17))+(((-1.0)*x1165*x1166))))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[6];\nIkReal x1169=IKcos(j18);\nIkReal x1170=IKsin(j18);\nIkReal x1171=(cj17*sj16);\nIkReal x1172=(cj16*cj17);\nIkReal x1173=(cj15*px);\nIkReal x1174=((1.0)*cj16);\nIkReal x1175=(py*sj15);\nIkReal x1176=(px*sj15);\nIkReal x1177=((0.321)*x1170);\nIkReal x1178=((0.321)*x1169);\nIkReal x1179=((1.0)*cj15*py);\nevalcond[0]=(x1176+((sj17*x1177))+(((-1.0)*x1179)));\nevalcond[1]=((0.253041)+(((0.2568)*x1169))+(((0.2)*x1175))+(((0.2)*x1173))+(((-1.0)*pp)));\nevalcond[2]=(((sj16*x1178))+(((0.4)*sj16))+((x1172*x1177))+pz);\nevalcond[3]=((0.4)+x1178+(((-1.0)*x1173*x1174))+((pz*sj16))+(((-1.0)*x1174*x1175))+(((0.1)*cj16)));\nevalcond[4]=((0.1)+((cj16*x1178))+(((-1.0)*x1171*x1177))+(((0.4)*cj16))+(((-1.0)*x1175))+(((-1.0)*x1173)));\nevalcond[5]=(x1177+((sj17*x1176))+(((-1.0)*sj17*x1179))+((pz*x1172))+(((-0.1)*x1171))+((x1171*x1175))+((x1171*x1173)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nIkReal x1180=((250.0)*sj16);\nIkReal x1181=(py*sj15);\nIkReal x1182=(cj15*px);\nCheckValue<IkReal> x1183=IKPowWithIntegerCheck(cj16,-1);\nif(!x1183.valid){\ncontinue;\n}\nCheckValue<IkReal> x1184=IKPowWithIntegerCheck(cj17,-1);\nif(!x1184.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1183.value)*(x1184.value)*(((((-1000.0)*pz))+((x1180*x1182))+((x1180*x1181))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1182))+(((-0.778816199376947)*x1181)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1183.value)*(x1184.value)*(((((-1000.0)*pz))+((x1180*x1182))+((x1180*x1181))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1182))+(((-0.778816199376947)*x1181))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x1183.value)*(x1184.value)*(((((-1000.0)*pz))+((x1180*x1182))+((x1180*x1181))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1182))+(((-0.778816199376947)*x1181))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[6];\nIkReal x1185=IKcos(j18);\nIkReal x1186=IKsin(j18);\nIkReal x1187=(cj17*sj16);\nIkReal x1188=(cj16*cj17);\nIkReal x1189=(cj15*px);\nIkReal x1190=((1.0)*cj16);\nIkReal x1191=(py*sj15);\nIkReal x1192=(px*sj15);\nIkReal x1193=((0.321)*x1186);\nIkReal x1194=((0.321)*x1185);\nIkReal x1195=((1.0)*cj15*py);\nevalcond[0]=(x1192+(((-1.0)*x1195))+((sj17*x1193)));\nevalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1191))+(((0.2)*x1189))+(((0.2568)*x1185)));\nevalcond[2]=(((x1188*x1193))+(((0.4)*sj16))+((sj16*x1194))+pz);\nevalcond[3]=((0.4)+x1194+(((-1.0)*x1189*x1190))+(((-1.0)*x1190*x1191))+((pz*sj16))+(((0.1)*cj16)));\nevalcond[4]=((0.1)+(((-1.0)*x1187*x1193))+((cj16*x1194))+(((0.4)*cj16))+(((-1.0)*x1189))+(((-1.0)*x1191)));\nevalcond[5]=(((x1187*x1189))+x1193+((x1187*x1191))+((pz*x1188))+(((-0.1)*x1187))+(((-1.0)*sj17*x1195))+((sj17*x1192)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j18array[1], cj18array[1], sj18array[1];\nbool j18valid[1]={false};\n_nj18 = 1;\nCheckValue<IkReal> x1196=IKPowWithIntegerCheck(sj17,-1);\nif(!x1196.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1196.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1196.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj18array[0]=IKatan2(((0.00311526479750779)*(x1196.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));\nsj18array[0]=IKsin(j18array[0]);\ncj18array[0]=IKcos(j18array[0]);\nif( j18array[0] > IKPI )\n{\n    j18array[0]-=IK2PI;\n}\nelse if( j18array[0] < -IKPI )\n{    j18array[0]+=IK2PI;\n}\nj18valid[0] = true;\nfor(int ij18 = 0; ij18 < 1; ++ij18)\n{\nif( !j18valid[ij18] )\n{\n    continue;\n}\n_ij18[0] = ij18; _ij18[1] = -1;\nfor(int iij18 = ij18+1; iij18 < 1; ++iij18)\n{\nif( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )\n{\n    j18valid[iij18]=false; _ij18[1] = iij18; break; \n}\n}\nj18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];\n{\nIkReal evalcond[6];\nIkReal x1197=IKcos(j18);\nIkReal x1198=IKsin(j18);\nIkReal x1199=(cj17*sj16);\nIkReal x1200=(cj16*cj17);\nIkReal x1201=(cj15*px);\nIkReal x1202=((1.0)*cj16);\nIkReal x1203=(py*sj15);\nIkReal x1204=(px*sj15);\nIkReal x1205=((0.321)*x1198);\nIkReal x1206=((0.321)*x1197);\nIkReal x1207=((1.0)*cj15*py);\nevalcond[0]=(x1204+((sj17*x1205))+(((-1.0)*x1207)));\nevalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2568)*x1197))+(((0.2)*x1201))+(((0.2)*x1203)));\nevalcond[2]=(((sj16*x1206))+(((0.4)*sj16))+((x1200*x1205))+pz);\nevalcond[3]=((0.4)+x1206+((pz*sj16))+(((-1.0)*x1202*x1203))+(((-1.0)*x1201*x1202))+(((0.1)*cj16)));\nevalcond[4]=((0.1)+(((-1.0)*x1199*x1205))+(((0.4)*cj16))+(((-1.0)*x1203))+(((-1.0)*x1201))+((cj16*x1206)));\nevalcond[5]=(x1205+((sj17*x1204))+(((-0.1)*x1199))+((x1199*x1201))+((x1199*x1203))+(((-1.0)*sj17*x1207))+((pz*x1200)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n    }\n}\nreturn solutions.GetNumSolutions()>0;\n}\ninline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {\nfor(int rotationiter = 0; rotationiter < 1; ++rotationiter) {\nIkReal x194=((1.0)*cj17);\nIkReal x195=(cj18*sj16);\nIkReal x196=(cj16*sj17);\nIkReal x197=(sj16*sj18);\nIkReal x198=(sj16*sj17);\nIkReal x199=(cj16*cj18);\nIkReal x200=(sj17*sj18);\nIkReal x201=(cj16*sj18);\nIkReal x202=(cj18*sj15*sj17);\nIkReal x203=((((-1.0)*x194*x199))+x197);\nIkReal x204=(((sj15*x198))+((cj15*cj17)));\nIkReal x205=(((cj15*x198))+(((-1.0)*sj15*x194)));\nIkReal x206=((((-1.0)*x194*x197))+x199);\nIkReal x207=(cj15*x206);\nIkReal x208=((((-1.0)*x194*x195))+(((-1.0)*x201)));\nIkReal x209=((((-1.0)*x194*x201))+(((-1.0)*x195)));\nIkReal x210=(cj15*x208);\nIkReal x211=(((cj15*x200))+((sj15*x206)));\nIkReal x212=((((-1.0)*sj15*x200))+x207);\nIkReal x213=(((cj15*cj18*sj17))+((sj15*x208)));\nIkReal x214=(x210+(((-1.0)*x202)));\nnew_r00=(((r20*x203))+((r00*x214))+((r10*x213)));\nnew_r01=(((r11*x213))+((r21*x203))+((r01*x214)));\nnew_r02=(((r02*((x210+(((-1.0)*x202))))))+((r22*x203))+((r12*x213)));\nnew_r10=(((r20*x196))+((r00*x205))+((r10*x204)));\nnew_r11=(((r11*x204))+((r01*x205))+((r21*x196)));\nnew_r12=(((r22*x196))+((r12*x204))+((r02*x205)));\nnew_r20=(((r00*(((((-1.0)*sj15*x200))+x207))))+((r20*x209))+((r10*x211)));\nnew_r21=(((r11*x211))+((r21*x209))+((r01*x212)));\nnew_r22=(((r22*x209))+((r12*x211))+((r02*x212)));\n{\nIkReal j20array[2], cj20array[2], sj20array[2];\nbool j20valid[2]={false};\n_nj20 = 2;\ncj20array[0]=new_r22;\nif( cj20array[0] >= -1-IKFAST_SINCOS_THRESH && cj20array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j20valid[0] = j20valid[1] = true;\n    j20array[0] = IKacos(cj20array[0]);\n    sj20array[0] = IKsin(j20array[0]);\n    cj20array[1] = cj20array[0];\n    j20array[1] = -j20array[0];\n    sj20array[1] = -sj20array[0];\n}\nelse if( isnan(cj20array[0]) )\n{\n    // probably any value will work\n    j20valid[0] = true;\n    cj20array[0] = 1; sj20array[0] = 0; j20array[0] = 0;\n}\nfor(int ij20 = 0; ij20 < 2; ++ij20)\n{\nif( !j20valid[ij20] )\n{\n    continue;\n}\n_ij20[0] = ij20; _ij20[1] = -1;\nfor(int iij20 = ij20+1; iij20 < 2; ++iij20)\n{\nif( j20valid[iij20] && IKabs(cj20array[ij20]-cj20array[iij20]) < IKFAST_SOLUTION_THRESH && IKabs(sj20array[ij20]-sj20array[iij20]) < IKFAST_SOLUTION_THRESH )\n{\n    j20valid[iij20]=false; _ij20[1] = iij20; break; \n}\n}\nj20 = j20array[ij20]; cj20 = cj20array[ij20]; sj20 = sj20array[ij20];\n\n{\nIkReal j19eval[2];\nIkReal x215=((1.0)*cj17);\nIkReal x216=(cj18*sj16);\nIkReal x217=(cj16*sj17);\nIkReal x218=(sj16*sj18);\nIkReal x219=(sj16*sj17);\nIkReal x220=(cj16*cj18);\nIkReal x221=(sj17*sj18);\nIkReal x222=(cj16*sj18);\nIkReal x223=(cj18*sj15*sj17);\nIkReal x224=((((-1.0)*x215*x220))+x218);\nIkReal x225=x204;\nIkReal x226=x205;\nIkReal x227=(x220+(((-1.0)*x215*x218)));\nIkReal x228=(cj15*x227);\nIkReal x229=x208;\nIkReal x230=x209;\nIkReal x231=(cj15*x229);\nIkReal x232=(((cj15*x221))+((sj15*x227)));\nIkReal x233=(x228+(((-1.0)*sj15*x221)));\nIkReal x234=(((cj15*cj18*sj17))+((sj15*x229)));\nIkReal x235=(x231+(((-1.0)*x223)));\nnew_r00=(((r20*x224))+((r10*x234))+((r00*x235)));\nnew_r01=(((r11*x234))+((r01*x235))+((r21*x224)));\nnew_r02=(((r02*((x231+(((-1.0)*x223))))))+((r22*x224))+((r12*x234)));\nnew_r10=(((r00*x226))+((r10*x225))+((r20*x217)));\nnew_r11=(((r21*x217))+((r01*x226))+((r11*x225)));\nnew_r12=(((r12*x225))+((r22*x217))+((r02*x226)));\nnew_r20=(((r10*x232))+((r00*((x228+(((-1.0)*sj15*x221))))))+((r20*x230)));\nnew_r21=(((r11*x232))+((r01*x233))+((r21*x230)));\nnew_r22=(((r02*x233))+((r12*x232))+((r22*x230)));\nj19eval[0]=sj20;\nj19eval[1]=IKsign(sj20);\nif( IKabs(j19eval[0]) < 0.0000010000000000  || IKabs(j19eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j19eval[1];\nIkReal x236=((1.0)*cj17);\nIkReal x237=(cj18*sj16);\nIkReal x238=(cj16*sj17);\nIkReal x239=(sj16*sj18);\nIkReal x240=(sj16*sj17);\nIkReal x241=(cj16*cj18);\nIkReal x242=(sj17*sj18);\nIkReal x243=(cj16*sj18);\nIkReal x244=(cj18*sj15*sj17);\nIkReal x245=((((-1.0)*x236*x241))+x239);\nIkReal x246=x204;\nIkReal x247=x205;\nIkReal x248=(x241+(((-1.0)*x236*x239)));\nIkReal x249=(cj15*x248);\nIkReal x250=x208;\nIkReal x251=x209;\nIkReal x252=(cj15*x250);\nIkReal x253=(((sj15*x248))+((cj15*x242)));\nIkReal x254=(x249+(((-1.0)*sj15*x242)));\nIkReal x255=(((cj15*cj18*sj17))+((sj15*x250)));\nIkReal x256=((((-1.0)*x244))+x252);\nnew_r00=(((r00*x256))+((r10*x255))+((r20*x245)));\nnew_r01=(((r11*x255))+((r01*x256))+((r21*x245)));\nnew_r02=(((r22*x245))+((r12*x255))+((r02*(((((-1.0)*x244))+x252)))));\nnew_r10=(((r20*x238))+((r00*x247))+((r10*x246)));\nnew_r11=(((r01*x247))+((r11*x246))+((r21*x238)));\nnew_r12=(((r02*x247))+((r12*x246))+((r22*x238)));\nnew_r20=(((r20*x251))+((r10*x253))+((r00*((x249+(((-1.0)*sj15*x242)))))));\nnew_r21=(((r21*x251))+((r11*x253))+((r01*x254)));\nnew_r22=(((r12*x253))+((r22*x251))+((r02*x254)));\nj19eval[0]=sj20;\nif( IKabs(j19eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j19array[2], cj19array[2], sj19array[2];\nbool j19valid[2]={false};\n_nj19 = 2;\nCheckValue<IkReal> x258 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x258.valid){\ncontinue;\n}\nIkReal x257=x258.value;\nj19array[0]=((-1.0)*x257);\nsj19array[0]=IKsin(j19array[0]);\ncj19array[0]=IKcos(j19array[0]);\nj19array[1]=((3.14159265358979)+(((-1.0)*x257)));\nsj19array[1]=IKsin(j19array[1]);\ncj19array[1]=IKcos(j19array[1]);\nif( j19array[0] > IKPI )\n{\n    j19array[0]-=IK2PI;\n}\nelse if( j19array[0] < -IKPI )\n{    j19array[0]+=IK2PI;\n}\nj19valid[0] = true;\nif( j19array[1] > IKPI )\n{\n    j19array[1]-=IK2PI;\n}\nelse if( j19array[1] < -IKPI )\n{    j19array[1]+=IK2PI;\n}\nj19valid[1] = true;\nfor(int ij19 = 0; ij19 < 2; ++ij19)\n{\nif( !j19valid[ij19] )\n{\n    continue;\n}\n_ij19[0] = ij19; _ij19[1] = -1;\nfor(int iij19 = ij19+1; iij19 < 2; ++iij19)\n{\nif( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )\n{\n    j19valid[iij19]=false; _ij19[1] = iij19; break; \n}\n}\nj19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*new_r02*(IKsin(j19))))+((new_r12*(IKcos(j19)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nIkReal x259=((1.0)*sj19);\nif( IKabs(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x259)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x259))+((cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x259))))+IKsqr(((((-1.0)*new_r01*x259))+((cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x259))), ((((-1.0)*new_r01*x259))+((cj19*new_r00))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x260=IKsin(j21);\nIkReal x261=IKcos(j21);\nIkReal x262=((1.0)*sj19);\nIkReal x263=((1.0)*x261);\nIkReal x264=(sj19*x260);\nIkReal x265=((1.0)*x260);\nIkReal x266=(cj19*x263);\nevalcond[0]=(x260+((cj19*new_r01))+((new_r11*sj19)));\nevalcond[1]=(((cj19*x260))+((sj19*x261))+new_r01);\nevalcond[2]=((((-1.0)*x263))+((new_r10*sj19))+((cj19*new_r00)));\nevalcond[3]=((((-1.0)*new_r00*x262))+((cj19*new_r10))+(((-1.0)*x265)));\nevalcond[4]=((((-1.0)*new_r01*x262))+((cj19*new_r11))+(((-1.0)*x263)));\nevalcond[5]=(x264+new_r00+(((-1.0)*x266)));\nevalcond[6]=(x264+new_r11+(((-1.0)*x266)));\nevalcond[7]=((((-1.0)*x261*x262))+new_r10+(((-1.0)*cj19*x265)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j19array[2], cj19array[2], sj19array[2];\nbool j19valid[2]={false};\n_nj19 = 2;\nCheckValue<IkReal> x268 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x268.valid){\ncontinue;\n}\nIkReal x267=x268.value;\nj19array[0]=((-1.0)*x267);\nsj19array[0]=IKsin(j19array[0]);\ncj19array[0]=IKcos(j19array[0]);\nj19array[1]=((3.14159265358979)+(((-1.0)*x267)));\nsj19array[1]=IKsin(j19array[1]);\ncj19array[1]=IKcos(j19array[1]);\nif( j19array[0] > IKPI )\n{\n    j19array[0]-=IK2PI;\n}\nelse if( j19array[0] < -IKPI )\n{    j19array[0]+=IK2PI;\n}\nj19valid[0] = true;\nif( j19array[1] > IKPI )\n{\n    j19array[1]-=IK2PI;\n}\nelse if( j19array[1] < -IKPI )\n{    j19array[1]+=IK2PI;\n}\nj19valid[1] = true;\nfor(int ij19 = 0; ij19 < 2; ++ij19)\n{\nif( !j19valid[ij19] )\n{\n    continue;\n}\n_ij19[0] = ij19; _ij19[1] = -1;\nfor(int iij19 = ij19+1; iij19 < 2; ++iij19)\n{\nif( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )\n{\n    j19valid[iij19]=false; _ij19[1] = iij19; break; \n}\n}\nj19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*new_r02*(IKsin(j19))))+((new_r12*(IKcos(j19)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nIkReal x269=((1.0)*sj19);\nif( IKabs(((((-1.0)*new_r00*x269))+((cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x269))+(((-1.0)*cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x269))+((cj19*new_r01))))+IKsqr(((((-1.0)*new_r01*x269))+(((-1.0)*cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((((-1.0)*new_r00*x269))+((cj19*new_r01))), ((((-1.0)*new_r01*x269))+(((-1.0)*cj19*new_r00))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x270=IKsin(j21);\nIkReal x271=IKcos(j21);\nIkReal x272=((1.0)*cj19);\nIkReal x273=((1.0)*sj19);\nIkReal x274=((1.0)*x270);\nIkReal x275=(sj19*x271);\nIkReal x276=(sj19*x270);\nIkReal x277=(x270*x272);\nevalcond[0]=(x271+((new_r10*sj19))+((cj19*new_r00)));\nevalcond[1]=((((-1.0)*x274))+((cj19*new_r01))+((new_r11*sj19)));\nevalcond[2]=(x276+((cj19*x271))+new_r00);\nevalcond[3]=((((-1.0)*new_r00*x273))+(((-1.0)*x274))+((cj19*new_r10)));\nevalcond[4]=((((-1.0)*new_r01*x273))+(((-1.0)*x271))+((cj19*new_r11)));\nevalcond[5]=(x275+(((-1.0)*x277))+new_r01);\nevalcond[6]=(x275+(((-1.0)*x277))+new_r10);\nevalcond[7]=((((-1.0)*x271*x272))+(((-1.0)*x270*x273))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j19, j21]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j19array[1], cj19array[1], sj19array[1];\nbool j19valid[1]={false};\n_nj19 = 1;\nCheckValue<IkReal> x279=IKPowWithIntegerCheck(sj20,-1);\nif(!x279.valid){\ncontinue;\n}\nIkReal x278=x279.value;\nCheckValue<IkReal> x280=IKPowWithIntegerCheck(new_r12,-1);\nif(!x280.valid){\ncontinue;\n}\nif( IKabs((x278*(x280.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj20*cj20))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x278)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x278*(x280.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj20*cj20)))))))+IKsqr((new_r02*x278))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj19array[0]=IKatan2((x278*(x280.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj20*cj20)))))), (new_r02*x278));\nsj19array[0]=IKsin(j19array[0]);\ncj19array[0]=IKcos(j19array[0]);\nif( j19array[0] > IKPI )\n{\n    j19array[0]-=IK2PI;\n}\nelse if( j19array[0] < -IKPI )\n{    j19array[0]+=IK2PI;\n}\nj19valid[0] = true;\nfor(int ij19 = 0; ij19 < 1; ++ij19)\n{\nif( !j19valid[ij19] )\n{\n    continue;\n}\n_ij19[0] = ij19; _ij19[1] = -1;\nfor(int iij19 = ij19+1; iij19 < 1; ++iij19)\n{\nif( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )\n{\n    j19valid[iij19]=false; _ij19[1] = iij19; break; \n}\n}\nj19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];\n{\nIkReal evalcond[8];\nIkReal x281=IKcos(j19);\nIkReal x282=IKsin(j19);\nIkReal x283=((1.0)*sj20);\nIkReal x284=(new_r02*x281);\nIkReal x285=(new_r12*x282);\nIkReal x286=(sj20*x281);\nIkReal x287=(sj20*x282);\nevalcond[0]=((((-1.0)*x281*x283))+new_r02);\nevalcond[1]=((((-1.0)*x282*x283))+new_r12);\nevalcond[2]=(((new_r12*x281))+(((-1.0)*new_r02*x282)));\nevalcond[3]=(x285+x284+(((-1.0)*x283)));\nevalcond[4]=(((cj20*new_r20))+((new_r00*x286))+((new_r10*x287)));\nevalcond[5]=(((cj20*new_r21))+((new_r11*x287))+((new_r01*x286)));\nevalcond[6]=((-1.0)+((sj20*x285))+((sj20*x284))+((cj20*new_r22)));\nevalcond[7]=(((cj20*x284))+((cj20*x285))+(((-1.0)*new_r22*x283)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j21eval[2];\nIkReal x288=((1.0)*cj17);\nIkReal x289=(cj18*sj16);\nIkReal x290=(cj16*sj17);\nIkReal x291=(sj16*sj18);\nIkReal x292=(sj16*sj17);\nIkReal x293=(cj16*cj18);\nIkReal x294=(sj17*sj18);\nIkReal x295=(cj16*sj18);\nIkReal x296=(cj18*sj15*sj17);\nIkReal x297=(x291+(((-1.0)*x288*x293)));\nIkReal x298=x204;\nIkReal x299=x205;\nIkReal x300=(x293+(((-1.0)*x288*x291)));\nIkReal x301=(cj15*x300);\nIkReal x302=x208;\nIkReal x303=x209;\nIkReal x304=(cj15*x302);\nIkReal x305=(((sj15*x300))+((cj15*x294)));\nIkReal x306=((((-1.0)*sj15*x294))+x301);\nIkReal x307=(((cj15*cj18*sj17))+((sj15*x302)));\nIkReal x308=((((-1.0)*x296))+x304);\nnew_r00=(((r20*x297))+((r10*x307))+((r00*x308)));\nnew_r01=(((r11*x307))+((r01*x308))+((r21*x297)));\nnew_r02=(((r02*(((((-1.0)*x296))+x304))))+((r22*x297))+((r12*x307)));\nnew_r10=(((r20*x290))+((r00*x299))+((r10*x298)));\nnew_r11=(((r01*x299))+((r21*x290))+((r11*x298)));\nnew_r12=(((r12*x298))+((r02*x299))+((r22*x290)));\nnew_r20=(((r00*(((((-1.0)*sj15*x294))+x301))))+((r20*x303))+((r10*x305)));\nnew_r21=(((r11*x305))+((r21*x303))+((r01*x306)));\nnew_r22=(((r22*x303))+((r02*x306))+((r12*x305)));\nj21eval[0]=sj20;\nj21eval[1]=IKsign(sj20);\nif( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j21eval[2];\nIkReal x309=((1.0)*cj17);\nIkReal x310=(cj18*sj16);\nIkReal x311=(cj16*sj17);\nIkReal x312=(sj16*sj18);\nIkReal x313=(sj16*sj17);\nIkReal x314=(cj16*cj18);\nIkReal x315=(sj17*sj18);\nIkReal x316=(cj16*sj18);\nIkReal x317=(cj18*sj15*sj17);\nIkReal x318=(x312+(((-1.0)*x309*x314)));\nIkReal x319=x204;\nIkReal x320=x205;\nIkReal x321=(x314+(((-1.0)*x309*x312)));\nIkReal x322=(cj15*x321);\nIkReal x323=x208;\nIkReal x324=x209;\nIkReal x325=(cj15*x323);\nIkReal x326=(((cj15*x315))+((sj15*x321)));\nIkReal x327=(x322+(((-1.0)*sj15*x315)));\nIkReal x328=(((cj15*cj18*sj17))+((sj15*x323)));\nIkReal x329=(x325+(((-1.0)*x317)));\nnew_r00=(((r00*x329))+((r20*x318))+((r10*x328)));\nnew_r01=(((r11*x328))+((r01*x329))+((r21*x318)));\nnew_r02=(((r02*((x325+(((-1.0)*x317))))))+((r12*x328))+((r22*x318)));\nnew_r10=(((r00*x320))+((r20*x311))+((r10*x319)));\nnew_r11=(((r11*x319))+((r01*x320))+((r21*x311)));\nnew_r12=(((r02*x320))+((r12*x319))+((r22*x311)));\nnew_r20=(((r20*x324))+((r10*x326))+((r00*((x322+(((-1.0)*sj15*x315)))))));\nnew_r21=(((r21*x324))+((r11*x326))+((r01*x327)));\nnew_r22=(((r02*x327))+((r12*x326))+((r22*x324)));\nj21eval[0]=sj20;\nj21eval[1]=sj19;\nif( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j21eval[3];\nIkReal x330=((1.0)*cj17);\nIkReal x331=(cj18*sj16);\nIkReal x332=(cj16*sj17);\nIkReal x333=(sj16*sj18);\nIkReal x334=(sj16*sj17);\nIkReal x335=(cj16*cj18);\nIkReal x336=(sj17*sj18);\nIkReal x337=(cj16*sj18);\nIkReal x338=(cj18*sj15*sj17);\nIkReal x339=(x333+(((-1.0)*x330*x335)));\nIkReal x340=x204;\nIkReal x341=x205;\nIkReal x342=(x335+(((-1.0)*x330*x333)));\nIkReal x343=(cj15*x342);\nIkReal x344=x208;\nIkReal x345=x209;\nIkReal x346=(cj15*x344);\nIkReal x347=(((sj15*x342))+((cj15*x336)));\nIkReal x348=(x343+(((-1.0)*sj15*x336)));\nIkReal x349=(((cj15*cj18*sj17))+((sj15*x344)));\nIkReal x350=(x346+(((-1.0)*x338)));\nnew_r00=(((r00*x350))+((r20*x339))+((r10*x349)));\nnew_r01=(((r01*x350))+((r21*x339))+((r11*x349)));\nnew_r02=(((r22*x339))+((r02*((x346+(((-1.0)*x338))))))+((r12*x349)));\nnew_r10=(((r00*x341))+((r20*x332))+((r10*x340)));\nnew_r11=(((r01*x341))+((r21*x332))+((r11*x340)));\nnew_r12=(((r22*x332))+((r02*x341))+((r12*x340)));\nnew_r20=(((r00*((x343+(((-1.0)*sj15*x336))))))+((r20*x345))+((r10*x347)));\nnew_r21=(((r01*x348))+((r21*x345))+((r11*x347)));\nnew_r22=(((r22*x345))+((r02*x348))+((r12*x347)));\nj21eval[0]=cj20;\nj21eval[1]=sj19;\nj21eval[2]=sj20;\nif( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x351=((1.0)*sj19);\nIkReal x352=((((-1.0)*new_r02*x351))+((cj19*new_r12)));\nIkReal x353=(((new_r10*sj19))+((cj19*new_r00)));\nIkReal x354=(((cj19*new_r01))+((new_r11*sj19)));\nIkReal x355=((-1.0)+((cj19*new_r02))+((new_r12*sj19)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*cj19))+new_r02);\nevalcond[3]=((((-1.0)*x351))+new_r12);\nevalcond[4]=x352;\nevalcond[5]=x352;\nevalcond[6]=x355;\nevalcond[7]=x354;\nevalcond[8]=x353;\nevalcond[9]=x353;\nevalcond[10]=x354;\nevalcond[11]=x355;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x356=IKcos(j21);\nIkReal x357=IKsin(j21);\nIkReal x358=((1.0)*new_r12);\nIkReal x359=((1.0)*x357);\nIkReal x360=((1.0)*x356);\nevalcond[0]=(x356+new_r20);\nevalcond[1]=((((-1.0)*x359))+new_r21);\nevalcond[2]=(new_r01+((new_r12*x356)));\nevalcond[3]=(new_r00+((new_r12*x357)));\nevalcond[4]=(new_r11+(((-1.0)*new_r02*x360)));\nevalcond[5]=((((-1.0)*new_r02*x359))+new_r10);\nevalcond[6]=((((-1.0)*x359))+((new_r02*new_r10))+(((-1.0)*new_r00*x358)));\nevalcond[7]=((((-1.0)*x360))+(((-1.0)*new_r01*x358))+((new_r02*new_r11)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x361=(new_r12*sj19);\nIkReal x362=((1.0)*sj19);\nIkReal x363=(cj19*new_r00);\nIkReal x364=((1.0)*cj19);\nIkReal x365=(((cj19*new_r12))+(((-1.0)*new_r02*x362)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(cj19+new_r02);\nevalcond[3]=(sj19+new_r12);\nevalcond[4]=x365;\nevalcond[5]=x365;\nevalcond[6]=((1.0)+x361+((cj19*new_r02)));\nevalcond[7]=(((cj19*new_r01))+((new_r11*sj19)));\nevalcond[8]=(x363+((new_r10*sj19)));\nevalcond[9]=((((-1.0)*x363))+(((-1.0)*new_r10*x362)));\nevalcond[10]=((((-1.0)*new_r11*x362))+(((-1.0)*new_r01*x364)));\nevalcond[11]=((-1.0)+(((-1.0)*x361))+(((-1.0)*new_r02*x364)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((-1.0)*new_r21), new_r20);\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x366=IKcos(j21);\nIkReal x367=IKsin(j21);\nIkReal x368=((1.0)*new_r02);\nIkReal x369=((1.0)*x366);\nIkReal x370=((1.0)*x367);\nevalcond[0]=(x367+new_r21);\nevalcond[1]=((((-1.0)*x369))+new_r20);\nevalcond[2]=(new_r11+((new_r02*x366)));\nevalcond[3]=(new_r10+((new_r02*x367)));\nevalcond[4]=((((-1.0)*new_r12*x369))+new_r01);\nevalcond[5]=((((-1.0)*new_r12*x370))+new_r00);\nevalcond[6]=((((-1.0)*x370))+((new_r00*new_r12))+(((-1.0)*new_r10*x368)));\nevalcond[7]=((((-1.0)*x369))+((new_r01*new_r12))+(((-1.0)*new_r11*x368)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x371=((((-1.0)*cj20))+new_r22);\nIkReal x372=((((-1.0)*sj20))+new_r02);\nIkReal x373=((1.0)*sj20);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)));\nevalcond[1]=x371;\nevalcond[2]=x371;\nevalcond[3]=x372;\nevalcond[4]=new_r12;\nevalcond[5]=x372;\nevalcond[6]=(((new_r00*sj20))+((cj20*new_r20)));\nevalcond[7]=(((new_r01*sj20))+((cj20*new_r21)));\nevalcond[8]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));\nevalcond[9]=(((cj20*new_r02))+(((-1.0)*new_r22*x373)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(new_r10, new_r11);\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x374=IKcos(j21);\nIkReal x375=IKsin(j21);\nIkReal x376=((1.0)*new_r02);\nIkReal x377=((1.0)*x374);\nevalcond[0]=(new_r20+((new_r02*x374)));\nevalcond[1]=((((-1.0)*x375))+new_r10);\nevalcond[2]=((((-1.0)*x377))+new_r11);\nevalcond[3]=(new_r01+((new_r22*x375)));\nevalcond[4]=(new_r21+(((-1.0)*x375*x376)));\nevalcond[5]=((((-1.0)*new_r22*x377))+new_r00);\nevalcond[6]=((((-1.0)*new_r21*x376))+((new_r01*new_r22))+x375);\nevalcond[7]=((((-1.0)*new_r20*x376))+((new_r00*new_r22))+(((-1.0)*x377)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x378=((((-1.0)*cj20))+new_r22);\nIkReal x379=((1.0)*sj20);\nIkReal x380=((1.0)*cj20);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));\nevalcond[1]=x378;\nevalcond[2]=x378;\nevalcond[3]=(sj20+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x379))+(((-1.0)*new_r02)));\nevalcond[6]=((((-1.0)*new_r00*x379))+((cj20*new_r20)));\nevalcond[7]=(((cj20*new_r21))+(((-1.0)*new_r01*x379)));\nevalcond[8]=((-1.0)+((cj20*new_r22))+(((-1.0)*new_r02*x379)));\nevalcond[9]=((((-1.0)*new_r22*x379))+(((-1.0)*new_r02*x380)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x381=IKsin(j21);\nIkReal x382=IKcos(j21);\nIkReal x383=((1.0)*new_r22);\nIkReal x384=((1.0)*x382);\nevalcond[0]=(((new_r02*x381))+new_r21);\nevalcond[1]=((((-1.0)*new_r02*x384))+new_r20);\nevalcond[2]=((((-1.0)*x381))+(((-1.0)*new_r10)));\nevalcond[3]=((((-1.0)*x384))+(((-1.0)*new_r11)));\nevalcond[4]=(((new_r22*x381))+(((-1.0)*new_r01)));\nevalcond[5]=((((-1.0)*new_r00))+(((-1.0)*x382*x383)));\nevalcond[6]=((((-1.0)*new_r01*x383))+x381+((new_r02*new_r21)));\nevalcond[7]=((((-1.0)*new_r00*x383))+(((-1.0)*x384))+((new_r02*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x385=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));\nIkReal x386=(((cj19*new_r02))+((new_r12*sj19)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x385;\nevalcond[7]=x385;\nevalcond[8]=x386;\nevalcond[9]=x386;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nIkReal x387=((1.0)*sj19);\nif( IKabs(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x387)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x387))+((cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x387))))+IKsqr(((((-1.0)*new_r01*x387))+((cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x387))), ((((-1.0)*new_r01*x387))+((cj19*new_r00))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x388=IKsin(j21);\nIkReal x389=IKcos(j21);\nIkReal x390=((1.0)*sj19);\nIkReal x391=((1.0)*x389);\nIkReal x392=(sj19*x388);\nIkReal x393=((1.0)*x388);\nIkReal x394=(cj19*x391);\nevalcond[0]=(x388+((cj19*new_r01))+((new_r11*sj19)));\nevalcond[1]=(((cj19*x388))+new_r01+((sj19*x389)));\nevalcond[2]=((((-1.0)*x391))+((new_r10*sj19))+((cj19*new_r00)));\nevalcond[3]=((((-1.0)*x393))+((cj19*new_r10))+(((-1.0)*new_r00*x390)));\nevalcond[4]=((((-1.0)*new_r01*x390))+(((-1.0)*x391))+((cj19*new_r11)));\nevalcond[5]=((((-1.0)*x394))+x392+new_r00);\nevalcond[6]=((((-1.0)*x394))+x392+new_r11);\nevalcond[7]=((((-1.0)*cj19*x393))+(((-1.0)*x389*x390))+new_r10);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x395=(new_r12*sj19);\nIkReal x396=((1.0)*new_r02);\nIkReal x397=((((-1.0)*sj19*x396))+((cj19*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x397;\nevalcond[7]=x397;\nevalcond[8]=(x395+((cj19*new_r02)));\nevalcond[9]=((((-1.0)*cj19*x396))+(((-1.0)*x395)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nIkReal x398=((1.0)*sj19);\nif( IKabs(((((-1.0)*new_r00*x398))+((cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x398))+(((-1.0)*cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x398))+((cj19*new_r01))))+IKsqr(((((-1.0)*new_r01*x398))+(((-1.0)*cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((((-1.0)*new_r00*x398))+((cj19*new_r01))), ((((-1.0)*new_r01*x398))+(((-1.0)*cj19*new_r00))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x399=IKsin(j21);\nIkReal x400=IKcos(j21);\nIkReal x401=((1.0)*cj19);\nIkReal x402=((1.0)*sj19);\nIkReal x403=((1.0)*x399);\nIkReal x404=(sj19*x400);\nIkReal x405=(sj19*x399);\nIkReal x406=(x399*x401);\nevalcond[0]=(x400+((new_r10*sj19))+((cj19*new_r00)));\nevalcond[1]=(((cj19*new_r01))+((new_r11*sj19))+(((-1.0)*x403)));\nevalcond[2]=(x405+new_r00+((cj19*x400)));\nevalcond[3]=((((-1.0)*new_r00*x402))+((cj19*new_r10))+(((-1.0)*x403)));\nevalcond[4]=(((cj19*new_r11))+(((-1.0)*new_r01*x402))+(((-1.0)*x400)));\nevalcond[5]=(x404+new_r01+(((-1.0)*x406)));\nevalcond[6]=(x404+new_r10+(((-1.0)*x406)));\nevalcond[7]=((((-1.0)*x400*x401))+(((-1.0)*x399*x402))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j21]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x408=IKPowWithIntegerCheck(sj20,-1);\nif(!x408.valid){\ncontinue;\n}\nIkReal x407=x408.value;\nCheckValue<IkReal> x409=IKPowWithIntegerCheck(cj20,-1);\nif(!x409.valid){\ncontinue;\n}\nCheckValue<IkReal> x410=IKPowWithIntegerCheck(sj19,-1);\nif(!x410.valid){\ncontinue;\n}\nif( IKabs((x407*(x409.value)*(x410.value)*(((((-1.0)*new_r11*sj20))+(((-1.0)*cj19*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x407)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x407*(x409.value)*(x410.value)*(((((-1.0)*new_r11*sj20))+(((-1.0)*cj19*new_r20))))))+IKsqr(((-1.0)*new_r20*x407))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2((x407*(x409.value)*(x410.value)*(((((-1.0)*new_r11*sj20))+(((-1.0)*cj19*new_r20))))), ((-1.0)*new_r20*x407));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[12];\nIkReal x411=IKsin(j21);\nIkReal x412=IKcos(j21);\nIkReal x413=(cj20*sj19);\nIkReal x414=(cj19*new_r01);\nIkReal x415=((1.0)*sj20);\nIkReal x416=(cj19*new_r00);\nIkReal x417=((1.0)*sj19);\nIkReal x418=((1.0)*x412);\nIkReal x419=(cj20*x411);\nIkReal x420=((1.0)*x411);\nIkReal x421=(cj19*x418);\nevalcond[0]=(((sj20*x412))+new_r20);\nevalcond[1]=((((-1.0)*x411*x415))+new_r21);\nevalcond[2]=(x414+x419+((new_r11*sj19)));\nevalcond[3]=((((-1.0)*x420))+((cj19*new_r10))+(((-1.0)*new_r00*x417)));\nevalcond[4]=(((cj19*new_r11))+(((-1.0)*x418))+(((-1.0)*new_r01*x417)));\nevalcond[5]=(((cj19*x419))+new_r01+((sj19*x412)));\nevalcond[6]=((((-1.0)*cj20*x418))+x416+((new_r10*sj19)));\nevalcond[7]=((((-1.0)*cj20*x421))+new_r00+((sj19*x411)));\nevalcond[8]=(((x411*x413))+(((-1.0)*x421))+new_r11);\nevalcond[9]=((((-1.0)*x413*x418))+new_r10+(((-1.0)*cj19*x420)));\nevalcond[10]=(((cj20*x414))+x411+(((-1.0)*new_r21*x415))+((new_r11*x413)));\nevalcond[11]=((((-1.0)*new_r20*x415))+((cj20*x416))+((new_r10*x413))+(((-1.0)*x418)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x423=IKPowWithIntegerCheck(sj20,-1);\nif(!x423.valid){\ncontinue;\n}\nIkReal x422=x423.value;\nCheckValue<IkReal> x424=IKPowWithIntegerCheck(sj19,-1);\nif(!x424.valid){\ncontinue;\n}\nif( IKabs((new_r21*x422)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x422*(x424.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x422))+IKsqr((x422*(x424.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2((new_r21*x422), (x422*(x424.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21))))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[12];\nIkReal x425=IKsin(j21);\nIkReal x426=IKcos(j21);\nIkReal x427=(cj20*sj19);\nIkReal x428=(cj19*new_r01);\nIkReal x429=((1.0)*sj20);\nIkReal x430=(cj19*new_r00);\nIkReal x431=((1.0)*sj19);\nIkReal x432=((1.0)*x426);\nIkReal x433=(cj20*x425);\nIkReal x434=((1.0)*x425);\nIkReal x435=(cj19*x432);\nevalcond[0]=(((sj20*x426))+new_r20);\nevalcond[1]=((((-1.0)*x425*x429))+new_r21);\nevalcond[2]=(x428+x433+((new_r11*sj19)));\nevalcond[3]=((((-1.0)*new_r00*x431))+(((-1.0)*x434))+((cj19*new_r10)));\nevalcond[4]=((((-1.0)*x432))+(((-1.0)*new_r01*x431))+((cj19*new_r11)));\nevalcond[5]=(((cj19*x433))+((sj19*x426))+new_r01);\nevalcond[6]=((((-1.0)*cj20*x432))+x430+((new_r10*sj19)));\nevalcond[7]=(((sj19*x425))+(((-1.0)*cj20*x435))+new_r00);\nevalcond[8]=((((-1.0)*x435))+((x425*x427))+new_r11);\nevalcond[9]=((((-1.0)*x427*x432))+(((-1.0)*cj19*x434))+new_r10);\nevalcond[10]=(((new_r11*x427))+x425+(((-1.0)*new_r21*x429))+((cj20*x428)));\nevalcond[11]=((((-1.0)*x432))+((new_r10*x427))+(((-1.0)*new_r20*x429))+((cj20*x430)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x436=IKPowWithIntegerCheck(IKsign(sj20),-1);\nif(!x436.valid){\ncontinue;\n}\nCheckValue<IkReal> x437 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x437.valid){\ncontinue;\n}\nj21array[0]=((-1.5707963267949)+(((1.5707963267949)*(x436.value)))+(x437.value));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[12];\nIkReal x438=IKsin(j21);\nIkReal x439=IKcos(j21);\nIkReal x440=(cj20*sj19);\nIkReal x441=(cj19*new_r01);\nIkReal x442=((1.0)*sj20);\nIkReal x443=(cj19*new_r00);\nIkReal x444=((1.0)*sj19);\nIkReal x445=((1.0)*x439);\nIkReal x446=(cj20*x438);\nIkReal x447=((1.0)*x438);\nIkReal x448=(cj19*x445);\nevalcond[0]=(((sj20*x439))+new_r20);\nevalcond[1]=((((-1.0)*x438*x442))+new_r21);\nevalcond[2]=(x446+x441+((new_r11*sj19)));\nevalcond[3]=((((-1.0)*x447))+(((-1.0)*new_r00*x444))+((cj19*new_r10)));\nevalcond[4]=((((-1.0)*x445))+(((-1.0)*new_r01*x444))+((cj19*new_r11)));\nevalcond[5]=(((cj19*x446))+((sj19*x439))+new_r01);\nevalcond[6]=((((-1.0)*cj20*x445))+x443+((new_r10*sj19)));\nevalcond[7]=(((sj19*x438))+(((-1.0)*cj20*x448))+new_r00);\nevalcond[8]=((((-1.0)*x448))+((x438*x440))+new_r11);\nevalcond[9]=((((-1.0)*cj19*x447))+new_r10+(((-1.0)*x440*x445)));\nevalcond[10]=(((new_r11*x440))+x438+((cj20*x441))+(((-1.0)*new_r21*x442)));\nevalcond[11]=((((-1.0)*x445))+((new_r10*x440))+(((-1.0)*new_r20*x442))+((cj20*x443)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j19array[1], cj19array[1], sj19array[1];\nbool j19valid[1]={false};\n_nj19 = 1;\nCheckValue<IkReal> x449=IKPowWithIntegerCheck(IKsign(sj20),-1);\nif(!x449.valid){\ncontinue;\n}\nCheckValue<IkReal> x450 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);\nif(!x450.valid){\ncontinue;\n}\nj19array[0]=((-1.5707963267949)+(((1.5707963267949)*(x449.value)))+(x450.value));\nsj19array[0]=IKsin(j19array[0]);\ncj19array[0]=IKcos(j19array[0]);\nif( j19array[0] > IKPI )\n{\n    j19array[0]-=IK2PI;\n}\nelse if( j19array[0] < -IKPI )\n{    j19array[0]+=IK2PI;\n}\nj19valid[0] = true;\nfor(int ij19 = 0; ij19 < 1; ++ij19)\n{\nif( !j19valid[ij19] )\n{\n    continue;\n}\n_ij19[0] = ij19; _ij19[1] = -1;\nfor(int iij19 = ij19+1; iij19 < 1; ++iij19)\n{\nif( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )\n{\n    j19valid[iij19]=false; _ij19[1] = iij19; break; \n}\n}\nj19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];\n{\nIkReal evalcond[8];\nIkReal x451=IKcos(j19);\nIkReal x452=IKsin(j19);\nIkReal x453=((1.0)*sj20);\nIkReal x454=(new_r02*x451);\nIkReal x455=(new_r12*x452);\nIkReal x456=(sj20*x451);\nIkReal x457=(sj20*x452);\nevalcond[0]=((((-1.0)*x451*x453))+new_r02);\nevalcond[1]=((((-1.0)*x452*x453))+new_r12);\nevalcond[2]=(((new_r12*x451))+(((-1.0)*new_r02*x452)));\nevalcond[3]=((((-1.0)*x453))+x454+x455);\nevalcond[4]=(((new_r10*x457))+((new_r00*x456))+((cj20*new_r20)));\nevalcond[5]=(((new_r11*x457))+((new_r01*x456))+((cj20*new_r21)));\nevalcond[6]=((-1.0)+((sj20*x454))+((sj20*x455))+((cj20*new_r22)));\nevalcond[7]=(((cj20*x455))+((cj20*x454))+(((-1.0)*new_r22*x453)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j21eval[2];\nIkReal x458=((1.0)*cj17);\nIkReal x459=(cj18*sj16);\nIkReal x460=(cj16*sj17);\nIkReal x461=(sj16*sj18);\nIkReal x462=(sj16*sj17);\nIkReal x463=(cj16*cj18);\nIkReal x464=(sj17*sj18);\nIkReal x465=(cj16*sj18);\nIkReal x466=(cj18*sj15*sj17);\nIkReal x467=(x461+(((-1.0)*x458*x463)));\nIkReal x468=x204;\nIkReal x469=x205;\nIkReal x470=(x463+(((-1.0)*x458*x461)));\nIkReal x471=(cj15*x470);\nIkReal x472=x208;\nIkReal x473=x209;\nIkReal x474=(cj15*x472);\nIkReal x475=(((cj15*x464))+((sj15*x470)));\nIkReal x476=(x471+(((-1.0)*sj15*x464)));\nIkReal x477=(((cj15*cj18*sj17))+((sj15*x472)));\nIkReal x478=((((-1.0)*x466))+x474);\nnew_r00=(((r10*x477))+((r20*x467))+((r00*x478)));\nnew_r01=(((r11*x477))+((r21*x467))+((r01*x478)));\nnew_r02=(((r22*x467))+((r02*(((((-1.0)*x466))+x474))))+((r12*x477)));\nnew_r10=(((r20*x460))+((r00*x469))+((r10*x468)));\nnew_r11=(((r11*x468))+((r01*x469))+((r21*x460)));\nnew_r12=(((r22*x460))+((r12*x468))+((r02*x469)));\nnew_r20=(((r10*x475))+((r20*x473))+((r00*((x471+(((-1.0)*sj15*x464)))))));\nnew_r21=(((r21*x473))+((r11*x475))+((r01*x476)));\nnew_r22=(((r02*x476))+((r12*x475))+((r22*x473)));\nj21eval[0]=sj20;\nj21eval[1]=IKsign(sj20);\nif( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j21eval[2];\nIkReal x479=((1.0)*cj17);\nIkReal x480=(cj18*sj16);\nIkReal x481=(cj16*sj17);\nIkReal x482=(sj16*sj18);\nIkReal x483=(sj16*sj17);\nIkReal x484=(cj16*cj18);\nIkReal x485=(sj17*sj18);\nIkReal x486=(cj16*sj18);\nIkReal x487=(cj18*sj15*sj17);\nIkReal x488=(x482+(((-1.0)*x479*x484)));\nIkReal x489=x204;\nIkReal x490=x205;\nIkReal x491=(x484+(((-1.0)*x479*x482)));\nIkReal x492=(cj15*x491);\nIkReal x493=x208;\nIkReal x494=x209;\nIkReal x495=(cj15*x493);\nIkReal x496=(((cj15*x485))+((sj15*x491)));\nIkReal x497=((((-1.0)*sj15*x485))+x492);\nIkReal x498=(((cj15*cj18*sj17))+((sj15*x493)));\nIkReal x499=((((-1.0)*x487))+x495);\nnew_r00=(((r20*x488))+((r10*x498))+((r00*x499)));\nnew_r01=(((r11*x498))+((r21*x488))+((r01*x499)));\nnew_r02=(((r02*(((((-1.0)*x487))+x495))))+((r12*x498))+((r22*x488)));\nnew_r10=(((r20*x481))+((r10*x489))+((r00*x490)));\nnew_r11=(((r11*x489))+((r21*x481))+((r01*x490)));\nnew_r12=(((r02*x490))+((r12*x489))+((r22*x481)));\nnew_r20=(((r10*x496))+((r00*(((((-1.0)*sj15*x485))+x492))))+((r20*x494)));\nnew_r21=(((r11*x496))+((r21*x494))+((r01*x497)));\nnew_r22=(((r02*x497))+((r22*x494))+((r12*x496)));\nj21eval[0]=sj20;\nj21eval[1]=sj19;\nif( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j21eval[3];\nIkReal x500=((1.0)*cj17);\nIkReal x501=(cj18*sj16);\nIkReal x502=(cj16*sj17);\nIkReal x503=(sj16*sj18);\nIkReal x504=(sj16*sj17);\nIkReal x505=(cj16*cj18);\nIkReal x506=(sj17*sj18);\nIkReal x507=(cj16*sj18);\nIkReal x508=(cj18*sj15*sj17);\nIkReal x509=(x503+(((-1.0)*x500*x505)));\nIkReal x510=x204;\nIkReal x511=x205;\nIkReal x512=(x505+(((-1.0)*x500*x503)));\nIkReal x513=(cj15*x512);\nIkReal x514=x208;\nIkReal x515=x209;\nIkReal x516=(cj15*x514);\nIkReal x517=(((cj15*x506))+((sj15*x512)));\nIkReal x518=((((-1.0)*sj15*x506))+x513);\nIkReal x519=(((cj15*cj18*sj17))+((sj15*x514)));\nIkReal x520=(x516+(((-1.0)*x508)));\nnew_r00=(((r20*x509))+((r10*x519))+((r00*x520)));\nnew_r01=(((r11*x519))+((r21*x509))+((r01*x520)));\nnew_r02=(((r22*x509))+((r02*((x516+(((-1.0)*x508))))))+((r12*x519)));\nnew_r10=(((r20*x502))+((r10*x510))+((r00*x511)));\nnew_r11=(((r01*x511))+((r11*x510))+((r21*x502)));\nnew_r12=(((r22*x502))+((r02*x511))+((r12*x510)));\nnew_r20=(((r00*(((((-1.0)*sj15*x506))+x513))))+((r20*x515))+((r10*x517)));\nnew_r21=(((r01*x518))+((r11*x517))+((r21*x515)));\nnew_r22=(((r02*x518))+((r22*x515))+((r12*x517)));\nj21eval[0]=cj20;\nj21eval[1]=sj19;\nj21eval[2]=sj20;\nif( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x521=((1.0)*sj19);\nIkReal x522=((((-1.0)*new_r02*x521))+((cj19*new_r12)));\nIkReal x523=(((new_r10*sj19))+((cj19*new_r00)));\nIkReal x524=(((cj19*new_r01))+((new_r11*sj19)));\nIkReal x525=((-1.0)+((cj19*new_r02))+((new_r12*sj19)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*cj19))+new_r02);\nevalcond[3]=((((-1.0)*x521))+new_r12);\nevalcond[4]=x522;\nevalcond[5]=x522;\nevalcond[6]=x525;\nevalcond[7]=x524;\nevalcond[8]=x523;\nevalcond[9]=x523;\nevalcond[10]=x524;\nevalcond[11]=x525;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x526=IKcos(j21);\nIkReal x527=IKsin(j21);\nIkReal x528=((1.0)*new_r12);\nIkReal x529=((1.0)*x527);\nIkReal x530=((1.0)*x526);\nevalcond[0]=(x526+new_r20);\nevalcond[1]=((((-1.0)*x529))+new_r21);\nevalcond[2]=(((new_r12*x526))+new_r01);\nevalcond[3]=(((new_r12*x527))+new_r00);\nevalcond[4]=(new_r11+(((-1.0)*new_r02*x530)));\nevalcond[5]=((((-1.0)*new_r02*x529))+new_r10);\nevalcond[6]=((((-1.0)*new_r00*x528))+(((-1.0)*x529))+((new_r02*new_r10)));\nevalcond[7]=((((-1.0)*x530))+(((-1.0)*new_r01*x528))+((new_r02*new_r11)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x531=(new_r12*sj19);\nIkReal x532=((1.0)*sj19);\nIkReal x533=(cj19*new_r00);\nIkReal x534=((1.0)*cj19);\nIkReal x535=(((cj19*new_r12))+(((-1.0)*new_r02*x532)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(cj19+new_r02);\nevalcond[3]=(sj19+new_r12);\nevalcond[4]=x535;\nevalcond[5]=x535;\nevalcond[6]=((1.0)+x531+((cj19*new_r02)));\nevalcond[7]=(((cj19*new_r01))+((new_r11*sj19)));\nevalcond[8]=(x533+((new_r10*sj19)));\nevalcond[9]=((((-1.0)*x533))+(((-1.0)*new_r10*x532)));\nevalcond[10]=((((-1.0)*new_r11*x532))+(((-1.0)*new_r01*x534)));\nevalcond[11]=((-1.0)+(((-1.0)*x531))+(((-1.0)*new_r02*x534)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((-1.0)*new_r21), new_r20);\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x536=IKcos(j21);\nIkReal x537=IKsin(j21);\nIkReal x538=((1.0)*new_r02);\nIkReal x539=((1.0)*x536);\nIkReal x540=((1.0)*x537);\nevalcond[0]=(x537+new_r21);\nevalcond[1]=((((-1.0)*x539))+new_r20);\nevalcond[2]=(((new_r02*x536))+new_r11);\nevalcond[3]=(((new_r02*x537))+new_r10);\nevalcond[4]=((((-1.0)*new_r12*x539))+new_r01);\nevalcond[5]=((((-1.0)*new_r12*x540))+new_r00);\nevalcond[6]=(((new_r00*new_r12))+(((-1.0)*x540))+(((-1.0)*new_r10*x538)));\nevalcond[7]=(((new_r01*new_r12))+(((-1.0)*x539))+(((-1.0)*new_r11*x538)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x541=((((-1.0)*cj20))+new_r22);\nIkReal x542=((((-1.0)*sj20))+new_r02);\nIkReal x543=((1.0)*sj20);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)));\nevalcond[1]=x541;\nevalcond[2]=x541;\nevalcond[3]=x542;\nevalcond[4]=new_r12;\nevalcond[5]=x542;\nevalcond[6]=(((new_r00*sj20))+((cj20*new_r20)));\nevalcond[7]=(((new_r01*sj20))+((cj20*new_r21)));\nevalcond[8]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));\nevalcond[9]=((((-1.0)*new_r22*x543))+((cj20*new_r02)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(new_r10, new_r11);\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x544=IKcos(j21);\nIkReal x545=IKsin(j21);\nIkReal x546=((1.0)*new_r02);\nIkReal x547=((1.0)*x544);\nevalcond[0]=(((new_r02*x544))+new_r20);\nevalcond[1]=((((-1.0)*x545))+new_r10);\nevalcond[2]=((((-1.0)*x547))+new_r11);\nevalcond[3]=(((new_r22*x545))+new_r01);\nevalcond[4]=((((-1.0)*x545*x546))+new_r21);\nevalcond[5]=((((-1.0)*new_r22*x547))+new_r00);\nevalcond[6]=(((new_r01*new_r22))+(((-1.0)*new_r21*x546))+x545);\nevalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x546))+(((-1.0)*x547)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x548=((((-1.0)*cj20))+new_r22);\nIkReal x549=((1.0)*sj20);\nIkReal x550=((1.0)*cj20);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));\nevalcond[1]=x548;\nevalcond[2]=x548;\nevalcond[3]=(sj20+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x549))+(((-1.0)*new_r02)));\nevalcond[6]=((((-1.0)*new_r00*x549))+((cj20*new_r20)));\nevalcond[7]=((((-1.0)*new_r01*x549))+((cj20*new_r21)));\nevalcond[8]=((-1.0)+((cj20*new_r22))+(((-1.0)*new_r02*x549)));\nevalcond[9]=((((-1.0)*new_r22*x549))+(((-1.0)*new_r02*x550)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nif( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x551=IKsin(j21);\nIkReal x552=IKcos(j21);\nIkReal x553=((1.0)*new_r22);\nIkReal x554=((1.0)*x552);\nevalcond[0]=(((new_r02*x551))+new_r21);\nevalcond[1]=(new_r20+(((-1.0)*new_r02*x554)));\nevalcond[2]=((((-1.0)*x551))+(((-1.0)*new_r10)));\nevalcond[3]=((((-1.0)*x554))+(((-1.0)*new_r11)));\nevalcond[4]=((((-1.0)*new_r01))+((new_r22*x551)));\nevalcond[5]=((((-1.0)*x552*x553))+(((-1.0)*new_r00)));\nevalcond[6]=((((-1.0)*new_r01*x553))+x551+((new_r02*new_r21)));\nevalcond[7]=((((-1.0)*new_r00*x553))+(((-1.0)*x554))+((new_r02*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x555=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));\nIkReal x556=(((cj19*new_r02))+((new_r12*sj19)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x555;\nevalcond[7]=x555;\nevalcond[8]=x556;\nevalcond[9]=x556;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nIkReal x557=((1.0)*sj19);\nif( IKabs(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x557)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x557))+((cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x557))))+IKsqr(((((-1.0)*new_r01*x557))+((cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x557))), ((((-1.0)*new_r01*x557))+((cj19*new_r00))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x558=IKsin(j21);\nIkReal x559=IKcos(j21);\nIkReal x560=((1.0)*sj19);\nIkReal x561=((1.0)*x559);\nIkReal x562=(sj19*x558);\nIkReal x563=((1.0)*x558);\nIkReal x564=(cj19*x561);\nevalcond[0]=(x558+((cj19*new_r01))+((new_r11*sj19)));\nevalcond[1]=(((cj19*x558))+new_r01+((sj19*x559)));\nevalcond[2]=(((new_r10*sj19))+((cj19*new_r00))+(((-1.0)*x561)));\nevalcond[3]=((((-1.0)*new_r00*x560))+((cj19*new_r10))+(((-1.0)*x563)));\nevalcond[4]=(((cj19*new_r11))+(((-1.0)*x561))+(((-1.0)*new_r01*x560)));\nevalcond[5]=(x562+new_r00+(((-1.0)*x564)));\nevalcond[6]=(x562+new_r11+(((-1.0)*x564)));\nevalcond[7]=((((-1.0)*x559*x560))+(((-1.0)*cj19*x563))+new_r10);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x565=(new_r12*sj19);\nIkReal x566=((1.0)*new_r02);\nIkReal x567=((((-1.0)*sj19*x566))+((cj19*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x567;\nevalcond[7]=x567;\nevalcond[8]=(x565+((cj19*new_r02)));\nevalcond[9]=((((-1.0)*x565))+(((-1.0)*cj19*x566)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nIkReal x568=((1.0)*sj19);\nif( IKabs(((((-1.0)*new_r00*x568))+((cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x568)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x568))+((cj19*new_r01))))+IKsqr(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x568))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2(((((-1.0)*new_r00*x568))+((cj19*new_r01))), ((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x568))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[8];\nIkReal x569=IKsin(j21);\nIkReal x570=IKcos(j21);\nIkReal x571=((1.0)*cj19);\nIkReal x572=((1.0)*sj19);\nIkReal x573=((1.0)*x569);\nIkReal x574=(sj19*x570);\nIkReal x575=(sj19*x569);\nIkReal x576=(x569*x571);\nevalcond[0]=(x570+((new_r10*sj19))+((cj19*new_r00)));\nevalcond[1]=((((-1.0)*x573))+((cj19*new_r01))+((new_r11*sj19)));\nevalcond[2]=(((cj19*x570))+x575+new_r00);\nevalcond[3]=((((-1.0)*x573))+(((-1.0)*new_r00*x572))+((cj19*new_r10)));\nevalcond[4]=((((-1.0)*x570))+(((-1.0)*new_r01*x572))+((cj19*new_r11)));\nevalcond[5]=((((-1.0)*x576))+x574+new_r01);\nevalcond[6]=((((-1.0)*x576))+x574+new_r10);\nevalcond[7]=((((-1.0)*x569*x572))+(((-1.0)*x570*x571))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j21]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x578=IKPowWithIntegerCheck(sj20,-1);\nif(!x578.valid){\ncontinue;\n}\nIkReal x577=x578.value;\nCheckValue<IkReal> x579=IKPowWithIntegerCheck(cj20,-1);\nif(!x579.valid){\ncontinue;\n}\nCheckValue<IkReal> x580=IKPowWithIntegerCheck(sj19,-1);\nif(!x580.valid){\ncontinue;\n}\nif( IKabs((x577*(x579.value)*(x580.value)*(((((-1.0)*new_r11*sj20))+(((-1.0)*cj19*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x577)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x577*(x579.value)*(x580.value)*(((((-1.0)*new_r11*sj20))+(((-1.0)*cj19*new_r20))))))+IKsqr(((-1.0)*new_r20*x577))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2((x577*(x579.value)*(x580.value)*(((((-1.0)*new_r11*sj20))+(((-1.0)*cj19*new_r20))))), ((-1.0)*new_r20*x577));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[12];\nIkReal x581=IKsin(j21);\nIkReal x582=IKcos(j21);\nIkReal x583=(cj20*sj19);\nIkReal x584=(cj19*new_r01);\nIkReal x585=((1.0)*sj20);\nIkReal x586=(cj19*new_r00);\nIkReal x587=((1.0)*sj19);\nIkReal x588=((1.0)*x582);\nIkReal x589=(cj20*x581);\nIkReal x590=((1.0)*x581);\nIkReal x591=(cj19*x588);\nevalcond[0]=(((sj20*x582))+new_r20);\nevalcond[1]=(new_r21+(((-1.0)*x581*x585)));\nevalcond[2]=(x584+x589+((new_r11*sj19)));\nevalcond[3]=((((-1.0)*x590))+((cj19*new_r10))+(((-1.0)*new_r00*x587)));\nevalcond[4]=((((-1.0)*new_r01*x587))+((cj19*new_r11))+(((-1.0)*x588)));\nevalcond[5]=(((sj19*x582))+((cj19*x589))+new_r01);\nevalcond[6]=(x586+((new_r10*sj19))+(((-1.0)*cj20*x588)));\nevalcond[7]=((((-1.0)*cj20*x591))+((sj19*x581))+new_r00);\nevalcond[8]=(((x581*x583))+(((-1.0)*x591))+new_r11);\nevalcond[9]=((((-1.0)*cj19*x590))+(((-1.0)*x583*x588))+new_r10);\nevalcond[10]=((((-1.0)*new_r21*x585))+((cj20*x584))+x581+((new_r11*x583)));\nevalcond[11]=((((-1.0)*new_r20*x585))+((cj20*x586))+(((-1.0)*x588))+((new_r10*x583)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x593=IKPowWithIntegerCheck(sj20,-1);\nif(!x593.valid){\ncontinue;\n}\nIkReal x592=x593.value;\nCheckValue<IkReal> x594=IKPowWithIntegerCheck(sj19,-1);\nif(!x594.valid){\ncontinue;\n}\nif( IKabs((new_r21*x592)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x592*(x594.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x592))+IKsqr((x592*(x594.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj21array[0]=IKatan2((new_r21*x592), (x592*(x594.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21))))));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[12];\nIkReal x595=IKsin(j21);\nIkReal x596=IKcos(j21);\nIkReal x597=(cj20*sj19);\nIkReal x598=(cj19*new_r01);\nIkReal x599=((1.0)*sj20);\nIkReal x600=(cj19*new_r00);\nIkReal x601=((1.0)*sj19);\nIkReal x602=((1.0)*x596);\nIkReal x603=(cj20*x595);\nIkReal x604=((1.0)*x595);\nIkReal x605=(cj19*x602);\nevalcond[0]=(((sj20*x596))+new_r20);\nevalcond[1]=((((-1.0)*x595*x599))+new_r21);\nevalcond[2]=(x598+x603+((new_r11*sj19)));\nevalcond[3]=((((-1.0)*x604))+((cj19*new_r10))+(((-1.0)*new_r00*x601)));\nevalcond[4]=((((-1.0)*x602))+((cj19*new_r11))+(((-1.0)*new_r01*x601)));\nevalcond[5]=(((sj19*x596))+((cj19*x603))+new_r01);\nevalcond[6]=((((-1.0)*cj20*x602))+x600+((new_r10*sj19)));\nevalcond[7]=(((sj19*x595))+(((-1.0)*cj20*x605))+new_r00);\nevalcond[8]=(((x595*x597))+(((-1.0)*x605))+new_r11);\nevalcond[9]=((((-1.0)*cj19*x604))+(((-1.0)*x597*x602))+new_r10);\nevalcond[10]=(((cj20*x598))+(((-1.0)*new_r21*x599))+((new_r11*x597))+x595);\nevalcond[11]=((((-1.0)*new_r20*x599))+((new_r10*x597))+((cj20*x600))+(((-1.0)*x602)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j21array[1], cj21array[1], sj21array[1];\nbool j21valid[1]={false};\n_nj21 = 1;\nCheckValue<IkReal> x606=IKPowWithIntegerCheck(IKsign(sj20),-1);\nif(!x606.valid){\ncontinue;\n}\nCheckValue<IkReal> x607 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x607.valid){\ncontinue;\n}\nj21array[0]=((-1.5707963267949)+(((1.5707963267949)*(x606.value)))+(x607.value));\nsj21array[0]=IKsin(j21array[0]);\ncj21array[0]=IKcos(j21array[0]);\nif( j21array[0] > IKPI )\n{\n    j21array[0]-=IK2PI;\n}\nelse if( j21array[0] < -IKPI )\n{    j21array[0]+=IK2PI;\n}\nj21valid[0] = true;\nfor(int ij21 = 0; ij21 < 1; ++ij21)\n{\nif( !j21valid[ij21] )\n{\n    continue;\n}\n_ij21[0] = ij21; _ij21[1] = -1;\nfor(int iij21 = ij21+1; iij21 < 1; ++iij21)\n{\nif( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )\n{\n    j21valid[iij21]=false; _ij21[1] = iij21; break; \n}\n}\nj21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];\n{\nIkReal evalcond[12];\nIkReal x608=IKsin(j21);\nIkReal x609=IKcos(j21);\nIkReal x610=(cj20*sj19);\nIkReal x611=(cj19*new_r01);\nIkReal x612=((1.0)*sj20);\nIkReal x613=(cj19*new_r00);\nIkReal x614=((1.0)*sj19);\nIkReal x615=((1.0)*x609);\nIkReal x616=(cj20*x608);\nIkReal x617=((1.0)*x608);\nIkReal x618=(cj19*x615);\nevalcond[0]=(((sj20*x609))+new_r20);\nevalcond[1]=(new_r21+(((-1.0)*x608*x612)));\nevalcond[2]=(x616+x611+((new_r11*sj19)));\nevalcond[3]=((((-1.0)*x617))+(((-1.0)*new_r00*x614))+((cj19*new_r10)));\nevalcond[4]=((((-1.0)*x615))+((cj19*new_r11))+(((-1.0)*new_r01*x614)));\nevalcond[5]=(((sj19*x609))+((cj19*x616))+new_r01);\nevalcond[6]=((((-1.0)*cj20*x615))+x613+((new_r10*sj19)));\nevalcond[7]=(((sj19*x608))+(((-1.0)*cj20*x618))+new_r00);\nevalcond[8]=(((x608*x610))+(((-1.0)*x618))+new_r11);\nevalcond[9]=((((-1.0)*x610*x615))+(((-1.0)*cj19*x617))+new_r10);\nevalcond[10]=((((-1.0)*new_r21*x612))+((new_r11*x610))+((cj20*x611))+x608);\nevalcond[11]=(((new_r10*x610))+((cj20*x613))+(((-1.0)*x615))+(((-1.0)*new_r20*x612)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);\nvinfos[0].jointtype = 17;\nvinfos[0].foffset = j12;\nvinfos[0].indices[0] = _ij12[0];\nvinfos[0].indices[1] = _ij12[1];\nvinfos[0].maxsolutions = _nj12;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j15;\nvinfos[1].indices[0] = _ij15[0];\nvinfos[1].indices[1] = _ij15[1];\nvinfos[1].maxsolutions = _nj15;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j16;\nvinfos[2].indices[0] = _ij16[0];\nvinfos[2].indices[1] = _ij16[1];\nvinfos[2].maxsolutions = _nj16;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j17;\nvinfos[3].indices[0] = _ij17[0];\nvinfos[3].indices[1] = _ij17[1];\nvinfos[3].maxsolutions = _nj17;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j18;\nvinfos[4].indices[0] = _ij18[0];\nvinfos[4].indices[1] = _ij18[1];\nvinfos[4].maxsolutions = _nj18;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j19;\nvinfos[5].indices[0] = _ij19[0];\nvinfos[5].indices[1] = _ij19[1];\nvinfos[5].maxsolutions = _nj19;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j20;\nvinfos[6].indices[0] = _ij20[0];\nvinfos[6].indices[1] = _ij20[1];\nvinfos[6].maxsolutions = _nj20;\nvinfos[7].jointtype = 1;\nvinfos[7].foffset = j21;\nvinfos[7].indices[0] = _ij21[0];\nvinfos[7].indices[1] = _ij21[1];\nvinfos[7].maxsolutions = _nj21;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\n}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[3];\n    const int maxsteps = 110;\n    for(int i = 0; i < 3; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[3];\n    IkReal err[3];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 3; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 3; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 3; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 3; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[3] = {false};\n    for(int i = 0; i < 3; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 3; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {\n    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];\n    if( det < 0 ) {\n        numroots=0;\n    }\n    else if( det == 0 ) {\n        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];\n        numroots = 1;\n    }\n    else {\n        det = IKsqrt(det);\n        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);\n        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);\n        numroots = 2;\n    }\n}\nstatic inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[5];\n    const int maxsteps = 110;\n    for(int i = 0; i < 5; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[5];\n    IkReal err[5];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 5; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 5; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 5; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 5; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[5] = {false};\n    for(int i = 0; i < 5; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 5; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[4];\n    const int maxsteps = 110;\n    for(int i = 0; i < 4; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[4];\n    IkReal err[4];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 4; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 4; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 4; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 4; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[4] = {false};\n    for(int i = 0; i < 4; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 4; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[7];\n    const int maxsteps = 110;\n    for(int i = 0; i < 7; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[7];\n    IkReal err[7];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 7; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 7; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 7; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 7; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[7] = {false};\n    for(int i = 0; i < 7; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 7; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[6];\n    const int maxsteps = 110;\n    for(int i = 0; i < 6; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[6];\n    IkReal err[6];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 6; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 6; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 6; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 6; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[6] = {false};\n    for(int i = 0; i < 6; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 6; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[8];\n    const int maxsteps = 110;\n    for(int i = 0; i < 8; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[8];\n    IkReal err[8];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 8; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 8; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 8; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 8; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[8] = {false};\n    for(int i = 0; i < 8; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 8; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\n};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"72948cfc3ff77d3858ae895ad25226f4\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\nchar* ComputeFkWrapper(const IkReal* j) {\n    IkReal eetrans[3] = {0};\n    IkReal eerot[9] = {0};\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n\nstd::vector<IkReal> TrueComputeIk(int argc, char** argv)\n{\n    std::vector<IkReal> solvalues(GetNumJoints());\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return solvalues;\n}\n"]}