{"version":3,"file":"./solvers/HiroNX_leftarm_torso.html","sources":["./solvers/HiroNX_leftarm_torso.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AA/NA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;;;;;AAiOA;;;;;;;;;;;;;;;AAq7KA;AACA;AACA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-10-07 00:44:23.705464\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68,x69,x70,x71,x72,x73,x74,x75;\nx0=IKsin(j[0]);\nx1=IKsin(j[5]);\nx2=IKsin(j[2]);\nx3=IKsin(j[3]);\nx4=(x2*x3);\nx5=IKcos(j[2]);\nx6=IKcos(j[3]);\nx7=(x5*x6);\nx8=((1.0)*x7);\nx9=(x4+(((-1.0)*(1.0)*x8)));\nx10=(x1*x9);\nx11=((0.258820142606703)*x10);\nx12=IKcos(j[5]);\nx13=((0.258820142606703)*x12);\nx14=IKcos(j[4]);\nx15=(x2*x6);\nx16=((1.0)*x15);\nx17=(x3*x5);\nx18=((1.0)*x17);\nx19=((((-1.0)*(1.0)*x16))+(((-1.0)*(1.0)*x18)));\nx20=(x14*x19);\nx21=(x13*x20);\nx22=IKcos(j[0]);\nx23=IKcos(j[1]);\nIkReal x76=((1.0)*x23);\nx24=((((-1.0)*x18*x76))+(((-1.0)*x16*x76)));\nx25=IKsin(j[4]);\nx26=IKsin(j[1]);\nx27=((1.0)*x26);\nx28=(x25*x27);\nx29=((1.0)*x23*x4);\nx30=(x14*(((((-1.0)*(1.0)*x29))+((x23*x7)))));\nx31=(((x1*x24))+((x12*((x30+(((-1.0)*(1.0)*x28)))))));\nx32=((0.965925532213041)*x1);\nx33=(x2*x26*x6);\nx34=((((-1.0)*(1.0)*x17*x27))+(((-1.0)*(1.0)*x33)));\nx35=(x32*x34);\nx36=((0.965925532213041)*x12);\nx37=(x23*x25);\nx38=(x26*x7);\nx39=(x27*x4);\nx40=(x14*((x38+(((-1.0)*(1.0)*x39)))));\nx41=(x37+x40);\nx42=(x36*x41);\nx43=IKcos(j[6]);\nx44=(x18+x16);\nx45=(x25*x43*x44);\nx46=((0.258820142606703)*x45);\nx47=IKsin(j[6]);\nx48=((1.0)*x12);\nx49=((1.0)*x1);\nx50=((((-1.0)*(1.0)*x14*x44*x49))+(((-1.0)*(1.0)*x48*x9)));\nx51=(x47*x50);\nx52=((0.258820142606703)*x51);\nx53=(x14*x27);\nx54=(x25*((x29+(((-1.0)*(1.0)*x23*x8)))));\nx55=(((x49*(((((1.0)*x30))+(((-1.0)*(1.0)*x28))))))+(((-1.0)*(1.0)*x24*x48)));\nx56=(((x43*(((((-1.0)*(1.0)*x53))+x54))))+((x47*x55)));\nx57=(x14*x23);\nx58=(x25*((x39+(((-1.0)*(1.0)*x27*x7)))));\nx59=(x43*((x58+x57)));\nx60=((0.965925532213041)*x59);\nx61=(((x49*(((((1.0)*x37))+(((1.0)*x40))))))+(((-1.0)*(1.0)*x34*x48)));\nx62=(x47*x61);\nx63=((0.965925532213041)*x62);\nx64=(x19*x25*x47);\nx65=((0.258820142606703)*x64);\nx66=(x43*x50);\nx67=((0.258820142606703)*x66);\nx68=(((x47*(((((-1.0)*(1.0)*x54))+x53))))+((x43*x55)));\nx69=(x47*(((((-1.0)*(1.0)*x58))+(((-1.0)*(1.0)*x57)))));\nx70=((0.965925532213041)*x69);\nx71=(x43*x61);\nx72=((0.965925532213041)*x71);\nx73=((0.258820142606703)*x1);\nx74=((0.04)*x17);\nx75=((0.09)*x17);\neerot[0]=(((x0*(((((-1.0)*(1.0)*x21))+(((-1.0)*(1.0)*x11))))))+((x22*x31))+((x0*(((((-1.0)*(1.0)*x35))+(((-1.0)*(1.0)*x42)))))));\neerot[1]=(((x0*(((((-1.0)*(1.0)*x60))+(((-1.0)*(1.0)*x63))))))+((x0*(((((-1.0)*(1.0)*x52))+(((-1.0)*(1.0)*x46))))))+((x22*x56)));\neerot[2]=(((x22*x68))+((x0*(((((-1.0)*(1.0)*x70))+(((-1.0)*(1.0)*x72))))))+((x0*(((((-1.0)*(1.0)*x65))+(((-1.0)*(1.0)*x67)))))));\neetrans[0]=((((((((-0.235)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[3]))))+(((-0.03)*(IKcos(j[1]))*(IKcos(j[2]))*(IKcos(j[3]))))+(((-0.25)*(IKcos(j[1]))*(IKsin(j[2]))))+(((((((0.09)*(IKsin(j[1]))*(IKsin(j[4]))))+(((((((0.09)*(IKcos(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.09)*(IKcos(j[1]))*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((0.04)*(IKsin(j[1]))*(IKsin(j[4]))))+(((((((0.04)*(IKcos(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.04)*(IKcos(j[1]))*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))+(((((((-0.09)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[2]))))+(((-0.09)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[3]))))))*(IKcos(j[5]))))+(((-0.095)*(IKsin(j[1]))))+(((-0.235)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[2]))))+(((0.03)*(IKcos(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((((((0.04)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[3]))))+(((0.04)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[2]))))))*(IKsin(j[5]))))))*(IKcos(j[0]))))+(((((((-0.00776460427820108)*(IKcos(j[3]))*(IKsin(j[2]))))+(((((((0.0103528057042681)*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.0103528057042681)*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKsin(j[5]))))+(((0.0608227335125751)*(IKcos(j[2]))*(IKcos(j[3]))))+(((((((-0.0232938128346032)*(IKsin(j[2]))*(IKsin(j[3]))))+(((0.0232938128346032)*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKcos(j[5]))))+(((((((-0.0103528057042681)*(IKcos(j[2]))*(IKsin(j[3]))))+(((-0.0103528057042681)*(IKcos(j[3]))*(IKsin(j[2]))))))*(IKcos(j[4]))*(IKcos(j[5]))))+(((-0.0608227335125751)*(IKsin(j[2]))*(IKsin(j[3]))))+(((0.0647050356516757)*(IKcos(j[2]))))+(((-0.00776460427820108)*(IKcos(j[2]))*(IKsin(j[3]))))+(((((((-0.0232938128346032)*(IKcos(j[3]))*(IKsin(j[2]))))+(((-0.0232938128346032)*(IKcos(j[2]))*(IKsin(j[3]))))))*(IKcos(j[4]))*(IKsin(j[5]))))))*(IKsin(j[0]))))+(((-0.145)*(IKsin(j[0]))))+(((((((0.0289777659663912)*(IKcos(j[2]))*(IKcos(j[3]))*(IKsin(j[1]))))+(((((((-0.0386370212885216)*(IKcos(j[3]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((-0.0386370212885216)*(IKcos(j[2]))*(IKsin(j[1]))*(IKsin(j[3]))))))*(IKsin(j[5]))))+(((((((0.0869332978991737)*(IKcos(j[1]))*(IKsin(j[4]))))+(((-0.965925532213041)*(((((-0.09)*(IKcos(j[2]))*(IKcos(j[3]))*(IKsin(j[1]))))+(((0.09)*(IKsin(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((0.0386370212885216)*(IKcos(j[1]))*(IKsin(j[4]))))+(((-0.965925532213041)*(((((0.04)*(IKsin(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.04)*(IKcos(j[2]))*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))+(((((((0.0869332978991737)*(IKcos(j[2]))*(IKsin(j[1]))*(IKsin(j[3]))))+(((0.0869332978991737)*(IKcos(j[3]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKcos(j[5]))))+(((-0.0917629255602389)*(IKcos(j[1]))))+(((0.226992500070065)*(IKcos(j[3]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((0.226992500070065)*(IKcos(j[2]))*(IKsin(j[1]))*(IKsin(j[3]))))+(((-0.0289777659663912)*(IKsin(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((0.24148138305326)*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKsin(j[0])))));\neerot[3]=(((x22*((x35+x42))))+((x0*x31))+((x22*((x11+x21)))));\neerot[4]=(((x0*x56))+((x22*((x46+x52))))+((x22*((x60+x63)))));\neerot[5]=(((x22*((x67+x65))))+((x0*x68))+((x22*((x70+x72)))));\neetrans[1]=((((0.145)*(IKcos(j[0]))))+(((((((((((-0.0869332978991737)*(IKcos(j[2]))*(IKsin(j[1]))*(IKsin(j[3]))))+(((-0.0869332978991737)*(IKcos(j[3]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKcos(j[5]))))+(((0.0917629255602389)*(IKcos(j[1]))))+(((-0.226992500070065)*(IKcos(j[2]))*(IKsin(j[1]))*(IKsin(j[3]))))+(((((((0.965925532213041)*(((((-0.09)*(IKcos(j[2]))*(IKcos(j[3]))*(IKsin(j[1]))))+(((0.09)*(IKsin(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))))*(IKcos(j[4]))))+(((-0.0869332978991737)*(IKcos(j[1]))*(IKsin(j[4]))))))*(IKsin(j[5]))))+(((-0.226992500070065)*(IKcos(j[3]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((0.0289777659663912)*(IKsin(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((((((-0.0386370212885216)*(IKcos(j[1]))*(IKsin(j[4]))))+(((0.965925532213041)*(((((0.04)*(IKsin(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.04)*(IKcos(j[2]))*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))+(((((((0.0386370212885216)*(IKcos(j[2]))*(IKsin(j[1]))*(IKsin(j[3]))))+(((0.0386370212885216)*(IKcos(j[3]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKsin(j[5]))))+(((-0.0289777659663912)*(IKcos(j[2]))*(IKcos(j[3]))*(IKsin(j[1]))))+(((-0.24148138305326)*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKcos(j[0]))))+(((((((-0.0608227335125751)*(IKcos(j[2]))*(IKcos(j[3]))))+(((0.0608227335125751)*(IKsin(j[2]))*(IKsin(j[3]))))+(((0.00776460427820108)*(IKcos(j[3]))*(IKsin(j[2]))))+(((((((0.0232938128346032)*(IKcos(j[3]))*(IKsin(j[2]))))+(((0.0232938128346032)*(IKcos(j[2]))*(IKsin(j[3]))))))*(IKcos(j[4]))*(IKsin(j[5]))))+(((((((0.0103528057042681)*(IKcos(j[3]))*(IKsin(j[2]))))+(((0.0103528057042681)*(IKcos(j[2]))*(IKsin(j[3]))))))*(IKcos(j[4]))*(IKcos(j[5]))))+(((0.00776460427820108)*(IKcos(j[2]))*(IKsin(j[3]))))+(((((((0.0232938128346032)*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.0232938128346032)*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKcos(j[5]))))+(((((((0.0103528057042681)*(IKcos(j[2]))*(IKcos(j[3]))))+(((-0.0103528057042681)*(IKsin(j[2]))*(IKsin(j[3]))))))*(IKsin(j[5]))))+(((-0.0647050356516757)*(IKcos(j[2]))))))*(IKcos(j[0]))))+(((((((-0.235)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[3]))))+(((-0.03)*(IKcos(j[1]))*(IKcos(j[2]))*(IKcos(j[3]))))+(((-0.25)*(IKcos(j[1]))*(IKsin(j[2]))))+(((((((0.09)*(IKsin(j[1]))*(IKsin(j[4]))))+(((((((0.09)*(IKcos(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.09)*(IKcos(j[1]))*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((0.04)*(IKsin(j[1]))*(IKsin(j[4]))))+(((((((0.04)*(IKcos(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.04)*(IKcos(j[1]))*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))+(((((((-0.09)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[2]))))+(((-0.09)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[3]))))))*(IKcos(j[5]))))+(((-0.095)*(IKsin(j[1]))))+(((-0.235)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[2]))))+(((0.03)*(IKcos(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((((((0.04)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[3]))))+(((0.04)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[2]))))))*(IKsin(j[5]))))))*(IKsin(j[0])))));\neerot[6]=((((-1.0)*(1.0)*x13*x41))+(((-1.0)*(1.0)*x34*x73))+(((0.965925532213041)*x10))+((x20*x36)));\neerot[7]=((((-1.0)*(0.258820142606703)*x59))+(((-1.0)*(0.258820142606703)*x62))+(((0.965925532213041)*x45))+(((0.965925532213041)*x51)));\neerot[8]=((((0.965925532213041)*x66))+(((-1.0)*(0.258820142606703)*x71))+(((-1.0)*(0.258820142606703)*x69))+(((0.965925532213041)*x64)));\nIkReal x77=((1.0)*x13);\nIkReal x78=((1.0)*x73);\neetrans[2]=((0.370296)+((x14*x36*(((((0.04)*x15))+x74))))+(((0.00776460427820108)*x38))+((x36*(((((0.09)*x4))+(((-1.0)*(0.09)*x7))))))+(((-1.0)*x78*(((((0.04)*x33))+((x26*x74))))))+(((0.0647050356516757)*x2*x26))+((x14*x32*((x75+(((0.09)*x15))))))+(((0.0608227335125751)*x33))+(((0.0289777659663912)*x17))+(((-1.0)*x77*(((((-1.0)*(0.04)*x37))+(((-1.0)*(0.04)*x40))))))+(((-1.0)*(0.24148138305326)*x5))+(((0.226992500070065)*x4))+(((-1.0)*x78*(((((-1.0)*(0.09)*x40))+(((-1.0)*(0.09)*x37))))))+(((-1.0)*x77*(((((-1.0)*(0.09)*x33))+(((-1.0)*(1.0)*x26*x75))))))+(((0.0608227335125751)*x17*x26))+(((-1.0)*(0.00776460427820108)*x26*x4))+((x32*(((((-1.0)*(0.04)*x4))+(((0.04)*x7))))))+(((0.0289777659663912)*x15))+(((-1.0)*(0.0245879135476367)*x23))+(((-1.0)*(0.226992500070065)*x7)));\n}\n\nIKFAST_API int GetNumFreeParameters() { return 1; }\nIKFAST_API int* GetFreeParameters() { static int freeparams[] = {0}; return freeparams; }\nIKFAST_API int GetNumJoints() { return 7; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j11,cj11,sj11,htj11,j11mul,j12,cj12,sj12,htj12,j12mul,j13,cj13,sj13,htj13,j13mul,j14,cj14,sj14,htj14,j14mul,j15,cj15,sj15,htj15,j15mul,j16,cj16,sj16,htj16,j16mul,j0,cj0,sj0,htj0,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij11[2], _nj11,_ij12[2], _nj12,_ij13[2], _nj13,_ij14[2], _nj14,_ij15[2], _nj15,_ij16[2], _nj16,_ij0[2], _nj0;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj11=numeric_limits<IkReal>::quiet_NaN(); _ij11[0] = -1; _ij11[1] = -1; _nj11 = -1; j12=numeric_limits<IkReal>::quiet_NaN(); _ij12[0] = -1; _ij12[1] = -1; _nj12 = -1; j13=numeric_limits<IkReal>::quiet_NaN(); _ij13[0] = -1; _ij13[1] = -1; _nj13 = -1; j14=numeric_limits<IkReal>::quiet_NaN(); _ij14[0] = -1; _ij14[1] = -1; _nj14 = -1; j15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1; j16=numeric_limits<IkReal>::quiet_NaN(); _ij16[0] = -1; _ij16[1] = -1; _nj16 = -1;  _ij0[0] = -1; _ij0[1] = -1; _nj0 = 0; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nj0=pfree[0]; cj0=cos(pfree[0]); sj0=sin(pfree[0]), htj0=tan(pfree[0]*0.5);\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=((((-1.0)*(1.0)*r12*(IKsin(j0))))+(((-1.0)*(1.0)*r02*(IKcos(j0)))));\nnew_r01=(((r01*(IKcos(j0))))+((r11*(IKsin(j0)))));\nnew_r02=(((r00*(IKcos(j0))))+((r10*(IKsin(j0)))));\nnew_px=(((((px+(((0.04)*r00))))*(IKcos(j0))))+(((((((0.04)*r10))+py))*(IKsin(j0)))));\nnew_r10=((((0.965925532213041)*r02*(IKsin(j0))))+(((-1.0)*(0.965925532213041)*r12*(IKcos(j0))))+(((0.258820142606703)*r22)));\nnew_r11=((((-1.0)*(0.965925532213041)*r01*(IKsin(j0))))+(((-1.0)*(0.258820142606703)*r21))+(((0.965925532213041)*r11*(IKcos(j0)))));\nnew_r12=((((0.965925532213041)*r10*(IKcos(j0))))+(((-1.0)*(0.258820142606703)*r20))+(((-1.0)*(0.965925532213041)*r00*(IKsin(j0)))));\nnew_py=((-0.0442191386441994)+(((-1.0)*(0.258820142606703)*pz))+(((-1.0)*(0.0103528057042681)*r20))+(((((((0.0386370212885216)*r10))+(((0.965925532213041)*py))))*(IKcos(j0))))+(((((((-1.0)*(0.0386370212885216)*r00))+(((-1.0)*(0.965925532213041)*px))))*(IKsin(j0)))));\nnew_r20=((((-1.0)*(0.965925532213041)*r22))+(((-1.0)*(0.258820142606703)*r12*(IKcos(j0))))+(((0.258820142606703)*r02*(IKsin(j0)))));\nnew_r21=((((0.258820142606703)*r11*(IKcos(j0))))+(((-1.0)*(0.258820142606703)*r01*(IKsin(j0))))+(((0.965925532213041)*r21)));\nnew_r22=((((-1.0)*(0.258820142606703)*r00*(IKsin(j0))))+(((0.258820142606703)*r10*(IKcos(j0))))+(((0.965925532213041)*r20)));\nnew_pz=((-0.395207281554332)+(((((((-1.0)*(0.258820142606703)*px))+(((-1.0)*(0.0103528057042681)*r00))))*(IKsin(j0))))+(((0.965925532213041)*pz))+(((0.0386370212885216)*r20))+(((((((0.0103528057042681)*r10))+(((0.258820142606703)*py))))*(IKcos(j0)))));\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x79=((1.0)*py);\nIkReal x80=((1.0)*pz);\nIkReal x81=((1.0)*px);\npp=((pz*pz)+(py*py)+(px*px));\nnpx=(((pz*r20))+((py*r10))+((px*r00)));\nnpy=(((pz*r21))+((py*r11))+((px*r01)));\nnpz=(((px*r02))+((pz*r22))+((py*r12)));\nrxp0_0=((((-1.0)*r20*x79))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x80)));\nrxp0_2=((((-1.0)*r10*x81))+((py*r00)));\nrxp1_0=((((-1.0)*r21*x79))+((pz*r11)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x80)));\nrxp1_2=((((-1.0)*r11*x81))+((py*r01)));\nrxp2_0=((((-1.0)*r22*x79))+((pz*r12)));\nrxp2_1=((((-1.0)*r02*x80))+((px*r22)));\nrxp2_2=(((py*r02))+(((-1.0)*r12*x81)));\nIkReal op[72], zeror[48];\nint numroots;;\nIkReal x82=(cj14*r21);\nIkReal x83=(r22*sj14);\nIkReal x84=((2.0)*r20);\nIkReal x85=(cj14*x84);\nIkReal x86=((-1.0)*x82);\nIkReal x87=((0.57)*r20);\nIkReal x88=((6.0)*rxp0_0);\nIkReal x89=(x87+x88);\nIkReal x90=((65.0)*npx);\nIkReal x91=((100.0)*pp);\nIkReal x92=((6.0)*rxp0_1);\nIkReal x93=(x91+x92);\nIkReal x94=((1.14)*r21);\nIkReal x95=((12.0)*rxp1_0);\nIkReal x96=((12.0)*rxp1_1);\nIkReal x97=((((-1.0)*x88))+(((-1.0)*x87)));\nIkReal x98=(x91+(((-1.0)*x92)));\nIkReal x99=(r21*sj14);\nIkReal x100=(cj14*r22);\nIkReal x101=((-1.0)*x100);\nIkReal x102=((2.0)*r01);\nIkReal x103=(sj14*x84);\nIkReal x104=((2.0)*r11);\nIkReal x105=((-1.0)*(((1.0)*r00)));\nIkReal x106=((-1.0)*x99);\nIkReal x107=((-1.0)*(((1.0)*r10)));\nIkReal x108=((0.095)*r00);\nIkReal x109=((((-1.0)*x108))+rxp0_2);\nIkReal x110=((0.095)*r10);\nIkReal x111=((-1.0)*x110);\nIkReal x112=((0.19)*r01);\nIkReal x113=((2.0)*rxp1_2);\nIkReal x114=((0.19)*r11);\nIkReal x115=(x108+(((-1.0)*(1.0)*rxp0_2)));\nIkReal x116=((1.08)*r01);\nIkReal x117=((((1.14)*r22))+(((12.0)*rxp2_0)));\nIkReal x118=((1.08)*r11);\nIkReal x119=((((12.0)*rxp2_1))+(((-1.0)*(94.0)*npz)));\nIkReal x120=((2.0)*r02);\nIkReal x121=((2.0)*r12);\nIkReal x122=((0.18)*r21);\nIkReal x123=((((2.0)*rxp2_2))+(((-1.0)*(0.19)*r02)));\nIkReal x124=((-1.0)*(((0.19)*r12)));\nIkReal x125=((-1.0)*x83);\nIkReal x126=((29.0)*npx);\nop[0]=(x83+x82);\nop[1]=0;\nop[2]=x85;\nop[3]=0;\nop[4]=(x86+x83);\nop[5]=0;\nop[6]=x89;\nop[7]=((3.5)+x93+(((-1.0)*x90)));\nop[8]=((((-1.0)*x94))+(((-1.0)*x95)));\nop[9]=((((130.0)*npy))+(((-1.0)*x96)));\nop[10]=x97;\nop[11]=((3.5)+x98+x90);\nop[12]=(x101+x99+r00);\nop[13]=r10;\nop[14]=(x103+(((-1.0)*x102)));\nop[15]=((-1.0)*x104);\nop[16]=(x105+x106+x101);\nop[17]=x107;\nop[18]=x109;\nop[19]=x111;\nop[20]=((((-1.0)*x113))+x112);\nop[21]=x114;\nop[22]=x115;\nop[23]=x110;\nop[24]=((-1.0)*x103);\nop[25]=0;\nop[26]=((4.0)*x99);\nop[27]=0;\nop[28]=x103;\nop[29]=0;\nop[30]=((((-1.0)*x116))+x117);\nop[31]=((((-1.0)*x118))+x119);\nop[32]=((-1.0)*(((2.16)*r00)));\nop[33]=((-1.0)*(((2.16)*r10)));\nop[34]=(x117+x116);\nop[35]=(x119+x118);\nop[36]=(x120+x85);\nop[37]=x121;\nop[38]=((-4.0)*x82);\nop[39]=0;\nop[40]=(x120+(((-1.0)*x85)));\nop[41]=x121;\nop[42]=(x123+(((-1.0)*x122)));\nop[43]=x124;\nop[44]=((-1.0)*(((0.36)*r20)));\nop[45]=0;\nop[46]=(x122+x123);\nop[47]=x124;\nop[48]=(x125+x82);\nop[49]=0;\nop[50]=x85;\nop[51]=0;\nop[52]=(x125+x86);\nop[53]=0;\nop[54]=x97;\nop[55]=((-4.96)+x126+x98);\nop[56]=(x95+x94);\nop[57]=(x96+(((-1.0)*(58.0)*npy)));\nop[58]=x89;\nop[59]=((-4.96)+x93+(((-1.0)*x126)));\nop[60]=(x105+x100+x99);\nop[61]=x107;\nop[62]=(x102+x103);\nop[63]=x104;\nop[64]=(x106+x100+r00);\nop[65]=r10;\nop[66]=x115;\nop[67]=x110;\nop[68]=((((-1.0)*x112))+x113);\nop[69]=((-1.0)*x114);\nop[70]=x109;\nop[71]=x111;\nsolvedialyticpoly8qep(op,zeror,numroots);\nIkReal j15array[16], cj15array[16], sj15array[16], j16array[16], cj16array[16], sj16array[16], j11array[16], cj11array[16], sj11array[16];\nint numsolutions = 0;\nfor(int ij15 = 0; ij15 < numroots; ij15 += 3)\n{\nIkReal htj15 = zeror[ij15+0], htj16 = zeror[ij15+1], htj11 = zeror[ij15+2];\nif(isnan(htj15)||isnan(htj16)||isnan(htj11)){\ncontinue;\n}\nj15array[numsolutions]=((2.0)*(atan(htj15)));\nj16array[numsolutions]=((2.0)*(atan(htj16)));\nj11array[numsolutions]=((2.0)*(atan(htj11)));\nif(isinf(htj15)){\ncj15array[numsolutions] = IKcos(j15array[numsolutions]);\nsj15array[numsolutions] = IKsin(j15array[numsolutions]);\n}\nelse{\nIkReal x127=htj15*htj15;\nCheckValue<IkReal> x128=IKPowWithIntegerCheck(((1.0)+x127),-1);\nif(!x128.valid){\ncontinue;\n}\ncj15array[numsolutions]=((x128.value)*(((1.0)+(((-1.0)*x127)))));\nCheckValue<IkReal> x129=IKPowWithIntegerCheck(((1.0)+(htj15*htj15)),-1);\nif(!x129.valid){\ncontinue;\n}\nsj15array[numsolutions]=((2.0)*htj15*(x129.value));\n}\nif(isinf(htj16)){\ncj16array[numsolutions] = IKcos(j16array[numsolutions]);\nsj16array[numsolutions] = IKsin(j16array[numsolutions]);\n}\nelse{\nIkReal x130=htj16*htj16;\nCheckValue<IkReal> x131=IKPowWithIntegerCheck(((1.0)+x130),-1);\nif(!x131.valid){\ncontinue;\n}\ncj16array[numsolutions]=((x131.value)*(((1.0)+(((-1.0)*x130)))));\nCheckValue<IkReal> x132=IKPowWithIntegerCheck(((1.0)+(htj16*htj16)),-1);\nif(!x132.valid){\ncontinue;\n}\nsj16array[numsolutions]=((2.0)*htj16*(x132.value));\n}\nif(isinf(htj11)){\ncj11array[numsolutions] = IKcos(j11array[numsolutions]);\nsj11array[numsolutions] = IKsin(j11array[numsolutions]);\n}\nelse{\nIkReal x133=htj11*htj11;\nCheckValue<IkReal> x134=IKPowWithIntegerCheck(((1.0)+x133),-1);\nif(!x134.valid){\ncontinue;\n}\ncj11array[numsolutions]=((x134.value)*(((1.0)+(((-1.0)*x133)))));\nCheckValue<IkReal> x135=IKPowWithIntegerCheck(((1.0)+(htj11*htj11)),-1);\nif(!x135.valid){\ncontinue;\n}\nsj11array[numsolutions]=((2.0)*htj11*(x135.value));\n}\nif( j15array[numsolutions] > IKPI )\n{\n    j15array[numsolutions]-=IK2PI;\n}\nelse if( j15array[numsolutions] < -IKPI )\n{\n    j15array[numsolutions]+=IK2PI;\n}\nif( j16array[numsolutions] > IKPI )\n{\n    j16array[numsolutions]-=IK2PI;\n}\nelse if( j16array[numsolutions] < -IKPI )\n{\n    j16array[numsolutions]+=IK2PI;\n}\nif( j11array[numsolutions] > IKPI )\n{\n    j11array[numsolutions]-=IK2PI;\n}\nelse if( j11array[numsolutions] < -IKPI )\n{\n    j11array[numsolutions]+=IK2PI;\n}\nnumsolutions++;\n}\nbool j15valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};\n_nj15 = 16;\n_nj16 = 1;\n_nj11 = 1;\nfor(int ij15 = 0; ij15 < numsolutions; ++ij15)\n    {\nif( !j15valid[ij15] )\n{\n    continue;\n}\n_ij15[0] = ij15; _ij15[1] = -1;\n_ij16[0] = 0; _ij16[1] = -1;\n_ij11[0] = 0; _ij11[1] = -1;\nfor(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)\n{\nif( !j15valid[iij15] ) { continue; }\nif( IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(cj16array[ij15]-cj16array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij15]-sj16array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(cj11array[ij15]-cj11array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj11array[ij15]-sj11array[iij15]) < IKFAST_SOLUTION_THRESH &&  1 )\n{\n    j15valid[iij15]=false; _ij15[1] = iij15; _ij16[1] = 0; _ij11[1] = 0;  break; \n}\n}\n    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];\n\n    j16 = j16array[ij15]; cj16 = cj16array[ij15]; sj16 = sj16array[ij15];\n\n    j11 = j11array[ij15]; cj11 = cj11array[ij15]; sj11 = sj11array[ij15];\n\ninnerfn(solutions);\n    }\n}\nreturn solutions.GetNumSolutions()>0;\n}\nstatic inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[3];\n    const int maxsteps = 110;\n    for(int i = 0; i < 3; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[3];\n    IkReal err[3];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 3; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 3; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 3; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 3; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[3] = {false};\n    for(int i = 0; i < 3; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 3; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {\n    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];\n    if( det < 0 ) {\n        numroots=0;\n    }\n    else if( det == 0 ) {\n        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];\n        numroots = 1;\n    }\n    else {\n        det = IKsqrt(det);\n        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);\n        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);\n        numroots = 2;\n    }\n}\nstatic inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[5];\n    const int maxsteps = 110;\n    for(int i = 0; i < 5; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[5];\n    IkReal err[5];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 5; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 5; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 5; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 5; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[5] = {false};\n    for(int i = 0; i < 5; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 5; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[4];\n    const int maxsteps = 110;\n    for(int i = 0; i < 4; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[4];\n    IkReal err[4];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 4; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 4; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 4; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 4; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[4] = {false};\n    for(int i = 0; i < 4; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 4; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[6];\n    const int maxsteps = 110;\n    for(int i = 0; i < 6; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[6];\n    IkReal err[6];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 6; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 6; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 6; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 6; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[6] = {false};\n    for(int i = 0; i < 6; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 6; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\ninline void innerfn(IkSolutionListBase<IkReal>& solutions) {\nfor(int fniter = 0; fniter < 1; ++fniter) {\n{\nIkReal j14eval[3];\nIkReal x136=((1.0)*cj15);\nIkReal x137=(((cj15*r01*sj16))+(((-1.0)*r02*sj15))+(((-1.0)*cj16*r00*x136)));\nIkReal x138=(cj11*cj16);\nIkReal x139=(cj11*sj16);\nj14eval[0]=x137;\nj14eval[1]=IKsign(x137);\nj14eval[2]=((IKabs((((r20*x139))+((r21*x138)))))+(IKabs((((r20*sj15*x138))+(((-1.0)*cj11*r22*x136))+(((-1.0)*r21*sj15*x139))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nIkReal x140=(((cj15*cj16*r10))+((r12*sj15))+(((-1.0)*(1.0)*cj15*r11*sj16)));\nIkReal x141=(r21*sj11);\nIkReal x142=(r20*sj11);\nj14eval[0]=x140;\nj14eval[1]=IKsign(x140);\nj14eval[2]=((IKabs((((cj15*r22*sj11))+((sj15*sj16*x141))+(((-1.0)*cj16*sj15*x142)))))+(IKabs((((cj16*x141))+((sj16*x142))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[2];\nIkReal x143=((((-1.0)*(1.0)*r22*sj15))+((cj15*r21*sj16))+(((-1.0)*(1.0)*cj15*cj16*r20)));\nj14eval[0]=x143;\nj14eval[1]=IKsign(x143);\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x144=(cj16*r10);\nIkReal x145=(r11*sj16);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j11))), 6.28318530717959)));\nevalcond[1]=((((-1.0)*cj15*x145))+((r12*sj15))+((cj15*x144)));\nevalcond[2]=((0.095)+(((-1.0)*(1.0)*py))+(((-0.09)*x145))+(((0.09)*x144)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j14eval[3];\nsj11=0;\ncj11=1.0;\nj11=0;\nIkReal x146=((1.0)*cj15);\nIkReal x147=(((r22*sj15))+(((-1.0)*r21*sj16*x146))+((cj15*cj16*r20)));\nj14eval[0]=x147;\nj14eval[1]=((IKabs((((r00*sj16))+((cj16*r01)))))+(IKabs(((((-1.0)*(1.0)*r01*sj15*sj16))+(((-1.0)*r02*x146))+((cj16*r00*sj15))))));\nj14eval[2]=IKsign(x147);\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=0;\ncj11=1.0;\nj11=0;\nIkReal x148=((1.0)*sj15);\nIkReal x149=((1.0)*cj15);\nIkReal x150=((((-1.0)*r02*x148))+((cj15*r01*sj16))+(((-1.0)*cj16*r00*x149)));\nj14eval[0]=x150;\nj14eval[1]=IKsign(x150);\nj14eval[2]=((IKabs((((cj16*r21))+((r20*sj16)))))+(IKabs(((((-1.0)*r21*sj16*x148))+(((-1.0)*r22*x149))+((cj16*r20*sj15))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=0;\ncj11=1.0;\nj11=0;\nIkReal x151=r10*r10;\nIkReal x152=r11*r11;\nIkReal x153=cj15*cj15;\nIkReal x154=((2.0)*cj15*r12);\nIkReal x155=(cj16*r10*sj15);\nIkReal x156=(r11*sj15*sj16);\nIkReal x157=(x152*x153);\nIkReal x158=(r10*sj16);\nIkReal x159=cj16*cj16;\nIkReal x160=(((x153*(r12*r12)))+((x157*x159))+(((-1.0)*x157))+x152+x151+(((-1.0)*x154*x155))+((x154*x156))+(((-1.0)*x151*x153*x159))+(((2.0)*cj16*r11*x153*x158)));\nj14eval[0]=x160;\nj14eval[1]=((IKabs((x156+((cj15*r12))+(((-1.0)*x155)))))+(IKabs((x158+((cj16*r11))))));\nj14eval[2]=IKsign(x160);\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j12, j13, j14]\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x161=(r11*sj15*sj16);\nIkReal x162=(cj16*r10*sj15);\nIkReal x163=(r10*sj16);\nIkReal x164=r10*r10;\nIkReal x165=r11*r11;\nIkReal x166=cj15*cj15;\nIkReal x167=((2.0)*cj15*r12);\nIkReal x168=(x165*x166);\nIkReal x169=cj16*cj16;\nCheckValue<IkReal> x170 = IKatan2WithCheck(IkReal(((((-1.0)*x162))+((cj15*r12))+x161)),IkReal((((cj16*r11))+x163)),IKFAST_ATAN2_MAGTHRESH);\nif(!x170.valid){\ncontinue;\n}\nCheckValue<IkReal> x171=IKPowWithIntegerCheck(IKsign(((((-1.0)*x162*x167))+(((-1.0)*x168))+(((-1.0)*x164*x166*x169))+((x166*(r12*r12)))+((x161*x167))+x164+x165+((x168*x169))+(((2.0)*cj16*r11*x163*x166)))),-1);\nif(!x171.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x170.value)+(((1.5707963267949)*(x171.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x172=IKsin(j14);\nIkReal x173=(cj16*r11);\nIkReal x174=(r10*sj16);\nIkReal x175=IKcos(j14);\nIkReal x176=((1.0)*x175);\nIkReal x177=((1.0)*sj16*x175);\nIkReal x178=((1.0)*cj15*x172);\nIkReal x179=((1.0)*cj16*x175);\nIkReal x180=(cj16*sj15*x172);\nIkReal x181=((1.0)*sj15*sj16*x172);\nevalcond[0]=((((-1.0)*r11*sj15*x177))+(((-1.0)*cj15*r12*x176))+((x172*x173))+((cj16*r10*sj15*x175))+((x172*x174)));\nevalcond[1]=((((-1.0)*r20*x177))+(((-1.0)*r21*x181))+(((-1.0)*r22*x178))+((r20*x180))+(((-1.0)*r21*x179)));\nevalcond[2]=((((-1.0)*r01*x179))+(((-1.0)*r00*x177))+(((-1.0)*r02*x178))+(((-1.0)*r01*x181))+((r00*x180)));\nevalcond[3]=((1.0)+(((-1.0)*x174*x176))+(((-1.0)*r12*x178))+(((-1.0)*x173*x176))+((r10*x180))+(((-1.0)*r11*x181)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=0;\ncj11=1.0;\nj11=0;\nIkReal x182=(cj16*r20);\nIkReal x183=(r02*sj15);\nIkReal x184=(r21*sj16);\nIkReal x185=(r22*sj15);\nIkReal x186=(cj15*cj16*r00);\nIkReal x187=(cj15*cj16*r20);\nIkReal x188=(cj15*r01*sj16);\nIkReal x189=(cj15*r21*sj16);\nIkReal x190=((((-0.36)*x186))+(((2.82)*x187))+(((-1.0)*(12.0)*pz))+(((-2.82)*x189))+(((0.36)*x188))+(((-1.08)*x184))+(((1.08)*x182))+(((-0.36)*x183))+(((2.82)*x185)));\nj12eval[0]=((IKabs(((-1.0)+x190)))+(IKabs(((1.0)+(((-0.12)*x186))+(((-0.94)*x189))+(((-1.0)*(4.0)*pz))+(((0.12)*x188))+(((-0.36)*x184))+(((0.94)*x185))+(((-0.12)*x183))+(((0.94)*x187))+(((0.36)*x182)))))+(IKabs(((1.0)+x190))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x191=(cj16*r20);\nIkReal x192=(r02*sj15);\nIkReal x193=(r21*sj16);\nIkReal x194=(r22*sj15);\nIkReal x195=(cj15*cj16*r00);\nIkReal x196=(cj15*cj16*r20);\nIkReal x197=(cj15*r01*sj16);\nIkReal x198=(cj15*r21*sj16);\nIkReal x199=((((-0.12)*x195))+(((-0.36)*x193))+(((-0.94)*x198))+(((-1.0)*(4.0)*pz))+(((-0.12)*x192))+(((0.94)*x194))+(((0.36)*x191))+(((0.94)*x196))+(((0.12)*x197)));\nIkReal x200=((((-1.08)*x193))+(((-1.0)*(12.0)*pz))+(((0.36)*x197))+(((-0.36)*x192))+(((2.82)*x194))+(((-0.36)*x195))+(((1.08)*x191))+(((-2.82)*x198))+(((2.82)*x196)));\nop[0]=((1.0)+x199);\nop[1]=0;\nop[2]=((1.0)+x200);\nop[3]=0;\nop[4]=((-1.0)+x200);\nop[5]=0;\nop[6]=((-1.0)+x199);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x201=(cj16*r00);\nIkReal x202=(cj16*r20);\nIkReal x203=(r01*sj16);\nIkReal x204=(r21*sj16);\nIkReal x205=(r22*sj15);\nIkReal x206=(cj15*cj16*r20);\nIkReal x207=(cj15*r21*sj16);\nIkReal x208=((((-0.0846)*x204))+(((0.0108)*x201))+(((0.2245)*x206))+(((-1.0)*(0.94)*pz))+(((0.2245)*x205))+(((-0.2245)*x207))+(((0.0846)*x202))+(((-0.0108)*x203))+(((-1.0)*(0.12)*px)));\nIkReal x209=((((-1.0)*(0.36)*px))+(((-0.6735)*x207))+(((0.6735)*x206))+(((0.6735)*x205))+(((0.0324)*x201))+(((-1.0)*(2.82)*pz))+(((-0.0324)*x203))+(((-0.2538)*x204))+(((0.2538)*x202)));\nj12evalpoly[0]=((-0.235)+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((0.235)+x208))))+(((-1.0)*(0.12)*(htj12*htj12*htj12)))+(((htj12*htj12*htj12*htj12)*(((0.235)+x209))))+(((-1.0)*(0.06)*htj12))+(((htj12*htj12)*(((-0.235)+x209))))+x208+(((-1.0)*(0.06)*(htj12*htj12*htj12*htj12*htj12))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x210=(r22*sj15);\nIkReal x211=((1.0)*cj12);\nIkReal x212=(r02*sj15);\nIkReal x213=(cj12*cj15*sj16);\nIkReal x214=(cj15*sj12);\nIkReal x215=(cj16*r20);\nIkReal x216=(cj16*r00);\nIkReal x217=((1.0)*cj12*cj15);\nIkReal x218=((1.0)*cj15*sj12);\nif( IKabs((((sj12*x210))+((x214*x215))+(((-1.0)*x211*x212))+(((-1.0)*r21*sj16*x218))+(((-1.0)*x216*x217))+((r01*x213)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj12*x212))+(((-1.0)*x215*x217))+((r21*x213))+((r01*sj16*x214))+(((-1.0)*x216*x218))+(((-1.0)*x210*x211)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj12*x210))+((x214*x215))+(((-1.0)*x211*x212))+(((-1.0)*r21*sj16*x218))+(((-1.0)*x216*x217))+((r01*x213))))+IKsqr(((((-1.0)*sj12*x212))+(((-1.0)*x215*x217))+((r21*x213))+((r01*sj16*x214))+(((-1.0)*x216*x218))+(((-1.0)*x210*x211))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((sj12*x210))+((x214*x215))+(((-1.0)*x211*x212))+(((-1.0)*r21*sj16*x218))+(((-1.0)*x216*x217))+((r01*x213))), ((((-1.0)*sj12*x212))+(((-1.0)*x215*x217))+((r21*x213))+((r01*sj16*x214))+(((-1.0)*x216*x218))+(((-1.0)*x210*x211))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x219=IKsin(j13);\nIkReal x220=(cj12*x219);\nIkReal x221=IKcos(j13);\nIkReal x222=(sj12*x221);\nIkReal x223=(cj15*cj16);\nIkReal x224=((1.0)*cj15*sj16);\nIkReal x225=(cj12*x221);\nIkReal x226=(sj12*x219);\nIkReal x227=((((-1.0)*x226))+x225);\nIkReal x228=(cj16*sj14);\nIkReal x229=(sj14*sj16);\nIkReal x230=((1.0)*cj14*cj15);\nIkReal x231=(cj14*cj16*sj15);\nIkReal x232=((1.0)*cj14*sj15*sj16);\nIkReal x233=((0.09)*cj16);\nIkReal x234=((0.09)*sj16);\nevalcond[0]=(((r00*x223))+((r02*sj15))+(((-1.0)*r01*x224))+x220+x222);\nevalcond[1]=(((r22*sj15))+(((-1.0)*r21*x224))+((r20*x223))+x227);\nevalcond[2]=(((r00*x229))+((r01*x228))+(((-1.0)*r01*x232))+(((-1.0)*r02*x230))+((r00*x231))+x227);\nevalcond[3]=(((r20*x231))+((r20*x229))+(((-1.0)*x222))+(((-1.0)*r22*x230))+((r21*x228))+(((-1.0)*r21*x232))+(((-1.0)*x220)));\nevalcond[4]=((((-1.0)*(1.0)*pz))+((r20*x233))+(((0.03)*x222))+(((-0.235)*x225))+(((0.03)*x220))+(((-1.0)*(0.25)*cj12))+(((0.235)*x226))+(((-1.0)*r21*x234)));\nevalcond[5]=((((-1.0)*r01*x234))+(((-1.0)*(1.0)*px))+(((-0.235)*x222))+(((-1.0)*(0.25)*sj12))+(((-0.235)*x220))+((r00*x233))+(((-0.03)*x225))+(((0.03)*x226)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x235=((1.0)*sj15);\nIkReal x236=((1.0)*cj15);\nCheckValue<IkReal> x237 = IKatan2WithCheck(IkReal((((cj16*r21))+((r20*sj16)))),IkReal(((((-1.0)*r21*sj16*x235))+((cj16*r20*sj15))+(((-1.0)*r22*x236)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x237.valid){\ncontinue;\n}\nCheckValue<IkReal> x238=IKPowWithIntegerCheck(IKsign(((((-1.0)*r02*x235))+((cj15*r01*sj16))+(((-1.0)*cj16*r00*x236)))),-1);\nif(!x238.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x237.value)+(((1.5707963267949)*(x238.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x239=IKsin(j14);\nIkReal x240=(cj16*r11);\nIkReal x241=(r10*sj16);\nIkReal x242=IKcos(j14);\nIkReal x243=((1.0)*x242);\nIkReal x244=((1.0)*sj16*x242);\nIkReal x245=((1.0)*cj15*x239);\nIkReal x246=((1.0)*cj16*x242);\nIkReal x247=(cj16*sj15*x239);\nIkReal x248=((1.0)*sj15*sj16*x239);\nevalcond[0]=(((x239*x241))+(((-1.0)*r11*sj15*x244))+(((-1.0)*cj15*r12*x243))+((cj16*r10*sj15*x242))+((x239*x240)));\nevalcond[1]=((((-1.0)*r21*x246))+(((-1.0)*r20*x244))+(((-1.0)*r22*x245))+((r20*x247))+(((-1.0)*r21*x248)));\nevalcond[2]=((((-1.0)*r01*x248))+(((-1.0)*r01*x246))+(((-1.0)*r00*x244))+((r00*x247))+(((-1.0)*r02*x245)));\nevalcond[3]=((1.0)+(((-1.0)*r12*x245))+(((-1.0)*x240*x243))+(((-1.0)*r11*x248))+(((-1.0)*x241*x243))+((r10*x247)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=0;\ncj11=1.0;\nj11=0;\nIkReal x249=(cj16*r20);\nIkReal x250=(r02*sj15);\nIkReal x251=(r21*sj16);\nIkReal x252=(r22*sj15);\nIkReal x253=(cj15*cj16*r00);\nIkReal x254=(cj15*cj16*r20);\nIkReal x255=(cj15*r01*sj16);\nIkReal x256=(cj15*r21*sj16);\nIkReal x257=((((-1.0)*(12.0)*pz))+(((-1.08)*x251))+(((2.82)*x252))+(((-0.36)*x253))+(((2.82)*x254))+(((-2.82)*x256))+(((-0.36)*x250))+(((0.36)*x255))+(((1.08)*x249)));\nj12eval[0]=((IKabs(((1.0)+x257)))+(IKabs(((1.0)+(((-0.94)*x256))+(((0.12)*x255))+(((-1.0)*(4.0)*pz))+(((0.94)*x252))+(((-0.12)*x250))+(((-0.12)*x253))+(((0.94)*x254))+(((-0.36)*x251))+(((0.36)*x249)))))+(IKabs(((-1.0)+x257))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x258=(cj16*r20);\nIkReal x259=(r02*sj15);\nIkReal x260=(r21*sj16);\nIkReal x261=(r22*sj15);\nIkReal x262=(cj15*cj16*r00);\nIkReal x263=(cj15*cj16*r20);\nIkReal x264=(cj15*r01*sj16);\nIkReal x265=(cj15*r21*sj16);\nIkReal x266=((((-0.12)*x262))+(((-0.36)*x260))+(((0.36)*x258))+(((-1.0)*(4.0)*pz))+(((-0.12)*x259))+(((0.94)*x263))+(((-0.94)*x265))+(((0.94)*x261))+(((0.12)*x264)));\nIkReal x267=((((1.08)*x258))+(((0.36)*x264))+(((-1.0)*(12.0)*pz))+(((2.82)*x263))+(((-0.36)*x259))+(((-2.82)*x265))+(((-1.08)*x260))+(((2.82)*x261))+(((-0.36)*x262)));\nop[0]=((1.0)+x266);\nop[1]=0;\nop[2]=((1.0)+x267);\nop[3]=0;\nop[4]=((-1.0)+x267);\nop[5]=0;\nop[6]=((-1.0)+x266);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x268=(cj16*r00);\nIkReal x269=(cj16*r20);\nIkReal x270=(r01*sj16);\nIkReal x271=(r21*sj16);\nIkReal x272=(r22*sj15);\nIkReal x273=(cj15*cj16*r20);\nIkReal x274=(cj15*r21*sj16);\nIkReal x275=((((-0.0846)*x271))+(((0.0846)*x269))+(((-0.2245)*x274))+(((0.2245)*x273))+(((0.2245)*x272))+(((-1.0)*(0.94)*pz))+(((0.0108)*x268))+(((-0.0108)*x270))+(((-1.0)*(0.12)*px)));\nIkReal x276=((((-1.0)*(0.36)*px))+(((-0.6735)*x274))+(((0.2538)*x269))+(((-0.2538)*x271))+(((0.6735)*x272))+(((0.0324)*x268))+(((-1.0)*(2.82)*pz))+(((0.6735)*x273))+(((-0.0324)*x270)));\nj12evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj12*htj12*htj12)))+(((-1.0)*(0.06)*htj12))+x275+(((htj12*htj12*htj12*htj12)*(((0.235)+x276))))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((0.235)+x275))))+(((-1.0)*(0.06)*(htj12*htj12*htj12*htj12*htj12)))+(((htj12*htj12)*(((-0.235)+x276)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x277=(r22*sj15);\nIkReal x278=((1.0)*cj12);\nIkReal x279=(r02*sj15);\nIkReal x280=(cj12*cj15*sj16);\nIkReal x281=(cj15*sj12);\nIkReal x282=(cj16*r20);\nIkReal x283=(cj16*r00);\nIkReal x284=((1.0)*cj12*cj15);\nIkReal x285=((1.0)*cj15*sj12);\nif( IKabs((((sj12*x277))+((r01*x280))+(((-1.0)*x283*x284))+((x281*x282))+(((-1.0)*r21*sj16*x285))+(((-1.0)*x278*x279)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x283*x285))+(((-1.0)*x282*x284))+(((-1.0)*sj12*x279))+((r21*x280))+(((-1.0)*x277*x278))+((r01*sj16*x281)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj12*x277))+((r01*x280))+(((-1.0)*x283*x284))+((x281*x282))+(((-1.0)*r21*sj16*x285))+(((-1.0)*x278*x279))))+IKsqr(((((-1.0)*x283*x285))+(((-1.0)*x282*x284))+(((-1.0)*sj12*x279))+((r21*x280))+(((-1.0)*x277*x278))+((r01*sj16*x281))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((sj12*x277))+((r01*x280))+(((-1.0)*x283*x284))+((x281*x282))+(((-1.0)*r21*sj16*x285))+(((-1.0)*x278*x279))), ((((-1.0)*x283*x285))+(((-1.0)*x282*x284))+(((-1.0)*sj12*x279))+((r21*x280))+(((-1.0)*x277*x278))+((r01*sj16*x281))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x286=IKsin(j13);\nIkReal x287=(cj12*x286);\nIkReal x288=IKcos(j13);\nIkReal x289=(sj12*x288);\nIkReal x290=(cj15*cj16);\nIkReal x291=((1.0)*cj15*sj16);\nIkReal x292=(cj12*x288);\nIkReal x293=(sj12*x286);\nIkReal x294=(x292+(((-1.0)*x293)));\nIkReal x295=(cj16*sj14);\nIkReal x296=(sj14*sj16);\nIkReal x297=((1.0)*cj14*cj15);\nIkReal x298=(cj14*cj16*sj15);\nIkReal x299=((1.0)*cj14*sj15*sj16);\nIkReal x300=((0.09)*cj16);\nIkReal x301=((0.09)*sj16);\nevalcond[0]=(((r02*sj15))+((r00*x290))+(((-1.0)*r01*x291))+x287+x289);\nevalcond[1]=((((-1.0)*r21*x291))+x294+((r22*sj15))+((r20*x290)));\nevalcond[2]=(((r01*x295))+x294+((r00*x298))+(((-1.0)*r01*x299))+((r00*x296))+(((-1.0)*r02*x297)));\nevalcond[3]=(((r20*x298))+(((-1.0)*r22*x297))+((r21*x295))+(((-1.0)*x287))+(((-1.0)*r21*x299))+((r20*x296))+(((-1.0)*x289)));\nevalcond[4]=((((-1.0)*r21*x301))+(((-0.235)*x292))+(((0.235)*x293))+(((-1.0)*(1.0)*pz))+(((0.03)*x289))+((r20*x300))+(((-1.0)*(0.25)*cj12))+(((0.03)*x287)));\nevalcond[5]=((((-1.0)*(1.0)*px))+(((-1.0)*(0.25)*sj12))+(((-1.0)*r01*x301))+(((-0.03)*x292))+((r00*x300))+(((-0.235)*x289))+(((0.03)*x293))+(((-0.235)*x287)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x302=((1.0)*cj15);\nCheckValue<IkReal> x303 = IKatan2WithCheck(IkReal((((r00*sj16))+((cj16*r01)))),IkReal(((((-1.0)*r02*x302))+(((-1.0)*(1.0)*r01*sj15*sj16))+((cj16*r00*sj15)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x303.valid){\ncontinue;\n}\nCheckValue<IkReal> x304=IKPowWithIntegerCheck(IKsign((((r22*sj15))+(((-1.0)*r21*sj16*x302))+((cj15*cj16*r20)))),-1);\nif(!x304.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x303.value)+(((1.5707963267949)*(x304.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x305=IKsin(j14);\nIkReal x306=(cj16*r11);\nIkReal x307=(r10*sj16);\nIkReal x308=IKcos(j14);\nIkReal x309=((1.0)*x308);\nIkReal x310=((1.0)*sj16*x308);\nIkReal x311=((1.0)*cj15*x305);\nIkReal x312=((1.0)*cj16*x308);\nIkReal x313=(cj16*sj15*x305);\nIkReal x314=((1.0)*sj15*sj16*x305);\nevalcond[0]=(((cj16*r10*sj15*x308))+((x305*x306))+(((-1.0)*cj15*r12*x309))+(((-1.0)*r11*sj15*x310))+((x305*x307)));\nevalcond[1]=(((r20*x313))+(((-1.0)*r21*x314))+(((-1.0)*r20*x310))+(((-1.0)*r22*x311))+(((-1.0)*r21*x312)));\nevalcond[2]=((((-1.0)*r01*x312))+(((-1.0)*r01*x314))+(((-1.0)*r00*x310))+((r00*x313))+(((-1.0)*r02*x311)));\nevalcond[3]=((1.0)+(((-1.0)*x306*x309))+(((-1.0)*r12*x311))+((r10*x313))+(((-1.0)*x307*x309))+(((-1.0)*r11*x314)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=0;\ncj11=1.0;\nj11=0;\nIkReal x315=(cj16*r20);\nIkReal x316=(r02*sj15);\nIkReal x317=(r21*sj16);\nIkReal x318=(r22*sj15);\nIkReal x319=(cj15*cj16*r00);\nIkReal x320=(cj15*cj16*r20);\nIkReal x321=(cj15*r01*sj16);\nIkReal x322=(cj15*r21*sj16);\nIkReal x323=((((-1.0)*(12.0)*pz))+(((-1.08)*x317))+(((0.36)*x321))+(((-0.36)*x319))+(((2.82)*x318))+(((-0.36)*x316))+(((1.08)*x315))+(((2.82)*x320))+(((-2.82)*x322)));\nj12eval[0]=((IKabs(((1.0)+(((0.94)*x320))+(((-1.0)*(4.0)*pz))+(((-0.94)*x322))+(((-0.36)*x317))+(((-0.12)*x319))+(((0.36)*x315))+(((-0.12)*x316))+(((0.12)*x321))+(((0.94)*x318)))))+(IKabs(((-1.0)+x323)))+(IKabs(((1.0)+x323))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x324=(cj16*r20);\nIkReal x325=(r02*sj15);\nIkReal x326=(r21*sj16);\nIkReal x327=(r22*sj15);\nIkReal x328=(cj15*cj16*r00);\nIkReal x329=(cj15*cj16*r20);\nIkReal x330=(cj15*r01*sj16);\nIkReal x331=(cj15*r21*sj16);\nIkReal x332=((((0.94)*x327))+(((-0.36)*x326))+(((0.36)*x324))+(((-0.12)*x328))+(((-1.0)*(4.0)*pz))+(((0.94)*x329))+(((-0.94)*x331))+(((-0.12)*x325))+(((0.12)*x330)));\nIkReal x333=((((0.36)*x330))+(((-1.0)*(12.0)*pz))+(((2.82)*x329))+(((-1.08)*x326))+(((-2.82)*x331))+(((1.08)*x324))+(((-0.36)*x325))+(((2.82)*x327))+(((-0.36)*x328)));\nop[0]=((1.0)+x332);\nop[1]=0;\nop[2]=((1.0)+x333);\nop[3]=0;\nop[4]=((-1.0)+x333);\nop[5]=0;\nop[6]=((-1.0)+x332);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x334=(cj16*r00);\nIkReal x335=(cj16*r20);\nIkReal x336=(r01*sj16);\nIkReal x337=(r21*sj16);\nIkReal x338=(r22*sj15);\nIkReal x339=(cj15*cj16*r20);\nIkReal x340=(cj15*r21*sj16);\nIkReal x341=((((-0.0846)*x337))+(((0.0846)*x335))+(((0.0108)*x334))+(((0.2245)*x339))+(((0.2245)*x338))+(((-1.0)*(0.94)*pz))+(((-0.0108)*x336))+(((-0.2245)*x340))+(((-1.0)*(0.12)*px)));\nIkReal x342=((((0.6735)*x339))+(((0.6735)*x338))+(((0.2538)*x335))+(((-0.0324)*x336))+(((-0.2538)*x337))+(((-1.0)*(0.36)*px))+(((0.0324)*x334))+(((-1.0)*(2.82)*pz))+(((-0.6735)*x340)));\nj12evalpoly[0]=((-0.235)+(((htj12*htj12*htj12*htj12)*(((0.235)+x342))))+(((-1.0)*(0.12)*(htj12*htj12*htj12)))+(((-1.0)*(0.06)*htj12))+x341+(((-1.0)*(0.06)*(htj12*htj12*htj12*htj12*htj12)))+(((htj12*htj12)*(((-0.235)+x342))))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((0.235)+x341)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x343=(r22*sj15);\nIkReal x344=((1.0)*cj12);\nIkReal x345=(r02*sj15);\nIkReal x346=(cj12*cj15*sj16);\nIkReal x347=(cj15*sj12);\nIkReal x348=(cj16*r20);\nIkReal x349=(cj16*r00);\nIkReal x350=((1.0)*cj12*cj15);\nIkReal x351=((1.0)*cj15*sj12);\nif( IKabs((((sj12*x343))+(((-1.0)*x344*x345))+(((-1.0)*x349*x350))+(((-1.0)*r21*sj16*x351))+((r01*x346))+((x347*x348)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x348*x350))+((r21*x346))+(((-1.0)*sj12*x345))+(((-1.0)*x343*x344))+((r01*sj16*x347))+(((-1.0)*x349*x351)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj12*x343))+(((-1.0)*x344*x345))+(((-1.0)*x349*x350))+(((-1.0)*r21*sj16*x351))+((r01*x346))+((x347*x348))))+IKsqr(((((-1.0)*x348*x350))+((r21*x346))+(((-1.0)*sj12*x345))+(((-1.0)*x343*x344))+((r01*sj16*x347))+(((-1.0)*x349*x351))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((sj12*x343))+(((-1.0)*x344*x345))+(((-1.0)*x349*x350))+(((-1.0)*r21*sj16*x351))+((r01*x346))+((x347*x348))), ((((-1.0)*x348*x350))+((r21*x346))+(((-1.0)*sj12*x345))+(((-1.0)*x343*x344))+((r01*sj16*x347))+(((-1.0)*x349*x351))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x352=IKsin(j13);\nIkReal x353=(cj12*x352);\nIkReal x354=IKcos(j13);\nIkReal x355=(sj12*x354);\nIkReal x356=(cj15*cj16);\nIkReal x357=((1.0)*cj15*sj16);\nIkReal x358=(cj12*x354);\nIkReal x359=(sj12*x352);\nIkReal x360=(x358+(((-1.0)*x359)));\nIkReal x361=(cj16*sj14);\nIkReal x362=(sj14*sj16);\nIkReal x363=((1.0)*cj14*cj15);\nIkReal x364=(cj14*cj16*sj15);\nIkReal x365=((1.0)*cj14*sj15*sj16);\nIkReal x366=((0.09)*cj16);\nIkReal x367=((0.09)*sj16);\nevalcond[0]=(((r00*x356))+(((-1.0)*r01*x357))+((r02*sj15))+x355+x353);\nevalcond[1]=(((r22*sj15))+(((-1.0)*r21*x357))+((r20*x356))+x360);\nevalcond[2]=(((r00*x364))+((r01*x361))+(((-1.0)*r01*x365))+((r00*x362))+(((-1.0)*r02*x363))+x360);\nevalcond[3]=(((r20*x364))+(((-1.0)*r21*x365))+((r20*x362))+(((-1.0)*r22*x363))+(((-1.0)*x355))+((r21*x361))+(((-1.0)*x353)));\nevalcond[4]=((((0.235)*x359))+(((0.03)*x353))+((r20*x366))+(((-1.0)*(1.0)*pz))+(((-1.0)*r21*x367))+(((0.03)*x355))+(((-0.235)*x358))+(((-1.0)*(0.25)*cj12)));\nevalcond[5]=((((-1.0)*(1.0)*px))+(((-0.03)*x358))+(((-1.0)*(0.25)*sj12))+((r00*x366))+(((-0.235)*x353))+(((-0.235)*x355))+(((0.03)*x359))+(((-1.0)*r01*x367)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x368=(cj16*r10);\nIkReal x369=(r11*sj16);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j11)))), 6.28318530717959)));\nevalcond[1]=(((r12*sj15))+((cj15*x368))+(((-1.0)*cj15*x369)));\nevalcond[2]=((-0.095)+(((-1.0)*(1.0)*py))+(((0.09)*x368))+(((-0.09)*x369)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j14eval[3];\nsj11=0;\ncj11=-1.0;\nj11=3.14159265358979;\nIkReal x370=((1.0)*sj16);\nIkReal x371=(((r22*sj15))+(((-1.0)*cj15*r21*x370))+((cj15*cj16*r20)));\nIkReal x372=((1.0)*cj16);\nj14eval[0]=x371;\nj14eval[1]=((IKabs((((r01*sj15*sj16))+(((-1.0)*r00*sj15*x372))+((cj15*r02)))))+(IKabs(((((-1.0)*r01*x372))+(((-1.0)*r00*x370))))));\nj14eval[2]=IKsign(x371);\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=0;\ncj11=-1.0;\nj11=3.14159265358979;\nIkReal x373=((1.0)*cj16);\nIkReal x374=((((-1.0)*(1.0)*r02*sj15))+((cj15*r01*sj16))+(((-1.0)*cj15*r00*x373)));\nj14eval[0]=x374;\nj14eval[1]=IKsign(x374);\nj14eval[2]=((IKabs(((((-1.0)*(1.0)*r20*sj16))+(((-1.0)*r21*x373)))))+(IKabs((((r21*sj15*sj16))+((cj15*r22))+(((-1.0)*r20*sj15*x373))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=0;\ncj11=-1.0;\nj11=3.14159265358979;\nIkReal x375=r10*r10;\nIkReal x376=r11*r11;\nIkReal x377=cj15*cj15;\nIkReal x378=((2.0)*cj15*r12);\nIkReal x379=(cj16*r10*sj15);\nIkReal x380=(x376*x377);\nIkReal x381=(r10*sj16);\nIkReal x382=cj16*cj16;\nIkReal x383=((((-1.0)*x380))+(((-1.0)*x375*x377*x382))+((r11*sj15*sj16*x378))+((x377*(r12*r12)))+((x380*x382))+x376+x375+(((-1.0)*x378*x379))+(((2.0)*cj16*r11*x377*x381)));\nIkReal x384=((1.0)*r11);\nj14eval[0]=x383;\nj14eval[1]=((IKabs(((((-1.0)*x381))+(((-1.0)*cj16*x384)))))+(IKabs(((((-1.0)*sj15*sj16*x384))+x379+(((-1.0)*cj15*r12))))));\nj14eval[2]=IKsign(x383);\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j12, j13, j14]\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x385=(cj16*r10*sj15);\nIkReal x386=((1.0)*r11);\nIkReal x387=(r10*sj16);\nIkReal x388=r10*r10;\nIkReal x389=r11*r11;\nIkReal x390=cj15*cj15;\nIkReal x391=((2.0)*cj15*r12);\nIkReal x392=(x389*x390);\nIkReal x393=cj16*cj16;\nCheckValue<IkReal> x394=IKPowWithIntegerCheck(IKsign(((((-1.0)*x388*x390*x393))+((x392*x393))+(((2.0)*cj16*r11*x387*x390))+((x390*(r12*r12)))+(((-1.0)*x385*x391))+x388+x389+((r11*sj15*sj16*x391))+(((-1.0)*x392)))),-1);\nif(!x394.valid){\ncontinue;\n}\nCheckValue<IkReal> x395 = IKatan2WithCheck(IkReal((x385+(((-1.0)*sj15*sj16*x386))+(((-1.0)*cj15*r12)))),IkReal(((((-1.0)*cj16*x386))+(((-1.0)*x387)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x395.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x394.value)))+(x395.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x396=IKsin(j14);\nIkReal x397=(cj16*r11);\nIkReal x398=(r10*sj16);\nIkReal x399=IKcos(j14);\nIkReal x400=((1.0)*x399);\nIkReal x401=((1.0)*sj16*x399);\nIkReal x402=((1.0)*cj15*x396);\nIkReal x403=((1.0)*cj16*x399);\nIkReal x404=(cj16*sj15*x396);\nIkReal x405=((1.0)*sj15*sj16*x396);\nevalcond[0]=((((-1.0)*cj15*r12*x400))+((x396*x397))+(((-1.0)*r11*sj15*x401))+((x396*x398))+((cj16*r10*sj15*x399)));\nevalcond[1]=((((-1.0)*r20*x401))+(((-1.0)*r21*x403))+((r20*x404))+(((-1.0)*r22*x402))+(((-1.0)*r21*x405)));\nevalcond[2]=((((-1.0)*r01*x403))+((r00*x404))+(((-1.0)*r01*x405))+(((-1.0)*r02*x402))+(((-1.0)*r00*x401)));\nevalcond[3]=((-1.0)+(((-1.0)*r12*x402))+((r10*x404))+(((-1.0)*r11*x405))+(((-1.0)*x397*x400))+(((-1.0)*x398*x400)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=0;\ncj11=-1.0;\nj11=3.14159265358979;\nIkReal x406=(cj16*r20);\nIkReal x407=(r02*sj15);\nIkReal x408=(r21*sj16);\nIkReal x409=(r22*sj15);\nIkReal x410=(cj15*cj16*r00);\nIkReal x411=(cj15*cj16*r20);\nIkReal x412=(cj15*r01*sj16);\nIkReal x413=(cj15*r21*sj16);\nIkReal x414=((((-0.36)*x410))+(((-2.82)*x409))+(((0.36)*x412))+(((2.82)*x413))+(((-0.36)*x407))+(((12.0)*pz))+(((1.08)*x408))+(((-2.82)*x411))+(((-1.08)*x406)));\nj12eval[0]=((IKabs(((1.0)+x414)))+(IKabs(((-1.0)+(((-0.94)*x409))+(((0.94)*x413))+(((0.12)*x412))+(((-0.94)*x411))+(((4.0)*pz))+(((0.36)*x408))+(((-0.12)*x410))+(((-0.36)*x406))+(((-0.12)*x407)))))+(IKabs(((-1.0)+x414))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x415=(cj16*r20);\nIkReal x416=(r02*sj15);\nIkReal x417=(r21*sj16);\nIkReal x418=(r22*sj15);\nIkReal x419=(cj15*cj16*r00);\nIkReal x420=(cj15*cj16*r20);\nIkReal x421=(cj15*r01*sj16);\nIkReal x422=(cj15*r21*sj16);\nIkReal x423=((((-0.94)*x420))+(((-0.36)*x415))+(((-0.12)*x416))+(((-0.94)*x418))+(((4.0)*pz))+(((0.12)*x421))+(((0.94)*x422))+(((-0.12)*x419))+(((0.36)*x417)));\nIkReal x424=((((-0.36)*x419))+(((0.36)*x421))+(((-2.82)*x420))+(((-0.36)*x416))+(((2.82)*x422))+(((-1.08)*x415))+(((12.0)*pz))+(((1.08)*x417))+(((-2.82)*x418)));\nop[0]=((-1.0)+x423);\nop[1]=0;\nop[2]=((-1.0)+x424);\nop[3]=0;\nop[4]=((1.0)+x424);\nop[5]=0;\nop[6]=((1.0)+x423);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x425=(cj16*r20);\nIkReal x426=((0.36)*x425);\nIkReal x427=(r21*sj16);\nIkReal x428=((0.36)*x427);\nIkReal x429=(r22*sj15);\nIkReal x430=(cj14*cj15*r22);\nIkReal x431=(cj15*cj16*r20);\nIkReal x432=(cj15*r21*sj16);\nIkReal x433=(cj16*r21*sj14);\nIkReal x434=(r20*sj14*sj16);\nIkReal x435=((0.12)*cj14*sj15);\nIkReal x436=((((-0.94)*x432))+(((-1.0)*(4.0)*pz))+(((-1.0)*x428))+(((-1.0)*x427*x435))+(((0.12)*x433))+x426+(((0.94)*x431))+(((0.12)*x434))+((x425*x435))+(((0.94)*x429))+(((-0.12)*x430)));\nIkReal x437=(cj14*sj15);\nIkReal x438=((((2.82)*x431))+(((-1.0)*(12.0)*pz))+(((0.36)*x434))+((x426*x437))+(((0.36)*x433))+(((-1.0)*x428*x437))+(((1.08)*x425))+(((-2.82)*x432))+(((-1.08)*x427))+(((-0.36)*x430))+(((2.82)*x429)));\nj12evalpoly[0]=((-1.0)+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((1.0)+x436))))+(((htj12*htj12*htj12*htj12)*(((1.0)+x438))))+x436+(((htj12*htj12)*(((-1.0)+x438)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x439=(r02*sj15);\nIkReal x440=(r22*sj15);\nIkReal x441=(cj12*cj15);\nIkReal x442=(cj16*r00);\nIkReal x443=(cj15*sj12);\nIkReal x444=(cj16*r20);\nIkReal x445=(r01*sj16);\nIkReal x446=((1.0)*cj12*cj15);\nIkReal x447=(r21*sj16);\nIkReal x448=((1.0)*cj15*sj12);\nif( IKabs((((x443*x444))+(((-1.0)*x447*x448))+((x441*x442))+((cj12*x439))+((sj12*x440))+(((-1.0)*x445*x446)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj12*x439))+(((-1.0)*cj12*x440))+((x441*x447))+((x442*x443))+(((-1.0)*x445*x448))+(((-1.0)*x444*x446)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x443*x444))+(((-1.0)*x447*x448))+((x441*x442))+((cj12*x439))+((sj12*x440))+(((-1.0)*x445*x446))))+IKsqr((((sj12*x439))+(((-1.0)*cj12*x440))+((x441*x447))+((x442*x443))+(((-1.0)*x445*x448))+(((-1.0)*x444*x446))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((x443*x444))+(((-1.0)*x447*x448))+((x441*x442))+((cj12*x439))+((sj12*x440))+(((-1.0)*x445*x446))), (((sj12*x439))+(((-1.0)*cj12*x440))+((x441*x447))+((x442*x443))+(((-1.0)*x445*x448))+(((-1.0)*x444*x446))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x449=IKcos(j13);\nIkReal x450=(cj12*x449);\nIkReal x451=(cj15*cj16);\nIkReal x452=IKsin(j13);\nIkReal x453=(sj12*x452);\nIkReal x454=((1.0)*cj15*sj16);\nIkReal x455=(cj12*x452);\nIkReal x456=(sj12*x449);\nIkReal x457=((((-1.0)*x456))+(((-1.0)*x455)));\nIkReal x458=(cj16*sj14);\nIkReal x459=(sj14*sj16);\nIkReal x460=((1.0)*cj14*cj15);\nIkReal x461=(cj14*cj16*sj15);\nIkReal x462=((1.0)*cj14*sj15*sj16);\nIkReal x463=((0.09)*cj16);\nIkReal x464=((0.09)*sj16);\nevalcond[0]=(((r22*sj15))+(((-1.0)*r21*x454))+x450+(((-1.0)*x453))+((r20*x451)));\nevalcond[1]=((((-1.0)*r01*x454))+((r02*sj15))+x457+((r00*x451)));\nevalcond[2]=((((-1.0)*r01*x462))+(((-1.0)*r02*x460))+(((-1.0)*x450))+((r00*x459))+x453+((r01*x458))+((r00*x461)));\nevalcond[3]=(((r20*x461))+((r20*x459))+(((-1.0)*r21*x462))+(((-1.0)*r22*x460))+x457+((r21*x458)));\nevalcond[4]=((((-0.235)*x450))+(((0.03)*x456))+(((-1.0)*(1.0)*pz))+(((0.03)*x455))+(((-1.0)*r21*x464))+(((0.235)*x453))+(((-1.0)*(0.25)*cj12))+((r20*x463)));\nevalcond[5]=((((-1.0)*(1.0)*px))+(((-0.03)*x453))+(((-1.0)*r01*x464))+(((0.25)*sj12))+(((0.235)*x456))+(((0.235)*x455))+(((0.03)*x450))+((r00*x463)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x465=((1.0)*cj16);\nCheckValue<IkReal> x466 = IKatan2WithCheck(IkReal(((((-1.0)*(1.0)*r20*sj16))+(((-1.0)*r21*x465)))),IkReal((((r21*sj15*sj16))+((cj15*r22))+(((-1.0)*r20*sj15*x465)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x466.valid){\ncontinue;\n}\nCheckValue<IkReal> x467=IKPowWithIntegerCheck(IKsign(((((-1.0)*(1.0)*r02*sj15))+((cj15*r01*sj16))+(((-1.0)*cj15*r00*x465)))),-1);\nif(!x467.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x466.value)+(((1.5707963267949)*(x467.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x468=IKsin(j14);\nIkReal x469=(cj16*r11);\nIkReal x470=(r10*sj16);\nIkReal x471=IKcos(j14);\nIkReal x472=((1.0)*x471);\nIkReal x473=((1.0)*sj16*x471);\nIkReal x474=((1.0)*cj15*x468);\nIkReal x475=((1.0)*cj16*x471);\nIkReal x476=(cj16*sj15*x468);\nIkReal x477=((1.0)*sj15*sj16*x468);\nevalcond[0]=((((-1.0)*cj15*r12*x472))+((x468*x470))+((x468*x469))+(((-1.0)*r11*sj15*x473))+((cj16*r10*sj15*x471)));\nevalcond[1]=(((r20*x476))+(((-1.0)*r22*x474))+(((-1.0)*r21*x477))+(((-1.0)*r20*x473))+(((-1.0)*r21*x475)));\nevalcond[2]=((((-1.0)*r01*x477))+(((-1.0)*r02*x474))+((r00*x476))+(((-1.0)*r00*x473))+(((-1.0)*r01*x475)));\nevalcond[3]=((-1.0)+(((-1.0)*x469*x472))+((r10*x476))+(((-1.0)*x470*x472))+(((-1.0)*r11*x477))+(((-1.0)*r12*x474)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=0;\ncj11=-1.0;\nj11=3.14159265358979;\nIkReal x478=(cj16*r20);\nIkReal x479=(r02*sj15);\nIkReal x480=(r21*sj16);\nIkReal x481=(r22*sj15);\nIkReal x482=(cj15*cj16*r00);\nIkReal x483=(cj15*cj16*r20);\nIkReal x484=(cj15*r01*sj16);\nIkReal x485=(cj15*r21*sj16);\nIkReal x486=((((0.36)*x484))+(((-2.82)*x483))+(((-0.36)*x482))+(((-0.36)*x479))+(((2.82)*x485))+(((-1.08)*x478))+(((12.0)*pz))+(((-2.82)*x481))+(((1.08)*x480)));\nj12eval[0]=((IKabs(((-1.0)+(((0.36)*x480))+(((-0.94)*x483))+(((0.12)*x484))+(((-0.12)*x482))+(((-0.36)*x478))+(((4.0)*pz))+(((-0.94)*x481))+(((-0.12)*x479))+(((0.94)*x485)))))+(IKabs(((-1.0)+x486)))+(IKabs(((1.0)+x486))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x487=(cj16*r20);\nIkReal x488=(r02*sj15);\nIkReal x489=(r21*sj16);\nIkReal x490=(r22*sj15);\nIkReal x491=(cj15*cj16*r00);\nIkReal x492=(cj15*cj16*r20);\nIkReal x493=(cj15*r01*sj16);\nIkReal x494=(cj15*r21*sj16);\nIkReal x495=((((-0.94)*x492))+(((0.36)*x489))+(((0.12)*x493))+(((-0.36)*x487))+(((4.0)*pz))+(((-0.12)*x491))+(((-0.12)*x488))+(((-0.94)*x490))+(((0.94)*x494)));\nIkReal x496=((((0.36)*x493))+(((2.82)*x494))+(((-1.08)*x487))+(((-2.82)*x490))+(((-0.36)*x488))+(((-0.36)*x491))+(((1.08)*x489))+(((12.0)*pz))+(((-2.82)*x492)));\nop[0]=((-1.0)+x495);\nop[1]=0;\nop[2]=((-1.0)+x496);\nop[3]=0;\nop[4]=((1.0)+x496);\nop[5]=0;\nop[6]=((1.0)+x495);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x497=(cj16*r20);\nIkReal x498=((0.36)*x497);\nIkReal x499=(r21*sj16);\nIkReal x500=((0.36)*x499);\nIkReal x501=(r22*sj15);\nIkReal x502=(cj14*cj15*r22);\nIkReal x503=(cj15*cj16*r20);\nIkReal x504=(cj15*r21*sj16);\nIkReal x505=(cj16*r21*sj14);\nIkReal x506=(r20*sj14*sj16);\nIkReal x507=((0.12)*cj14*sj15);\nIkReal x508=((((-1.0)*x500))+(((-1.0)*x499*x507))+(((-1.0)*(4.0)*pz))+(((0.94)*x501))+(((0.12)*x505))+(((0.12)*x506))+(((-0.94)*x504))+((x497*x507))+(((0.94)*x503))+(((-0.12)*x502))+x498);\nIkReal x509=(cj14*sj15);\nIkReal x510=((((-1.08)*x499))+(((-1.0)*(12.0)*pz))+(((2.82)*x501))+(((1.08)*x497))+((x498*x509))+(((2.82)*x503))+(((-1.0)*x500*x509))+(((0.36)*x506))+(((-2.82)*x504))+(((0.36)*x505))+(((-0.36)*x502)));\nj12evalpoly[0]=((-1.0)+(((htj12*htj12)*(((-1.0)+x510))))+x508+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((1.0)+x508))))+(((htj12*htj12*htj12*htj12)*(((1.0)+x510)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x511=(r02*sj15);\nIkReal x512=(r22*sj15);\nIkReal x513=(cj12*cj15);\nIkReal x514=(cj16*r00);\nIkReal x515=(cj15*sj12);\nIkReal x516=(cj16*r20);\nIkReal x517=(r01*sj16);\nIkReal x518=((1.0)*cj12*cj15);\nIkReal x519=(r21*sj16);\nIkReal x520=((1.0)*cj15*sj12);\nif( IKabs(((((-1.0)*x519*x520))+((x515*x516))+((sj12*x512))+(((-1.0)*x517*x518))+((x513*x514))+((cj12*x511)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x513*x519))+(((-1.0)*x517*x520))+((x514*x515))+(((-1.0)*x516*x518))+(((-1.0)*cj12*x512))+((sj12*x511)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x519*x520))+((x515*x516))+((sj12*x512))+(((-1.0)*x517*x518))+((x513*x514))+((cj12*x511))))+IKsqr((((x513*x519))+(((-1.0)*x517*x520))+((x514*x515))+(((-1.0)*x516*x518))+(((-1.0)*cj12*x512))+((sj12*x511))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*x519*x520))+((x515*x516))+((sj12*x512))+(((-1.0)*x517*x518))+((x513*x514))+((cj12*x511))), (((x513*x519))+(((-1.0)*x517*x520))+((x514*x515))+(((-1.0)*x516*x518))+(((-1.0)*cj12*x512))+((sj12*x511))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x521=IKcos(j13);\nIkReal x522=(cj12*x521);\nIkReal x523=(cj15*cj16);\nIkReal x524=IKsin(j13);\nIkReal x525=(sj12*x524);\nIkReal x526=((1.0)*cj15*sj16);\nIkReal x527=(cj12*x524);\nIkReal x528=(sj12*x521);\nIkReal x529=((((-1.0)*x528))+(((-1.0)*x527)));\nIkReal x530=(cj16*sj14);\nIkReal x531=(sj14*sj16);\nIkReal x532=((1.0)*cj14*cj15);\nIkReal x533=(cj14*cj16*sj15);\nIkReal x534=((1.0)*cj14*sj15*sj16);\nIkReal x535=((0.09)*cj16);\nIkReal x536=((0.09)*sj16);\nevalcond[0]=(((r20*x523))+(((-1.0)*r21*x526))+((r22*sj15))+(((-1.0)*x525))+x522);\nevalcond[1]=(((r00*x523))+((r02*sj15))+x529+(((-1.0)*r01*x526)));\nevalcond[2]=((((-1.0)*r01*x534))+((r00*x533))+(((-1.0)*r02*x532))+(((-1.0)*x522))+((r01*x530))+((r00*x531))+x525);\nevalcond[3]=(((r21*x530))+(((-1.0)*r21*x534))+((r20*x533))+((r20*x531))+(((-1.0)*r22*x532))+x529);\nevalcond[4]=((((-1.0)*r21*x536))+(((0.03)*x528))+(((0.235)*x525))+(((-1.0)*(1.0)*pz))+(((-0.235)*x522))+(((-1.0)*(0.25)*cj12))+(((0.03)*x527))+((r20*x535)));\nevalcond[5]=((((-1.0)*(1.0)*px))+((r00*x535))+(((-1.0)*r01*x536))+(((0.235)*x527))+(((0.03)*x522))+(((0.235)*x528))+(((0.25)*sj12))+(((-0.03)*x525)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x537=((1.0)*sj16);\nIkReal x538=((1.0)*cj16);\nCheckValue<IkReal> x539=IKPowWithIntegerCheck(IKsign((((r22*sj15))+((cj15*cj16*r20))+(((-1.0)*cj15*r21*x537)))),-1);\nif(!x539.valid){\ncontinue;\n}\nCheckValue<IkReal> x540 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x537))+(((-1.0)*r01*x538)))),IkReal((((r01*sj15*sj16))+(((-1.0)*r00*sj15*x538))+((cj15*r02)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x540.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x539.value)))+(x540.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x541=IKsin(j14);\nIkReal x542=(cj16*r11);\nIkReal x543=(r10*sj16);\nIkReal x544=IKcos(j14);\nIkReal x545=((1.0)*x544);\nIkReal x546=((1.0)*sj16*x544);\nIkReal x547=((1.0)*cj15*x541);\nIkReal x548=((1.0)*cj16*x544);\nIkReal x549=(cj16*sj15*x541);\nIkReal x550=((1.0)*sj15*sj16*x541);\nevalcond[0]=((((-1.0)*r11*sj15*x546))+(((-1.0)*cj15*r12*x545))+((x541*x542))+((cj16*r10*sj15*x544))+((x541*x543)));\nevalcond[1]=((((-1.0)*r20*x546))+((r20*x549))+(((-1.0)*r21*x550))+(((-1.0)*r21*x548))+(((-1.0)*r22*x547)));\nevalcond[2]=((((-1.0)*r02*x547))+(((-1.0)*r01*x550))+(((-1.0)*r00*x546))+((r00*x549))+(((-1.0)*r01*x548)));\nevalcond[3]=((-1.0)+(((-1.0)*r11*x550))+(((-1.0)*r12*x547))+((r10*x549))+(((-1.0)*x543*x545))+(((-1.0)*x542*x545)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=0;\ncj11=-1.0;\nj11=3.14159265358979;\nIkReal x551=(cj16*r20);\nIkReal x552=(r02*sj15);\nIkReal x553=(r21*sj16);\nIkReal x554=(r22*sj15);\nIkReal x555=(cj15*cj16*r00);\nIkReal x556=(cj15*cj16*r20);\nIkReal x557=(cj15*r01*sj16);\nIkReal x558=(cj15*r21*sj16);\nIkReal x559=((((-2.82)*x554))+(((1.08)*x553))+(((-1.08)*x551))+(((-0.36)*x552))+(((-0.36)*x555))+(((2.82)*x558))+(((-2.82)*x556))+(((0.36)*x557))+(((12.0)*pz)));\nj12eval[0]=((IKabs(((-1.0)+(((0.36)*x553))+(((0.12)*x557))+(((-0.94)*x556))+(((4.0)*pz))+(((-0.36)*x551))+(((-0.12)*x552))+(((0.94)*x558))+(((-0.94)*x554))+(((-0.12)*x555)))))+(IKabs(((1.0)+x559)))+(IKabs(((-1.0)+x559))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x560=(cj16*r20);\nIkReal x561=(r02*sj15);\nIkReal x562=(r21*sj16);\nIkReal x563=(r22*sj15);\nIkReal x564=(cj15*cj16*r00);\nIkReal x565=(cj15*cj16*r20);\nIkReal x566=(cj15*r01*sj16);\nIkReal x567=(cj15*r21*sj16);\nIkReal x568=((((-0.36)*x560))+(((0.94)*x567))+(((-0.12)*x561))+(((4.0)*pz))+(((0.36)*x562))+(((0.12)*x566))+(((-0.94)*x565))+(((-0.12)*x564))+(((-0.94)*x563)));\nIkReal x569=((((-2.82)*x563))+(((-2.82)*x565))+(((1.08)*x562))+(((2.82)*x567))+(((-0.36)*x564))+(((0.36)*x566))+(((-0.36)*x561))+(((12.0)*pz))+(((-1.08)*x560)));\nop[0]=((-1.0)+x568);\nop[1]=0;\nop[2]=((-1.0)+x569);\nop[3]=0;\nop[4]=((1.0)+x569);\nop[5]=0;\nop[6]=((1.0)+x568);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x570=(cj16*r20);\nIkReal x571=((0.36)*x570);\nIkReal x572=(r21*sj16);\nIkReal x573=((0.36)*x572);\nIkReal x574=(r22*sj15);\nIkReal x575=(cj14*cj15*r22);\nIkReal x576=(cj15*cj16*r20);\nIkReal x577=(cj15*r21*sj16);\nIkReal x578=(cj16*r21*sj14);\nIkReal x579=(r20*sj14*sj16);\nIkReal x580=((0.12)*cj14*sj15);\nIkReal x581=((((0.12)*x579))+x571+(((-1.0)*(4.0)*pz))+(((-1.0)*x572*x580))+(((-0.94)*x577))+(((0.94)*x574))+((x570*x580))+(((0.94)*x576))+(((-1.0)*x573))+(((-0.12)*x575))+(((0.12)*x578)));\nIkReal x582=(cj14*sj15);\nIkReal x583=((((0.36)*x578))+(((-1.0)*x573*x582))+(((0.36)*x579))+(((-1.0)*(12.0)*pz))+(((-1.08)*x572))+(((2.82)*x574))+(((-0.36)*x575))+(((2.82)*x576))+((x571*x582))+(((-2.82)*x577))+(((1.08)*x570)));\nj12evalpoly[0]=((-1.0)+(((htj12*htj12)*(((-1.0)+x583))))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((1.0)+x581))))+(((htj12*htj12*htj12*htj12)*(((1.0)+x583))))+x581);\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x584=(r02*sj15);\nIkReal x585=(r22*sj15);\nIkReal x586=(cj12*cj15);\nIkReal x587=(cj16*r00);\nIkReal x588=(cj15*sj12);\nIkReal x589=(cj16*r20);\nIkReal x590=(r01*sj16);\nIkReal x591=((1.0)*cj12*cj15);\nIkReal x592=(r21*sj16);\nIkReal x593=((1.0)*cj15*sj12);\nif( IKabs((((sj12*x585))+((x588*x589))+(((-1.0)*x592*x593))+((cj12*x584))+((x586*x587))+(((-1.0)*x590*x591)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x590*x593))+(((-1.0)*cj12*x585))+((x586*x592))+((sj12*x584))+(((-1.0)*x589*x591))+((x587*x588)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj12*x585))+((x588*x589))+(((-1.0)*x592*x593))+((cj12*x584))+((x586*x587))+(((-1.0)*x590*x591))))+IKsqr(((((-1.0)*x590*x593))+(((-1.0)*cj12*x585))+((x586*x592))+((sj12*x584))+(((-1.0)*x589*x591))+((x587*x588))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((sj12*x585))+((x588*x589))+(((-1.0)*x592*x593))+((cj12*x584))+((x586*x587))+(((-1.0)*x590*x591))), ((((-1.0)*x590*x593))+(((-1.0)*cj12*x585))+((x586*x592))+((sj12*x584))+(((-1.0)*x589*x591))+((x587*x588))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x594=IKcos(j13);\nIkReal x595=(cj12*x594);\nIkReal x596=(cj15*cj16);\nIkReal x597=IKsin(j13);\nIkReal x598=(sj12*x597);\nIkReal x599=((1.0)*cj15*sj16);\nIkReal x600=(cj12*x597);\nIkReal x601=(sj12*x594);\nIkReal x602=((((-1.0)*x600))+(((-1.0)*x601)));\nIkReal x603=(cj16*sj14);\nIkReal x604=(sj14*sj16);\nIkReal x605=((1.0)*cj14*cj15);\nIkReal x606=(cj14*cj16*sj15);\nIkReal x607=((1.0)*cj14*sj15*sj16);\nIkReal x608=((0.09)*cj16);\nIkReal x609=((0.09)*sj16);\nevalcond[0]=((((-1.0)*x598))+((r22*sj15))+(((-1.0)*r21*x599))+((r20*x596))+x595);\nevalcond[1]=(((r00*x596))+(((-1.0)*r01*x599))+((r02*sj15))+x602);\nevalcond[2]=(((r00*x606))+(((-1.0)*x595))+(((-1.0)*r01*x607))+((r01*x603))+(((-1.0)*r02*x605))+((r00*x604))+x598);\nevalcond[3]=((((-1.0)*r21*x607))+((r20*x606))+(((-1.0)*r22*x605))+((r21*x603))+((r20*x604))+x602);\nevalcond[4]=((((0.235)*x598))+(((-1.0)*(1.0)*pz))+(((-1.0)*r21*x609))+(((-0.235)*x595))+(((0.03)*x600))+((r20*x608))+(((-1.0)*(0.25)*cj12))+(((0.03)*x601)));\nevalcond[5]=(((r00*x608))+(((-1.0)*(1.0)*px))+(((0.235)*x600))+(((0.03)*x595))+(((0.25)*sj12))+(((0.235)*x601))+(((-0.03)*x598))+(((-1.0)*r01*x609)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x610=(cj16*r00);\nIkReal x611=(r01*sj16);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j11)))), 6.28318530717959)));\nevalcond[1]=((((-1.0)*cj15*x611))+((r02*sj15))+((cj15*x610)));\nevalcond[2]=((-0.095)+(((-1.0)*(1.0)*px))+(((-0.09)*x611))+(((0.09)*x610)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j14eval[3];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x612=((1.0)*sj16);\nIkReal x613=(((cj15*cj16*r10))+((r12*sj15))+(((-1.0)*cj15*r11*x612)));\nIkReal x614=((1.0)*cj16);\nj14eval[0]=x613;\nj14eval[1]=IKsign(x613);\nj14eval[2]=((IKabs(((((-1.0)*r21*x614))+(((-1.0)*r20*x612)))))+(IKabs(((((-1.0)*r20*sj15*x614))+((r21*sj15*sj16))+((cj15*r22))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x615=((1.0)*cj16);\nIkReal x616=((((-1.0)*(1.0)*r22*sj15))+((cj15*r21*sj16))+(((-1.0)*cj15*r20*x615)));\nj14eval[0]=x616;\nj14eval[1]=IKsign(x616);\nj14eval[2]=((IKabs((((r11*sj15*sj16))+(((-1.0)*r10*sj15*x615))+((cj15*r12)))))+(IKabs(((((-1.0)*r11*x615))+(((-1.0)*(1.0)*r10*sj16))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x617=r00*r00;\nIkReal x618=r01*r01;\nIkReal x619=cj15*cj15;\nIkReal x620=((2.0)*cj15*r02);\nIkReal x621=(cj16*r00*sj15);\nIkReal x622=(x618*x619);\nIkReal x623=(r00*sj16);\nIkReal x624=cj16*cj16;\nIkReal x625=(x617+x618+(((-1.0)*x622))+(((2.0)*cj16*r01*x619*x623))+((x622*x624))+(((-1.0)*x617*x619*x624))+((x619*(r02*r02)))+(((-1.0)*x620*x621))+((r01*sj15*sj16*x620)));\nIkReal x626=((1.0)*r01);\nj14eval[0]=x625;\nj14eval[1]=IKsign(x625);\nj14eval[2]=((IKabs(((((-1.0)*x623))+(((-1.0)*cj16*x626)))))+(IKabs(((((-1.0)*cj15*r02))+x621+(((-1.0)*sj15*sj16*x626))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j12, j13, j14]\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x627=(cj16*r00*sj15);\nIkReal x628=((1.0)*r01);\nIkReal x629=(r00*sj16);\nIkReal x630=r00*r00;\nIkReal x631=r01*r01;\nIkReal x632=cj15*cj15;\nIkReal x633=((2.0)*cj15*r02);\nIkReal x634=(x631*x632);\nIkReal x635=cj16*cj16;\nCheckValue<IkReal> x636=IKPowWithIntegerCheck(IKsign((((x632*(r02*r02)))+(((-1.0)*x627*x633))+(((-1.0)*x634))+x630+x631+((r01*sj15*sj16*x633))+(((2.0)*cj16*r01*x629*x632))+(((-1.0)*x630*x632*x635))+((x634*x635)))),-1);\nif(!x636.valid){\ncontinue;\n}\nCheckValue<IkReal> x637 = IKatan2WithCheck(IkReal(((((-1.0)*sj15*sj16*x628))+(((-1.0)*cj15*r02))+x627)),IkReal(((((-1.0)*x629))+(((-1.0)*cj16*x628)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x637.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x636.value)))+(x637.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x638=IKsin(j14);\nIkReal x639=(cj16*r01);\nIkReal x640=(r00*sj16);\nIkReal x641=IKcos(j14);\nIkReal x642=((1.0)*cj15*r02);\nIkReal x643=(cj16*r00*sj15);\nIkReal x644=(r01*sj15);\nIkReal x645=((1.0)*sj16*x641);\nIkReal x646=((1.0)*cj15*x638);\nIkReal x647=((1.0)*cj16*x641);\nIkReal x648=(cj16*sj15*x638);\nIkReal x649=((1.0)*sj15*sj16*x638);\nIkReal x650=((1.0)*x641);\nevalcond[0]=(((x638*x639))+((x641*x643))+((x638*x640))+(((-1.0)*x644*x645))+(((-1.0)*x641*x642)));\nevalcond[1]=((((-1.0)*r21*x649))+(((-1.0)*r21*x647))+(((-1.0)*r20*x645))+((r20*x648))+(((-1.0)*r22*x646)));\nevalcond[2]=((((-1.0)*r10*x645))+(((-1.0)*r12*x646))+(((-1.0)*r11*x649))+(((-1.0)*r11*x647))+((r10*x648)));\nevalcond[3]=((-1.0)+(((-1.0)*x640*x650))+(((-1.0)*x638*x642))+(((-1.0)*sj16*x638*x644))+((x638*x643))+(((-1.0)*x639*x650)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x651=(cj16*r20);\nIkReal x652=(r12*sj15);\nIkReal x653=(r21*sj16);\nIkReal x654=(r22*sj15);\nIkReal x655=(cj15*cj16*r10);\nIkReal x656=(cj15*cj16*r20);\nIkReal x657=(cj15*r11*sj16);\nIkReal x658=(cj15*r21*sj16);\nIkReal x659=((((1.08)*x651))+(((-1.0)*(12.0)*pz))+(((-0.36)*x655))+(((2.82)*x654))+(((-1.08)*x653))+(((-2.82)*x658))+(((2.82)*x656))+(((0.36)*x657))+(((-0.36)*x652)));\nj12eval[0]=((IKabs(((1.0)+(((0.12)*x657))+(((0.94)*x654))+(((-0.12)*x655))+(((-1.0)*(4.0)*pz))+(((0.94)*x656))+(((-0.94)*x658))+(((-0.36)*x653))+(((-0.12)*x652))+(((0.36)*x651)))))+(IKabs(((1.0)+x659)))+(IKabs(((-1.0)+x659))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x660=(cj16*r20);\nIkReal x661=(r12*sj15);\nIkReal x662=(r21*sj16);\nIkReal x663=(r22*sj15);\nIkReal x664=(cj15*cj16*r10);\nIkReal x665=(cj15*cj16*r20);\nIkReal x666=(cj15*r11*sj16);\nIkReal x667=(cj15*r21*sj16);\nIkReal x668=((((0.94)*x663))+(((-1.0)*(4.0)*pz))+(((0.36)*x660))+(((0.12)*x666))+(((-0.12)*x664))+(((-0.94)*x667))+(((-0.12)*x661))+(((-0.36)*x662))+(((0.94)*x665)));\nIkReal x669=((((-1.0)*(12.0)*pz))+(((-1.08)*x662))+(((0.36)*x666))+(((-0.36)*x664))+(((2.82)*x665))+(((1.08)*x660))+(((2.82)*x663))+(((-2.82)*x667))+(((-0.36)*x661)));\nop[0]=((1.0)+x668);\nop[1]=0;\nop[2]=((1.0)+x669);\nop[3]=0;\nop[4]=((-1.0)+x669);\nop[5]=0;\nop[6]=((-1.0)+x668);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x670=(cj16*r10);\nIkReal x671=(cj16*r20);\nIkReal x672=(r11*sj16);\nIkReal x673=(r21*sj16);\nIkReal x674=(r22*sj15);\nIkReal x675=(cj15*cj16*r20);\nIkReal x676=(cj15*r21*sj16);\nIkReal x677=((((0.0108)*x670))+(((-1.0)*(0.12)*py))+(((-0.2245)*x676))+(((0.2245)*x675))+(((0.2245)*x674))+(((-0.0846)*x673))+(((-1.0)*(0.94)*pz))+(((0.0846)*x671))+(((-0.0108)*x672)));\nIkReal x678=((((0.6735)*x674))+(((-1.0)*(0.36)*py))+(((-0.2538)*x673))+(((0.6735)*x675))+(((0.2538)*x671))+(((0.0324)*x670))+(((-0.0324)*x672))+(((-1.0)*(2.82)*pz))+(((-0.6735)*x676)));\nj12evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj12*htj12*htj12)))+(((-1.0)*(0.06)*htj12))+(((htj12*htj12*htj12*htj12)*(((0.235)+x678))))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((0.235)+x677))))+(((htj12*htj12)*(((-0.235)+x678))))+(((-1.0)*(0.06)*(htj12*htj12*htj12*htj12*htj12)))+x677);\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x679=(r22*sj15);\nIkReal x680=((1.0)*cj12);\nIkReal x681=(r12*sj15);\nIkReal x682=(cj12*cj15*sj16);\nIkReal x683=(cj15*sj12);\nIkReal x684=(cj16*r20);\nIkReal x685=(cj16*r10);\nIkReal x686=((1.0)*cj12*cj15);\nIkReal x687=((1.0)*cj15*sj12);\nif( IKabs((((r11*x682))+(((-1.0)*x680*x681))+(((-1.0)*x685*x686))+((x683*x684))+((sj12*x679))+(((-1.0)*r21*sj16*x687)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x679*x680))+(((-1.0)*x685*x687))+((r11*sj16*x683))+((r21*x682))+(((-1.0)*x684*x686))+(((-1.0)*sj12*x681)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r11*x682))+(((-1.0)*x680*x681))+(((-1.0)*x685*x686))+((x683*x684))+((sj12*x679))+(((-1.0)*r21*sj16*x687))))+IKsqr(((((-1.0)*x679*x680))+(((-1.0)*x685*x687))+((r11*sj16*x683))+((r21*x682))+(((-1.0)*x684*x686))+(((-1.0)*sj12*x681))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((r11*x682))+(((-1.0)*x680*x681))+(((-1.0)*x685*x686))+((x683*x684))+((sj12*x679))+(((-1.0)*r21*sj16*x687))), ((((-1.0)*x679*x680))+(((-1.0)*x685*x687))+((r11*sj16*x683))+((r21*x682))+(((-1.0)*x684*x686))+(((-1.0)*sj12*x681))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x688=IKsin(j13);\nIkReal x689=(cj12*x688);\nIkReal x690=IKcos(j13);\nIkReal x691=(sj12*x690);\nIkReal x692=(cj15*cj16);\nIkReal x693=((1.0)*cj15*sj16);\nIkReal x694=(cj12*x690);\nIkReal x695=(sj12*x688);\nIkReal x696=((((-1.0)*x695))+x694);\nIkReal x697=(cj16*sj14);\nIkReal x698=(sj14*sj16);\nIkReal x699=((1.0)*cj14*cj15);\nIkReal x700=(cj14*cj16*sj15);\nIkReal x701=((1.0)*cj14*sj15*sj16);\nIkReal x702=((0.09)*cj16);\nIkReal x703=((0.09)*sj16);\nevalcond[0]=((((-1.0)*r11*x693))+((r12*sj15))+x691+x689+((r10*x692)));\nevalcond[1]=((((-1.0)*r21*x693))+((r22*sj15))+((r20*x692))+x696);\nevalcond[2]=((((-1.0)*r12*x699))+(((-1.0)*r11*x701))+((r10*x700))+((r11*x697))+x696+((r10*x698)));\nevalcond[3]=((((-1.0)*x689))+((r20*x700))+(((-1.0)*r21*x701))+(((-1.0)*x691))+(((-1.0)*r22*x699))+((r21*x697))+((r20*x698)));\nevalcond[4]=((((-1.0)*(1.0)*pz))+(((-0.235)*x694))+(((0.235)*x695))+(((0.03)*x691))+((r20*x702))+(((-1.0)*(0.25)*cj12))+(((0.03)*x689))+(((-1.0)*r21*x703)));\nevalcond[5]=((((-0.235)*x691))+(((-1.0)*(1.0)*py))+(((-0.03)*x694))+(((-0.235)*x689))+(((-1.0)*(0.25)*sj12))+(((0.03)*x695))+(((-1.0)*r11*x703))+((r10*x702)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x704=((1.0)*cj16);\nCheckValue<IkReal> x705=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj15*r20*x704))+(((-1.0)*(1.0)*r22*sj15))+((cj15*r21*sj16)))),-1);\nif(!x705.valid){\ncontinue;\n}\nCheckValue<IkReal> x706 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x704))+(((-1.0)*(1.0)*r10*sj16)))),IkReal(((((-1.0)*r10*sj15*x704))+((r11*sj15*sj16))+((cj15*r12)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x706.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x705.value)))+(x706.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x707=IKsin(j14);\nIkReal x708=(cj16*r01);\nIkReal x709=(r00*sj16);\nIkReal x710=IKcos(j14);\nIkReal x711=((1.0)*cj15*r02);\nIkReal x712=(cj16*r00*sj15);\nIkReal x713=(r01*sj15);\nIkReal x714=((1.0)*sj16*x710);\nIkReal x715=((1.0)*cj15*x707);\nIkReal x716=((1.0)*cj16*x710);\nIkReal x717=(cj16*sj15*x707);\nIkReal x718=((1.0)*sj15*sj16*x707);\nIkReal x719=((1.0)*x710);\nevalcond[0]=(((x710*x712))+((x707*x708))+((x707*x709))+(((-1.0)*x713*x714))+(((-1.0)*x710*x711)));\nevalcond[1]=((((-1.0)*r20*x714))+(((-1.0)*r21*x716))+(((-1.0)*r21*x718))+((r20*x717))+(((-1.0)*r22*x715)));\nevalcond[2]=(((r10*x717))+(((-1.0)*r12*x715))+(((-1.0)*r10*x714))+(((-1.0)*r11*x716))+(((-1.0)*r11*x718)));\nevalcond[3]=((-1.0)+(((-1.0)*x707*x711))+(((-1.0)*x708*x719))+((x707*x712))+(((-1.0)*x709*x719))+(((-1.0)*sj16*x707*x713)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x720=(cj16*r20);\nIkReal x721=(r12*sj15);\nIkReal x722=(r21*sj16);\nIkReal x723=(r22*sj15);\nIkReal x724=(cj15*cj16*r10);\nIkReal x725=(cj15*cj16*r20);\nIkReal x726=(cj15*r11*sj16);\nIkReal x727=(cj15*r21*sj16);\nIkReal x728=((((-1.0)*(12.0)*pz))+(((-2.82)*x727))+(((2.82)*x725))+(((1.08)*x720))+(((2.82)*x723))+(((-0.36)*x724))+(((-0.36)*x721))+(((-1.08)*x722))+(((0.36)*x726)));\nj12eval[0]=((IKabs(((1.0)+(((0.94)*x723))+(((-0.12)*x724))+(((-0.94)*x727))+(((-1.0)*(4.0)*pz))+(((0.36)*x720))+(((0.94)*x725))+(((-0.36)*x722))+(((0.12)*x726))+(((-0.12)*x721)))))+(IKabs(((1.0)+x728)))+(IKabs(((-1.0)+x728))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x729=(cj16*r20);\nIkReal x730=(r12*sj15);\nIkReal x731=(r21*sj16);\nIkReal x732=(r22*sj15);\nIkReal x733=(cj15*cj16*r10);\nIkReal x734=(cj15*cj16*r20);\nIkReal x735=(cj15*r11*sj16);\nIkReal x736=(cj15*r21*sj16);\nIkReal x737=((((-1.0)*(4.0)*pz))+(((0.36)*x729))+(((0.12)*x735))+(((-0.12)*x733))+(((-0.94)*x736))+(((0.94)*x734))+(((-0.12)*x730))+(((-0.36)*x731))+(((0.94)*x732)));\nIkReal x738=((((-1.0)*(12.0)*pz))+(((-0.36)*x730))+(((-1.08)*x731))+(((-0.36)*x733))+(((-2.82)*x736))+(((1.08)*x729))+(((2.82)*x734))+(((0.36)*x735))+(((2.82)*x732)));\nop[0]=((1.0)+x737);\nop[1]=0;\nop[2]=((1.0)+x738);\nop[3]=0;\nop[4]=((-1.0)+x738);\nop[5]=0;\nop[6]=((-1.0)+x737);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x739=(cj16*r10);\nIkReal x740=(cj16*r20);\nIkReal x741=(r11*sj16);\nIkReal x742=(r21*sj16);\nIkReal x743=(r22*sj15);\nIkReal x744=(cj15*cj16*r20);\nIkReal x745=(cj15*r21*sj16);\nIkReal x746=((((0.0108)*x739))+(((-1.0)*(0.12)*py))+(((0.0846)*x740))+(((-1.0)*(0.94)*pz))+(((0.2245)*x744))+(((-0.2245)*x745))+(((-0.0108)*x741))+(((-0.0846)*x742))+(((0.2245)*x743)));\nIkReal x747=((((-1.0)*(0.36)*py))+(((-0.0324)*x741))+(((-0.6735)*x745))+(((0.2538)*x740))+(((0.6735)*x743))+(((-1.0)*(2.82)*pz))+(((-0.2538)*x742))+(((0.6735)*x744))+(((0.0324)*x739)));\nj12evalpoly[0]=((-0.235)+(((htj12*htj12*htj12*htj12)*(((0.235)+x747))))+(((-1.0)*(0.12)*(htj12*htj12*htj12)))+(((-1.0)*(0.06)*htj12))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((0.235)+x746))))+x746+(((-1.0)*(0.06)*(htj12*htj12*htj12*htj12*htj12)))+(((htj12*htj12)*(((-0.235)+x747)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x748=(r22*sj15);\nIkReal x749=((1.0)*cj12);\nIkReal x750=(r12*sj15);\nIkReal x751=(cj12*cj15*sj16);\nIkReal x752=(cj15*sj12);\nIkReal x753=(cj16*r20);\nIkReal x754=(cj16*r10);\nIkReal x755=((1.0)*cj12*cj15);\nIkReal x756=((1.0)*cj15*sj12);\nif( IKabs((((sj12*x748))+((r11*x751))+(((-1.0)*r21*sj16*x756))+(((-1.0)*x754*x755))+((x752*x753))+(((-1.0)*x749*x750)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x754*x756))+(((-1.0)*x748*x749))+(((-1.0)*x753*x755))+((r21*x751))+(((-1.0)*sj12*x750))+((r11*sj16*x752)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj12*x748))+((r11*x751))+(((-1.0)*r21*sj16*x756))+(((-1.0)*x754*x755))+((x752*x753))+(((-1.0)*x749*x750))))+IKsqr(((((-1.0)*x754*x756))+(((-1.0)*x748*x749))+(((-1.0)*x753*x755))+((r21*x751))+(((-1.0)*sj12*x750))+((r11*sj16*x752))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((sj12*x748))+((r11*x751))+(((-1.0)*r21*sj16*x756))+(((-1.0)*x754*x755))+((x752*x753))+(((-1.0)*x749*x750))), ((((-1.0)*x754*x756))+(((-1.0)*x748*x749))+(((-1.0)*x753*x755))+((r21*x751))+(((-1.0)*sj12*x750))+((r11*sj16*x752))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x757=IKsin(j13);\nIkReal x758=(cj12*x757);\nIkReal x759=IKcos(j13);\nIkReal x760=(sj12*x759);\nIkReal x761=(cj15*cj16);\nIkReal x762=((1.0)*cj15*sj16);\nIkReal x763=(cj12*x759);\nIkReal x764=(sj12*x757);\nIkReal x765=((((-1.0)*x764))+x763);\nIkReal x766=(cj16*sj14);\nIkReal x767=(sj14*sj16);\nIkReal x768=((1.0)*cj14*cj15);\nIkReal x769=(cj14*cj16*sj15);\nIkReal x770=((1.0)*cj14*sj15*sj16);\nIkReal x771=((0.09)*cj16);\nIkReal x772=((0.09)*sj16);\nevalcond[0]=(((r10*x761))+((r12*sj15))+x760+(((-1.0)*r11*x762))+x758);\nevalcond[1]=(((r20*x761))+((r22*sj15))+x765+(((-1.0)*r21*x762)));\nevalcond[2]=(((r11*x766))+(((-1.0)*r12*x768))+((r10*x767))+(((-1.0)*r11*x770))+x765+((r10*x769)));\nevalcond[3]=((((-1.0)*r22*x768))+((r20*x767))+(((-1.0)*x760))+((r21*x766))+((r20*x769))+(((-1.0)*x758))+(((-1.0)*r21*x770)));\nevalcond[4]=((((-1.0)*r21*x772))+(((0.235)*x764))+(((-1.0)*(1.0)*pz))+(((-0.235)*x763))+((r20*x771))+(((0.03)*x758))+(((-1.0)*(0.25)*cj12))+(((0.03)*x760)));\nevalcond[5]=((((-1.0)*(1.0)*py))+((r10*x771))+(((-1.0)*(0.25)*sj12))+(((-0.03)*x763))+(((-0.235)*x758))+(((-1.0)*r11*x772))+(((0.03)*x764))+(((-0.235)*x760)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x773=((1.0)*sj16);\nIkReal x774=((1.0)*cj16);\nCheckValue<IkReal> x775=IKPowWithIntegerCheck(IKsign((((cj15*cj16*r10))+((r12*sj15))+(((-1.0)*cj15*r11*x773)))),-1);\nif(!x775.valid){\ncontinue;\n}\nCheckValue<IkReal> x776 = IKatan2WithCheck(IkReal(((((-1.0)*r20*x773))+(((-1.0)*r21*x774)))),IkReal(((((-1.0)*r20*sj15*x774))+((r21*sj15*sj16))+((cj15*r22)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x776.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x775.value)))+(x776.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x777=IKsin(j14);\nIkReal x778=(cj16*r01);\nIkReal x779=(r00*sj16);\nIkReal x780=IKcos(j14);\nIkReal x781=((1.0)*cj15*r02);\nIkReal x782=(cj16*r00*sj15);\nIkReal x783=(r01*sj15);\nIkReal x784=((1.0)*sj16*x780);\nIkReal x785=((1.0)*cj15*x777);\nIkReal x786=((1.0)*cj16*x780);\nIkReal x787=(cj16*sj15*x777);\nIkReal x788=((1.0)*sj15*sj16*x777);\nIkReal x789=((1.0)*x780);\nevalcond[0]=((((-1.0)*x783*x784))+(((-1.0)*x780*x781))+((x777*x778))+((x777*x779))+((x780*x782)));\nevalcond[1]=((((-1.0)*r21*x786))+((r20*x787))+(((-1.0)*r22*x785))+(((-1.0)*r21*x788))+(((-1.0)*r20*x784)));\nevalcond[2]=((((-1.0)*r11*x788))+(((-1.0)*r12*x785))+((r10*x787))+(((-1.0)*r11*x786))+(((-1.0)*r10*x784)));\nevalcond[3]=((-1.0)+(((-1.0)*x778*x789))+(((-1.0)*sj16*x777*x783))+(((-1.0)*x779*x789))+(((-1.0)*x777*x781))+((x777*x782)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x790=(cj16*r20);\nIkReal x791=(r12*sj15);\nIkReal x792=(r21*sj16);\nIkReal x793=(r22*sj15);\nIkReal x794=(cj15*cj16*r10);\nIkReal x795=(cj15*cj16*r20);\nIkReal x796=(cj15*r11*sj16);\nIkReal x797=(cj15*r21*sj16);\nIkReal x798=((((2.82)*x795))+(((-0.36)*x791))+(((-1.0)*(12.0)*pz))+(((-1.08)*x792))+(((-0.36)*x794))+(((0.36)*x796))+(((1.08)*x790))+(((2.82)*x793))+(((-2.82)*x797)));\nj12eval[0]=((IKabs(((1.0)+(((0.36)*x790))+(((-0.94)*x797))+(((-1.0)*(4.0)*pz))+(((-0.12)*x794))+(((-0.36)*x792))+(((0.12)*x796))+(((0.94)*x793))+(((0.94)*x795))+(((-0.12)*x791)))))+(IKabs(((-1.0)+x798)))+(IKabs(((1.0)+x798))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x799=(cj16*r20);\nIkReal x800=(r12*sj15);\nIkReal x801=(r21*sj16);\nIkReal x802=(r22*sj15);\nIkReal x803=(cj15*cj16*r10);\nIkReal x804=(cj15*cj16*r20);\nIkReal x805=(cj15*r11*sj16);\nIkReal x806=(cj15*r21*sj16);\nIkReal x807=((((0.12)*x805))+(((0.94)*x802))+(((-1.0)*(4.0)*pz))+(((0.36)*x799))+(((-0.12)*x800))+(((-0.12)*x803))+(((0.94)*x804))+(((-0.94)*x806))+(((-0.36)*x801)));\nIkReal x808=((((0.36)*x805))+(((-1.08)*x801))+(((2.82)*x804))+(((-1.0)*(12.0)*pz))+(((1.08)*x799))+(((-2.82)*x806))+(((2.82)*x802))+(((-0.36)*x800))+(((-0.36)*x803)));\nop[0]=((1.0)+x807);\nop[1]=0;\nop[2]=((1.0)+x808);\nop[3]=0;\nop[4]=((-1.0)+x808);\nop[5]=0;\nop[6]=((-1.0)+x807);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x809=(cj16*r10);\nIkReal x810=(cj16*r20);\nIkReal x811=(r11*sj16);\nIkReal x812=(r21*sj16);\nIkReal x813=(r22*sj15);\nIkReal x814=(cj15*cj16*r20);\nIkReal x815=(cj15*r21*sj16);\nIkReal x816=((((-1.0)*(0.12)*py))+(((-0.0846)*x812))+(((0.0108)*x809))+(((-0.0108)*x811))+(((0.2245)*x813))+(((-0.2245)*x815))+(((0.2245)*x814))+(((-1.0)*(0.94)*pz))+(((0.0846)*x810)));\nIkReal x817=((((-1.0)*(0.36)*py))+(((0.0324)*x809))+(((-0.2538)*x812))+(((-0.0324)*x811))+(((0.2538)*x810))+(((0.6735)*x813))+(((0.6735)*x814))+(((-1.0)*(2.82)*pz))+(((-0.6735)*x815)));\nj12evalpoly[0]=((-0.235)+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((0.235)+x816))))+(((-1.0)*(0.12)*(htj12*htj12*htj12)))+(((-1.0)*(0.06)*htj12))+(((htj12*htj12)*(((-0.235)+x817))))+(((htj12*htj12*htj12*htj12)*(((0.235)+x817))))+x816+(((-1.0)*(0.06)*(htj12*htj12*htj12*htj12*htj12))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x818=(r22*sj15);\nIkReal x819=((1.0)*cj12);\nIkReal x820=(r12*sj15);\nIkReal x821=(cj12*cj15*sj16);\nIkReal x822=(cj15*sj12);\nIkReal x823=(cj16*r20);\nIkReal x824=(cj16*r10);\nIkReal x825=((1.0)*cj12*cj15);\nIkReal x826=((1.0)*cj15*sj12);\nif( IKabs(((((-1.0)*x819*x820))+((sj12*x818))+(((-1.0)*x824*x825))+(((-1.0)*r21*sj16*x826))+((r11*x821))+((x822*x823)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r11*sj16*x822))+(((-1.0)*x818*x819))+(((-1.0)*x823*x825))+(((-1.0)*x824*x826))+((r21*x821))+(((-1.0)*sj12*x820)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x819*x820))+((sj12*x818))+(((-1.0)*x824*x825))+(((-1.0)*r21*sj16*x826))+((r11*x821))+((x822*x823))))+IKsqr((((r11*sj16*x822))+(((-1.0)*x818*x819))+(((-1.0)*x823*x825))+(((-1.0)*x824*x826))+((r21*x821))+(((-1.0)*sj12*x820))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*x819*x820))+((sj12*x818))+(((-1.0)*x824*x825))+(((-1.0)*r21*sj16*x826))+((r11*x821))+((x822*x823))), (((r11*sj16*x822))+(((-1.0)*x818*x819))+(((-1.0)*x823*x825))+(((-1.0)*x824*x826))+((r21*x821))+(((-1.0)*sj12*x820))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x827=IKsin(j13);\nIkReal x828=(cj12*x827);\nIkReal x829=IKcos(j13);\nIkReal x830=(sj12*x829);\nIkReal x831=(cj15*cj16);\nIkReal x832=((1.0)*cj15*sj16);\nIkReal x833=(cj12*x829);\nIkReal x834=(sj12*x827);\nIkReal x835=((((-1.0)*x834))+x833);\nIkReal x836=(cj16*sj14);\nIkReal x837=(sj14*sj16);\nIkReal x838=((1.0)*cj14*cj15);\nIkReal x839=(cj14*cj16*sj15);\nIkReal x840=((1.0)*cj14*sj15*sj16);\nIkReal x841=((0.09)*cj16);\nIkReal x842=((0.09)*sj16);\nevalcond[0]=(x830+((r12*sj15))+x828+((r10*x831))+(((-1.0)*r11*x832)));\nevalcond[1]=(((r22*sj15))+x835+(((-1.0)*r21*x832))+((r20*x831)));\nevalcond[2]=((((-1.0)*r11*x840))+((r11*x836))+x835+((r10*x839))+((r10*x837))+(((-1.0)*r12*x838)));\nevalcond[3]=(((r20*x837))+((r21*x836))+(((-1.0)*r22*x838))+(((-1.0)*x830))+((r20*x839))+(((-1.0)*x828))+(((-1.0)*r21*x840)));\nevalcond[4]=((((-1.0)*(1.0)*pz))+(((0.235)*x834))+(((0.03)*x830))+(((0.03)*x828))+(((-0.235)*x833))+((r20*x841))+(((-1.0)*r21*x842))+(((-1.0)*(0.25)*cj12)));\nevalcond[5]=((((-0.03)*x833))+(((-1.0)*(1.0)*py))+(((0.03)*x834))+((r10*x841))+(((-1.0)*(0.25)*sj12))+(((-0.235)*x828))+(((-1.0)*r11*x842))+(((-0.235)*x830)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x843=(cj16*r00);\nIkReal x844=(r01*sj16);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j11)))), 6.28318530717959)));\nevalcond[1]=(((r02*sj15))+((cj15*x843))+(((-1.0)*cj15*x844)));\nevalcond[2]=((0.095)+(((-1.0)*(1.0)*px))+(((-0.09)*x844))+(((0.09)*x843)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j14eval[3];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x845=((1.0)*cj15);\nIkReal x846=(((cj15*cj16*r10))+((r12*sj15))+(((-1.0)*r11*sj16*x845)));\nj14eval[0]=x846;\nj14eval[1]=IKsign(x846);\nj14eval[2]=((IKabs((((cj16*r21))+((r20*sj16)))))+(IKabs((((cj16*r20*sj15))+(((-1.0)*r22*x845))+(((-1.0)*(1.0)*r21*sj15*sj16))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x847=((1.0)*sj15);\nIkReal x848=((1.0)*cj15);\nIkReal x849=((((-1.0)*cj16*r20*x848))+(((-1.0)*r22*x847))+((cj15*r21*sj16)));\nj14eval[0]=x849;\nj14eval[1]=IKsign(x849);\nj14eval[2]=((IKabs(((((-1.0)*r11*sj16*x847))+(((-1.0)*r12*x848))+((cj16*r10*sj15)))))+(IKabs((((r10*sj16))+((cj16*r11))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x850=r00*r00;\nIkReal x851=r01*r01;\nIkReal x852=cj15*cj15;\nIkReal x853=((2.0)*cj15*r02);\nIkReal x854=(cj16*r00*sj15);\nIkReal x855=(r01*sj15*sj16);\nIkReal x856=(x851*x852);\nIkReal x857=(r00*sj16);\nIkReal x858=cj16*cj16;\nIkReal x859=((((-1.0)*x853*x854))+((x852*(r02*r02)))+x850+x851+((x856*x858))+(((2.0)*cj16*r01*x852*x857))+((x853*x855))+(((-1.0)*x856))+(((-1.0)*x850*x852*x858)));\nj14eval[0]=x859;\nj14eval[1]=IKsign(x859);\nj14eval[2]=((IKabs((x857+((cj16*r01)))))+(IKabs((x855+(((-1.0)*x854))+((cj15*r02))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j12, j13, j14]\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x860=(r01*sj15*sj16);\nIkReal x861=(cj16*r00*sj15);\nIkReal x862=(r00*sj16);\nIkReal x863=r00*r00;\nIkReal x864=r01*r01;\nIkReal x865=cj15*cj15;\nIkReal x866=((2.0)*cj15*r02);\nIkReal x867=(x864*x865);\nIkReal x868=cj16*cj16;\nCheckValue<IkReal> x869 = IKatan2WithCheck(IkReal((x860+((cj15*r02))+(((-1.0)*x861)))),IkReal((x862+((cj16*r01)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x869.valid){\ncontinue;\n}\nCheckValue<IkReal> x870=IKPowWithIntegerCheck(IKsign(((((2.0)*cj16*r01*x862*x865))+(((-1.0)*x867))+((x867*x868))+(((-1.0)*x863*x865*x868))+x863+x864+((x860*x866))+((x865*(r02*r02)))+(((-1.0)*x861*x866)))),-1);\nif(!x870.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x869.value)+(((1.5707963267949)*(x870.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x871=IKsin(j14);\nIkReal x872=(cj16*r01);\nIkReal x873=(r00*sj16);\nIkReal x874=IKcos(j14);\nIkReal x875=((1.0)*cj15*r02);\nIkReal x876=(cj16*r00*sj15);\nIkReal x877=(r01*sj15);\nIkReal x878=((1.0)*sj16*x874);\nIkReal x879=((1.0)*cj15*x871);\nIkReal x880=((1.0)*cj16*x874);\nIkReal x881=(cj16*sj15*x871);\nIkReal x882=((1.0)*sj15*sj16*x871);\nIkReal x883=((1.0)*x874);\nevalcond[0]=(((x871*x872))+((x871*x873))+(((-1.0)*x877*x878))+((x874*x876))+(((-1.0)*x874*x875)));\nevalcond[1]=((((-1.0)*r21*x880))+(((-1.0)*r21*x882))+((r20*x881))+(((-1.0)*r20*x878))+(((-1.0)*r22*x879)));\nevalcond[2]=((((-1.0)*r11*x882))+(((-1.0)*r12*x879))+(((-1.0)*r10*x878))+((r10*x881))+(((-1.0)*r11*x880)));\nevalcond[3]=((1.0)+(((-1.0)*x871*x875))+(((-1.0)*sj16*x871*x877))+(((-1.0)*x872*x883))+((x871*x876))+(((-1.0)*x873*x883)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x884=(cj16*r20);\nIkReal x885=(r12*sj15);\nIkReal x886=(r21*sj16);\nIkReal x887=(r22*sj15);\nIkReal x888=(cj15*cj16*r10);\nIkReal x889=(cj15*cj16*r20);\nIkReal x890=(cj15*r11*sj16);\nIkReal x891=(cj15*r21*sj16);\nIkReal x892=((((-1.08)*x884))+(((1.08)*x886))+(((-0.36)*x885))+(((2.82)*x891))+(((-0.36)*x888))+(((-2.82)*x889))+(((12.0)*pz))+(((-2.82)*x887))+(((0.36)*x890)));\nj12eval[0]=((IKabs(((-1.0)+x892)))+(IKabs(((1.0)+x892)))+(IKabs(((-1.0)+(((0.12)*x890))+(((-0.94)*x887))+(((-0.94)*x889))+(((-0.36)*x884))+(((0.36)*x886))+(((4.0)*pz))+(((-0.12)*x885))+(((-0.12)*x888))+(((0.94)*x891))))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x893=(cj16*r20);\nIkReal x894=(r12*sj15);\nIkReal x895=(r21*sj16);\nIkReal x896=(r22*sj15);\nIkReal x897=(cj15*cj16*r10);\nIkReal x898=(cj15*cj16*r20);\nIkReal x899=(cj15*r11*sj16);\nIkReal x900=(cj15*r21*sj16);\nIkReal x901=((((0.12)*x899))+(((-0.36)*x893))+(((-0.94)*x896))+(((0.94)*x900))+(((4.0)*pz))+(((-0.12)*x894))+(((0.36)*x895))+(((-0.94)*x898))+(((-0.12)*x897)));\nIkReal x902=((((2.82)*x900))+(((1.08)*x895))+(((-0.36)*x894))+(((0.36)*x899))+(((-2.82)*x896))+(((-2.82)*x898))+(((-1.08)*x893))+(((12.0)*pz))+(((-0.36)*x897)));\nop[0]=((-1.0)+x901);\nop[1]=0;\nop[2]=((-1.0)+x902);\nop[3]=0;\nop[4]=((1.0)+x902);\nop[5]=0;\nop[6]=((1.0)+x901);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x903=(cj16*r20);\nIkReal x904=((0.36)*x903);\nIkReal x905=(r21*sj16);\nIkReal x906=((0.36)*x905);\nIkReal x907=(r22*sj15);\nIkReal x908=(cj14*cj15*r22);\nIkReal x909=(cj15*cj16*r20);\nIkReal x910=(cj15*r21*sj16);\nIkReal x911=(cj16*r21*sj14);\nIkReal x912=(r20*sj14*sj16);\nIkReal x913=((0.12)*cj14*sj15);\nIkReal x914=((((-0.12)*x908))+(((-1.0)*(4.0)*pz))+(((-1.0)*x905*x913))+x904+((x903*x913))+(((-0.94)*x910))+(((0.94)*x907))+(((0.94)*x909))+(((-1.0)*x906))+(((0.12)*x911))+(((0.12)*x912)));\nIkReal x915=(cj14*sj15);\nIkReal x916=((((-2.82)*x910))+(((-1.0)*(12.0)*pz))+(((-0.36)*x908))+(((0.36)*x912))+(((2.82)*x907))+(((2.82)*x909))+(((0.36)*x911))+(((-1.08)*x905))+(((1.08)*x903))+(((-1.0)*x906*x915))+((x904*x915)));\nj12evalpoly[0]=((-1.0)+(((htj12*htj12*htj12*htj12)*(((1.0)+x916))))+x914+(((htj12*htj12)*(((-1.0)+x916))))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((1.0)+x914)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x917=(r12*sj15);\nIkReal x918=(r22*sj15);\nIkReal x919=(cj12*cj15);\nIkReal x920=(cj16*r10);\nIkReal x921=(cj15*sj12);\nIkReal x922=(cj16*r20);\nIkReal x923=(r11*sj16);\nIkReal x924=((1.0)*cj12*cj15);\nIkReal x925=(r21*sj16);\nIkReal x926=((1.0)*cj15*sj12);\nif( IKabs(((((-1.0)*x923*x924))+(((-1.0)*x925*x926))+((sj12*x918))+((cj12*x917))+((x921*x922))+((x919*x920)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x920*x921))+((sj12*x917))+(((-1.0)*x923*x926))+(((-1.0)*x922*x924))+((x919*x925))+(((-1.0)*cj12*x918)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x923*x924))+(((-1.0)*x925*x926))+((sj12*x918))+((cj12*x917))+((x921*x922))+((x919*x920))))+IKsqr((((x920*x921))+((sj12*x917))+(((-1.0)*x923*x926))+(((-1.0)*x922*x924))+((x919*x925))+(((-1.0)*cj12*x918))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*x923*x924))+(((-1.0)*x925*x926))+((sj12*x918))+((cj12*x917))+((x921*x922))+((x919*x920))), (((x920*x921))+((sj12*x917))+(((-1.0)*x923*x926))+(((-1.0)*x922*x924))+((x919*x925))+(((-1.0)*cj12*x918))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x927=IKcos(j13);\nIkReal x928=(cj12*x927);\nIkReal x929=(cj15*cj16);\nIkReal x930=IKsin(j13);\nIkReal x931=(sj12*x930);\nIkReal x932=((1.0)*cj15*sj16);\nIkReal x933=(cj12*x930);\nIkReal x934=(sj12*x927);\nIkReal x935=((((-1.0)*x934))+(((-1.0)*x933)));\nIkReal x936=(cj16*sj14);\nIkReal x937=(sj14*sj16);\nIkReal x938=((1.0)*cj14*cj15);\nIkReal x939=(cj14*cj16*sj15);\nIkReal x940=((1.0)*cj14*sj15*sj16);\nIkReal x941=((0.09)*cj16);\nIkReal x942=((0.09)*sj16);\nevalcond[0]=((((-1.0)*r21*x932))+((r22*sj15))+(((-1.0)*x931))+x928+((r20*x929)));\nevalcond[1]=(((r12*sj15))+(((-1.0)*r11*x932))+((r10*x929))+x935);\nevalcond[2]=((((-1.0)*x928))+((r11*x936))+(((-1.0)*r12*x938))+((r10*x939))+(((-1.0)*r11*x940))+((r10*x937))+x931);\nevalcond[3]=(((r20*x939))+(((-1.0)*r22*x938))+((r21*x936))+((r20*x937))+(((-1.0)*r21*x940))+x935);\nevalcond[4]=((((0.235)*x931))+(((-1.0)*(1.0)*pz))+(((-1.0)*r21*x942))+(((0.03)*x933))+(((-0.235)*x928))+((r20*x941))+(((0.03)*x934))+(((-1.0)*(0.25)*cj12)));\nevalcond[5]=((((-1.0)*(1.0)*py))+(((0.235)*x933))+(((0.03)*x928))+(((-0.03)*x931))+(((-1.0)*r11*x942))+(((0.25)*sj12))+((r10*x941))+(((0.235)*x934)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x943=((1.0)*sj15);\nIkReal x944=((1.0)*cj15);\nCheckValue<IkReal> x945 = IKatan2WithCheck(IkReal((((r10*sj16))+((cj16*r11)))),IkReal(((((-1.0)*r12*x944))+((cj16*r10*sj15))+(((-1.0)*r11*sj16*x943)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x945.valid){\ncontinue;\n}\nCheckValue<IkReal> x946=IKPowWithIntegerCheck(IKsign(((((-1.0)*r22*x943))+(((-1.0)*cj16*r20*x944))+((cj15*r21*sj16)))),-1);\nif(!x946.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x945.value)+(((1.5707963267949)*(x946.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x947=IKsin(j14);\nIkReal x948=(cj16*r01);\nIkReal x949=(r00*sj16);\nIkReal x950=IKcos(j14);\nIkReal x951=((1.0)*cj15*r02);\nIkReal x952=(cj16*r00*sj15);\nIkReal x953=(r01*sj15);\nIkReal x954=((1.0)*sj16*x950);\nIkReal x955=((1.0)*cj15*x947);\nIkReal x956=((1.0)*cj16*x950);\nIkReal x957=(cj16*sj15*x947);\nIkReal x958=((1.0)*sj15*sj16*x947);\nIkReal x959=((1.0)*x950);\nevalcond[0]=((((-1.0)*x953*x954))+((x950*x952))+(((-1.0)*x950*x951))+((x947*x949))+((x947*x948)));\nevalcond[1]=((((-1.0)*r21*x958))+(((-1.0)*r21*x956))+(((-1.0)*r22*x955))+(((-1.0)*r20*x954))+((r20*x957)));\nevalcond[2]=(((r10*x957))+(((-1.0)*r12*x955))+(((-1.0)*r11*x958))+(((-1.0)*r11*x956))+(((-1.0)*r10*x954)));\nevalcond[3]=((1.0)+(((-1.0)*sj16*x947*x953))+(((-1.0)*x947*x951))+(((-1.0)*x949*x959))+((x947*x952))+(((-1.0)*x948*x959)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x960=(cj16*r20);\nIkReal x961=(r12*sj15);\nIkReal x962=(r21*sj16);\nIkReal x963=(r22*sj15);\nIkReal x964=(cj15*cj16*r10);\nIkReal x965=(cj15*cj16*r20);\nIkReal x966=(cj15*r11*sj16);\nIkReal x967=(cj15*r21*sj16);\nIkReal x968=((((-0.36)*x964))+(((-2.82)*x965))+(((1.08)*x962))+(((2.82)*x967))+(((-0.36)*x961))+(((0.36)*x966))+(((-2.82)*x963))+(((12.0)*pz))+(((-1.08)*x960)));\nj12eval[0]=((IKabs(((-1.0)+(((0.94)*x967))+(((-0.12)*x961))+(((-0.94)*x965))+(((0.36)*x962))+(((-0.36)*x960))+(((0.12)*x966))+(((4.0)*pz))+(((-0.12)*x964))+(((-0.94)*x963)))))+(IKabs(((1.0)+x968)))+(IKabs(((-1.0)+x968))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x969=(cj16*r20);\nIkReal x970=(r12*sj15);\nIkReal x971=(r21*sj16);\nIkReal x972=(r22*sj15);\nIkReal x973=(cj15*cj16*r10);\nIkReal x974=(cj15*cj16*r20);\nIkReal x975=(cj15*r11*sj16);\nIkReal x976=(cj15*r21*sj16);\nIkReal x977=((((-0.12)*x970))+(((0.12)*x975))+(((-0.94)*x974))+(((0.36)*x971))+(((4.0)*pz))+(((-0.94)*x972))+(((0.94)*x976))+(((-0.12)*x973))+(((-0.36)*x969)));\nIkReal x978=((((1.08)*x971))+(((-0.36)*x973))+(((-0.36)*x970))+(((2.82)*x976))+(((0.36)*x975))+(((-1.08)*x969))+(((-2.82)*x974))+(((12.0)*pz))+(((-2.82)*x972)));\nop[0]=((-1.0)+x977);\nop[1]=0;\nop[2]=((-1.0)+x978);\nop[3]=0;\nop[4]=((1.0)+x978);\nop[5]=0;\nop[6]=((1.0)+x977);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x979=(cj16*r20);\nIkReal x980=((0.36)*x979);\nIkReal x981=(r21*sj16);\nIkReal x982=((0.36)*x981);\nIkReal x983=(r22*sj15);\nIkReal x984=(cj14*cj15*r22);\nIkReal x985=(cj15*cj16*r20);\nIkReal x986=(cj15*r21*sj16);\nIkReal x987=(cj16*r21*sj14);\nIkReal x988=(r20*sj14*sj16);\nIkReal x989=((0.12)*cj14*sj15);\nIkReal x990=(((x979*x989))+(((0.12)*x988))+(((0.94)*x985))+(((-1.0)*(4.0)*pz))+(((-1.0)*x981*x989))+(((-1.0)*x982))+(((0.94)*x983))+x980+(((0.12)*x987))+(((-0.12)*x984))+(((-0.94)*x986)));\nIkReal x991=(cj14*sj15);\nIkReal x992=((((-1.08)*x981))+(((-1.0)*(12.0)*pz))+(((0.36)*x988))+(((-2.82)*x986))+(((-1.0)*x982*x991))+(((0.36)*x987))+(((-0.36)*x984))+(((2.82)*x985))+((x980*x991))+(((2.82)*x983))+(((1.08)*x979)));\nj12evalpoly[0]=((-1.0)+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((1.0)+x990))))+(((htj12*htj12)*(((-1.0)+x992))))+(((htj12*htj12*htj12*htj12)*(((1.0)+x992))))+x990);\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x993=(r12*sj15);\nIkReal x994=(r22*sj15);\nIkReal x995=(cj12*cj15);\nIkReal x996=(cj16*r10);\nIkReal x997=(cj15*sj12);\nIkReal x998=(cj16*r20);\nIkReal x999=(r11*sj16);\nIkReal x1000=((1.0)*cj12*cj15);\nIkReal x1001=(r21*sj16);\nIkReal x1002=((1.0)*cj15*sj12);\nif( IKabs((((cj12*x993))+((x997*x998))+((x995*x996))+((sj12*x994))+(((-1.0)*x1000*x999))+(((-1.0)*x1001*x1002)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj12*x993))+((x1001*x995))+(((-1.0)*cj12*x994))+((x996*x997))+(((-1.0)*x1002*x999))+(((-1.0)*x1000*x998)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj12*x993))+((x997*x998))+((x995*x996))+((sj12*x994))+(((-1.0)*x1000*x999))+(((-1.0)*x1001*x1002))))+IKsqr((((sj12*x993))+((x1001*x995))+(((-1.0)*cj12*x994))+((x996*x997))+(((-1.0)*x1002*x999))+(((-1.0)*x1000*x998))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((cj12*x993))+((x997*x998))+((x995*x996))+((sj12*x994))+(((-1.0)*x1000*x999))+(((-1.0)*x1001*x1002))), (((sj12*x993))+((x1001*x995))+(((-1.0)*cj12*x994))+((x996*x997))+(((-1.0)*x1002*x999))+(((-1.0)*x1000*x998))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x1003=IKcos(j13);\nIkReal x1004=(cj12*x1003);\nIkReal x1005=(cj15*cj16);\nIkReal x1006=IKsin(j13);\nIkReal x1007=(sj12*x1006);\nIkReal x1008=((1.0)*cj15*sj16);\nIkReal x1009=(cj12*x1006);\nIkReal x1010=(sj12*x1003);\nIkReal x1011=((((-1.0)*x1010))+(((-1.0)*x1009)));\nIkReal x1012=(cj16*sj14);\nIkReal x1013=(sj14*sj16);\nIkReal x1014=((1.0)*cj14*cj15);\nIkReal x1015=(cj14*cj16*sj15);\nIkReal x1016=((1.0)*cj14*sj15*sj16);\nIkReal x1017=((0.09)*cj16);\nIkReal x1018=((0.09)*sj16);\nevalcond[0]=(((r22*sj15))+x1004+(((-1.0)*x1007))+(((-1.0)*r21*x1008))+((r20*x1005)));\nevalcond[1]=(((r12*sj15))+((r10*x1005))+x1011+(((-1.0)*r11*x1008)));\nevalcond[2]=((((-1.0)*r11*x1016))+(((-1.0)*x1004))+((r10*x1013))+x1007+((r10*x1015))+(((-1.0)*r12*x1014))+((r11*x1012)));\nevalcond[3]=(((r20*x1015))+((r21*x1012))+(((-1.0)*r21*x1016))+x1011+(((-1.0)*r22*x1014))+((r20*x1013)));\nevalcond[4]=(((r20*x1017))+(((-1.0)*(1.0)*pz))+(((0.03)*x1009))+(((-0.235)*x1004))+(((0.03)*x1010))+(((-1.0)*(0.25)*cj12))+(((0.235)*x1007))+(((-1.0)*r21*x1018)));\nevalcond[5]=((((-0.03)*x1007))+((r10*x1017))+(((-1.0)*(1.0)*py))+(((0.235)*x1009))+(((0.03)*x1004))+(((0.235)*x1010))+(((0.25)*sj12))+(((-1.0)*r11*x1018)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x1019=((1.0)*cj15);\nCheckValue<IkReal> x1020 = IKatan2WithCheck(IkReal((((cj16*r21))+((r20*sj16)))),IkReal(((((-1.0)*r22*x1019))+((cj16*r20*sj15))+(((-1.0)*(1.0)*r21*sj15*sj16)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1020.valid){\ncontinue;\n}\nCheckValue<IkReal> x1021=IKPowWithIntegerCheck(IKsign(((((-1.0)*r11*sj16*x1019))+((cj15*cj16*r10))+((r12*sj15)))),-1);\nif(!x1021.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x1020.value)+(((1.5707963267949)*(x1021.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x1022=IKsin(j14);\nIkReal x1023=(cj16*r01);\nIkReal x1024=(r00*sj16);\nIkReal x1025=IKcos(j14);\nIkReal x1026=((1.0)*cj15*r02);\nIkReal x1027=(cj16*r00*sj15);\nIkReal x1028=(r01*sj15);\nIkReal x1029=((1.0)*sj16*x1025);\nIkReal x1030=((1.0)*cj15*x1022);\nIkReal x1031=((1.0)*cj16*x1025);\nIkReal x1032=(cj16*sj15*x1022);\nIkReal x1033=((1.0)*sj15*sj16*x1022);\nIkReal x1034=((1.0)*x1025);\nevalcond[0]=(((x1022*x1024))+(((-1.0)*x1028*x1029))+((x1022*x1023))+(((-1.0)*x1025*x1026))+((x1025*x1027)));\nevalcond[1]=((((-1.0)*r21*x1031))+((r20*x1032))+(((-1.0)*r22*x1030))+(((-1.0)*r20*x1029))+(((-1.0)*r21*x1033)));\nevalcond[2]=(((r10*x1032))+(((-1.0)*r11*x1031))+(((-1.0)*r10*x1029))+(((-1.0)*r12*x1030))+(((-1.0)*r11*x1033)));\nevalcond[3]=((1.0)+(((-1.0)*x1022*x1026))+(((-1.0)*x1024*x1034))+(((-1.0)*sj16*x1022*x1028))+(((-1.0)*x1023*x1034))+((x1022*x1027)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x1035=(cj16*r20);\nIkReal x1036=(r12*sj15);\nIkReal x1037=(r21*sj16);\nIkReal x1038=(r22*sj15);\nIkReal x1039=(cj15*cj16*r10);\nIkReal x1040=(cj15*cj16*r20);\nIkReal x1041=(cj15*r11*sj16);\nIkReal x1042=(cj15*r21*sj16);\nIkReal x1043=((((-2.82)*x1040))+(((-2.82)*x1038))+(((2.82)*x1042))+(((-1.08)*x1035))+(((-0.36)*x1039))+(((1.08)*x1037))+(((12.0)*pz))+(((-0.36)*x1036))+(((0.36)*x1041)));\nj12eval[0]=((IKabs(((-1.0)+x1043)))+(IKabs(((1.0)+x1043)))+(IKabs(((-1.0)+(((0.36)*x1037))+(((-0.12)*x1039))+(((0.94)*x1042))+(((0.12)*x1041))+(((-0.94)*x1038))+(((4.0)*pz))+(((-0.94)*x1040))+(((-0.36)*x1035))+(((-0.12)*x1036))))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x1044=(cj16*r20);\nIkReal x1045=(r12*sj15);\nIkReal x1046=(r21*sj16);\nIkReal x1047=(r22*sj15);\nIkReal x1048=(cj15*cj16*r10);\nIkReal x1049=(cj15*cj16*r20);\nIkReal x1050=(cj15*r11*sj16);\nIkReal x1051=(cj15*r21*sj16);\nIkReal x1052=((((-0.36)*x1044))+(((0.12)*x1050))+(((-0.94)*x1047))+(((0.94)*x1051))+(((4.0)*pz))+(((-0.12)*x1045))+(((-0.12)*x1048))+(((-0.94)*x1049))+(((0.36)*x1046)));\nIkReal x1053=((((-2.82)*x1047))+(((0.36)*x1050))+(((-1.08)*x1044))+(((-2.82)*x1049))+(((1.08)*x1046))+(((12.0)*pz))+(((2.82)*x1051))+(((-0.36)*x1045))+(((-0.36)*x1048)));\nop[0]=((-1.0)+x1052);\nop[1]=0;\nop[2]=((-1.0)+x1053);\nop[3]=0;\nop[4]=((1.0)+x1053);\nop[5]=0;\nop[6]=((1.0)+x1052);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x1054=(cj16*r20);\nIkReal x1055=((0.36)*x1054);\nIkReal x1056=(r21*sj16);\nIkReal x1057=((0.36)*x1056);\nIkReal x1058=(r22*sj15);\nIkReal x1059=(cj14*cj15*r22);\nIkReal x1060=(cj15*cj16*r20);\nIkReal x1061=(cj15*r21*sj16);\nIkReal x1062=(cj16*r21*sj14);\nIkReal x1063=(r20*sj14*sj16);\nIkReal x1064=((0.12)*cj14*sj15);\nIkReal x1065=((((0.12)*x1062))+(((0.12)*x1063))+(((-1.0)*(4.0)*pz))+x1055+((x1054*x1064))+(((-0.12)*x1059))+(((0.94)*x1058))+(((-0.94)*x1061))+(((-1.0)*x1056*x1064))+(((0.94)*x1060))+(((-1.0)*x1057)));\nIkReal x1066=(cj14*sj15);\nIkReal x1067=((((-1.0)*(12.0)*pz))+(((-1.08)*x1056))+(((2.82)*x1058))+(((-1.0)*x1057*x1066))+(((2.82)*x1060))+(((0.36)*x1063))+(((1.08)*x1054))+(((-0.36)*x1059))+((x1055*x1066))+(((0.36)*x1062))+(((-2.82)*x1061)));\nj12evalpoly[0]=((-1.0)+x1065+(((htj12*htj12*htj12*htj12)*(((1.0)+x1067))))+(((htj12*htj12)*(((-1.0)+x1067))))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((1.0)+x1065)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x1068=(r12*sj15);\nIkReal x1069=(r22*sj15);\nIkReal x1070=(cj12*cj15);\nIkReal x1071=(cj16*r10);\nIkReal x1072=(cj15*sj12);\nIkReal x1073=(cj16*r20);\nIkReal x1074=(r11*sj16);\nIkReal x1075=((1.0)*cj12*cj15);\nIkReal x1076=(r21*sj16);\nIkReal x1077=((1.0)*cj15*sj12);\nif( IKabs((((x1072*x1073))+(((-1.0)*x1076*x1077))+((sj12*x1069))+(((-1.0)*x1074*x1075))+((cj12*x1068))+((x1070*x1071)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x1071*x1072))+((x1070*x1076))+((sj12*x1068))+(((-1.0)*x1074*x1077))+(((-1.0)*cj12*x1069))+(((-1.0)*x1073*x1075)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1072*x1073))+(((-1.0)*x1076*x1077))+((sj12*x1069))+(((-1.0)*x1074*x1075))+((cj12*x1068))+((x1070*x1071))))+IKsqr((((x1071*x1072))+((x1070*x1076))+((sj12*x1068))+(((-1.0)*x1074*x1077))+(((-1.0)*cj12*x1069))+(((-1.0)*x1073*x1075))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((x1072*x1073))+(((-1.0)*x1076*x1077))+((sj12*x1069))+(((-1.0)*x1074*x1075))+((cj12*x1068))+((x1070*x1071))), (((x1071*x1072))+((x1070*x1076))+((sj12*x1068))+(((-1.0)*x1074*x1077))+(((-1.0)*cj12*x1069))+(((-1.0)*x1073*x1075))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x1078=IKcos(j13);\nIkReal x1079=(cj12*x1078);\nIkReal x1080=(cj15*cj16);\nIkReal x1081=IKsin(j13);\nIkReal x1082=(sj12*x1081);\nIkReal x1083=((1.0)*cj15*sj16);\nIkReal x1084=(cj12*x1081);\nIkReal x1085=(sj12*x1078);\nIkReal x1086=((((-1.0)*x1085))+(((-1.0)*x1084)));\nIkReal x1087=(cj16*sj14);\nIkReal x1088=(sj14*sj16);\nIkReal x1089=((1.0)*cj14*cj15);\nIkReal x1090=(cj14*cj16*sj15);\nIkReal x1091=((1.0)*cj14*sj15*sj16);\nIkReal x1092=((0.09)*cj16);\nIkReal x1093=((0.09)*sj16);\nevalcond[0]=(((r22*sj15))+x1079+(((-1.0)*r21*x1083))+((r20*x1080))+(((-1.0)*x1082)));\nevalcond[1]=(((r10*x1080))+((r12*sj15))+x1086+(((-1.0)*r11*x1083)));\nevalcond[2]=((((-1.0)*r11*x1091))+((r10*x1090))+((r11*x1087))+((r10*x1088))+x1082+(((-1.0)*r12*x1089))+(((-1.0)*x1079)));\nevalcond[3]=(((r20*x1090))+(((-1.0)*r21*x1091))+((r20*x1088))+x1086+(((-1.0)*r22*x1089))+((r21*x1087)));\nevalcond[4]=(((r20*x1092))+(((-1.0)*(1.0)*pz))+(((0.03)*x1085))+(((0.03)*x1084))+(((-1.0)*r21*x1093))+(((-0.235)*x1079))+(((0.235)*x1082))+(((-1.0)*(0.25)*cj12)));\nevalcond[5]=((((-1.0)*(1.0)*py))+(((-1.0)*r11*x1093))+(((0.25)*sj12))+(((0.235)*x1085))+(((0.235)*x1084))+(((0.03)*x1079))+((r10*x1092))+(((-0.03)*x1082)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j12, j13, j14]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x1094=((1.0)*cj16);\nIkReal x1095=((1.0)*cj11);\nIkReal x1096=(r11*sj11);\nIkReal x1097=(r10*sj11);\nIkReal x1098=(sj15*sj16);\nIkReal x1099=((1.0)*cj16*sj15);\nCheckValue<IkReal> x1100=IKPowWithIntegerCheck(IKsign(((((-1.0)*r22*sj15))+((cj15*r21*sj16))+(((-1.0)*cj15*r20*x1094)))),-1);\nif(!x1100.valid){\ncontinue;\n}\nCheckValue<IkReal> x1101 = IKatan2WithCheck(IkReal(((((-1.0)*cj16*r01*x1095))+(((-1.0)*r00*sj16*x1095))+(((-1.0)*x1094*x1096))+(((-1.0)*sj16*x1097)))),IkReal((((cj11*cj15*r02))+((cj11*r01*x1098))+((cj15*r12*sj11))+((x1096*x1098))+(((-1.0)*x1097*x1099))+(((-1.0)*cj11*r00*x1099)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1101.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1100.value)))+(x1101.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[3];\nIkReal x1102=IKsin(j14);\nIkReal x1103=((1.0)*cj15*x1102);\nIkReal x1104=IKcos(j14);\nIkReal x1105=((1.0)*cj16*x1104);\nIkReal x1106=((1.0)*sj16*x1104);\nIkReal x1107=(cj16*sj15*x1102);\nIkReal x1108=((1.0)*sj15*sj16*x1102);\nevalcond[0]=((((-1.0)*r21*x1105))+((r20*x1107))+(((-1.0)*r22*x1103))+(((-1.0)*r21*x1108))+(((-1.0)*r20*x1106)));\nevalcond[1]=((((-1.0)*r10*x1106))+cj11+((r10*x1107))+(((-1.0)*r11*x1105))+(((-1.0)*r12*x1103))+(((-1.0)*r11*x1108)));\nevalcond[2]=((((-1.0)*r01*x1108))+(((-1.0)*r00*x1106))+(((-1.0)*r02*x1103))+(((-1.0)*r01*x1105))+((r00*x1107))+(((-1.0)*(1.0)*sj11)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nIkReal x1109=(cj11*pz);\nIkReal x1110=(r02*sj15);\nIkReal x1111=(cj11*cj16*r20);\nIkReal x1112=(cj11*r21*sj16);\nIkReal x1113=(cj11*r22*sj15);\nIkReal x1114=(cj15*cj16*r00);\nIkReal x1115=(cj15*r01*sj16);\nIkReal x1116=(cj11*cj15*cj16*r20);\nIkReal x1117=(cj11*cj15*r21*sj16);\nIkReal x1118=((((2.82)*x1116))+(((1.08)*x1111))+(((-2.82)*x1117))+(((-0.36)*x1114))+(((-1.08)*x1112))+(((-0.36)*x1110))+(((0.36)*x1115))+(((-12.0)*x1109))+(((2.82)*x1113)));\nj12eval[0]=((IKabs(((((-1.0)*(1.0)*cj11))+x1118)))+(IKabs(((((-0.36)*x1112))+(((0.94)*x1116))+(((-0.12)*x1110))+(((0.36)*x1111))+(((-4.0)*x1109))+(((-0.94)*x1117))+(((-0.12)*x1114))+cj11+(((0.12)*x1115))+(((0.94)*x1113)))))+(IKabs((x1118+cj11))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x1119=(cj11*pz);\nIkReal x1120=(r02*sj15);\nIkReal x1121=(cj11*cj16*r20);\nIkReal x1122=(cj11*r21*sj16);\nIkReal x1123=(cj11*r22*sj15);\nIkReal x1124=(cj15*cj16*r00);\nIkReal x1125=(cj15*r01*sj16);\nIkReal x1126=(cj11*cj15*cj16*r20);\nIkReal x1127=(cj11*cj15*r21*sj16);\nIkReal x1128=((((0.12)*x1125))+(((-0.36)*x1122))+(((-0.94)*x1127))+(((0.94)*x1123))+(((0.94)*x1126))+(((-0.12)*x1120))+(((0.36)*x1121))+(((-4.0)*x1119))+(((-0.12)*x1124)));\nIkReal x1129=((((-0.36)*x1120))+(((-1.08)*x1122))+(((2.82)*x1123))+(((1.08)*x1121))+(((2.82)*x1126))+(((-2.82)*x1127))+(((-0.36)*x1124))+(((0.36)*x1125))+(((-12.0)*x1119)));\nIkReal x1130=((-1.0)*(((1.0)*cj11)));\nop[0]=(x1128+cj11);\nop[1]=0;\nop[2]=(x1129+cj11);\nop[3]=0;\nop[4]=(x1129+x1130);\nop[5]=0;\nop[6]=(x1128+x1130);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x1131=(pz*sj11);\nIkReal x1132=(r12*sj15);\nIkReal x1133=(cj15*cj16*r10);\nIkReal x1134=(cj15*r11*sj16);\nIkReal x1135=(cj16*r20*sj11);\nIkReal x1136=(r21*sj11*sj16);\nIkReal x1137=(r22*sj11*sj15);\nIkReal x1138=(cj15*cj16*r20*sj11);\nIkReal x1139=(cj15*r21*sj11*sj16);\nIkReal x1140=((((-0.36)*x1136))+(((0.94)*x1137))+(((0.12)*x1134))+(((-4.0)*x1131))+(((-0.12)*x1133))+(((0.36)*x1135))+(((0.94)*x1138))+(((-0.94)*x1139))+(((-0.12)*x1132)));\nIkReal x1141=((-1.0)*(((1.0)*sj11)));\nIkReal x1142=((((-2.82)*x1139))+(((-12.0)*x1131))+(((-1.08)*x1136))+(((-0.36)*x1132))+(((-0.36)*x1133))+(((1.08)*x1135))+(((2.82)*x1138))+(((0.36)*x1134))+(((2.82)*x1137)));\nj12evalpoly[0]=((((htj12*htj12*htj12*htj12*htj12*htj12)*((sj11+x1140))))+(((htj12*htj12*htj12*htj12)*((sj11+x1142))))+x1141+x1140+(((htj12*htj12)*((x1141+x1142)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x1143=(r22*sj15);\nIkReal x1144=(cj12*r21);\nIkReal x1145=(cj16*sj14);\nIkReal x1146=(r20*sj14*sj16);\nIkReal x1147=(cj15*cj16*r20);\nIkReal x1148=((1.0)*cj12);\nIkReal x1149=(cj14*cj15*r22);\nIkReal x1150=(cj15*sj16);\nIkReal x1151=((1.0)*r21*sj12);\nIkReal x1152=(cj14*cj16*r20*sj15);\nIkReal x1153=(cj14*sj15*sj16);\nif( IKabs((((cj12*x1146))+(((-1.0)*x1148*x1149))+(((-1.0)*x1150*x1151))+(((-1.0)*cj12*r21*x1153))+((x1144*x1145))+((sj12*x1147))+((cj12*x1152))+((sj12*x1143)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x1144*x1150))+(((-1.0)*x1151*x1153))+(((-1.0)*x1143*x1148))+(((-1.0)*x1147*x1148))+((r21*sj12*x1145))+((sj12*x1152))+((sj12*x1146))+(((-1.0)*sj12*x1149)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj12*x1146))+(((-1.0)*x1148*x1149))+(((-1.0)*x1150*x1151))+(((-1.0)*cj12*r21*x1153))+((x1144*x1145))+((sj12*x1147))+((cj12*x1152))+((sj12*x1143))))+IKsqr((((x1144*x1150))+(((-1.0)*x1151*x1153))+(((-1.0)*x1143*x1148))+(((-1.0)*x1147*x1148))+((r21*sj12*x1145))+((sj12*x1152))+((sj12*x1146))+(((-1.0)*sj12*x1149))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((cj12*x1146))+(((-1.0)*x1148*x1149))+(((-1.0)*x1150*x1151))+(((-1.0)*cj12*r21*x1153))+((x1144*x1145))+((sj12*x1147))+((cj12*x1152))+((sj12*x1143))), (((x1144*x1150))+(((-1.0)*x1151*x1153))+(((-1.0)*x1143*x1148))+(((-1.0)*x1147*x1148))+((r21*sj12*x1145))+((sj12*x1152))+((sj12*x1146))+(((-1.0)*sj12*x1149))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[9];\nIkReal x1154=IKcos(j13);\nIkReal x1155=(cj12*x1154);\nIkReal x1156=(cj15*cj16);\nIkReal x1157=IKsin(j13);\nIkReal x1158=(sj12*x1157);\nIkReal x1159=((1.0)*x1158);\nIkReal x1160=((1.0)*cj15*sj16);\nIkReal x1161=(cj12*x1157);\nIkReal x1162=(cj11*x1161);\nIkReal x1163=(sj12*x1154);\nIkReal x1164=(cj11*x1163);\nIkReal x1165=(sj11*x1161);\nIkReal x1166=(sj11*x1163);\nIkReal x1167=(cj16*sj14);\nIkReal x1168=(sj14*sj16);\nIkReal x1169=((1.0)*cj14*cj15);\nIkReal x1170=(cj14*cj16*sj15);\nIkReal x1171=((1.0)*cj14*sj15*sj16);\nIkReal x1172=((0.09)*cj16);\nIkReal x1173=((0.09)*sj16);\nIkReal x1174=(cj11*x1155);\nIkReal x1175=(sj11*x1155);\nIkReal x1176=((0.25)*sj12);\nIkReal x1177=((0.03)*sj12*x1157);\nevalcond[0]=(((r22*sj15))+x1155+(((-1.0)*x1159))+((r20*x1156))+(((-1.0)*r21*x1160)));\nevalcond[1]=((((-1.0)*r01*x1160))+((r02*sj15))+x1162+x1164+((r00*x1156)));\nevalcond[2]=(((r10*x1156))+((r12*sj15))+x1166+x1165+(((-1.0)*r11*x1160)));\nevalcond[3]=((((-1.0)*x1161))+(((-1.0)*r22*x1169))+((r20*x1168))+((r20*x1170))+(((-1.0)*x1163))+(((-1.0)*r21*x1171))+((r21*x1167)));\nevalcond[4]=((((0.03)*x1163))+(((-1.0)*(1.0)*pz))+(((-1.0)*r21*x1173))+(((0.03)*x1161))+(((0.235)*x1158))+(((-0.235)*x1155))+(((-1.0)*(0.25)*cj12))+((r20*x1172)));\nevalcond[5]=(((r00*x1170))+(((-1.0)*cj11*x1159))+((r00*x1168))+(((-1.0)*r01*x1171))+(((-1.0)*r02*x1169))+x1174+((r01*x1167)));\nevalcond[6]=(((r11*x1167))+((r10*x1168))+(((-1.0)*sj11*x1159))+(((-1.0)*r12*x1169))+((r10*x1170))+x1175+(((-1.0)*r11*x1171)));\nevalcond[7]=((((-1.0)*(1.0)*px))+(((-1.0)*(0.095)*sj11))+(((-1.0)*r01*x1173))+(((-0.03)*x1174))+((cj11*x1177))+(((-0.235)*x1164))+((r00*x1172))+(((-1.0)*cj11*x1176))+(((-0.235)*x1162)));\nevalcond[8]=((((-0.235)*x1166))+(((-1.0)*(1.0)*py))+((r10*x1172))+(((-0.235)*x1165))+(((-0.03)*x1175))+((sj11*x1177))+(((-1.0)*sj11*x1176))+(((0.095)*cj11))+(((-1.0)*r11*x1173)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x1178=((1.0)*sj16);\nIkReal x1179=(r21*sj11);\nIkReal x1180=(r20*sj11);\nCheckValue<IkReal> x1181 = IKatan2WithCheck(IkReal(((((-1.0)*cj16*x1179))+(((-1.0)*x1178*x1180)))),IkReal((((cj15*r22*sj11))+(((-1.0)*cj16*sj15*x1180))+((sj15*sj16*x1179)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1181.valid){\ncontinue;\n}\nCheckValue<IkReal> x1182=IKPowWithIntegerCheck(IKsign((((cj15*cj16*r10))+((r12*sj15))+(((-1.0)*cj15*r11*x1178)))),-1);\nif(!x1182.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x1181.value)+(((1.5707963267949)*(x1182.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[3];\nIkReal x1183=IKsin(j14);\nIkReal x1184=((1.0)*cj15*x1183);\nIkReal x1185=IKcos(j14);\nIkReal x1186=((1.0)*cj16*x1185);\nIkReal x1187=((1.0)*sj16*x1185);\nIkReal x1188=(cj16*sj15*x1183);\nIkReal x1189=((1.0)*sj15*sj16*x1183);\nevalcond[0]=((((-1.0)*r20*x1187))+(((-1.0)*r21*x1189))+(((-1.0)*r22*x1184))+(((-1.0)*r21*x1186))+((r20*x1188)));\nevalcond[1]=((((-1.0)*r11*x1189))+cj11+((r10*x1188))+(((-1.0)*r10*x1187))+(((-1.0)*r11*x1186))+(((-1.0)*r12*x1184)));\nevalcond[2]=((((-1.0)*r01*x1186))+(((-1.0)*r00*x1187))+((r00*x1188))+(((-1.0)*r01*x1189))+(((-1.0)*(1.0)*sj11))+(((-1.0)*r02*x1184)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nIkReal x1190=(cj11*pz);\nIkReal x1191=(r02*sj15);\nIkReal x1192=(cj11*cj16*r20);\nIkReal x1193=(cj11*r21*sj16);\nIkReal x1194=(cj11*r22*sj15);\nIkReal x1195=(cj15*cj16*r00);\nIkReal x1196=(cj15*r01*sj16);\nIkReal x1197=(cj11*cj15*cj16*r20);\nIkReal x1198=(cj11*cj15*r21*sj16);\nIkReal x1199=((((-1.08)*x1193))+(((2.82)*x1197))+(((-12.0)*x1190))+(((-2.82)*x1198))+(((1.08)*x1192))+(((-0.36)*x1195))+(((2.82)*x1194))+(((0.36)*x1196))+(((-0.36)*x1191)));\nj12eval[0]=((IKabs(((((-0.12)*x1191))+(((-0.12)*x1195))+(((-0.36)*x1193))+(((0.94)*x1194))+cj11+(((0.94)*x1197))+(((0.36)*x1192))+(((0.12)*x1196))+(((-4.0)*x1190))+(((-0.94)*x1198)))))+(IKabs(((((-1.0)*(1.0)*cj11))+x1199)))+(IKabs((cj11+x1199))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x1200=(cj11*pz);\nIkReal x1201=(r02*sj15);\nIkReal x1202=(cj11*cj16*r20);\nIkReal x1203=(cj11*r21*sj16);\nIkReal x1204=(cj11*r22*sj15);\nIkReal x1205=(cj15*cj16*r00);\nIkReal x1206=(cj15*r01*sj16);\nIkReal x1207=(cj11*cj15*cj16*r20);\nIkReal x1208=(cj11*cj15*r21*sj16);\nIkReal x1209=((((0.94)*x1204))+(((-4.0)*x1200))+(((-0.12)*x1205))+(((-0.12)*x1201))+(((-0.94)*x1208))+(((0.12)*x1206))+(((-0.36)*x1203))+(((0.94)*x1207))+(((0.36)*x1202)));\nIkReal x1210=((((0.36)*x1206))+(((2.82)*x1204))+(((2.82)*x1207))+(((-0.36)*x1201))+(((-1.08)*x1203))+(((-2.82)*x1208))+(((-12.0)*x1200))+(((1.08)*x1202))+(((-0.36)*x1205)));\nIkReal x1211=((-1.0)*(((1.0)*cj11)));\nop[0]=(x1209+cj11);\nop[1]=0;\nop[2]=(cj11+x1210);\nop[3]=0;\nop[4]=(x1210+x1211);\nop[5]=0;\nop[6]=(x1209+x1211);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x1212=(pz*sj11);\nIkReal x1213=(r12*sj15);\nIkReal x1214=(cj15*cj16*r10);\nIkReal x1215=(cj15*r11*sj16);\nIkReal x1216=(cj16*r20*sj11);\nIkReal x1217=(r21*sj11*sj16);\nIkReal x1218=(r22*sj11*sj15);\nIkReal x1219=(cj15*cj16*r20*sj11);\nIkReal x1220=(cj15*r21*sj11*sj16);\nIkReal x1221=((((-0.12)*x1214))+(((-4.0)*x1212))+(((0.94)*x1218))+(((-0.94)*x1220))+(((-0.36)*x1217))+(((-0.12)*x1213))+(((0.36)*x1216))+(((0.94)*x1219))+(((0.12)*x1215)));\nIkReal x1222=((-1.0)*(((1.0)*sj11)));\nIkReal x1223=((((-12.0)*x1212))+(((2.82)*x1218))+(((-1.08)*x1217))+(((-0.36)*x1214))+(((1.08)*x1216))+(((-0.36)*x1213))+(((-2.82)*x1220))+(((2.82)*x1219))+(((0.36)*x1215)));\nj12evalpoly[0]=((((htj12*htj12)*((x1222+x1223))))+(((htj12*htj12*htj12*htj12)*((sj11+x1223))))+x1222+x1221+(((htj12*htj12*htj12*htj12*htj12*htj12)*((sj11+x1221)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x1224=(r22*sj15);\nIkReal x1225=(cj12*r21);\nIkReal x1226=(cj16*sj14);\nIkReal x1227=(r20*sj14*sj16);\nIkReal x1228=(cj15*cj16*r20);\nIkReal x1229=((1.0)*cj12);\nIkReal x1230=(cj14*cj15*r22);\nIkReal x1231=(cj15*sj16);\nIkReal x1232=((1.0)*r21*sj12);\nIkReal x1233=(cj14*cj16*r20*sj15);\nIkReal x1234=(cj14*sj15*sj16);\nif( IKabs((((sj12*x1228))+(((-1.0)*x1229*x1230))+((x1225*x1226))+((cj12*x1227))+((cj12*x1233))+((sj12*x1224))+(((-1.0)*x1231*x1232))+(((-1.0)*cj12*r21*x1234)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1228*x1229))+((sj12*x1227))+(((-1.0)*sj12*x1230))+((x1225*x1231))+(((-1.0)*x1232*x1234))+((r21*sj12*x1226))+(((-1.0)*x1224*x1229))+((sj12*x1233)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj12*x1228))+(((-1.0)*x1229*x1230))+((x1225*x1226))+((cj12*x1227))+((cj12*x1233))+((sj12*x1224))+(((-1.0)*x1231*x1232))+(((-1.0)*cj12*r21*x1234))))+IKsqr(((((-1.0)*x1228*x1229))+((sj12*x1227))+(((-1.0)*sj12*x1230))+((x1225*x1231))+(((-1.0)*x1232*x1234))+((r21*sj12*x1226))+(((-1.0)*x1224*x1229))+((sj12*x1233))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((sj12*x1228))+(((-1.0)*x1229*x1230))+((x1225*x1226))+((cj12*x1227))+((cj12*x1233))+((sj12*x1224))+(((-1.0)*x1231*x1232))+(((-1.0)*cj12*r21*x1234))), ((((-1.0)*x1228*x1229))+((sj12*x1227))+(((-1.0)*sj12*x1230))+((x1225*x1231))+(((-1.0)*x1232*x1234))+((r21*sj12*x1226))+(((-1.0)*x1224*x1229))+((sj12*x1233))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[9];\nIkReal x1235=IKcos(j13);\nIkReal x1236=(cj12*x1235);\nIkReal x1237=(cj15*cj16);\nIkReal x1238=IKsin(j13);\nIkReal x1239=(sj12*x1238);\nIkReal x1240=((1.0)*x1239);\nIkReal x1241=((1.0)*cj15*sj16);\nIkReal x1242=(cj12*x1238);\nIkReal x1243=(cj11*x1242);\nIkReal x1244=(sj12*x1235);\nIkReal x1245=(cj11*x1244);\nIkReal x1246=(sj11*x1242);\nIkReal x1247=(sj11*x1244);\nIkReal x1248=(cj16*sj14);\nIkReal x1249=(sj14*sj16);\nIkReal x1250=((1.0)*cj14*cj15);\nIkReal x1251=(cj14*cj16*sj15);\nIkReal x1252=((1.0)*cj14*sj15*sj16);\nIkReal x1253=((0.09)*cj16);\nIkReal x1254=((0.09)*sj16);\nIkReal x1255=(cj11*x1236);\nIkReal x1256=(sj11*x1236);\nIkReal x1257=((0.25)*sj12);\nIkReal x1258=((0.03)*sj12*x1238);\nevalcond[0]=(((r22*sj15))+(((-1.0)*r21*x1241))+x1236+((r20*x1237))+(((-1.0)*x1240)));\nevalcond[1]=(((r02*sj15))+(((-1.0)*r01*x1241))+((r00*x1237))+x1245+x1243);\nevalcond[2]=(((r12*sj15))+(((-1.0)*r11*x1241))+x1247+x1246+((r10*x1237)));\nevalcond[3]=((((-1.0)*r22*x1250))+((r20*x1249))+(((-1.0)*r21*x1252))+(((-1.0)*x1242))+((r20*x1251))+(((-1.0)*x1244))+((r21*x1248)));\nevalcond[4]=(((r20*x1253))+(((-1.0)*(1.0)*pz))+(((0.03)*x1242))+(((0.235)*x1239))+(((0.03)*x1244))+(((-0.235)*x1236))+(((-1.0)*r21*x1254))+(((-1.0)*(0.25)*cj12)));\nevalcond[5]=(((r00*x1251))+(((-1.0)*r01*x1252))+((r01*x1248))+x1255+(((-1.0)*r02*x1250))+((r00*x1249))+(((-1.0)*cj11*x1240)));\nevalcond[6]=((((-1.0)*sj11*x1240))+((r10*x1251))+x1256+(((-1.0)*r11*x1252))+((r10*x1249))+((r11*x1248))+(((-1.0)*r12*x1250)));\nevalcond[7]=((((-1.0)*(1.0)*px))+(((-1.0)*(0.095)*sj11))+((r00*x1253))+(((-1.0)*cj11*x1257))+(((-0.235)*x1243))+((cj11*x1258))+(((-0.235)*x1245))+(((-0.03)*x1255))+(((-1.0)*r01*x1254)));\nevalcond[8]=((((-1.0)*(1.0)*py))+(((-0.235)*x1246))+(((-1.0)*r11*x1254))+(((-0.235)*x1247))+((r10*x1253))+(((-1.0)*sj11*x1257))+(((0.095)*cj11))+((sj11*x1258))+(((-0.03)*x1256)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x1259=((1.0)*cj15);\nIkReal x1260=(cj11*cj16);\nIkReal x1261=(cj11*sj16);\nCheckValue<IkReal> x1262=IKPowWithIntegerCheck(IKsign((((cj15*r01*sj16))+(((-1.0)*r02*sj15))+(((-1.0)*cj16*r00*x1259)))),-1);\nif(!x1262.valid){\ncontinue;\n}\nCheckValue<IkReal> x1263 = IKatan2WithCheck(IkReal((((r21*x1260))+((r20*x1261)))),IkReal((((r20*sj15*x1260))+(((-1.0)*r21*sj15*x1261))+(((-1.0)*cj11*r22*x1259)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1263.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1262.value)))+(x1263.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[3];\nIkReal x1264=IKsin(j14);\nIkReal x1265=((1.0)*cj15*x1264);\nIkReal x1266=IKcos(j14);\nIkReal x1267=((1.0)*cj16*x1266);\nIkReal x1268=((1.0)*sj16*x1266);\nIkReal x1269=(cj16*sj15*x1264);\nIkReal x1270=((1.0)*sj15*sj16*x1264);\nevalcond[0]=((((-1.0)*r21*x1270))+(((-1.0)*r22*x1265))+((r20*x1269))+(((-1.0)*r20*x1268))+(((-1.0)*r21*x1267)));\nevalcond[1]=((((-1.0)*r10*x1268))+(((-1.0)*r11*x1270))+cj11+(((-1.0)*r11*x1267))+((r10*x1269))+(((-1.0)*r12*x1265)));\nevalcond[2]=((((-1.0)*r01*x1270))+(((-1.0)*r00*x1268))+((r00*x1269))+(((-1.0)*r01*x1267))+(((-1.0)*r02*x1265))+(((-1.0)*(1.0)*sj11)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nIkReal x1271=(cj11*pz);\nIkReal x1272=(r02*sj15);\nIkReal x1273=(cj11*cj16*r20);\nIkReal x1274=(cj11*r21*sj16);\nIkReal x1275=(cj11*r22*sj15);\nIkReal x1276=(cj15*cj16*r00);\nIkReal x1277=(cj15*r01*sj16);\nIkReal x1278=(cj11*cj15*cj16*r20);\nIkReal x1279=(cj11*cj15*r21*sj16);\nIkReal x1280=((((-12.0)*x1271))+(((-2.82)*x1279))+(((2.82)*x1275))+(((2.82)*x1278))+(((0.36)*x1277))+(((1.08)*x1273))+(((-0.36)*x1276))+(((-1.08)*x1274))+(((-0.36)*x1272)));\nj12eval[0]=((IKabs((cj11+x1280)))+(IKabs(((((-1.0)*(1.0)*cj11))+x1280)))+(IKabs(((((0.12)*x1277))+(((-4.0)*x1271))+(((-0.12)*x1276))+(((-0.12)*x1272))+cj11+(((0.36)*x1273))+(((-0.94)*x1279))+(((0.94)*x1275))+(((0.94)*x1278))+(((-0.36)*x1274))))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x1281=(cj11*pz);\nIkReal x1282=(r02*sj15);\nIkReal x1283=(cj11*cj16*r20);\nIkReal x1284=(cj11*r21*sj16);\nIkReal x1285=(cj11*r22*sj15);\nIkReal x1286=(cj15*cj16*r00);\nIkReal x1287=(cj15*r01*sj16);\nIkReal x1288=(cj11*cj15*cj16*r20);\nIkReal x1289=(cj11*cj15*r21*sj16);\nIkReal x1290=((((-0.36)*x1284))+(((0.94)*x1285))+(((0.94)*x1288))+(((-0.12)*x1286))+(((0.12)*x1287))+(((-0.12)*x1282))+(((0.36)*x1283))+(((-4.0)*x1281))+(((-0.94)*x1289)));\nIkReal x1291=((((-2.82)*x1289))+(((-1.08)*x1284))+(((1.08)*x1283))+(((-0.36)*x1282))+(((2.82)*x1285))+(((-0.36)*x1286))+(((2.82)*x1288))+(((0.36)*x1287))+(((-12.0)*x1281)));\nIkReal x1292=((-1.0)*(((1.0)*cj11)));\nop[0]=(x1290+cj11);\nop[1]=0;\nop[2]=(x1291+cj11);\nop[3]=0;\nop[4]=(x1291+x1292);\nop[5]=0;\nop[6]=(x1290+x1292);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x1293=(pz*sj11);\nIkReal x1294=(r12*sj15);\nIkReal x1295=(cj15*cj16*r10);\nIkReal x1296=(cj15*r11*sj16);\nIkReal x1297=(cj16*r20*sj11);\nIkReal x1298=(r21*sj11*sj16);\nIkReal x1299=(r22*sj11*sj15);\nIkReal x1300=(cj15*cj16*r20*sj11);\nIkReal x1301=(cj15*r21*sj11*sj16);\nIkReal x1302=((((0.36)*x1297))+(((0.94)*x1299))+(((0.94)*x1300))+(((0.12)*x1296))+(((-0.36)*x1298))+(((-0.12)*x1294))+(((-0.94)*x1301))+(((-0.12)*x1295))+(((-4.0)*x1293)));\nIkReal x1303=((-1.0)*(((1.0)*sj11)));\nIkReal x1304=((((1.08)*x1297))+(((0.36)*x1296))+(((-12.0)*x1293))+(((-0.36)*x1294))+(((-2.82)*x1301))+(((2.82)*x1300))+(((-1.08)*x1298))+(((2.82)*x1299))+(((-0.36)*x1295)));\nj12evalpoly[0]=(x1302+x1303+(((htj12*htj12)*((x1304+x1303))))+(((htj12*htj12*htj12*htj12)*((x1304+sj11))))+(((htj12*htj12*htj12*htj12*htj12*htj12)*((x1302+sj11)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x1305=(r22*sj15);\nIkReal x1306=(cj12*r21);\nIkReal x1307=(cj16*sj14);\nIkReal x1308=(r20*sj14*sj16);\nIkReal x1309=(cj15*cj16*r20);\nIkReal x1310=((1.0)*cj12);\nIkReal x1311=(cj14*cj15*r22);\nIkReal x1312=(cj15*sj16);\nIkReal x1313=((1.0)*r21*sj12);\nIkReal x1314=(cj14*cj16*r20*sj15);\nIkReal x1315=(cj14*sj15*sj16);\nif( IKabs(((((-1.0)*x1312*x1313))+((sj12*x1305))+(((-1.0)*cj12*r21*x1315))+((sj12*x1309))+((cj12*x1314))+((cj12*x1308))+((x1306*x1307))+(((-1.0)*x1310*x1311)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj12*x1314))+(((-1.0)*x1309*x1310))+((x1306*x1312))+(((-1.0)*x1305*x1310))+(((-1.0)*sj12*x1311))+(((-1.0)*x1313*x1315))+((r21*sj12*x1307))+((sj12*x1308)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1312*x1313))+((sj12*x1305))+(((-1.0)*cj12*r21*x1315))+((sj12*x1309))+((cj12*x1314))+((cj12*x1308))+((x1306*x1307))+(((-1.0)*x1310*x1311))))+IKsqr((((sj12*x1314))+(((-1.0)*x1309*x1310))+((x1306*x1312))+(((-1.0)*x1305*x1310))+(((-1.0)*sj12*x1311))+(((-1.0)*x1313*x1315))+((r21*sj12*x1307))+((sj12*x1308))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*x1312*x1313))+((sj12*x1305))+(((-1.0)*cj12*r21*x1315))+((sj12*x1309))+((cj12*x1314))+((cj12*x1308))+((x1306*x1307))+(((-1.0)*x1310*x1311))), (((sj12*x1314))+(((-1.0)*x1309*x1310))+((x1306*x1312))+(((-1.0)*x1305*x1310))+(((-1.0)*sj12*x1311))+(((-1.0)*x1313*x1315))+((r21*sj12*x1307))+((sj12*x1308))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[9];\nIkReal x1316=IKcos(j13);\nIkReal x1317=(cj12*x1316);\nIkReal x1318=(cj15*cj16);\nIkReal x1319=IKsin(j13);\nIkReal x1320=(sj12*x1319);\nIkReal x1321=((1.0)*x1320);\nIkReal x1322=((1.0)*cj15*sj16);\nIkReal x1323=(cj12*x1319);\nIkReal x1324=(cj11*x1323);\nIkReal x1325=(sj12*x1316);\nIkReal x1326=(cj11*x1325);\nIkReal x1327=(sj11*x1323);\nIkReal x1328=(sj11*x1325);\nIkReal x1329=(cj16*sj14);\nIkReal x1330=(sj14*sj16);\nIkReal x1331=((1.0)*cj14*cj15);\nIkReal x1332=(cj14*cj16*sj15);\nIkReal x1333=((1.0)*cj14*sj15*sj16);\nIkReal x1334=((0.09)*cj16);\nIkReal x1335=((0.09)*sj16);\nIkReal x1336=(cj11*x1317);\nIkReal x1337=(sj11*x1317);\nIkReal x1338=((0.25)*sj12);\nIkReal x1339=((0.03)*sj12*x1319);\nevalcond[0]=(((r22*sj15))+(((-1.0)*r21*x1322))+(((-1.0)*x1321))+((r20*x1318))+x1317);\nevalcond[1]=(x1326+x1324+((r00*x1318))+((r02*sj15))+(((-1.0)*r01*x1322)));\nevalcond[2]=(x1328+x1327+((r12*sj15))+(((-1.0)*r11*x1322))+((r10*x1318)));\nevalcond[3]=((((-1.0)*r22*x1331))+(((-1.0)*x1325))+((r20*x1332))+((r20*x1330))+(((-1.0)*r21*x1333))+(((-1.0)*x1323))+((r21*x1329)));\nevalcond[4]=((((-0.235)*x1317))+(((-1.0)*(1.0)*pz))+(((0.235)*x1320))+((r20*x1334))+(((0.03)*x1325))+(((-1.0)*(0.25)*cj12))+(((-1.0)*r21*x1335))+(((0.03)*x1323)));\nevalcond[5]=(((r00*x1332))+(((-1.0)*r02*x1331))+((r01*x1329))+x1336+(((-1.0)*cj11*x1321))+((r00*x1330))+(((-1.0)*r01*x1333)));\nevalcond[6]=((((-1.0)*r11*x1333))+((r10*x1330))+(((-1.0)*r12*x1331))+x1337+((r10*x1332))+(((-1.0)*sj11*x1321))+((r11*x1329)));\nevalcond[7]=((((-1.0)*(1.0)*px))+(((-1.0)*(0.095)*sj11))+(((-0.03)*x1336))+((cj11*x1339))+(((-1.0)*r01*x1335))+(((-1.0)*cj11*x1338))+((r00*x1334))+(((-0.235)*x1324))+(((-0.235)*x1326)));\nevalcond[8]=((((-0.03)*x1337))+(((-1.0)*(1.0)*py))+((sj11*x1339))+(((-0.235)*x1328))+(((-1.0)*r11*x1335))+((r10*x1334))+(((0.095)*cj11))+(((-0.235)*x1327))+(((-1.0)*sj11*x1338)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j11;\nvinfos[1].indices[0] = _ij11[0];\nvinfos[1].indices[1] = _ij11[1];\nvinfos[1].maxsolutions = _nj11;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j12;\nvinfos[2].indices[0] = _ij12[0];\nvinfos[2].indices[1] = _ij12[1];\nvinfos[2].maxsolutions = _nj12;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j13;\nvinfos[3].indices[0] = _ij13[0];\nvinfos[3].indices[1] = _ij13[1];\nvinfos[3].maxsolutions = _nj13;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j14;\nvinfos[4].indices[0] = _ij14[0];\nvinfos[4].indices[1] = _ij14[1];\nvinfos[4].maxsolutions = _nj14;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j15;\nvinfos[5].indices[0] = _ij15[0];\nvinfos[5].indices[1] = _ij15[1];\nvinfos[5].maxsolutions = _nj15;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j16;\nvinfos[6].indices[0] = _ij16[0];\nvinfos[6].indices[1] = _ij16[1];\nvinfos[6].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])\nstatic inline bool checkconsistency8(const IkReal* Breal)\n{\n    IkReal norm = 0.1;\n    for(int i = 0; i < 7; ++i) {\n        norm += IKabs(Breal[i]);\n    }\n    // HACK should be 1e-5*norm\n    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved\n    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;\n}\n/// \\brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)\n///\n/// matcoeffs is of length 54*3, for 3 matrices\nstatic inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)\n{\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};\n    IkReal IKFAST_ALIGNED16(A[8*8]);\n    IkReal IKFAST_ALIGNED16(work[16*16*15]);\n    int ipiv[8];\n    int info, coeffindex;\n    const int worksize=16*16*15;\n    const int matrixdim = 8;\n    const int matrixdim2 = 16;\n    numroots = 0;\n    // first setup M = [0 I; -C -B] and A\n    coeffindex = 0;\n    for(int j = 0; j < 4; ++j) {\n        for(int k = 0; k < 6; ++k) {\n            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];\n        }\n    }\n    for(int j = 0; j < 4; ++j) {\n        for(int k = 0; k < 6; ++k) {\n            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];\n        }\n    }\n    for(int j = 0; j < 4; ++j) {\n        for(int k = 0; k < 6; ++k) {\n            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];\n        }\n        for(int k = 0; k < 2; ++k) {\n            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;\n        }\n    }\n    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};\n    int lfindex = -1;\n    bool bsingular = true;\n    do {\n        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);\n        if( info == 0 ) {\n            bsingular = false;\n            for(int j = 0; j < matrixdim; ++j) {\n                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {\n                    bsingular = true;\n                    break;\n                }\n            }\n            if( !bsingular ) {\n                break;\n            }\n        }\n        if( lfindex == 3 ) {\n            break;\n        }\n        // transform by the linear functional\n        lfindex++;\n        const IkReal* lf = lfpossibilities[lfindex];\n        // have to reinitialize A\n        coeffindex = 0;\n        for(int j = 0; j < 4; ++j) {\n            for(int k = 0; k < 6; ++k) {\n                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];\n                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;\n                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);\n                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);\n                coeffindex++;\n            }\n            for(int k = 0; k < 2; ++k) {\n                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;\n            }\n        }\n    } while(lfindex<4);\n\n    if( bsingular ) {\n        return;\n    }\n    dgetrs_(\"No transpose\", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);\n    if( info != 0 ) {\n        return;\n    }\n\n    // set identity in upper corner\n    for(int j = 0; j < matrixdim; ++j) {\n        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;\n    }\n    IkReal IKFAST_ALIGNED16(wr[16]);\n    IkReal IKFAST_ALIGNED16(wi[16]);\n    IkReal IKFAST_ALIGNED16(vr[16*16]);\n    int one=1;\n    dgeev_(\"N\", \"V\", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);\n    if( info != 0 ) {\n        return;\n    }\n    IkReal Breal[matrixdim-1];\n    for(int i = 0; i < matrixdim2; ++i) {\n        // HACK should be tol*100\n        if( IKabs(wi[i]) < 5e-5 ) {\n            IkReal* ev = vr+matrixdim2*i;\n            if( IKabs(wr[i]) > 1 ) {\n                ev += matrixdim;\n            }\n            // consistency has to be checked!!\n            if( IKabs(ev[0]) < tol ) {\n                continue;\n            }\n            IkReal iconst = 1/ev[0];\n            for(int j = 1; j < matrixdim; ++j) {\n                Breal[j-1] = ev[j]*iconst;\n            }\n            if( checkconsistency8(Breal) ) {\n                if( lfindex >= 0 ) {\n                    const IkReal* lf = lfpossibilities[lfindex];\n                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);\n                }\n                else {\n                    rawroots[numroots++] = wr[i];\n                }\n                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);\n                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);\n                if( bsmall0 && bsmall1 ) {\n                    rawroots[numroots++] = ev[2]/ev[0];\n                    rawroots[numroots++] = ev[1]/ev[0];\n                }\n                else if( bsmall0 && !bsmall1 ) {\n                    rawroots[numroots++] = ev[3]/ev[1];\n                    rawroots[numroots++] = ev[1]/ev[0];\n                }\n                else if( !bsmall0 && bsmall1 ) {\n                    rawroots[numroots++] = ev[6]/ev[4];\n                    rawroots[numroots++] = ev[7]/ev[6];\n                }\n                else if( !bsmall0 && !bsmall1 ) {\n                    rawroots[numroots++] = ev[7]/ev[5];\n                    rawroots[numroots++] = ev[7]/ev[6];\n                }\n            }\n        }\n    }\n}};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"73b00fade606224fff41ab84a072b721\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\nchar* ComputeFkWrapper(const IkReal* j) {\n    IkReal eetrans[3] = {0};\n    IkReal eerot[9] = {0};\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n\nstd::vector<IkReal> TrueComputeIk(int argc, char** argv)\n{\n    std::vector<IkReal> solvalues(GetNumJoints());\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return solvalues;\n}\n"]}