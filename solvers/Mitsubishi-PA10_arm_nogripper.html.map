{"version":3,"file":"./solvers/Mitsubishi-PA10_arm_nogripper.html","sources":["./solvers/Mitsubishi-PA10_arm_nogripper.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAIA;;;;;;;;;;;;;;;AA4iPA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;AArwPA;AAAA;AAAA;;;;;;;;AAFA;AAAA;AAAA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-05-22 07:18:42.341898\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63;\nx0=IKcos(j[0]);\nx1=IKcos(j[1]);\nx2=IKcos(j[2]);\nx3=IKsin(j[0]);\nx4=IKsin(j[2]);\nx5=IKsin(j[3]);\nx6=IKcos(j[3]);\nx7=IKsin(j[1]);\nx8=IKcos(j[4]);\nx9=IKsin(j[4]);\nx10=IKsin(j[6]);\nx11=IKsin(j[5]);\nx12=IKcos(j[5]);\nx13=IKcos(j[6]);\nx14=((0.5)*x0);\nx15=((0.085)*x8);\nx16=((1.0)*x5);\nx17=((1.0)*x4);\nx18=((1.0)*x3);\nx19=((0.085)*x9);\nx20=((1.0)*x11);\nx21=((1.0)*x12);\nx22=((0.5)*x3);\nx23=((1.0)*x0);\nx24=((0.085)*x5);\nx25=(x1*x2);\nx26=(x6*x7);\nx27=(x2*x7);\nx28=(x1*x6);\nx29=(x0*x7);\nx30=(x3*x7);\nx31=(x17*x3);\nx32=((1.0)*x28);\nx33=(x4*x7*x9);\nx34=(x16*x29);\nx35=(x23*x26);\nx36=(x16*x30);\nx37=(x18*x26);\nx38=((((-1.0)*x31))+((x0*x25)));\nx39=(((x0*x4))+((x25*x3)));\nx40=((((-1.0)*x1*x31))+((x0*x2)));\nx41=((((-1.0)*x32))+((x27*x5)));\nx42=(x31+(((-1.0)*x23*x25)));\nx43=((((-1.0)*x0*x1*x17))+(((-1.0)*x18*x2)));\nx44=((((-1.0)*x0*x17))+(((-1.0)*x18*x25)));\nx45=(((x1*x16))+(((1.0)*x2*x26)));\nx46=((-1.0)*x45);\nx47=(x39*x6);\nx48=(x11*x41);\nx49=(x38*x6);\nx50=(x42*x5);\nx51=(x44*x5);\nx52=((((-1.0)*x34))+x49);\nx53=((((-1.0)*x36))+x47);\nx54=((((-1.0)*x35))+x50);\nx55=((((-1.0)*x37))+x51);\nx56=(((x4*x7*x8))+((x45*x9)));\nx57=(((x46*x8))+x33);\nx58=(x11*x55);\nx59=(((x53*x8))+((x40*x9)));\nx60=(((x9*(((((-1.0)*x47))+x36))))+((x40*x8)));\nx61=(((x43*x9))+((x52*x8)));\nx62=(x12*x59);\nx63=(((x9*(((((-1.0)*x49))+x34))))+((x43*x8)));\neerot[0]=(((x10*x63))+((x13*((((x12*x61))+((x11*x54)))))));\neerot[1]=(((x13*x63))+((x10*(((((-1.0)*x20*x54))+(((-1.0)*x21*x61)))))));\neerot[2]=(((x11*x61))+((x12*(((((-1.0)*x16*x42))+x35)))));\neetrans[0]=(((x5*((((x14*x25))+(((-1.0)*x22*x4))))))+((x11*((((x19*x43))+((x15*x52))))))+((x14*x26))+((x12*(((((-1.0)*x24*x42))+(((0.085)*x0*x26))))))+(((0.45)*x29)));\neerot[3]=(((x13*((x58+x62))))+((x10*x60)));\neerot[4]=(((x13*x60))+((x10*(((((-1.0)*x20*x55))+(((-1.0)*x21*x59)))))));\neerot[5]=(((x12*(((((-1.0)*x16*x44))+x37))))+((x11*x59)));\neetrans[1]=((((0.45)*x30))+((x22*x26))+((x11*((((x19*x40))+((x15*x53))))))+((x5*((((x22*x25))+((x14*x4))))))+((x12*(((((-1.0)*x24*x44))+(((0.085)*x26*x3)))))));\neerot[6]=(((x13*((((x12*x57))+x48))))+((x10*x56)));\neerot[7]=(((x13*x56))+((x10*(((((-1.0)*x20*x41))+(((-1.0)*x21*x57)))))));\neerot[8]=(((x11*x57))+((x12*(((((-1.0)*x16*x27))+x32)))));\neetrans[2]=((0.315)+((x12*(((((0.085)*x28))+(((-1.0)*x24*x27))))))+(((-0.5)*x27*x5))+(((0.5)*x28))+(((0.45)*x1))+((x11*((((x15*x46))+((x19*x4*x7)))))));\n}\n\nIKFAST_API int GetNumFreeParameters() { return 1; }\nIKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }\nIKFAST_API int GetNumJoints() { return 7; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j2,cj2,sj2,htj2,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij2[2], _nj2;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij2[0] = -1; _ij2[1] = -1; _nj2 = 0; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nj2=pfree[0]; cj2=cos(pfree[0]); sj2=sin(pfree[0]), htj2=tan(pfree[0]*0.5);\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=r00;\nnew_r01=r01;\nnew_r02=r02;\nnew_px=(px+(((-0.085)*r02)));\nnew_r10=r10;\nnew_r11=r11;\nnew_r12=r12;\nnew_py=((((-0.085)*r12))+py);\nnew_r20=r20;\nnew_r21=r21;\nnew_r22=r22;\nnew_pz=((-0.315)+(((-0.085)*r22))+pz);\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x64=((1.0)*px);\nIkReal x65=((1.0)*pz);\nIkReal x66=((1.0)*py);\npp=((px*px)+(py*py)+(pz*pz));\nnpx=(((px*r00))+((py*r10))+((pz*r20)));\nnpy=(((px*r01))+((py*r11))+((pz*r21)));\nnpz=(((px*r02))+((py*r12))+((pz*r22)));\nrxp0_0=((((-1.0)*r20*x66))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x65)));\nrxp0_2=((((-1.0)*r10*x64))+((py*r00)));\nrxp1_0=((((-1.0)*r21*x66))+((pz*r11)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x65)));\nrxp1_2=((((-1.0)*r11*x64))+((py*r01)));\nrxp2_0=(((pz*r12))+(((-1.0)*r22*x66)));\nrxp2_1=(((px*r22))+(((-1.0)*r02*x65)));\nrxp2_2=((((-1.0)*r12*x64))+((py*r02)));\n{\nIkReal j3array[2], cj3array[2], sj3array[2];\nbool j3valid[2]={false};\n_nj3 = 2;\ncj3array[0]=((-1.00555555555556)+(((2.22222222222222)*pp)));\nif( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j3valid[0] = j3valid[1] = true;\n    j3array[0] = IKacos(cj3array[0]);\n    sj3array[0] = IKsin(j3array[0]);\n    cj3array[1] = cj3array[0];\n    j3array[1] = -j3array[0];\n    sj3array[1] = -sj3array[0];\n}\nelse if( isnan(cj3array[0]) )\n{\n    // probably any value will work\n    j3valid[0] = true;\n    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;\n}\nfor(int ij3 = 0; ij3 < 2; ++ij3)\n{\nif( !j3valid[ij3] )\n{\n    continue;\n}\n_ij3[0] = ij3; _ij3[1] = -1;\nfor(int iij3 = ij3+1; iij3 < 2; ++iij3)\n{\nif( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )\n{\n    j3valid[iij3]=false; _ij3[1] = iij3; break; \n}\n}\nj3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];\n\n{\nIkReal j0eval[2];\nj0eval[0]=((px*px)+(py*py));\nj0eval[1]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nj1eval[0]=((1.0)+(((2.22222222222222)*cj3))+(((1.23456790123457)*(cj3*cj3)))+(((1.23456790123457)*(cj2*cj2)*(sj3*sj3))));\nj1eval[1]=((((0.5)*(IKabs((cj2*sj3)))))+(IKabs(((-0.45)+(((-0.5)*cj3))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[2];\nIkReal x67=cj2*cj2;\nIkReal x68=sj2*sj2;\nIkReal x69=px*px;\nIkReal x70=py*py;\nIkReal x71=py*py*py*py;\nIkReal x72=sj2*sj2*sj2*sj2;\nIkReal x73=cj2*cj2*cj2*cj2;\nIkReal x74=((1.0)*px*py);\nIkReal x75=(x69*x70);\nIkReal x76=((2.0)*x67*x68);\nj0eval[0]=(((x75*x76))+((x72*x75))+((x73*x75))+((x71*x76))+((x71*x72))+((x71*x73)));\nj0eval[1]=((IKabs(((((-1.0)*x67*x74))+(((-1.0)*x68*x74)))))+(IKabs((((x68*x70))+((x67*x70))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0, j1]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x77=cj2*cj2;\nIkReal x78=py*py;\nIkReal x79=sj2*sj2;\nIkReal x80=((1.0)*px*py);\nIkReal x81=(((x78*x79))+((x77*x78)));\nIkReal x82=((((-1.0)*x77*x80))+(((-1.0)*x79*x80)));\nCheckValue<IkReal> x85 = IKatan2WithCheck(IkReal(x81),x82,IKFAST_ATAN2_MAGTHRESH);\nif(!x85.valid){\ncontinue;\n}\nIkReal x83=((1.0)*(x85.value));\nif((((x81*x81)+(x82*x82))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x86=IKPowWithIntegerCheck(IKabs(IKsqrt(((x81*x81)+(x82*x82)))),-1);\nif(!x86.valid){\ncontinue;\n}\nif( (((0.5)*py*sj2*sj3*(x86.value))) < -1-IKFAST_SINCOS_THRESH || (((0.5)*py*sj2*sj3*(x86.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x84=IKasin(((0.5)*py*sj2*sj3*(x86.value)));\nj0array[0]=(x84+(((-1.0)*x83)));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x84))+(((-1.0)*x83)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x87=IKcos(j0);\nIkReal x88=IKsin(j0);\nIkReal x89=sj2*sj2;\nIkReal x90=cj2*cj2;\nIkReal x91=px*px;\nIkReal x92=(px*py);\nIkReal x93=((1.0)*x91);\nIkReal x94=((0.5)*sj2*sj3);\nevalcond[0]=((((-1.0)*py*x87))+x94+((px*x88)));\nevalcond[1]=(((x87*((((x89*x92))+((x90*x92))))))+(((-1.0)*px*x94))+((x88*(((((-1.0)*x90*x93))+(((-1.0)*x89*x93)))))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j1eval[3];\nIkReal x95=(cj0*px);\nIkReal x96=((2.0)*pz);\nIkReal x97=(py*sj0);\nIkReal x98=(cj2*sj3);\nIkReal x99=((1.11111111111111)*cj3);\nj1eval[0]=((((1.11111111111111)*pz*x98))+((x97*x99))+x95+x97+((x95*x99)));\nj1eval[1]=IKsign(((((0.9)*x97))+(((0.9)*x95))+((cj3*x95))+((cj3*x97))+((pz*x98))));\nj1eval[2]=((IKabs(((0.405)+(((-1.0)*pz*x96))+(((0.9)*cj3))+(((0.5)*(cj3*cj3))))))+(IKabs((((x96*x97))+(((0.5)*cj3*x98))+(((0.45)*x98))+((x95*x96))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[3];\nIkReal x100=(cj0*px);\nIkReal x101=(cj2*sj3);\nIkReal x102=((10.0)*pp);\nIkReal x103=(py*sj0);\nIkReal x104=((1.11111111111111)*cj3);\nIkReal x105=((9.0)*cj3);\nIkReal x106=((18.0)*pz);\nj1eval[0]=((((1.11111111111111)*pz*x101))+x100+x103+((x103*x104))+((x100*x104)));\nj1eval[1]=IKsign(((((9.0)*pz*x101))+(((8.1)*x100))+(((8.1)*x103))+((x103*x105))+((x100*x105))));\nj1eval[2]=((IKabs(((-0.4275)+(((-1.0)*pz*x106))+((cj3*x102))+(((9.0)*pp))+(((-0.475)*cj3)))))+(IKabs((((x103*x106))+((x101*x102))+(((-0.475)*x101))+((x100*x106))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[3];\nIkReal x107=cj2*cj2;\nIkReal x108=cj3*cj3;\nIkReal x109=((2.0)*cj3);\nIkReal x110=(py*sj0);\nIkReal x111=(cj0*px);\nIkReal x112=((2.0)*cj2*sj3);\nIkReal x113=(x107*x108);\nj1eval[0]=((1.0)+(((-1.23456790123457)*x113))+(((2.22222222222222)*cj3))+(((1.23456790123457)*x107))+(((1.23456790123457)*x108)));\nj1eval[1]=((IKabs(((((1.8)*pz))+((x110*x112))+((x111*x112))+((pz*x109)))))+(IKabs((((x109*x111))+((x109*x110))+(((1.8)*x111))+(((1.8)*x110))+(((-1.0)*pz*x112))))));\nj1eval[2]=IKsign(((0.81)+x108+x107+(((1.8)*cj3))+(((-1.0)*x113))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x114=cj2*cj2;\nIkReal x115=cj3*cj3;\nIkReal x116=(cj2*sj3);\nIkReal x117=((2.0)*pz);\nIkReal x118=(py*sj0);\nIkReal x119=((2.0)*cj0*px);\nCheckValue<IkReal> x120 = IKatan2WithCheck(IkReal((((cj3*x119))+(((1.8)*cj0*px))+(((-1.0)*x116*x117))+(((2.0)*cj3*x118))+(((1.8)*x118)))),(((cj3*x117))+(((1.8)*pz))+(((2.0)*x116*x118))+((x116*x119))),IKFAST_ATAN2_MAGTHRESH);\nif(!x120.valid){\ncontinue;\n}\nCheckValue<IkReal> x121=IKPowWithIntegerCheck(IKsign(((0.81)+x115+x114+(((1.8)*cj3))+(((-1.0)*x114*x115)))),-1);\nif(!x121.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x120.value)+(((1.5707963267949)*(x121.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x122=IKcos(j1);\nIkReal x123=IKsin(j1);\nIkReal x124=(px*sj2);\nIkReal x125=((0.5)*sj3);\nIkReal x126=((0.5)*cj3);\nIkReal x127=(py*sj0);\nIkReal x128=((1.0)*cj2);\nIkReal x129=(cj0*py);\nIkReal x130=((1.0)*sj2);\nIkReal x131=(cj0*px);\nIkReal x132=(pz*x122);\nIkReal x133=(cj0*x122);\nIkReal x134=(cj2*x123);\nIkReal x135=((0.9)*x123);\nevalcond[0]=((((-0.45)*x122))+((x125*x134))+pz+(((-1.0)*x122*x126)));\nevalcond[1]=((-0.45)+(((-1.0)*x126))+x132+((x123*x131))+((x123*x127)));\nevalcond[2]=((0.0475)+((x127*x135))+(((0.9)*x132))+(((-1.0)*pp))+((x131*x135)));\nevalcond[3]=(((cj2*x122*x125))+(((0.45)*x123))+((x123*x126))+(((-1.0)*x131))+(((-1.0)*x127)));\nevalcond[4]=(((sj2*x122*x127))+(((-1.0)*pz*x123*x130))+(((-1.0)*x128*x129))+((x124*x133))+((cj2*px*sj0)));\nevalcond[5]=((((-1.0)*x122*x127*x128))+((pz*x134))+x125+(((-1.0)*x122*x128*x131))+(((-1.0)*x129*x130))+((sj0*x124)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x571=(cj2*sj3);\nIkReal x572=(py*sj0);\nIkReal x573=(cj0*px);\nIkReal x574=((18.0)*pz);\nIkReal x575=((9.0)*cj3);\nIkReal x576=((10.0)*pp);\nCheckValue<IkReal> x577=IKPowWithIntegerCheck(IKsign(((((8.1)*x573))+(((8.1)*x572))+(((9.0)*pz*x571))+((x573*x575))+((x572*x575)))),-1);\nif(!x577.valid){\ncontinue;\n}\nCheckValue<IkReal> x578 = IKatan2WithCheck(IkReal(((-0.4275)+(((9.0)*pp))+((cj3*x576))+(((-1.0)*pz*x574))+(((-0.475)*cj3)))),(((x571*x576))+((x573*x574))+((x572*x574))+(((-0.475)*x571))),IKFAST_ATAN2_MAGTHRESH);\nif(!x578.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x577.value)))+(x578.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x579=IKcos(j1);\nIkReal x580=IKsin(j1);\nIkReal x581=(px*sj2);\nIkReal x582=((0.5)*sj3);\nIkReal x583=((0.5)*cj3);\nIkReal x584=(py*sj0);\nIkReal x585=((1.0)*cj2);\nIkReal x586=(cj0*py);\nIkReal x587=((1.0)*sj2);\nIkReal x588=(cj0*px);\nIkReal x589=(pz*x579);\nIkReal x590=(cj0*x579);\nIkReal x591=(cj2*x580);\nIkReal x592=((0.9)*x580);\nevalcond[0]=((((-1.0)*x579*x583))+pz+(((-0.45)*x579))+((x582*x591)));\nevalcond[1]=((-0.45)+((x580*x584))+((x580*x588))+x589+(((-1.0)*x583)));\nevalcond[2]=((0.0475)+(((0.9)*x589))+(((-1.0)*pp))+((x584*x592))+((x588*x592)));\nevalcond[3]=(((cj2*x579*x582))+(((-1.0)*x588))+(((-1.0)*x584))+((x580*x583))+(((0.45)*x580)));\nevalcond[4]=(((sj2*x579*x584))+(((-1.0)*pz*x580*x587))+(((-1.0)*x585*x586))+((x581*x590))+((cj2*px*sj0)));\nevalcond[5]=(((sj0*x581))+((pz*x591))+(((-1.0)*x579*x585*x588))+(((-1.0)*x579*x584*x585))+(((-1.0)*x586*x587))+x582);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x593=((2.0)*pz);\nIkReal x594=(py*sj0);\nIkReal x595=(cj0*px);\nIkReal x596=(cj2*sj3);\nCheckValue<IkReal> x597 = IKatan2WithCheck(IkReal(((0.405)+(((0.9)*cj3))+(((0.5)*(cj3*cj3)))+(((-1.0)*pz*x593)))),((((0.45)*x596))+(((0.5)*cj3*x596))+((x593*x594))+((x593*x595))),IKFAST_ATAN2_MAGTHRESH);\nif(!x597.valid){\ncontinue;\n}\nCheckValue<IkReal> x598=IKPowWithIntegerCheck(IKsign((((pz*x596))+((cj3*x594))+((cj3*x595))+(((0.9)*x594))+(((0.9)*x595)))),-1);\nif(!x598.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x597.value)+(((1.5707963267949)*(x598.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x599=IKcos(j1);\nIkReal x600=IKsin(j1);\nIkReal x601=(px*sj2);\nIkReal x602=((0.5)*sj3);\nIkReal x603=((0.5)*cj3);\nIkReal x604=(py*sj0);\nIkReal x605=((1.0)*cj2);\nIkReal x606=(cj0*py);\nIkReal x607=((1.0)*sj2);\nIkReal x608=(cj0*px);\nIkReal x609=(pz*x599);\nIkReal x610=(cj0*x599);\nIkReal x611=(cj2*x600);\nIkReal x612=((0.9)*x600);\nevalcond[0]=((((-1.0)*x599*x603))+pz+(((-0.45)*x599))+((x602*x611)));\nevalcond[1]=((-0.45)+((x600*x604))+((x600*x608))+x609+(((-1.0)*x603)));\nevalcond[2]=((0.0475)+((x608*x612))+(((0.9)*x609))+(((-1.0)*pp))+((x604*x612)));\nevalcond[3]=((((0.45)*x600))+((x600*x603))+(((-1.0)*x608))+(((-1.0)*x604))+((cj2*x599*x602)));\nevalcond[4]=((((-1.0)*x605*x606))+((x601*x610))+(((-1.0)*pz*x600*x607))+((cj2*px*sj0))+((sj2*x599*x604)));\nevalcond[5]=(((sj0*x601))+(((-1.0)*x599*x604*x605))+(((-1.0)*x599*x605*x608))+((pz*x611))+x602+(((-1.0)*x606*x607)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nIkReal x613=((-0.45)+(((-0.5)*cj3)));\nCheckValue<IkReal> x616 = IKatan2WithCheck(IkReal(x613),((0.5)*cj2*sj3),IKFAST_ATAN2_MAGTHRESH);\nif(!x616.valid){\ncontinue;\n}\nIkReal x614=((1.0)*(x616.value));\nif((((x613*x613)+(((0.25)*(cj2*cj2)*(sj3*sj3))))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x617=IKPowWithIntegerCheck(IKabs(IKsqrt(((x613*x613)+(((0.25)*(cj2*cj2)*(sj3*sj3)))))),-1);\nif(!x617.valid){\ncontinue;\n}\nif( ((pz*(x617.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x617.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x615=IKasin((pz*(x617.value)));\nj1array[0]=((((-1.0)*x615))+(((-1.0)*x614)));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nj1array[1]=((3.14159265358979)+(((-1.0)*x614))+x615);\nsj1array[1]=IKsin(j1array[1]);\ncj1array[1]=IKcos(j1array[1]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nif( j1array[1] > IKPI )\n{\n    j1array[1]-=IK2PI;\n}\nelse if( j1array[1] < -IKPI )\n{    j1array[1]+=IK2PI;\n}\nj1valid[1] = true;\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n\n{\nIkReal j0eval[3];\nIkReal x618=pz*pz;\nIkReal x619=((1.0)*sj1);\nIkReal x620=(pp*sj1);\nIkReal x621=(sj2*sj3);\nIkReal x622=((2.0)*cj1*pz);\nj0eval[0]=((((-1.0)*x618*x619))+x620);\nj0eval[1]=((IKabs(((((-1.0)*px*x619*x621))+(((0.9)*py))+((cj3*py))+(((-1.0)*py*x622)))))+(IKabs(((((0.9)*px))+(((-1.0)*px*x622))+((py*sj1*x621))+((cj3*px))))));\nj0eval[2]=IKsign(((((-2.0)*sj1*x618))+(((2.0)*x620))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nIkReal x623=pz*pz;\nIkReal x624=(px*sj3);\nIkReal x625=(cj1*cj2);\nIkReal x626=((0.9)*sj1);\nIkReal x627=(cj3*sj1);\nIkReal x628=(py*sj3);\nj0eval[0]=(pp+(((-1.0)*x623)));\nj0eval[1]=((IKabs((((py*x626))+((py*x627))+((x625*x628))+(((-1.0)*sj2*x624)))))+(IKabs((((sj2*x628))+((x624*x625))+((px*x626))+((px*x627))))));\nj0eval[2]=IKsign(((((-2.0)*x623))+(((2.0)*pp))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nIkReal x629=pz*pz;\nIkReal x630=((20.0)*pp);\nIkReal x631=(pp*sj1);\nIkReal x632=(sj1*x629);\nIkReal x633=((18.0)*cj1*pz);\nIkReal x634=((9.0)*sj1*sj2*sj3);\nj0eval[0]=(x631+(((-1.0)*x632)));\nj0eval[1]=((IKabs((((py*x634))+(((-0.95)*px))+(((-1.0)*px*x633))+((px*x630)))))+(IKabs((((py*x630))+(((-0.95)*py))+(((-1.0)*px*x634))+(((-1.0)*py*x633))))));\nj0eval[2]=IKsign(((((-18.0)*x632))+(((18.0)*x631))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x635=((1.0)*pp);\nIkReal x636=((-0.45)+pz+(((-0.5)*cj3)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));\nevalcond[1]=((0.4525)+(((-1.0)*x635))+(((0.45)*cj3)));\nevalcond[2]=x636;\nevalcond[3]=x636;\nevalcond[4]=((0.0475)+(((-1.0)*x635))+(((0.9)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nIkReal x637=pz*pz;\nIkReal x638=(px*sj3);\nIkReal x639=(py*sj3);\nj0eval[0]=(pp+(((-1.0)*x637)));\nj0eval[1]=((IKabs(((((-1.0)*sj2*x638))+((cj2*x639)))))+(IKabs((((sj2*x639))+((cj2*x638))))));\nj0eval[2]=IKsign(((((2.0)*pp))+(((-2.0)*x637))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nIkReal x640=pz*pz;\nIkReal x641=cj2*cj2;\nIkReal x642=((2.0)*cj2);\nIkReal x643=(px*sj3);\nIkReal x644=((1.0)*cj2);\nIkReal x645=(py*sj3);\nj0eval[0]=((((-1.0)*x640*x644))+((cj2*pp)));\nj0eval[1]=IKsign((((pp*x642))+(((-1.0)*x640*x642))));\nj0eval[2]=((IKabs((((x641*x645))+(((-1.0)*sj2*x643*x644)))))+(IKabs((((cj2*sj2*x645))+((x641*x643))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nIkReal x646=pz*pz;\nIkReal x647=cj2*cj2;\nIkReal x648=(cj2*pp);\nIkReal x649=(cj2*sj2);\nIkReal x650=(px*sj3);\nIkReal x651=((1.0)*py*sj3);\nIkReal x652=(cj2*x646);\nj0eval[0]=((((-1.0)*x648))+x652);\nj0eval[1]=IKsign(((((2.0)*x652))+(((-2.0)*x648))));\nj0eval[2]=((IKabs((((x649*x650))+(((-1.0)*x647*x651)))))+(IKabs(((((-1.0)*x649*x651))+(((-1.0)*x647*x650))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x653=((1.0)*pp);\nIkReal x654=x636;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.4525)+(((-1.0)*x653))+(((0.45)*cj3)));\nevalcond[2]=x654;\nevalcond[3]=x654;\nevalcond[4]=((0.0475)+(((0.9)*pz))+(((-1.0)*x653)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nIkReal x655=pz*pz;\nj0eval[0]=((((-1.0)*pp))+x655);\nj0eval[1]=IKsign(((((-2.0)*pp))+(((2.0)*x655))));\nj0eval[2]=((IKabs((px*sj3)))+(IKabs((py*sj3))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x656=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.9025)+(((-1.0)*x656)));\nevalcond[2]=((-0.95)+pz);\nevalcond[3]=((0.0475)+(((0.9)*pz))+(((-1.0)*x656)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x658 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x658.valid){\ncontinue;\n}\nIkReal x657=x658.value;\nj0array[0]=((-1.0)*x657);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x657)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x659=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.0025)+(((-1.0)*x659)));\nevalcond[2]=((0.05)+pz);\nevalcond[3]=((0.0475)+(((0.9)*pz))+(((-1.0)*x659)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x661 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x661.valid){\ncontinue;\n}\nIkReal x660=x661.value;\nj0array[0]=((-1.0)*x660);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x660)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nCheckValue<IkReal> x662=IKPowWithIntegerCheck(IKsign(((((-2.0)*pp))+(((2.0)*(pz*pz))))),-1);\nif(!x662.valid){\ncontinue;\n}\nCheckValue<IkReal> x663 = IKatan2WithCheck(IkReal((px*sj3)),((-1.0)*py*sj3),IKFAST_ATAN2_MAGTHRESH);\nif(!x663.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x662.value)))+(x663.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x664=IKsin(j0);\nIkReal x665=IKcos(j0);\nIkReal x666=((1.0)*x665);\nevalcond[0]=((((-1.0)*py*x664))+(((-1.0)*px*x666)));\nevalcond[1]=((((0.5)*sj3))+((px*x664))+(((-1.0)*py*x666)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x667=((1.0)*pp);\nIkReal x668=x636;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.4525)+(((-1.0)*x667))+(((0.45)*cj3)));\nevalcond[2]=x668;\nevalcond[3]=x668;\nevalcond[4]=((0.0475)+(((0.9)*pz))+(((-1.0)*x667)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nIkReal x669=pz*pz;\nj0eval[0]=((((-1.0)*x669))+pp);\nj0eval[1]=IKsign(((((2.0)*pp))+(((-2.0)*x669))));\nj0eval[2]=((IKabs((px*sj3)))+(IKabs((py*sj3))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x670=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.9025)+(((-1.0)*x670)));\nevalcond[2]=((-0.95)+pz);\nevalcond[3]=((0.0475)+(((0.9)*pz))+(((-1.0)*x670)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x672 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x672.valid){\ncontinue;\n}\nIkReal x671=x672.value;\nj0array[0]=((-1.0)*x671);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x671)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x673=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.0025)+(((-1.0)*x673)));\nevalcond[2]=((0.05)+pz);\nevalcond[3]=((0.0475)+(((0.9)*pz))+(((-1.0)*x673)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x675 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x675.valid){\ncontinue;\n}\nIkReal x674=x675.value;\nj0array[0]=((-1.0)*x674);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x674)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nCheckValue<IkReal> x676=IKPowWithIntegerCheck(IKsign(((((2.0)*pp))+(((-2.0)*(pz*pz))))),-1);\nif(!x676.valid){\ncontinue;\n}\nCheckValue<IkReal> x677 = IKatan2WithCheck(IkReal((px*sj3)),((-1.0)*py*sj3),IKFAST_ATAN2_MAGTHRESH);\nif(!x677.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x676.value)))+(x677.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x678=IKsin(j0);\nIkReal x679=IKcos(j0);\nIkReal x680=((1.0)*x679);\nevalcond[0]=((((-1.0)*py*x678))+(((-1.0)*px*x680)));\nevalcond[1]=((((-1.0)*py*x680))+(((-0.5)*sj3))+((px*x678)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x681=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.9025)+(((-1.0)*x681)));\nevalcond[2]=((-0.95)+pz);\nevalcond[3]=((0.0475)+(((-1.0)*x681))+(((0.9)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(((((-1.0)*cj2*py))+((px*sj2)))))+(IKabs((((cj2*px))+((py*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nIkReal x682=((1.0)*py);\nj0eval[0]=((IKabs(((((-1.0)*cj2*x682))+((px*sj2)))))+(IKabs(((((-1.0)*cj2*px))+(((-1.0)*sj2*x682))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x683=((1.0)*cj2);\nCheckValue<IkReal> x685 = IKatan2WithCheck(IkReal(((((-1.0)*px*x683))+(((-1.0)*py*sj2)))),(((px*sj2))+(((-1.0)*py*x683))),IKFAST_ATAN2_MAGTHRESH);\nif(!x685.valid){\ncontinue;\n}\nIkReal x684=x685.value;\nj0array[0]=((-1.0)*x684);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x684)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x686=IKcos(j0);\nIkReal x687=IKsin(j0);\nIkReal x688=(px*x687);\nIkReal x689=((1.0)*x686);\nIkReal x690=(py*x687);\nevalcond[0]=(x688+(((-1.0)*py*x689)));\nevalcond[1]=((((-1.0)*px*x689))+(((-1.0)*x690)));\nevalcond[2]=((((-1.0)*cj2*py*x689))+((px*sj2*x686))+((sj2*x690))+((cj2*x688)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x692 = IKatan2WithCheck(IkReal(((((-1.0)*cj2*py))+((px*sj2)))),(((cj2*px))+((py*sj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x692.valid){\ncontinue;\n}\nIkReal x691=x692.value;\nj0array[0]=((-1.0)*x691);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x691)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x693=IKcos(j0);\nIkReal x694=IKsin(j0);\nIkReal x695=(px*x694);\nIkReal x696=((1.0)*x693);\nIkReal x697=((1.0)*py*x694);\nevalcond[0]=(x695+(((-1.0)*py*x696)));\nevalcond[1]=((((-1.0)*px*x696))+(((-1.0)*x697)));\nevalcond[2]=((((-1.0)*cj2*x697))+((sj2*x695))+(((-1.0)*cj2*px*x696))+(((-1.0)*py*sj2*x696)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x699 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x699.valid){\ncontinue;\n}\nIkReal x698=x699.value;\nj0array[0]=((-1.0)*x698);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x698)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x700=IKcos(j0);\nIkReal x701=IKsin(j0);\nIkReal x702=(py*sj2);\nIkReal x703=(px*sj2);\nIkReal x704=(cj2*px);\nIkReal x705=((1.0)*x700);\nIkReal x706=((1.0)*py*x701);\nevalcond[0]=((((-1.0)*px*x705))+(((-1.0)*x706)));\nevalcond[1]=(((x701*x704))+((x701*x702))+((x700*x703))+(((-1.0)*cj2*py*x705)));\nevalcond[2]=(((x701*x703))+(((-1.0)*x702*x705))+(((-1.0)*cj2*x706))+(((-1.0)*x704*x705)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x707=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.0025)+(((-1.0)*x707)));\nevalcond[2]=((0.05)+pz);\nevalcond[3]=((0.0475)+(((0.9)*pz))+(((-1.0)*x707)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(((((-1.0)*cj2*py))+((px*sj2)))))+(IKabs((((cj2*px))+((py*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nIkReal x708=((1.0)*py);\nj0eval[0]=((IKabs(((((-1.0)*cj2*px))+(((-1.0)*sj2*x708)))))+(IKabs(((((-1.0)*cj2*x708))+((px*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x709=((1.0)*cj2);\nCheckValue<IkReal> x711 = IKatan2WithCheck(IkReal(((((-1.0)*px*x709))+(((-1.0)*py*sj2)))),((((-1.0)*py*x709))+((px*sj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x711.valid){\ncontinue;\n}\nIkReal x710=x711.value;\nj0array[0]=((-1.0)*x710);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x710)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x712=IKcos(j0);\nIkReal x713=IKsin(j0);\nIkReal x714=(px*x713);\nIkReal x715=((1.0)*x712);\nIkReal x716=(py*x713);\nevalcond[0]=(x714+(((-1.0)*py*x715)));\nevalcond[1]=((((-1.0)*x716))+(((-1.0)*px*x715)));\nevalcond[2]=(((sj2*x716))+(((-1.0)*cj2*py*x715))+((cj2*x714))+((px*sj2*x712)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x718 = IKatan2WithCheck(IkReal(((((-1.0)*cj2*py))+((px*sj2)))),(((cj2*px))+((py*sj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x718.valid){\ncontinue;\n}\nIkReal x717=x718.value;\nj0array[0]=((-1.0)*x717);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x717)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x719=IKcos(j0);\nIkReal x720=IKsin(j0);\nIkReal x721=(px*x720);\nIkReal x722=((1.0)*x719);\nIkReal x723=((1.0)*py*x720);\nevalcond[0]=(x721+(((-1.0)*py*x722)));\nevalcond[1]=((((-1.0)*px*x722))+(((-1.0)*x723)));\nevalcond[2]=((((-1.0)*cj2*x723))+((sj2*x721))+(((-1.0)*py*sj2*x722))+(((-1.0)*cj2*px*x722)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x725 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x725.valid){\ncontinue;\n}\nIkReal x724=x725.value;\nj0array[0]=((-1.0)*x724);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x724)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x726=IKcos(j0);\nIkReal x727=IKsin(j0);\nIkReal x728=(py*sj2);\nIkReal x729=(px*sj2);\nIkReal x730=(cj2*px);\nIkReal x731=((1.0)*x726);\nIkReal x732=((1.0)*py*x727);\nevalcond[0]=((((-1.0)*px*x731))+(((-1.0)*x732)));\nevalcond[1]=(((x727*x730))+((x727*x728))+((x726*x729))+(((-1.0)*cj2*py*x731)));\nevalcond[2]=(((x727*x729))+(((-1.0)*cj2*x732))+(((-1.0)*x730*x731))+(((-1.0)*x728*x731)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x733=cj2*cj2;\nIkReal x734=((2.0)*cj2);\nIkReal x735=(cj2*sj2);\nIkReal x736=(px*sj3);\nIkReal x737=((1.0)*py*sj3);\nCheckValue<IkReal> x738 = IKatan2WithCheck(IkReal((((x735*x736))+(((-1.0)*x733*x737)))),((((-1.0)*x735*x737))+(((-1.0)*x733*x736))),IKFAST_ATAN2_MAGTHRESH);\nif(!x738.valid){\ncontinue;\n}\nCheckValue<IkReal> x739=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp*x734))+((x734*(pz*pz))))),-1);\nif(!x739.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x738.value)+(((1.5707963267949)*(x739.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x740=IKcos(j0);\nIkReal x741=IKsin(j0);\nIkReal x742=((0.5)*sj3);\nIkReal x743=(px*x741);\nIkReal x744=((1.0)*x740);\nIkReal x745=(py*x741);\nevalcond[0]=((((-1.0)*py*x744))+((sj2*x742))+x743);\nevalcond[1]=((((-1.0)*px*x744))+((cj2*x742))+(((-1.0)*x745)));\nevalcond[2]=(((px*sj2*x740))+((cj2*x743))+(((-1.0)*cj2*py*x744))+((sj2*x745)));\nevalcond[3]=((((-1.0)*cj2*px*x744))+(((-1.0)*py*sj2*x744))+(((-1.0)*cj2*x745))+((sj2*x743))+x742);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x746=cj2*cj2;\nIkReal x747=((2.0)*cj2);\nIkReal x748=(px*sj3);\nIkReal x749=(cj2*sj2);\nIkReal x750=(py*sj3);\nCheckValue<IkReal> x751=IKPowWithIntegerCheck(IKsign((((pp*x747))+(((-1.0)*x747*(pz*pz))))),-1);\nif(!x751.valid){\ncontinue;\n}\nCheckValue<IkReal> x752 = IKatan2WithCheck(IkReal(((((-1.0)*x748*x749))+((x746*x750)))),(((x746*x748))+((x749*x750))),IKFAST_ATAN2_MAGTHRESH);\nif(!x752.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x751.value)))+(x752.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x753=IKcos(j0);\nIkReal x754=IKsin(j0);\nIkReal x755=((0.5)*sj3);\nIkReal x756=(px*x754);\nIkReal x757=((1.0)*x753);\nIkReal x758=(py*x754);\nevalcond[0]=((((-1.0)*py*x757))+x756+((sj2*x755)));\nevalcond[1]=((((-1.0)*px*x757))+((cj2*x755))+(((-1.0)*x758)));\nevalcond[2]=(((px*sj2*x753))+((cj2*x756))+((sj2*x758))+(((-1.0)*cj2*py*x757)));\nevalcond[3]=((((-1.0)*py*sj2*x757))+(((-1.0)*cj2*px*x757))+(((-1.0)*cj2*x758))+x755+((sj2*x756)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x759=(px*sj3);\nIkReal x760=(py*sj3);\nCheckValue<IkReal> x761=IKPowWithIntegerCheck(IKsign(((((2.0)*pp))+(((-2.0)*(pz*pz))))),-1);\nif(!x761.valid){\ncontinue;\n}\nCheckValue<IkReal> x762 = IKatan2WithCheck(IkReal((((cj2*x760))+(((-1.0)*sj2*x759)))),(((sj2*x760))+((cj2*x759))),IKFAST_ATAN2_MAGTHRESH);\nif(!x762.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x761.value)))+(x762.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x763=IKcos(j0);\nIkReal x764=IKsin(j0);\nIkReal x765=((0.5)*sj3);\nIkReal x766=(px*x764);\nIkReal x767=((1.0)*x763);\nIkReal x768=(py*x764);\nevalcond[0]=((((-1.0)*py*x767))+((sj2*x765))+x766);\nevalcond[1]=(((cj2*x765))+(((-1.0)*px*x767))+(((-1.0)*x768)));\nevalcond[2]=(((cj2*x766))+((sj2*x768))+(((-1.0)*cj2*py*x767))+((px*sj2*x763)));\nevalcond[3]=(((sj2*x766))+(((-1.0)*py*sj2*x767))+x765+(((-1.0)*cj2*px*x767))+(((-1.0)*cj2*x768)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x769=((0.5)*cj3);\nIkReal x770=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));\nevalcond[1]=((0.4525)+(((0.45)*cj3))+(((-1.0)*x770)));\nevalcond[2]=((0.45)+pz+x769);\nevalcond[3]=((-0.45)+(((-1.0)*x769))+(((-1.0)*pz)));\nevalcond[4]=((0.0475)+(((-1.0)*x770))+(((-0.9)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nIkReal x771=pz*pz;\nIkReal x772=(px*sj3);\nIkReal x773=(py*sj3);\nj0eval[0]=((((-1.0)*pp))+x771);\nj0eval[1]=IKsign(((((-2.0)*pp))+(((2.0)*x771))));\nj0eval[2]=((IKabs((((cj2*x772))+(((-1.0)*sj2*x773)))))+(IKabs((((cj2*x773))+((sj2*x772))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nIkReal x774=pz*pz;\nIkReal x775=cj2*cj2;\nIkReal x776=(cj2*pp);\nIkReal x777=(px*sj3);\nIkReal x778=(cj2*sj2);\nIkReal x779=(py*sj3);\nIkReal x780=(cj2*x774);\nj0eval[0]=(x780+(((-1.0)*x776)));\nj0eval[1]=IKsign(((((-2.0)*x776))+(((2.0)*x780))));\nj0eval[2]=((IKabs((((x777*x778))+((x775*x779)))))+(IKabs(((((-1.0)*x778*x779))+((x775*x777))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nIkReal x781=cj2*cj2;\nIkReal x782=pz*pz;\nIkReal x783=((2.0)*cj2);\nIkReal x784=((1.0)*sj3);\nIkReal x785=(cj2*sj2);\nj0eval[0]=(((cj2*pp))+(((-1.0)*cj2*x782)));\nj0eval[1]=((IKabs((((py*sj3*x785))+(((-1.0)*px*x781*x784)))))+(IKabs(((((-1.0)*py*x781*x784))+(((-1.0)*px*x784*x785))))));\nj0eval[2]=IKsign((((pp*x783))+(((-1.0)*x782*x783))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x786=((0.5)*cj3);\nIkReal x787=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.4525)+(((-1.0)*x787))+(((0.45)*cj3)));\nevalcond[2]=((0.45)+pz+x786);\nevalcond[3]=((-0.45)+(((-1.0)*x786))+(((-1.0)*pz)));\nevalcond[4]=((0.0475)+(((-1.0)*x787))+(((-0.9)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nIkReal x788=pz*pz;\nj0eval[0]=((((-1.0)*pp))+x788);\nj0eval[1]=IKsign(((((-2.0)*pp))+(((2.0)*x788))));\nj0eval[2]=((IKabs((px*sj3)))+(IKabs((py*sj3))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x789=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.9025)+(((-1.0)*x789)));\nevalcond[2]=((0.95)+pz);\nevalcond[3]=((0.0475)+(((-1.0)*x789))+(((-0.9)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x791 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x791.valid){\ncontinue;\n}\nIkReal x790=x791.value;\nj0array[0]=((-1.0)*x790);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x790)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x792=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.0025)+(((-1.0)*x792)));\nevalcond[2]=((-0.05)+pz);\nevalcond[3]=((0.0475)+(((-1.0)*x792))+(((-0.9)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x794 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x794.valid){\ncontinue;\n}\nIkReal x793=x794.value;\nj0array[0]=((-1.0)*x793);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x793)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nCheckValue<IkReal> x795=IKPowWithIntegerCheck(IKsign(((((-2.0)*pp))+(((2.0)*(pz*pz))))),-1);\nif(!x795.valid){\ncontinue;\n}\nCheckValue<IkReal> x796 = IKatan2WithCheck(IkReal((px*sj3)),((-1.0)*py*sj3),IKFAST_ATAN2_MAGTHRESH);\nif(!x796.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x795.value)))+(x796.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x797=IKsin(j0);\nIkReal x798=IKcos(j0);\nIkReal x799=((1.0)*x798);\nevalcond[0]=((((-1.0)*px*x799))+(((-1.0)*py*x797)));\nevalcond[1]=((((0.5)*sj3))+((px*x797))+(((-1.0)*py*x799)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x800=((0.5)*cj3);\nIkReal x801=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.4525)+(((0.45)*cj3))+(((-1.0)*x801)));\nevalcond[2]=((0.45)+pz+x800);\nevalcond[3]=((-0.45)+(((-1.0)*pz))+(((-1.0)*x800)));\nevalcond[4]=((0.0475)+(((-1.0)*x801))+(((-0.9)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nIkReal x802=pz*pz;\nj0eval[0]=((((-1.0)*x802))+pp);\nj0eval[1]=IKsign(((((2.0)*pp))+(((-2.0)*x802))));\nj0eval[2]=((IKabs((px*sj3)))+(IKabs((py*sj3))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x803=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.9025)+(((-1.0)*x803)));\nevalcond[2]=((0.95)+pz);\nevalcond[3]=((0.0475)+(((-1.0)*x803))+(((-0.9)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x805 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x805.valid){\ncontinue;\n}\nIkReal x804=x805.value;\nj0array[0]=((-1.0)*x804);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x804)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x806=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.0025)+(((-1.0)*x806)));\nevalcond[2]=((-0.05)+pz);\nevalcond[3]=((0.0475)+(((-1.0)*x806))+(((-0.9)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x808 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x808.valid){\ncontinue;\n}\nIkReal x807=x808.value;\nj0array[0]=((-1.0)*x807);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x807)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nCheckValue<IkReal> x809=IKPowWithIntegerCheck(IKsign(((((2.0)*pp))+(((-2.0)*(pz*pz))))),-1);\nif(!x809.valid){\ncontinue;\n}\nCheckValue<IkReal> x810 = IKatan2WithCheck(IkReal((px*sj3)),((-1.0)*py*sj3),IKFAST_ATAN2_MAGTHRESH);\nif(!x810.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x809.value)))+(x810.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x811=IKsin(j0);\nIkReal x812=IKcos(j0);\nIkReal x813=((1.0)*x812);\nevalcond[0]=((((-1.0)*py*x811))+(((-1.0)*px*x813)));\nevalcond[1]=(((px*x811))+(((-1.0)*py*x813))+(((-0.5)*sj3)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x814=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.9025)+(((-1.0)*x814)));\nevalcond[2]=((0.95)+pz);\nevalcond[3]=((0.0475)+(((-1.0)*x814))+(((-0.9)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs((((cj2*px))+(((-1.0)*py*sj2)))))+(IKabs((((cj2*py))+((px*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nIkReal x815=((1.0)*sj2);\nj0eval[0]=((IKabs(((((-1.0)*cj2*py))+(((-1.0)*px*x815)))))+(IKabs(((((-1.0)*py*x815))+((cj2*px))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x816=((1.0)*py);\nCheckValue<IkReal> x818 = IKatan2WithCheck(IkReal(((((-1.0)*cj2*x816))+(((-1.0)*px*sj2)))),(((cj2*px))+(((-1.0)*sj2*x816))),IKFAST_ATAN2_MAGTHRESH);\nif(!x818.valid){\ncontinue;\n}\nIkReal x817=x818.value;\nj0array[0]=((-1.0)*x817);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x817)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x819=IKcos(j0);\nIkReal x820=IKsin(j0);\nIkReal x821=(px*x820);\nIkReal x822=((1.0)*x819);\nIkReal x823=(py*x820);\nevalcond[0]=((((-1.0)*py*x822))+x821);\nevalcond[1]=((((-1.0)*x823))+(((-1.0)*px*x822)));\nevalcond[2]=(((cj2*px*x819))+((sj2*x821))+(((-1.0)*py*sj2*x822))+((cj2*x823)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x825 = IKatan2WithCheck(IkReal((((cj2*px))+(((-1.0)*py*sj2)))),(((cj2*py))+((px*sj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x825.valid){\ncontinue;\n}\nIkReal x824=x825.value;\nj0array[0]=((-1.0)*x824);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x824)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x826=IKcos(j0);\nIkReal x827=IKsin(j0);\nIkReal x828=(px*x827);\nIkReal x829=((1.0)*x826);\nIkReal x830=((1.0)*py*x827);\nevalcond[0]=((((-1.0)*py*x829))+x828);\nevalcond[1]=((((-1.0)*px*x829))+(((-1.0)*x830)));\nevalcond[2]=((((-1.0)*cj2*py*x829))+(((-1.0)*px*sj2*x829))+((cj2*x828))+(((-1.0)*sj2*x830)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x832 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x832.valid){\ncontinue;\n}\nIkReal x831=x832.value;\nj0array[0]=((-1.0)*x831);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x831)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x833=IKsin(j0);\nIkReal x834=IKcos(j0);\nIkReal x835=(py*sj2);\nIkReal x836=((1.0)*x834);\nIkReal x837=(py*x833);\nIkReal x838=(px*x833);\nevalcond[0]=((((-1.0)*px*x836))+(((-1.0)*x837)));\nevalcond[1]=((((-1.0)*x835*x836))+((cj2*px*x834))+((cj2*x837))+((sj2*x838)));\nevalcond[2]=((((-1.0)*x833*x835))+(((-1.0)*cj2*py*x836))+((cj2*x838))+(((-1.0)*px*sj2*x836)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x839=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.0025)+(((-1.0)*x839)));\nevalcond[2]=((-0.05)+pz);\nevalcond[3]=((0.0475)+(((-1.0)*x839))+(((-0.9)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs((((cj2*px))+(((-1.0)*py*sj2)))))+(IKabs((((cj2*py))+((px*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nIkReal x840=((1.0)*sj2);\nj0eval[0]=((IKabs(((((-1.0)*py*x840))+((cj2*px)))))+(IKabs(((((-1.0)*px*x840))+(((-1.0)*cj2*py))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x841=((1.0)*py);\nCheckValue<IkReal> x843 = IKatan2WithCheck(IkReal(((((-1.0)*px*sj2))+(((-1.0)*cj2*x841)))),((((-1.0)*sj2*x841))+((cj2*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x843.valid){\ncontinue;\n}\nIkReal x842=x843.value;\nj0array[0]=((-1.0)*x842);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x842)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x844=IKcos(j0);\nIkReal x845=IKsin(j0);\nIkReal x846=(px*x845);\nIkReal x847=((1.0)*x844);\nIkReal x848=(py*x845);\nevalcond[0]=((((-1.0)*py*x847))+x846);\nevalcond[1]=((((-1.0)*px*x847))+(((-1.0)*x848)));\nevalcond[2]=(((cj2*px*x844))+((sj2*x846))+((cj2*x848))+(((-1.0)*py*sj2*x847)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x850 = IKatan2WithCheck(IkReal((((cj2*px))+(((-1.0)*py*sj2)))),(((cj2*py))+((px*sj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x850.valid){\ncontinue;\n}\nIkReal x849=x850.value;\nj0array[0]=((-1.0)*x849);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x849)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x851=IKcos(j0);\nIkReal x852=IKsin(j0);\nIkReal x853=(px*x852);\nIkReal x854=((1.0)*x851);\nIkReal x855=((1.0)*py*x852);\nevalcond[0]=((((-1.0)*py*x854))+x853);\nevalcond[1]=((((-1.0)*x855))+(((-1.0)*px*x854)));\nevalcond[2]=(((cj2*x853))+(((-1.0)*cj2*py*x854))+(((-1.0)*px*sj2*x854))+(((-1.0)*sj2*x855)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x857 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x857.valid){\ncontinue;\n}\nIkReal x856=x857.value;\nj0array[0]=((-1.0)*x856);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x856)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x858=IKsin(j0);\nIkReal x859=IKcos(j0);\nIkReal x860=(py*sj2);\nIkReal x861=((1.0)*x859);\nIkReal x862=(py*x858);\nIkReal x863=(px*x858);\nevalcond[0]=((((-1.0)*x862))+(((-1.0)*px*x861)));\nevalcond[1]=(((sj2*x863))+((cj2*x862))+(((-1.0)*x860*x861))+((cj2*px*x859)));\nevalcond[2]=(((cj2*x863))+(((-1.0)*cj2*py*x861))+(((-1.0)*px*sj2*x861))+(((-1.0)*x858*x860)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x864=cj2*cj2;\nIkReal x865=((2.0)*cj2);\nIkReal x866=((1.0)*sj3);\nIkReal x867=(cj2*sj2);\nCheckValue<IkReal> x868=IKPowWithIntegerCheck(IKsign((((pp*x865))+(((-1.0)*x865*(pz*pz))))),-1);\nif(!x868.valid){\ncontinue;\n}\nCheckValue<IkReal> x869 = IKatan2WithCheck(IkReal(((((-1.0)*px*x866*x867))+(((-1.0)*py*x864*x866)))),(((py*sj3*x867))+(((-1.0)*px*x864*x866))),IKFAST_ATAN2_MAGTHRESH);\nif(!x869.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x868.value)))+(x869.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x870=IKcos(j0);\nIkReal x871=IKsin(j0);\nIkReal x872=((0.5)*sj3);\nIkReal x873=(px*x871);\nIkReal x874=((1.0)*x870);\nIkReal x875=(py*x871);\nevalcond[0]=(((sj2*x872))+(((-1.0)*py*x874))+x873);\nevalcond[1]=((((-1.0)*cj2*x872))+(((-1.0)*x875))+(((-1.0)*px*x874)));\nevalcond[2]=(((cj2*x873))+(((-1.0)*cj2*py*x874))+(((-1.0)*sj2*x875))+(((-1.0)*px*sj2*x874)));\nevalcond[3]=(((sj2*x873))+((cj2*px*x870))+((cj2*x875))+(((-1.0)*py*sj2*x874))+x872);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x876=cj2*cj2;\nIkReal x877=((2.0)*cj2);\nIkReal x878=(px*sj3);\nIkReal x879=(cj2*sj2);\nIkReal x880=(py*sj3);\nCheckValue<IkReal> x881=IKPowWithIntegerCheck(IKsign((((x877*(pz*pz)))+(((-1.0)*pp*x877)))),-1);\nif(!x881.valid){\ncontinue;\n}\nCheckValue<IkReal> x882 = IKatan2WithCheck(IkReal((((x878*x879))+((x876*x880)))),(((x876*x878))+(((-1.0)*x879*x880))),IKFAST_ATAN2_MAGTHRESH);\nif(!x882.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x881.value)))+(x882.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x883=IKcos(j0);\nIkReal x884=IKsin(j0);\nIkReal x885=((0.5)*sj3);\nIkReal x886=(px*x884);\nIkReal x887=((1.0)*x883);\nIkReal x888=(py*x884);\nevalcond[0]=((((-1.0)*py*x887))+((sj2*x885))+x886);\nevalcond[1]=((((-1.0)*cj2*x885))+(((-1.0)*x888))+(((-1.0)*px*x887)));\nevalcond[2]=(((cj2*x886))+(((-1.0)*sj2*x888))+(((-1.0)*cj2*py*x887))+(((-1.0)*px*sj2*x887)));\nevalcond[3]=(((cj2*x888))+((cj2*px*x883))+((sj2*x886))+(((-1.0)*py*sj2*x887))+x885);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x889=(px*sj3);\nIkReal x890=(py*sj3);\nCheckValue<IkReal> x891=IKPowWithIntegerCheck(IKsign(((((-2.0)*pp))+(((2.0)*(pz*pz))))),-1);\nif(!x891.valid){\ncontinue;\n}\nCheckValue<IkReal> x892 = IKatan2WithCheck(IkReal((((cj2*x890))+((sj2*x889)))),(((cj2*x889))+(((-1.0)*sj2*x890))),IKFAST_ATAN2_MAGTHRESH);\nif(!x892.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x891.value)))+(x892.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x893=IKcos(j0);\nIkReal x894=IKsin(j0);\nIkReal x895=((0.5)*sj3);\nIkReal x896=(px*x894);\nIkReal x897=((1.0)*x893);\nIkReal x898=(py*x894);\nevalcond[0]=((((-1.0)*py*x897))+((sj2*x895))+x896);\nevalcond[1]=((((-1.0)*cj2*x895))+(((-1.0)*x898))+(((-1.0)*px*x897)));\nevalcond[2]=(((cj2*x896))+(((-1.0)*sj2*x898))+(((-1.0)*cj2*py*x897))+(((-1.0)*px*sj2*x897)));\nevalcond[3]=(((cj2*x898))+((cj2*px*x893))+((sj2*x896))+(((-1.0)*py*sj2*x897))+x895);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x899=((20.0)*pp);\nIkReal x900=((18.0)*sj1);\nIkReal x901=((18.0)*cj1*pz);\nIkReal x902=((9.0)*sj1*sj2*sj3);\nCheckValue<IkReal> x903=IKPowWithIntegerCheck(IKsign((((pp*x900))+(((-1.0)*x900*(pz*pz))))),-1);\nif(!x903.valid){\ncontinue;\n}\nCheckValue<IkReal> x904 = IKatan2WithCheck(IkReal(((((-1.0)*px*x902))+((py*x899))+(((-0.95)*py))+(((-1.0)*py*x901)))),((((-1.0)*px*x901))+(((-0.95)*px))+((px*x899))+((py*x902))),IKFAST_ATAN2_MAGTHRESH);\nif(!x904.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x903.value)))+(x904.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[6];\nIkReal x905=IKcos(j0);\nIkReal x906=IKsin(j0);\nIkReal x907=(cj1*sj2);\nIkReal x908=((0.9)*sj1);\nIkReal x909=((0.5)*sj3);\nIkReal x910=((0.5)*cj3);\nIkReal x911=(cj1*pz);\nIkReal x912=(pz*sj1);\nIkReal x913=(px*x906);\nIkReal x914=(px*x905);\nIkReal x915=(py*x906);\nIkReal x916=((1.0)*cj1*cj2);\nIkReal x917=((1.0)*py*x905);\nevalcond[0]=(((sj2*x909))+(((-1.0)*x917))+x913);\nevalcond[1]=((-0.45)+(((-1.0)*x910))+x911+((sj1*x914))+((sj1*x915)));\nevalcond[2]=((0.0475)+(((0.9)*x911))+(((-1.0)*pp))+((x908*x914))+((x908*x915)));\nevalcond[3]=((((0.45)*sj1))+(((-1.0)*x914))+(((-1.0)*x915))+((sj1*x910))+((cj1*cj2*x909)));\nevalcond[4]=(((cj2*x913))+((x907*x914))+((x907*x915))+(((-1.0)*sj2*x912))+(((-1.0)*cj2*x917)));\nevalcond[5]=(((sj2*x913))+((cj2*x912))+(((-1.0)*sj2*x917))+(((-1.0)*x914*x916))+x909+(((-1.0)*x915*x916)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x918=(px*sj3);\nIkReal x919=(cj1*cj2);\nIkReal x920=((0.9)*sj1);\nIkReal x921=(cj3*sj1);\nIkReal x922=(py*sj3);\nCheckValue<IkReal> x923=IKPowWithIntegerCheck(IKsign(((((2.0)*pp))+(((-2.0)*(pz*pz))))),-1);\nif(!x923.valid){\ncontinue;\n}\nCheckValue<IkReal> x924 = IKatan2WithCheck(IkReal((((x919*x922))+((py*x921))+((py*x920))+(((-1.0)*sj2*x918)))),(((x918*x919))+((px*x920))+((px*x921))+((sj2*x922))),IKFAST_ATAN2_MAGTHRESH);\nif(!x924.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x923.value)))+(x924.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[6];\nIkReal x925=IKcos(j0);\nIkReal x926=IKsin(j0);\nIkReal x927=(cj1*sj2);\nIkReal x928=((0.9)*sj1);\nIkReal x929=((0.5)*sj3);\nIkReal x930=((0.5)*cj3);\nIkReal x931=(cj1*pz);\nIkReal x932=(pz*sj1);\nIkReal x933=(px*x926);\nIkReal x934=(px*x925);\nIkReal x935=(py*x926);\nIkReal x936=((1.0)*cj1*cj2);\nIkReal x937=((1.0)*py*x925);\nevalcond[0]=(x933+((sj2*x929))+(((-1.0)*x937)));\nevalcond[1]=((-0.45)+((sj1*x934))+((sj1*x935))+x931+(((-1.0)*x930)));\nevalcond[2]=((0.0475)+((x928*x935))+((x928*x934))+(((-1.0)*pp))+(((0.9)*x931)));\nevalcond[3]=(((cj1*cj2*x929))+((sj1*x930))+(((-1.0)*x935))+(((-1.0)*x934))+(((0.45)*sj1)));\nevalcond[4]=((((-1.0)*cj2*x937))+((x927*x935))+((x927*x934))+((cj2*x933))+(((-1.0)*sj2*x932)));\nevalcond[5]=((((-1.0)*x935*x936))+(((-1.0)*sj2*x937))+(((-1.0)*x934*x936))+((cj2*x932))+((sj2*x933))+x929);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x938=((2.0)*sj1);\nIkReal x939=((2.0)*cj1*pz);\nIkReal x940=(sj1*sj2*sj3);\nCheckValue<IkReal> x941 = IKatan2WithCheck(IkReal(((((-1.0)*px*x940))+(((0.9)*py))+(((-1.0)*py*x939))+((cj3*py)))),((((-1.0)*px*x939))+(((0.9)*px))+((cj3*px))+((py*x940))),IKFAST_ATAN2_MAGTHRESH);\nif(!x941.valid){\ncontinue;\n}\nCheckValue<IkReal> x942=IKPowWithIntegerCheck(IKsign((((pp*x938))+(((-1.0)*x938*(pz*pz))))),-1);\nif(!x942.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x941.value)+(((1.5707963267949)*(x942.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[6];\nIkReal x943=IKcos(j0);\nIkReal x944=IKsin(j0);\nIkReal x945=(cj1*sj2);\nIkReal x946=((0.9)*sj1);\nIkReal x947=((0.5)*sj3);\nIkReal x948=((0.5)*cj3);\nIkReal x949=(cj1*pz);\nIkReal x950=(pz*sj1);\nIkReal x951=(px*x944);\nIkReal x952=(px*x943);\nIkReal x953=(py*x944);\nIkReal x954=((1.0)*cj1*cj2);\nIkReal x955=((1.0)*py*x943);\nevalcond[0]=(((sj2*x947))+(((-1.0)*x955))+x951);\nevalcond[1]=((-0.45)+(((-1.0)*x948))+((sj1*x952))+((sj1*x953))+x949);\nevalcond[2]=((0.0475)+(((-1.0)*pp))+((x946*x953))+((x946*x952))+(((0.9)*x949)));\nevalcond[3]=(((sj1*x948))+((cj1*cj2*x947))+(((-1.0)*x952))+(((-1.0)*x953))+(((0.45)*sj1)));\nevalcond[4]=((((-1.0)*cj2*x955))+((cj2*x951))+(((-1.0)*sj2*x950))+((x945*x952))+((x945*x953)));\nevalcond[5]=(((cj2*x950))+(((-1.0)*x953*x954))+(((-1.0)*sj2*x955))+((sj2*x951))+(((-1.0)*x952*x954))+x947);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x958 = IKatan2WithCheck(IkReal(((-1.0)*py)),px,IKFAST_ATAN2_MAGTHRESH);\nif(!x958.valid){\ncontinue;\n}\nIkReal x956=((1.0)*(x958.value));\nif((((px*px)+(py*py))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x959=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);\nif(!x959.valid){\ncontinue;\n}\nif( (((0.5)*sj2*sj3*(x959.value))) < -1-IKFAST_SINCOS_THRESH || (((0.5)*sj2*sj3*(x959.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x957=IKasin(((0.5)*sj2*sj3*(x959.value)));\nj0array[0]=((((-1.0)*x957))+(((-1.0)*x956)));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x956))+x957);\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n\n{\nIkReal j1eval[3];\nIkReal x960=(cj0*px);\nIkReal x961=((2.0)*pz);\nIkReal x962=(py*sj0);\nIkReal x963=(cj2*sj3);\nIkReal x964=((1.11111111111111)*cj3);\nj1eval[0]=(((x962*x964))+(((1.11111111111111)*pz*x963))+((x960*x964))+x962+x960);\nj1eval[1]=IKsign((((pz*x963))+(((0.9)*x962))+(((0.9)*x960))+((cj3*x962))+((cj3*x960))));\nj1eval[2]=((IKabs(((0.405)+(((-1.0)*pz*x961))+(((0.9)*cj3))+(((0.5)*(cj3*cj3))))))+(IKabs(((((0.5)*cj3*x963))+((x961*x962))+(((0.45)*x963))+((x960*x961))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[3];\nIkReal x965=(cj0*px);\nIkReal x966=(cj2*sj3);\nIkReal x967=((10.0)*pp);\nIkReal x968=(py*sj0);\nIkReal x969=((1.11111111111111)*cj3);\nIkReal x970=((9.0)*cj3);\nIkReal x971=((18.0)*pz);\nj1eval[0]=((((1.11111111111111)*pz*x966))+((x965*x969))+((x968*x969))+x965+x968);\nj1eval[1]=IKsign(((((8.1)*x968))+(((8.1)*x965))+(((9.0)*pz*x966))+((x968*x970))+((x965*x970))));\nj1eval[2]=((IKabs(((((-0.475)*x966))+((x968*x971))+((x965*x971))+((x966*x967)))))+(IKabs(((-0.4275)+(((-1.0)*pz*x971))+(((9.0)*pp))+((cj3*x967))+(((-0.475)*cj3))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[3];\nIkReal x972=cj2*cj2;\nIkReal x973=cj3*cj3;\nIkReal x974=((2.0)*cj3);\nIkReal x975=(py*sj0);\nIkReal x976=(cj0*px);\nIkReal x977=((2.0)*cj2*sj3);\nIkReal x978=(x972*x973);\nj1eval[0]=((1.0)+(((2.22222222222222)*cj3))+(((-1.23456790123457)*x978))+(((1.23456790123457)*x973))+(((1.23456790123457)*x972)));\nj1eval[1]=((IKabs(((((-1.0)*pz*x977))+(((1.8)*x975))+(((1.8)*x976))+((x974*x975))+((x974*x976)))))+(IKabs(((((1.8)*pz))+((x975*x977))+((x976*x977))+((pz*x974))))));\nj1eval[2]=IKsign(((0.81)+(((-1.0)*x978))+(((1.8)*cj3))+x973+x972));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x979=cj2*cj2;\nIkReal x980=cj3*cj3;\nIkReal x981=(cj2*sj3);\nIkReal x982=((2.0)*pz);\nIkReal x983=(py*sj0);\nIkReal x984=((2.0)*cj0*px);\nCheckValue<IkReal> x985 = IKatan2WithCheck(IkReal(((((2.0)*cj3*x983))+(((1.8)*cj0*px))+(((1.8)*x983))+((cj3*x984))+(((-1.0)*x981*x982)))),(((x981*x984))+(((1.8)*pz))+(((2.0)*x981*x983))+((cj3*x982))),IKFAST_ATAN2_MAGTHRESH);\nif(!x985.valid){\ncontinue;\n}\nCheckValue<IkReal> x986=IKPowWithIntegerCheck(IKsign(((0.81)+(((-1.0)*x979*x980))+(((1.8)*cj3))+x980+x979)),-1);\nif(!x986.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x985.value)+(((1.5707963267949)*(x986.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x987=IKcos(j1);\nIkReal x988=IKsin(j1);\nIkReal x989=(px*sj2);\nIkReal x990=((0.5)*sj3);\nIkReal x991=((0.5)*cj3);\nIkReal x992=(py*sj0);\nIkReal x993=((1.0)*cj2);\nIkReal x994=(cj0*py);\nIkReal x995=((1.0)*sj2);\nIkReal x996=(cj0*px);\nIkReal x997=(pz*x987);\nIkReal x998=(cj0*x987);\nIkReal x999=(cj2*x988);\nIkReal x1000=((0.9)*x988);\nevalcond[0]=(((x990*x999))+pz+(((-1.0)*x987*x991))+(((-0.45)*x987)));\nevalcond[1]=((-0.45)+((x988*x992))+((x988*x996))+(((-1.0)*x991))+x997);\nevalcond[2]=((0.0475)+((x1000*x996))+((x1000*x992))+(((0.9)*x997))+(((-1.0)*pp)));\nevalcond[3]=((((-1.0)*x992))+(((-1.0)*x996))+((cj2*x987*x990))+((x988*x991))+(((0.45)*x988)));\nevalcond[4]=(((x989*x998))+(((-1.0)*pz*x988*x995))+(((-1.0)*x993*x994))+((sj2*x987*x992))+((cj2*px*sj0)));\nevalcond[5]=((((-1.0)*x994*x995))+(((-1.0)*x987*x992*x993))+((pz*x999))+((sj0*x989))+(((-1.0)*x987*x993*x996))+x990);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x1001=(cj2*sj3);\nIkReal x1002=(py*sj0);\nIkReal x1003=(cj0*px);\nIkReal x1004=((18.0)*pz);\nIkReal x1005=((9.0)*cj3);\nIkReal x1006=((10.0)*pp);\nCheckValue<IkReal> x1007 = IKatan2WithCheck(IkReal(((-0.4275)+((cj3*x1006))+(((-1.0)*pz*x1004))+(((9.0)*pp))+(((-0.475)*cj3)))),((((-0.475)*x1001))+((x1002*x1004))+((x1001*x1006))+((x1003*x1004))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1007.valid){\ncontinue;\n}\nCheckValue<IkReal> x1008=IKPowWithIntegerCheck(IKsign(((((9.0)*pz*x1001))+(((8.1)*x1003))+(((8.1)*x1002))+((x1002*x1005))+((x1003*x1005)))),-1);\nif(!x1008.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x1007.value)+(((1.5707963267949)*(x1008.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x1009=IKcos(j1);\nIkReal x1010=IKsin(j1);\nIkReal x1011=(px*sj2);\nIkReal x1012=((0.5)*sj3);\nIkReal x1013=((0.5)*cj3);\nIkReal x1014=(py*sj0);\nIkReal x1015=((1.0)*cj2);\nIkReal x1016=(cj0*py);\nIkReal x1017=((1.0)*sj2);\nIkReal x1018=(cj0*px);\nIkReal x1019=(pz*x1009);\nIkReal x1020=(cj0*x1009);\nIkReal x1021=(cj2*x1010);\nIkReal x1022=((0.9)*x1010);\nevalcond[0]=((((-1.0)*x1009*x1013))+(((-0.45)*x1009))+pz+((x1012*x1021)));\nevalcond[1]=((-0.45)+x1019+(((-1.0)*x1013))+((x1010*x1014))+((x1010*x1018)));\nevalcond[2]=((0.0475)+(((0.9)*x1019))+((x1014*x1022))+(((-1.0)*pp))+((x1018*x1022)));\nevalcond[3]=((((0.45)*x1010))+((x1010*x1013))+((cj2*x1009*x1012))+(((-1.0)*x1014))+(((-1.0)*x1018)));\nevalcond[4]=(((x1011*x1020))+((sj2*x1009*x1014))+(((-1.0)*x1015*x1016))+(((-1.0)*pz*x1010*x1017))+((cj2*px*sj0)));\nevalcond[5]=(x1012+((sj0*x1011))+(((-1.0)*x1009*x1015*x1018))+(((-1.0)*x1016*x1017))+(((-1.0)*x1009*x1014*x1015))+((pz*x1021)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x1023=((2.0)*pz);\nIkReal x1024=(py*sj0);\nIkReal x1025=(cj0*px);\nIkReal x1026=(cj2*sj3);\nCheckValue<IkReal> x1027=IKPowWithIntegerCheck(IKsign(((((0.9)*x1024))+(((0.9)*x1025))+((cj3*x1025))+((cj3*x1024))+((pz*x1026)))),-1);\nif(!x1027.valid){\ncontinue;\n}\nCheckValue<IkReal> x1028 = IKatan2WithCheck(IkReal(((0.405)+(((-1.0)*pz*x1023))+(((0.9)*cj3))+(((0.5)*(cj3*cj3))))),((((0.5)*cj3*x1026))+((x1023*x1025))+((x1023*x1024))+(((0.45)*x1026))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1028.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1027.value)))+(x1028.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x1029=IKcos(j1);\nIkReal x1030=IKsin(j1);\nIkReal x1031=(px*sj2);\nIkReal x1032=((0.5)*sj3);\nIkReal x1033=((0.5)*cj3);\nIkReal x1034=(py*sj0);\nIkReal x1035=((1.0)*cj2);\nIkReal x1036=(cj0*py);\nIkReal x1037=((1.0)*sj2);\nIkReal x1038=(cj0*px);\nIkReal x1039=(pz*x1029);\nIkReal x1040=(cj0*x1029);\nIkReal x1041=(cj2*x1030);\nIkReal x1042=((0.9)*x1030);\nevalcond[0]=((((-0.45)*x1029))+(((-1.0)*x1029*x1033))+pz+((x1032*x1041)));\nevalcond[1]=((-0.45)+((x1030*x1038))+((x1030*x1034))+(((-1.0)*x1033))+x1039);\nevalcond[2]=((0.0475)+((x1038*x1042))+((x1034*x1042))+(((0.9)*x1039))+(((-1.0)*pp)));\nevalcond[3]=(((x1030*x1033))+(((-1.0)*x1034))+(((-1.0)*x1038))+((cj2*x1029*x1032))+(((0.45)*x1030)));\nevalcond[4]=((((-1.0)*x1035*x1036))+((x1031*x1040))+((sj2*x1029*x1034))+(((-1.0)*pz*x1030*x1037))+((cj2*px*sj0)));\nevalcond[5]=(x1032+(((-1.0)*x1029*x1034*x1035))+(((-1.0)*x1036*x1037))+((sj0*x1031))+((pz*x1041))+(((-1.0)*x1029*x1035*x1038)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\nreturn solutions.GetNumSolutions()>0;\n}\ninline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {\nfor(int rotationiter = 0; rotationiter < 1; ++rotationiter) {\nIkReal x136=((1.0)*cj3);\nIkReal x137=(sj0*sj2);\nIkReal x138=(cj2*sj1);\nIkReal x139=((1.0)*sj3);\nIkReal x140=(cj1*cj2);\nIkReal x141=(sj1*sj2);\nIkReal x142=(cj0*sj2);\nIkReal x143=((1.0)*cj1);\nIkReal x144=((((-1.0)*sj1*x139))+((cj3*x140)));\nIkReal x145=((((-1.0)*x137*x143))+((cj0*cj2)));\nIkReal x146=(((sj3*x140))+((cj3*sj1)));\nIkReal x147=((((-1.0)*x138*x139))+((cj1*cj3)));\nIkReal x148=(cj0*x144);\nIkReal x149=((((-1.0)*x136*x138))+(((-1.0)*cj1*x139)));\nIkReal x150=((((-1.0)*x142*x143))+(((-1.0)*cj2*sj0)));\nIkReal x151=(((sj0*x144))+((cj3*x142)));\nIkReal x152=(((cj0*x146))+(((-1.0)*x137*x139)));\nIkReal x153=(((sj0*x146))+((sj3*x142)));\nIkReal x154=(x148+(((-1.0)*cj3*x137)));\nnew_r00=(((r20*x149))+((r10*x151))+((r00*((x148+(((-1.0)*x136*x137)))))));\nnew_r01=(((r01*x154))+((r21*x149))+((r11*x151)));\nnew_r02=(((r02*x154))+((r22*x149))+((r12*x151)));\nnew_r10=(((r20*x141))+((r00*x150))+((r10*x145)));\nnew_r11=(((r01*x150))+((r21*x141))+((r11*x145)));\nnew_r12=(((r02*x150))+((r22*x141))+((r12*x145)));\nnew_r20=(((r20*x147))+((r00*x152))+((r10*x153)));\nnew_r21=(((r01*x152))+((r21*x147))+((r11*x153)));\nnew_r22=(((r02*x152))+((r22*x147))+((r12*x153)));\n{\nIkReal j5array[2], cj5array[2], sj5array[2];\nbool j5valid[2]={false};\n_nj5 = 2;\ncj5array[0]=new_r22;\nif( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j5valid[0] = j5valid[1] = true;\n    j5array[0] = IKacos(cj5array[0]);\n    sj5array[0] = IKsin(j5array[0]);\n    cj5array[1] = cj5array[0];\n    j5array[1] = -j5array[0];\n    sj5array[1] = -sj5array[0];\n}\nelse if( isnan(cj5array[0]) )\n{\n    // probably any value will work\n    j5valid[0] = true;\n    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;\n}\nfor(int ij5 = 0; ij5 < 2; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 2; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n\n{\nIkReal j4eval[2];\nIkReal x155=((1.0)*cj3);\nIkReal x156=(sj0*sj2);\nIkReal x157=(cj2*sj1);\nIkReal x158=((1.0)*sj3);\nIkReal x159=(cj1*cj2);\nIkReal x160=(sj1*sj2);\nIkReal x161=(cj0*sj2);\nIkReal x162=((1.0)*cj1);\nIkReal x163=x144;\nIkReal x164=x145;\nIkReal x165=x146;\nIkReal x166=x147;\nIkReal x167=(cj0*x163);\nIkReal x168=x149;\nIkReal x169=x150;\nIkReal x170=(((sj0*x163))+((cj3*x161)));\nIkReal x171=(((cj0*x165))+(((-1.0)*x156*x158)));\nIkReal x172=(((sj3*x161))+((sj0*x165)));\nIkReal x173=(x167+(((-1.0)*cj3*x156)));\nnew_r00=(((r00*((x167+(((-1.0)*x155*x156))))))+((r20*x168))+((r10*x170)));\nnew_r01=(((r01*x173))+((r21*x168))+((r11*x170)));\nnew_r02=(((r22*x168))+((r12*x170))+((r02*x173)));\nnew_r10=(((r00*x169))+((r20*x160))+((r10*x164)));\nnew_r11=(((r01*x169))+((r21*x160))+((r11*x164)));\nnew_r12=(((r22*x160))+((r12*x164))+((r02*x169)));\nnew_r20=(((r00*x171))+((r20*x166))+((r10*x172)));\nnew_r21=(((r01*x171))+((r21*x166))+((r11*x172)));\nnew_r22=(((r22*x166))+((r12*x172))+((r02*x171)));\nj4eval[0]=sj5;\nj4eval[1]=IKsign(sj5);\nif( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j4eval[1];\nIkReal x174=((1.0)*cj3);\nIkReal x175=(sj0*sj2);\nIkReal x176=(cj2*sj1);\nIkReal x177=((1.0)*sj3);\nIkReal x178=(cj1*cj2);\nIkReal x179=(sj1*sj2);\nIkReal x180=(cj0*sj2);\nIkReal x181=((1.0)*cj1);\nIkReal x182=x144;\nIkReal x183=x145;\nIkReal x184=x146;\nIkReal x185=x147;\nIkReal x186=(cj0*x182);\nIkReal x187=x149;\nIkReal x188=x150;\nIkReal x189=(((sj0*x182))+((cj3*x180)));\nIkReal x190=((((-1.0)*x175*x177))+((cj0*x184)));\nIkReal x191=(((sj3*x180))+((sj0*x184)));\nIkReal x192=(x186+(((-1.0)*cj3*x175)));\nnew_r00=(((r20*x187))+((r00*(((((-1.0)*x174*x175))+x186))))+((r10*x189)));\nnew_r01=(((r01*x192))+((r21*x187))+((r11*x189)));\nnew_r02=(((r12*x189))+((r02*x192))+((r22*x187)));\nnew_r10=(((r00*x188))+((r20*x179))+((r10*x183)));\nnew_r11=(((r01*x188))+((r21*x179))+((r11*x183)));\nnew_r12=(((r22*x179))+((r12*x183))+((r02*x188)));\nnew_r20=(((r00*x190))+((r20*x185))+((r10*x191)));\nnew_r21=(((r01*x190))+((r21*x185))+((r11*x191)));\nnew_r22=(((r12*x191))+((r02*x190))+((r22*x185)));\nj4eval[0]=sj5;\nif( IKabs(j4eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j4array[2], cj4array[2], sj4array[2];\nbool j4valid[2]={false};\n_nj4 = 2;\nCheckValue<IkReal> x194 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x194.valid){\ncontinue;\n}\nIkReal x193=x194.value;\nj4array[0]=((-1.0)*x193);\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nj4array[1]=((3.14159265358979)+(((-1.0)*x193)));\nsj4array[1]=IKsin(j4array[1]);\ncj4array[1]=IKcos(j4array[1]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nif( j4array[1] > IKPI )\n{\n    j4array[1]-=IK2PI;\n}\nelse if( j4array[1] < -IKPI )\n{    j4array[1]+=IK2PI;\n}\nj4valid[1] = true;\nfor(int ij4 = 0; ij4 < 2; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 2; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[1];\nevalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x195=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj4*x195))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x195)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x195))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x195))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((((-1.0)*cj4*x195))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x195))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x196=IKsin(j6);\nIkReal x197=IKcos(j6);\nIkReal x198=((1.0)*sj4);\nIkReal x199=((1.0)*x197);\nIkReal x200=(sj4*x196);\nIkReal x201=(sj4*x197);\nIkReal x202=(cj4*x196);\nIkReal x203=(cj4*x199);\nevalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x196);\nevalcond[1]=(x202+x201+new_r01);\nevalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x199)));\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*x196))+(((-1.0)*new_r00*x198)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x199))+(((-1.0)*new_r01*x198)));\nevalcond[5]=((((-1.0)*x203))+x200+new_r00);\nevalcond[6]=((((-1.0)*x203))+x200+new_r11);\nevalcond[7]=((((-1.0)*x197*x198))+new_r10+(((-1.0)*x202)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j4array[2], cj4array[2], sj4array[2];\nbool j4valid[2]={false};\n_nj4 = 2;\nCheckValue<IkReal> x205 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x205.valid){\ncontinue;\n}\nIkReal x204=x205.value;\nj4array[0]=((-1.0)*x204);\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nj4array[1]=((3.14159265358979)+(((-1.0)*x204)));\nsj4array[1]=IKsin(j4array[1]);\ncj4array[1]=IKcos(j4array[1]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nif( j4array[1] > IKPI )\n{\n    j4array[1]-=IK2PI;\n}\nelse if( j4array[1] < -IKPI )\n{    j4array[1]+=IK2PI;\n}\nj4valid[1] = true;\nfor(int ij4 = 0; ij4 < 2; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 2; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[1];\nevalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x206=((1.0)*new_r00);\nif( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x206)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x206)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x206))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x206))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x206))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x206))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x207=IKcos(j6);\nIkReal x208=IKsin(j6);\nIkReal x209=((1.0)*sj4);\nIkReal x210=((1.0)*x208);\nIkReal x211=(sj4*x207);\nIkReal x212=((1.0)*x207);\nIkReal x213=(cj4*x210);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x207);\nevalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x210)));\nevalcond[2]=(((cj4*x207))+((sj4*x208))+new_r00);\nevalcond[3]=((((-1.0)*new_r00*x209))+((cj4*new_r10))+(((-1.0)*x210)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x212))+(((-1.0)*new_r01*x209)));\nevalcond[5]=(x211+new_r01+(((-1.0)*x213)));\nevalcond[6]=(x211+new_r10+(((-1.0)*x213)));\nevalcond[7]=((((-1.0)*x208*x209))+(((-1.0)*cj4*x212))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j4, j6]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j4array[1], cj4array[1], sj4array[1];\nbool j4valid[1]={false};\n_nj4 = 1;\nCheckValue<IkReal> x215=IKPowWithIntegerCheck(sj5,-1);\nif(!x215.valid){\ncontinue;\n}\nIkReal x214=x215.value;\nCheckValue<IkReal> x216=IKPowWithIntegerCheck(new_r12,-1);\nif(!x216.valid){\ncontinue;\n}\nif( IKabs((x214*(x216.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x214)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x214*(x216.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))))+IKsqr((new_r02*x214))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj4array[0]=IKatan2((x214*(x216.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))), (new_r02*x214));\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nfor(int ij4 = 0; ij4 < 1; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 1; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[8];\nIkReal x217=IKcos(j4);\nIkReal x218=IKsin(j4);\nIkReal x219=((1.0)*sj5);\nIkReal x220=((1.0)*cj5);\nIkReal x221=(new_r12*x218);\nIkReal x222=(new_r02*x217);\nevalcond[0]=((((-1.0)*x217*x219))+new_r02);\nevalcond[1]=((((-1.0)*x218*x219))+new_r12);\nevalcond[2]=((((-1.0)*new_r02*x218))+((new_r12*x217)));\nevalcond[3]=(x221+x222+(((-1.0)*x219)));\nevalcond[4]=((((-1.0)*new_r22*x219))+((cj5*x221))+((cj5*x222)));\nevalcond[5]=((((-1.0)*new_r00*x217*x219))+(((-1.0)*new_r20*x220))+(((-1.0)*new_r10*x218*x219)));\nevalcond[6]=((((-1.0)*new_r11*x218*x219))+(((-1.0)*new_r21*x220))+(((-1.0)*new_r01*x217*x219)));\nevalcond[7]=((1.0)+(((-1.0)*x219*x221))+(((-1.0)*x219*x222))+(((-1.0)*new_r22*x220)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6eval[2];\nIkReal x223=((1.0)*cj3);\nIkReal x224=(sj0*sj2);\nIkReal x225=(cj2*sj1);\nIkReal x226=((1.0)*sj3);\nIkReal x227=(cj1*cj2);\nIkReal x228=(sj1*sj2);\nIkReal x229=(cj0*sj2);\nIkReal x230=((1.0)*cj1);\nIkReal x231=x144;\nIkReal x232=x145;\nIkReal x233=x146;\nIkReal x234=x147;\nIkReal x235=(cj0*x231);\nIkReal x236=x149;\nIkReal x237=x150;\nIkReal x238=(((cj3*x229))+((sj0*x231)));\nIkReal x239=((((-1.0)*x224*x226))+((cj0*x233)));\nIkReal x240=(((sj0*x233))+((sj3*x229)));\nIkReal x241=(x235+(((-1.0)*cj3*x224)));\nnew_r00=(((r10*x238))+((r20*x236))+((r00*((x235+(((-1.0)*x223*x224)))))));\nnew_r01=(((r11*x238))+((r01*x241))+((r21*x236)));\nnew_r02=(((r02*x241))+((r12*x238))+((r22*x236)));\nnew_r10=(((r20*x228))+((r10*x232))+((r00*x237)));\nnew_r11=(((r11*x232))+((r01*x237))+((r21*x228)));\nnew_r12=(((r02*x237))+((r22*x228))+((r12*x232)));\nnew_r20=(((r00*x239))+((r20*x234))+((r10*x240)));\nnew_r21=(((r01*x239))+((r11*x240))+((r21*x234)));\nnew_r22=(((r02*x239))+((r12*x240))+((r22*x234)));\nj6eval[0]=sj5;\nj6eval[1]=IKsign(sj5);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[2];\nIkReal x242=((1.0)*cj3);\nIkReal x243=(sj0*sj2);\nIkReal x244=(cj2*sj1);\nIkReal x245=((1.0)*sj3);\nIkReal x246=(cj1*cj2);\nIkReal x247=(sj1*sj2);\nIkReal x248=(cj0*sj2);\nIkReal x249=((1.0)*cj1);\nIkReal x250=x144;\nIkReal x251=x145;\nIkReal x252=x146;\nIkReal x253=x147;\nIkReal x254=(cj0*x250);\nIkReal x255=x149;\nIkReal x256=x150;\nIkReal x257=(((sj0*x250))+((cj3*x248)));\nIkReal x258=((((-1.0)*x243*x245))+((cj0*x252)));\nIkReal x259=(((sj3*x248))+((sj0*x252)));\nIkReal x260=(x254+(((-1.0)*cj3*x243)));\nnew_r00=(((r20*x255))+((r10*x257))+((r00*(((((-1.0)*x242*x243))+x254)))));\nnew_r01=(((r21*x255))+((r11*x257))+((r01*x260)));\nnew_r02=(((r02*x260))+((r12*x257))+((r22*x255)));\nnew_r10=(((r00*x256))+((r10*x251))+((r20*x247)));\nnew_r11=(((r11*x251))+((r01*x256))+((r21*x247)));\nnew_r12=(((r22*x247))+((r12*x251))+((r02*x256)));\nnew_r20=(((r20*x253))+((r00*x258))+((r10*x259)));\nnew_r21=(((r21*x253))+((r11*x259))+((r01*x258)));\nnew_r22=(((r12*x259))+((r22*x253))+((r02*x258)));\nj6eval[0]=sj4;\nj6eval[1]=sj5;\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[3];\nIkReal x261=((1.0)*cj3);\nIkReal x262=(sj0*sj2);\nIkReal x263=(cj2*sj1);\nIkReal x264=((1.0)*sj3);\nIkReal x265=(cj1*cj2);\nIkReal x266=(sj1*sj2);\nIkReal x267=(cj0*sj2);\nIkReal x268=((1.0)*cj1);\nIkReal x269=x144;\nIkReal x270=x145;\nIkReal x271=x146;\nIkReal x272=x147;\nIkReal x273=(cj0*x269);\nIkReal x274=x149;\nIkReal x275=x150;\nIkReal x276=(((cj3*x267))+((sj0*x269)));\nIkReal x277=((((-1.0)*x262*x264))+((cj0*x271)));\nIkReal x278=(((sj3*x267))+((sj0*x271)));\nIkReal x279=((((-1.0)*cj3*x262))+x273);\nnew_r00=(((r00*((x273+(((-1.0)*x261*x262))))))+((r10*x276))+((r20*x274)));\nnew_r01=(((r21*x274))+((r01*x279))+((r11*x276)));\nnew_r02=(((r02*x279))+((r22*x274))+((r12*x276)));\nnew_r10=(((r00*x275))+((r10*x270))+((r20*x266)));\nnew_r11=(((r21*x266))+((r01*x275))+((r11*x270)));\nnew_r12=(((r02*x275))+((r22*x266))+((r12*x270)));\nnew_r20=(((r00*x277))+((r10*x278))+((r20*x272)));\nnew_r21=(((r21*x272))+((r01*x277))+((r11*x278)));\nnew_r22=(((r02*x277))+((r22*x272))+((r12*x278)));\nj6eval[0]=cj4;\nj6eval[1]=cj5;\nj6eval[2]=sj5;\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x280=(new_r22+(((-1.0)*cj5)));\nIkReal x281=((((-1.0)*sj5))+new_r12);\nIkReal x282=((1.0)*cj5);\nIkReal x283=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));\nevalcond[1]=x280;\nevalcond[2]=x280;\nevalcond[3]=new_r02;\nevalcond[4]=x281;\nevalcond[5]=x281;\nevalcond[6]=(((cj5*new_r12))+(((-1.0)*new_r22*x283)));\nevalcond[7]=((((-1.0)*new_r10*x283))+(((-1.0)*new_r20*x282)));\nevalcond[8]=((((-1.0)*new_r11*x283))+(((-1.0)*new_r21*x282)));\nevalcond[9]=((1.0)+(((-1.0)*new_r22*x282))+(((-1.0)*new_r12*x283)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x284 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x284.valid){\ncontinue;\n}\nCheckValue<IkReal> x285=IKPowWithIntegerCheck(IKsign(new_r12),-1);\nif(!x285.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x284.value)+(((1.5707963267949)*(x285.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x286=IKsin(j6);\nIkReal x287=IKcos(j6);\nIkReal x288=((1.0)*new_r12);\nIkReal x289=((1.0)*x287);\nevalcond[0]=(((new_r12*x287))+new_r20);\nevalcond[1]=(new_r11+((new_r22*x286)));\nevalcond[2]=(new_r21+(((-1.0)*x286*x288)));\nevalcond[3]=((((-1.0)*new_r22*x289))+new_r10);\nevalcond[4]=((((-1.0)*x286))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*x289))+(((-1.0)*new_r01)));\nevalcond[6]=(x286+((new_r11*new_r22))+(((-1.0)*new_r21*x288)));\nevalcond[7]=(((new_r10*new_r22))+(((-1.0)*x289))+(((-1.0)*new_r20*x288)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x290=(new_r22+(((-1.0)*cj5)));\nIkReal x291=((1.0)*cj5);\nIkReal x292=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));\nevalcond[1]=x290;\nevalcond[2]=x290;\nevalcond[3]=new_r02;\nevalcond[4]=(sj5+new_r12);\nevalcond[5]=((((-1.0)*x292))+(((-1.0)*new_r12)));\nevalcond[6]=((((-1.0)*new_r12*x291))+(((-1.0)*new_r22*x292)));\nevalcond[7]=((((-1.0)*new_r20*x291))+((new_r10*sj5)));\nevalcond[8]=((((-1.0)*new_r21*x291))+((new_r11*sj5)));\nevalcond[9]=((1.0)+((new_r12*sj5))+(((-1.0)*new_r22*x291)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r00, new_r01);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x293=IKsin(j6);\nIkReal x294=IKcos(j6);\nIkReal x295=((1.0)*new_r22);\nIkReal x296=((1.0)*x294);\nevalcond[0]=(((new_r12*x293))+new_r21);\nevalcond[1]=((((-1.0)*x293))+new_r00);\nevalcond[2]=((((-1.0)*x296))+new_r01);\nevalcond[3]=((((-1.0)*new_r12*x296))+new_r20);\nevalcond[4]=(((new_r22*x293))+(((-1.0)*new_r11)));\nevalcond[5]=((((-1.0)*new_r10))+(((-1.0)*x294*x295)));\nevalcond[6]=((((-1.0)*new_r11*x295))+((new_r12*new_r21))+x293);\nevalcond[7]=((((-1.0)*new_r10*x295))+(((-1.0)*x296))+((new_r12*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x297=((1.0)*cj4);\nIkReal x298=((1.0)*sj4);\nIkReal x299=(((cj4*new_r12))+(((-1.0)*new_r02*x298)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*x297))+new_r02);\nevalcond[3]=((((-1.0)*x298))+new_r12);\nevalcond[4]=x299;\nevalcond[5]=x299;\nevalcond[6]=((-1.0)+((new_r12*sj4))+((cj4*new_r02)));\nevalcond[7]=(((cj4*new_r01))+((new_r11*sj4)));\nevalcond[8]=(((cj4*new_r00))+((new_r10*sj4)));\nevalcond[9]=((((-1.0)*new_r10*x298))+(((-1.0)*new_r00*x297)));\nevalcond[10]=((((-1.0)*new_r01*x297))+(((-1.0)*new_r11*x298)));\nevalcond[11]=((1.0)+(((-1.0)*new_r12*x298))+(((-1.0)*new_r02*x297)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x300=IKcos(j6);\nIkReal x301=IKsin(j6);\nIkReal x302=((1.0)*new_r12);\nIkReal x303=((1.0)*x301);\nIkReal x304=((1.0)*x300);\nevalcond[0]=(x300+new_r20);\nevalcond[1]=(new_r21+(((-1.0)*x303)));\nevalcond[2]=(((new_r12*x300))+new_r01);\nevalcond[3]=(((new_r12*x301))+new_r00);\nevalcond[4]=((((-1.0)*new_r02*x304))+new_r11);\nevalcond[5]=((((-1.0)*new_r02*x303))+new_r10);\nevalcond[6]=(((new_r02*new_r10))+(((-1.0)*new_r00*x302))+(((-1.0)*x303)));\nevalcond[7]=((((-1.0)*new_r01*x302))+((new_r02*new_r11))+(((-1.0)*x304)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x305=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nIkReal x306=(((cj4*new_r00))+((new_r10*sj4)));\nIkReal x307=(((cj4*new_r01))+((new_r11*sj4)));\nIkReal x308=((1.0)+((new_r12*sj4))+((cj4*new_r02)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(cj4+new_r02);\nevalcond[3]=(sj4+new_r12);\nevalcond[4]=x305;\nevalcond[5]=x305;\nevalcond[6]=x308;\nevalcond[7]=x307;\nevalcond[8]=x306;\nevalcond[9]=x306;\nevalcond[10]=x307;\nevalcond[11]=x308;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r21), new_r20);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x309=IKcos(j6);\nIkReal x310=IKsin(j6);\nIkReal x311=((1.0)*new_r02);\nIkReal x312=((1.0)*new_r12);\nIkReal x313=((1.0)*x309);\nevalcond[0]=(x310+new_r21);\nevalcond[1]=((((-1.0)*x313))+new_r20);\nevalcond[2]=(((new_r02*x309))+new_r11);\nevalcond[3]=(((new_r02*x310))+new_r10);\nevalcond[4]=(new_r01+(((-1.0)*x309*x312)));\nevalcond[5]=((((-1.0)*x310*x312))+new_r00);\nevalcond[6]=(((new_r00*new_r12))+(((-1.0)*new_r10*x311))+(((-1.0)*x310)));\nevalcond[7]=(((new_r01*new_r12))+(((-1.0)*new_r11*x311))+(((-1.0)*x313)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x314=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nIkReal x315=(((new_r12*sj4))+((cj4*new_r02)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x314;\nevalcond[7]=x314;\nevalcond[8]=x315;\nevalcond[9]=x315;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x316=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj4*x316))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj4*x316))+((cj4*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x316))+(((-1.0)*new_r00*sj4))))+IKsqr(((((-1.0)*sj4*x316))+((cj4*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((((-1.0)*cj4*x316))+(((-1.0)*new_r00*sj4))), ((((-1.0)*sj4*x316))+((cj4*new_r00))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x317=IKsin(j6);\nIkReal x318=IKcos(j6);\nIkReal x319=((1.0)*sj4);\nIkReal x320=((1.0)*x318);\nIkReal x321=(sj4*x317);\nIkReal x322=(sj4*x318);\nIkReal x323=(cj4*x317);\nIkReal x324=(cj4*x320);\nevalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x317);\nevalcond[1]=(x322+x323+new_r01);\nevalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x320)));\nevalcond[3]=((((-1.0)*new_r00*x319))+((cj4*new_r10))+(((-1.0)*x317)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x320))+(((-1.0)*new_r01*x319)));\nevalcond[5]=((((-1.0)*x324))+x321+new_r00);\nevalcond[6]=((((-1.0)*x324))+x321+new_r11);\nevalcond[7]=((((-1.0)*x318*x319))+(((-1.0)*x323))+new_r10);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x325=(cj4*new_r02);\nIkReal x326=(new_r12*sj4);\nIkReal x327=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x327;\nevalcond[7]=x327;\nevalcond[8]=(x325+x326);\nevalcond[9]=((((-1.0)*x325))+(((-1.0)*x326)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x328=((1.0)*new_r00);\nif( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x328)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x328)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x328))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x328))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x328))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x328))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x329=IKcos(j6);\nIkReal x330=IKsin(j6);\nIkReal x331=((1.0)*sj4);\nIkReal x332=((1.0)*x330);\nIkReal x333=(sj4*x329);\nIkReal x334=((1.0)*x329);\nIkReal x335=(cj4*x332);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x329);\nevalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x332)));\nevalcond[2]=(((cj4*x329))+((sj4*x330))+new_r00);\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x331))+(((-1.0)*x332)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x334))+(((-1.0)*new_r01*x331)));\nevalcond[5]=(x333+(((-1.0)*x335))+new_r01);\nevalcond[6]=(x333+(((-1.0)*x335))+new_r10);\nevalcond[7]=((((-1.0)*cj4*x334))+(((-1.0)*x330*x331))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x336=(new_r22+(((-1.0)*cj5)));\nIkReal x337=((((-1.0)*sj5))+new_r02);\nIkReal x338=((1.0)*cj5);\nIkReal x339=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));\nevalcond[1]=x336;\nevalcond[2]=x336;\nevalcond[3]=x337;\nevalcond[4]=new_r12;\nevalcond[5]=x337;\nevalcond[6]=((((-1.0)*new_r22*x339))+((cj5*new_r02)));\nevalcond[7]=((((-1.0)*new_r20*x338))+(((-1.0)*new_r00*x339)));\nevalcond[8]=((((-1.0)*new_r21*x338))+(((-1.0)*new_r01*x339)));\nevalcond[9]=((1.0)+(((-1.0)*new_r22*x338))+(((-1.0)*new_r02*x339)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r10, new_r11);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x340=IKcos(j6);\nIkReal x341=IKsin(j6);\nIkReal x342=((1.0)*new_r02);\nIkReal x343=((1.0)*x340);\nevalcond[0]=(((new_r02*x340))+new_r20);\nevalcond[1]=(new_r10+(((-1.0)*x341)));\nevalcond[2]=(new_r11+(((-1.0)*x343)));\nevalcond[3]=(((new_r22*x341))+new_r01);\nevalcond[4]=((((-1.0)*x341*x342))+new_r21);\nevalcond[5]=(new_r00+(((-1.0)*new_r22*x343)));\nevalcond[6]=(((new_r01*new_r22))+x341+(((-1.0)*new_r21*x342)));\nevalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x342))+(((-1.0)*x343)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x344=(new_r22+(((-1.0)*cj5)));\nIkReal x345=((1.0)*cj5);\nIkReal x346=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));\nevalcond[1]=x344;\nevalcond[2]=x344;\nevalcond[3]=(sj5+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*new_r02))+(((-1.0)*x346)));\nevalcond[6]=((((-1.0)*new_r02*x345))+(((-1.0)*new_r22*x346)));\nevalcond[7]=(((new_r00*sj5))+(((-1.0)*new_r20*x345)));\nevalcond[8]=(((new_r01*sj5))+(((-1.0)*new_r21*x345)));\nevalcond[9]=((1.0)+((new_r02*sj5))+(((-1.0)*new_r22*x345)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x347 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x347.valid){\ncontinue;\n}\nCheckValue<IkReal> x348=IKPowWithIntegerCheck(IKsign(new_r02),-1);\nif(!x348.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x347.value)+(((1.5707963267949)*(x348.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x349=IKsin(j6);\nIkReal x350=IKcos(j6);\nIkReal x351=((1.0)*new_r01);\nIkReal x352=((1.0)*new_r00);\nIkReal x353=((1.0)*x350);\nevalcond[0]=(((new_r02*x349))+new_r21);\nevalcond[1]=((((-1.0)*new_r02*x353))+new_r20);\nevalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x349)));\nevalcond[3]=((((-1.0)*x353))+(((-1.0)*new_r11)));\nevalcond[4]=(((new_r22*x349))+(((-1.0)*x351)));\nevalcond[5]=((((-1.0)*new_r22*x353))+(((-1.0)*x352)));\nevalcond[6]=((((-1.0)*new_r22*x351))+x349+((new_r02*new_r21)));\nevalcond[7]=((((-1.0)*new_r22*x352))+(((-1.0)*x353))+((new_r02*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j6]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x355=IKPowWithIntegerCheck(sj5,-1);\nif(!x355.valid){\ncontinue;\n}\nIkReal x354=x355.value;\nCheckValue<IkReal> x356=IKPowWithIntegerCheck(cj4,-1);\nif(!x356.valid){\ncontinue;\n}\nCheckValue<IkReal> x357=IKPowWithIntegerCheck(cj5,-1);\nif(!x357.valid){\ncontinue;\n}\nif( IKabs((x354*(x356.value)*(x357.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x354)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x354*(x356.value)*(x357.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x354))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((x354*(x356.value)*(x357.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x354));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x358=IKsin(j6);\nIkReal x359=IKcos(j6);\nIkReal x360=((1.0)*sj5);\nIkReal x361=((1.0)*sj4);\nIkReal x362=(cj5*sj4);\nIkReal x363=(cj4*new_r01);\nIkReal x364=(cj4*new_r00);\nIkReal x365=((1.0)*x359);\nIkReal x366=(cj5*x358);\nIkReal x367=((1.0)*x358);\nevalcond[0]=(((sj5*x359))+new_r20);\nevalcond[1]=((((-1.0)*x358*x360))+new_r21);\nevalcond[2]=(((new_r11*sj4))+x363+x366);\nevalcond[3]=((((-1.0)*new_r00*x361))+(((-1.0)*x367))+((cj4*new_r10)));\nevalcond[4]=((((-1.0)*x365))+((cj4*new_r11))+(((-1.0)*new_r01*x361)));\nevalcond[5]=(((sj4*x359))+((cj4*x366))+new_r01);\nevalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x365))+x364);\nevalcond[7]=(((sj4*x358))+(((-1.0)*cj4*cj5*x365))+new_r00);\nevalcond[8]=(((x358*x362))+(((-1.0)*cj4*x365))+new_r11);\nevalcond[9]=((((-1.0)*cj4*x367))+(((-1.0)*cj5*x359*x361))+new_r10);\nevalcond[10]=(x358+((cj5*x363))+((new_r11*x362))+(((-1.0)*new_r21*x360)));\nevalcond[11]=((((-1.0)*new_r20*x360))+(((-1.0)*x365))+((cj5*x364))+((new_r10*x362)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x369=IKPowWithIntegerCheck(sj5,-1);\nif(!x369.valid){\ncontinue;\n}\nIkReal x368=x369.value;\nCheckValue<IkReal> x370=IKPowWithIntegerCheck(sj4,-1);\nif(!x370.valid){\ncontinue;\n}\nif( IKabs((x368*(x370.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x368)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x368*(x370.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x368))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((x368*(x370.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x368));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x371=IKsin(j6);\nIkReal x372=IKcos(j6);\nIkReal x373=((1.0)*sj5);\nIkReal x374=((1.0)*sj4);\nIkReal x375=(cj5*sj4);\nIkReal x376=(cj4*new_r01);\nIkReal x377=(cj4*new_r00);\nIkReal x378=((1.0)*x372);\nIkReal x379=(cj5*x371);\nIkReal x380=((1.0)*x371);\nevalcond[0]=(((sj5*x372))+new_r20);\nevalcond[1]=((((-1.0)*x371*x373))+new_r21);\nevalcond[2]=(((new_r11*sj4))+x379+x376);\nevalcond[3]=((((-1.0)*new_r00*x374))+((cj4*new_r10))+(((-1.0)*x380)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x378))+(((-1.0)*new_r01*x374)));\nevalcond[5]=(((sj4*x372))+((cj4*x379))+new_r01);\nevalcond[6]=((((-1.0)*cj5*x378))+((new_r10*sj4))+x377);\nevalcond[7]=(((sj4*x371))+(((-1.0)*cj4*cj5*x378))+new_r00);\nevalcond[8]=((((-1.0)*cj4*x378))+new_r11+((x371*x375)));\nevalcond[9]=((((-1.0)*cj4*x380))+new_r10+(((-1.0)*cj5*x372*x374)));\nevalcond[10]=((((-1.0)*new_r21*x373))+((cj5*x376))+x371+((new_r11*x375)));\nevalcond[11]=((((-1.0)*new_r20*x373))+(((-1.0)*x378))+((cj5*x377))+((new_r10*x375)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x381=IKPowWithIntegerCheck(IKsign(sj5),-1);\nif(!x381.valid){\ncontinue;\n}\nCheckValue<IkReal> x382 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x382.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x381.value)))+(x382.value));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x383=IKsin(j6);\nIkReal x384=IKcos(j6);\nIkReal x385=((1.0)*sj5);\nIkReal x386=((1.0)*sj4);\nIkReal x387=(cj5*sj4);\nIkReal x388=(cj4*new_r01);\nIkReal x389=(cj4*new_r00);\nIkReal x390=((1.0)*x384);\nIkReal x391=(cj5*x383);\nIkReal x392=((1.0)*x383);\nevalcond[0]=(((sj5*x384))+new_r20);\nevalcond[1]=(new_r21+(((-1.0)*x383*x385)));\nevalcond[2]=(((new_r11*sj4))+x388+x391);\nevalcond[3]=((((-1.0)*x392))+((cj4*new_r10))+(((-1.0)*new_r00*x386)));\nevalcond[4]=((((-1.0)*x390))+((cj4*new_r11))+(((-1.0)*new_r01*x386)));\nevalcond[5]=(((cj4*x391))+((sj4*x384))+new_r01);\nevalcond[6]=((((-1.0)*cj5*x390))+((new_r10*sj4))+x389);\nevalcond[7]=((((-1.0)*cj4*cj5*x390))+((sj4*x383))+new_r00);\nevalcond[8]=((((-1.0)*cj4*x390))+((x383*x387))+new_r11);\nevalcond[9]=((((-1.0)*cj4*x392))+(((-1.0)*cj5*x384*x386))+new_r10);\nevalcond[10]=(x383+((new_r11*x387))+(((-1.0)*new_r21*x385))+((cj5*x388)));\nevalcond[11]=((((-1.0)*x390))+(((-1.0)*new_r20*x385))+((new_r10*x387))+((cj5*x389)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j4array[1], cj4array[1], sj4array[1];\nbool j4valid[1]={false};\n_nj4 = 1;\nCheckValue<IkReal> x393=IKPowWithIntegerCheck(IKsign(sj5),-1);\nif(!x393.valid){\ncontinue;\n}\nCheckValue<IkReal> x394 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);\nif(!x394.valid){\ncontinue;\n}\nj4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x393.value)))+(x394.value));\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nfor(int ij4 = 0; ij4 < 1; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 1; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[8];\nIkReal x395=IKcos(j4);\nIkReal x396=IKsin(j4);\nIkReal x397=((1.0)*sj5);\nIkReal x398=((1.0)*cj5);\nIkReal x399=(new_r12*x396);\nIkReal x400=(new_r02*x395);\nevalcond[0]=((((-1.0)*x395*x397))+new_r02);\nevalcond[1]=((((-1.0)*x396*x397))+new_r12);\nevalcond[2]=((((-1.0)*new_r02*x396))+((new_r12*x395)));\nevalcond[3]=((((-1.0)*x397))+x399+x400);\nevalcond[4]=((((-1.0)*new_r22*x397))+((cj5*x399))+((cj5*x400)));\nevalcond[5]=((((-1.0)*new_r10*x396*x397))+(((-1.0)*new_r00*x395*x397))+(((-1.0)*new_r20*x398)));\nevalcond[6]=((((-1.0)*new_r21*x398))+(((-1.0)*new_r11*x396*x397))+(((-1.0)*new_r01*x395*x397)));\nevalcond[7]=((1.0)+(((-1.0)*new_r22*x398))+(((-1.0)*x397*x399))+(((-1.0)*x397*x400)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6eval[2];\nIkReal x401=((1.0)*cj3);\nIkReal x402=(sj0*sj2);\nIkReal x403=(cj2*sj1);\nIkReal x404=((1.0)*sj3);\nIkReal x405=(cj1*cj2);\nIkReal x406=(sj1*sj2);\nIkReal x407=(cj0*sj2);\nIkReal x408=((1.0)*cj1);\nIkReal x409=x144;\nIkReal x410=x145;\nIkReal x411=x146;\nIkReal x412=x147;\nIkReal x413=(cj0*x409);\nIkReal x414=x149;\nIkReal x415=x150;\nIkReal x416=(((sj0*x409))+((cj3*x407)));\nIkReal x417=(((cj0*x411))+(((-1.0)*x402*x404)));\nIkReal x418=(((sj0*x411))+((sj3*x407)));\nIkReal x419=((((-1.0)*cj3*x402))+x413);\nnew_r00=(((r00*(((((-1.0)*x401*x402))+x413))))+((r20*x414))+((r10*x416)));\nnew_r01=(((r11*x416))+((r01*x419))+((r21*x414)));\nnew_r02=(((r12*x416))+((r22*x414))+((r02*x419)));\nnew_r10=(((r00*x415))+((r10*x410))+((r20*x406)));\nnew_r11=(((r11*x410))+((r01*x415))+((r21*x406)));\nnew_r12=(((r12*x410))+((r22*x406))+((r02*x415)));\nnew_r20=(((r00*x417))+((r20*x412))+((r10*x418)));\nnew_r21=(((r11*x418))+((r01*x417))+((r21*x412)));\nnew_r22=(((r12*x418))+((r22*x412))+((r02*x417)));\nj6eval[0]=sj5;\nj6eval[1]=IKsign(sj5);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[2];\nIkReal x420=((1.0)*cj3);\nIkReal x421=(sj0*sj2);\nIkReal x422=(cj2*sj1);\nIkReal x423=((1.0)*sj3);\nIkReal x424=(cj1*cj2);\nIkReal x425=(sj1*sj2);\nIkReal x426=(cj0*sj2);\nIkReal x427=((1.0)*cj1);\nIkReal x428=x144;\nIkReal x429=x145;\nIkReal x430=x146;\nIkReal x431=x147;\nIkReal x432=(cj0*x428);\nIkReal x433=x149;\nIkReal x434=x150;\nIkReal x435=(((cj3*x426))+((sj0*x428)));\nIkReal x436=((((-1.0)*x421*x423))+((cj0*x430)));\nIkReal x437=(((sj0*x430))+((sj3*x426)));\nIkReal x438=((((-1.0)*cj3*x421))+x432);\nnew_r00=(((r00*(((((-1.0)*x420*x421))+x432))))+((r10*x435))+((r20*x433)));\nnew_r01=(((r21*x433))+((r01*x438))+((r11*x435)));\nnew_r02=(((r12*x435))+((r02*x438))+((r22*x433)));\nnew_r10=(((r20*x425))+((r00*x434))+((r10*x429)));\nnew_r11=(((r21*x425))+((r01*x434))+((r11*x429)));\nnew_r12=(((r02*x434))+((r22*x425))+((r12*x429)));\nnew_r20=(((r00*x436))+((r10*x437))+((r20*x431)));\nnew_r21=(((r21*x431))+((r01*x436))+((r11*x437)));\nnew_r22=(((r12*x437))+((r02*x436))+((r22*x431)));\nj6eval[0]=sj4;\nj6eval[1]=sj5;\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[3];\nIkReal x439=((1.0)*cj3);\nIkReal x440=(sj0*sj2);\nIkReal x441=(cj2*sj1);\nIkReal x442=((1.0)*sj3);\nIkReal x443=(cj1*cj2);\nIkReal x444=(sj1*sj2);\nIkReal x445=(cj0*sj2);\nIkReal x446=((1.0)*cj1);\nIkReal x447=x144;\nIkReal x448=x145;\nIkReal x449=x146;\nIkReal x450=x147;\nIkReal x451=(cj0*x447);\nIkReal x452=x149;\nIkReal x453=x150;\nIkReal x454=(((sj0*x447))+((cj3*x445)));\nIkReal x455=(((cj0*x449))+(((-1.0)*x440*x442)));\nIkReal x456=(((sj0*x449))+((sj3*x445)));\nIkReal x457=((((-1.0)*cj3*x440))+x451);\nnew_r00=(((r00*(((((-1.0)*x439*x440))+x451))))+((r20*x452))+((r10*x454)));\nnew_r01=(((r11*x454))+((r01*x457))+((r21*x452)));\nnew_r02=(((r12*x454))+((r02*x457))+((r22*x452)));\nnew_r10=(((r00*x453))+((r20*x444))+((r10*x448)));\nnew_r11=(((r21*x444))+((r11*x448))+((r01*x453)));\nnew_r12=(((r22*x444))+((r02*x453))+((r12*x448)));\nnew_r20=(((r20*x450))+((r00*x455))+((r10*x456)));\nnew_r21=(((r11*x456))+((r01*x455))+((r21*x450)));\nnew_r22=(((r12*x456))+((r02*x455))+((r22*x450)));\nj6eval[0]=cj4;\nj6eval[1]=cj5;\nj6eval[2]=sj5;\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x458=(new_r22+(((-1.0)*cj5)));\nIkReal x459=((((-1.0)*sj5))+new_r12);\nIkReal x460=((1.0)*cj5);\nIkReal x461=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));\nevalcond[1]=x458;\nevalcond[2]=x458;\nevalcond[3]=new_r02;\nevalcond[4]=x459;\nevalcond[5]=x459;\nevalcond[6]=(((cj5*new_r12))+(((-1.0)*new_r22*x461)));\nevalcond[7]=((((-1.0)*new_r20*x460))+(((-1.0)*new_r10*x461)));\nevalcond[8]=((((-1.0)*new_r21*x460))+(((-1.0)*new_r11*x461)));\nevalcond[9]=((1.0)+(((-1.0)*new_r12*x461))+(((-1.0)*new_r22*x460)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x462 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x462.valid){\ncontinue;\n}\nCheckValue<IkReal> x463=IKPowWithIntegerCheck(IKsign(new_r12),-1);\nif(!x463.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x462.value)+(((1.5707963267949)*(x463.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x464=IKsin(j6);\nIkReal x465=IKcos(j6);\nIkReal x466=((1.0)*new_r12);\nIkReal x467=((1.0)*x465);\nevalcond[0]=(((new_r12*x465))+new_r20);\nevalcond[1]=(new_r11+((new_r22*x464)));\nevalcond[2]=((((-1.0)*x464*x466))+new_r21);\nevalcond[3]=((((-1.0)*new_r22*x467))+new_r10);\nevalcond[4]=((((-1.0)*x464))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*x467))+(((-1.0)*new_r01)));\nevalcond[6]=((((-1.0)*new_r21*x466))+x464+((new_r11*new_r22)));\nevalcond[7]=((((-1.0)*new_r20*x466))+(((-1.0)*x467))+((new_r10*new_r22)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x468=(new_r22+(((-1.0)*cj5)));\nIkReal x469=((1.0)*cj5);\nIkReal x470=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));\nevalcond[1]=x468;\nevalcond[2]=x468;\nevalcond[3]=new_r02;\nevalcond[4]=(sj5+new_r12);\nevalcond[5]=((((-1.0)*x470))+(((-1.0)*new_r12)));\nevalcond[6]=((((-1.0)*new_r12*x469))+(((-1.0)*new_r22*x470)));\nevalcond[7]=(((new_r10*sj5))+(((-1.0)*new_r20*x469)));\nevalcond[8]=((((-1.0)*new_r21*x469))+((new_r11*sj5)));\nevalcond[9]=((1.0)+((new_r12*sj5))+(((-1.0)*new_r22*x469)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r00, new_r01);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x471=IKsin(j6);\nIkReal x472=IKcos(j6);\nIkReal x473=((1.0)*new_r22);\nIkReal x474=((1.0)*x472);\nevalcond[0]=(((new_r12*x471))+new_r21);\nevalcond[1]=((((-1.0)*x471))+new_r00);\nevalcond[2]=((((-1.0)*x474))+new_r01);\nevalcond[3]=((((-1.0)*new_r12*x474))+new_r20);\nevalcond[4]=(((new_r22*x471))+(((-1.0)*new_r11)));\nevalcond[5]=((((-1.0)*x472*x473))+(((-1.0)*new_r10)));\nevalcond[6]=((((-1.0)*new_r11*x473))+((new_r12*new_r21))+x471);\nevalcond[7]=((((-1.0)*x474))+(((-1.0)*new_r10*x473))+((new_r12*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x475=((1.0)*cj4);\nIkReal x476=((1.0)*sj4);\nIkReal x477=(((cj4*new_r12))+(((-1.0)*new_r02*x476)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*x475))+new_r02);\nevalcond[3]=((((-1.0)*x476))+new_r12);\nevalcond[4]=x477;\nevalcond[5]=x477;\nevalcond[6]=((-1.0)+((new_r12*sj4))+((cj4*new_r02)));\nevalcond[7]=(((cj4*new_r01))+((new_r11*sj4)));\nevalcond[8]=(((cj4*new_r00))+((new_r10*sj4)));\nevalcond[9]=((((-1.0)*new_r00*x475))+(((-1.0)*new_r10*x476)));\nevalcond[10]=((((-1.0)*new_r11*x476))+(((-1.0)*new_r01*x475)));\nevalcond[11]=((1.0)+(((-1.0)*new_r12*x476))+(((-1.0)*new_r02*x475)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r21, ((-1.0)*new_r20));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x478=IKcos(j6);\nIkReal x479=IKsin(j6);\nIkReal x480=((1.0)*new_r12);\nIkReal x481=((1.0)*x479);\nIkReal x482=((1.0)*x478);\nevalcond[0]=(x478+new_r20);\nevalcond[1]=((((-1.0)*x481))+new_r21);\nevalcond[2]=(((new_r12*x478))+new_r01);\nevalcond[3]=(((new_r12*x479))+new_r00);\nevalcond[4]=((((-1.0)*new_r02*x482))+new_r11);\nevalcond[5]=((((-1.0)*new_r02*x481))+new_r10);\nevalcond[6]=((((-1.0)*x481))+(((-1.0)*new_r00*x480))+((new_r02*new_r10)));\nevalcond[7]=((((-1.0)*new_r01*x480))+(((-1.0)*x482))+((new_r02*new_r11)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x483=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nIkReal x484=(((cj4*new_r00))+((new_r10*sj4)));\nIkReal x485=(((cj4*new_r01))+((new_r11*sj4)));\nIkReal x486=((1.0)+((new_r12*sj4))+((cj4*new_r02)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(cj4+new_r02);\nevalcond[3]=(sj4+new_r12);\nevalcond[4]=x483;\nevalcond[5]=x483;\nevalcond[6]=x486;\nevalcond[7]=x485;\nevalcond[8]=x484;\nevalcond[9]=x484;\nevalcond[10]=x485;\nevalcond[11]=x486;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r21), new_r20);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x487=IKcos(j6);\nIkReal x488=IKsin(j6);\nIkReal x489=((1.0)*new_r02);\nIkReal x490=((1.0)*new_r12);\nIkReal x491=((1.0)*x487);\nevalcond[0]=(x488+new_r21);\nevalcond[1]=((((-1.0)*x491))+new_r20);\nevalcond[2]=(((new_r02*x487))+new_r11);\nevalcond[3]=(((new_r02*x488))+new_r10);\nevalcond[4]=((((-1.0)*x487*x490))+new_r01);\nevalcond[5]=((((-1.0)*x488*x490))+new_r00);\nevalcond[6]=((((-1.0)*new_r10*x489))+((new_r00*new_r12))+(((-1.0)*x488)));\nevalcond[7]=((((-1.0)*new_r11*x489))+(((-1.0)*x491))+((new_r01*new_r12)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x492=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nIkReal x493=(((new_r12*sj4))+((cj4*new_r02)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x492;\nevalcond[7]=x492;\nevalcond[8]=x493;\nevalcond[9]=x493;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x494=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj4*x494))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x494)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x494))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x494))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((((-1.0)*cj4*x494))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x494))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x495=IKsin(j6);\nIkReal x496=IKcos(j6);\nIkReal x497=((1.0)*sj4);\nIkReal x498=((1.0)*x496);\nIkReal x499=(sj4*x495);\nIkReal x500=(sj4*x496);\nIkReal x501=(cj4*x495);\nIkReal x502=(cj4*x498);\nevalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x495);\nevalcond[1]=(x500+x501+new_r01);\nevalcond[2]=((((-1.0)*x498))+((cj4*new_r00))+((new_r10*sj4)));\nevalcond[3]=((((-1.0)*new_r00*x497))+((cj4*new_r10))+(((-1.0)*x495)));\nevalcond[4]=((((-1.0)*x498))+(((-1.0)*new_r01*x497))+((cj4*new_r11)));\nevalcond[5]=((((-1.0)*x502))+x499+new_r00);\nevalcond[6]=((((-1.0)*x502))+x499+new_r11);\nevalcond[7]=((((-1.0)*x496*x497))+new_r10+(((-1.0)*x501)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x503=(cj4*new_r02);\nIkReal x504=(new_r12*sj4);\nIkReal x505=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x505;\nevalcond[7]=x505;\nevalcond[8]=(x503+x504);\nevalcond[9]=((((-1.0)*x503))+(((-1.0)*x504)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x506=((1.0)*new_r00);\nif( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x506)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x506)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x506))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x506))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x506))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x506))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x507=IKcos(j6);\nIkReal x508=IKsin(j6);\nIkReal x509=((1.0)*sj4);\nIkReal x510=((1.0)*x508);\nIkReal x511=(sj4*x507);\nIkReal x512=((1.0)*x507);\nIkReal x513=(cj4*x510);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x507);\nevalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x510)));\nevalcond[2]=(((cj4*x507))+((sj4*x508))+new_r00);\nevalcond[3]=((((-1.0)*new_r00*x509))+((cj4*new_r10))+(((-1.0)*x510)));\nevalcond[4]=((((-1.0)*new_r01*x509))+((cj4*new_r11))+(((-1.0)*x512)));\nevalcond[5]=(x511+new_r01+(((-1.0)*x513)));\nevalcond[6]=(x511+new_r10+(((-1.0)*x513)));\nevalcond[7]=((((-1.0)*x508*x509))+(((-1.0)*cj4*x512))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x514=(new_r22+(((-1.0)*cj5)));\nIkReal x515=((((-1.0)*sj5))+new_r02);\nIkReal x516=((1.0)*cj5);\nIkReal x517=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));\nevalcond[1]=x514;\nevalcond[2]=x514;\nevalcond[3]=x515;\nevalcond[4]=new_r12;\nevalcond[5]=x515;\nevalcond[6]=(((cj5*new_r02))+(((-1.0)*new_r22*x517)));\nevalcond[7]=((((-1.0)*new_r20*x516))+(((-1.0)*new_r00*x517)));\nevalcond[8]=((((-1.0)*new_r01*x517))+(((-1.0)*new_r21*x516)));\nevalcond[9]=((1.0)+(((-1.0)*new_r22*x516))+(((-1.0)*new_r02*x517)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r10, new_r11);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x518=IKcos(j6);\nIkReal x519=IKsin(j6);\nIkReal x520=((1.0)*new_r02);\nIkReal x521=((1.0)*x518);\nevalcond[0]=(((new_r02*x518))+new_r20);\nevalcond[1]=((((-1.0)*x519))+new_r10);\nevalcond[2]=((((-1.0)*x521))+new_r11);\nevalcond[3]=(((new_r22*x519))+new_r01);\nevalcond[4]=(new_r21+(((-1.0)*x519*x520)));\nevalcond[5]=((((-1.0)*new_r22*x521))+new_r00);\nevalcond[6]=(((new_r01*new_r22))+(((-1.0)*new_r21*x520))+x519);\nevalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x520))+(((-1.0)*x521)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x522=(new_r22+(((-1.0)*cj5)));\nIkReal x523=((1.0)*cj5);\nIkReal x524=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));\nevalcond[1]=x522;\nevalcond[2]=x522;\nevalcond[3]=(sj5+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x524))+(((-1.0)*new_r02)));\nevalcond[6]=((((-1.0)*new_r22*x524))+(((-1.0)*new_r02*x523)));\nevalcond[7]=(((new_r00*sj5))+(((-1.0)*new_r20*x523)));\nevalcond[8]=(((new_r01*sj5))+(((-1.0)*new_r21*x523)));\nevalcond[9]=((1.0)+((new_r02*sj5))+(((-1.0)*new_r22*x523)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x525 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x525.valid){\ncontinue;\n}\nCheckValue<IkReal> x526=IKPowWithIntegerCheck(IKsign(new_r02),-1);\nif(!x526.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x525.value)+(((1.5707963267949)*(x526.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x527=IKsin(j6);\nIkReal x528=IKcos(j6);\nIkReal x529=((1.0)*new_r01);\nIkReal x530=((1.0)*new_r00);\nIkReal x531=((1.0)*x528);\nevalcond[0]=(((new_r02*x527))+new_r21);\nevalcond[1]=(new_r20+(((-1.0)*new_r02*x531)));\nevalcond[2]=((((-1.0)*x527))+(((-1.0)*new_r10)));\nevalcond[3]=((((-1.0)*x531))+(((-1.0)*new_r11)));\nevalcond[4]=((((-1.0)*x529))+((new_r22*x527)));\nevalcond[5]=((((-1.0)*new_r22*x531))+(((-1.0)*x530)));\nevalcond[6]=((((-1.0)*new_r22*x529))+x527+((new_r02*new_r21)));\nevalcond[7]=((((-1.0)*new_r22*x530))+(((-1.0)*x531))+((new_r02*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j6]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x533=IKPowWithIntegerCheck(sj5,-1);\nif(!x533.valid){\ncontinue;\n}\nIkReal x532=x533.value;\nCheckValue<IkReal> x534=IKPowWithIntegerCheck(cj4,-1);\nif(!x534.valid){\ncontinue;\n}\nCheckValue<IkReal> x535=IKPowWithIntegerCheck(cj5,-1);\nif(!x535.valid){\ncontinue;\n}\nif( IKabs((x532*(x534.value)*(x535.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x532)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x532*(x534.value)*(x535.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))))+IKsqr(((-1.0)*new_r20*x532))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((x532*(x534.value)*(x535.value)*((((new_r20*sj4))+(((-1.0)*new_r01*sj5))))), ((-1.0)*new_r20*x532));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x536=IKsin(j6);\nIkReal x537=IKcos(j6);\nIkReal x538=((1.0)*sj5);\nIkReal x539=((1.0)*sj4);\nIkReal x540=(cj5*sj4);\nIkReal x541=(cj4*new_r01);\nIkReal x542=(cj4*new_r00);\nIkReal x543=((1.0)*x537);\nIkReal x544=(cj5*x536);\nIkReal x545=((1.0)*x536);\nevalcond[0]=(((sj5*x537))+new_r20);\nevalcond[1]=(new_r21+(((-1.0)*x536*x538)));\nevalcond[2]=(((new_r11*sj4))+x544+x541);\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x539))+(((-1.0)*x545)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x543))+(((-1.0)*new_r01*x539)));\nevalcond[5]=(((cj4*x544))+new_r01+((sj4*x537)));\nevalcond[6]=(((new_r10*sj4))+x542+(((-1.0)*cj5*x543)));\nevalcond[7]=((((-1.0)*cj4*cj5*x543))+new_r00+((sj4*x536)));\nevalcond[8]=(((x536*x540))+new_r11+(((-1.0)*cj4*x543)));\nevalcond[9]=((((-1.0)*cj5*x537*x539))+new_r10+(((-1.0)*cj4*x545)));\nevalcond[10]=(((cj5*x541))+((new_r11*x540))+(((-1.0)*new_r21*x538))+x536);\nevalcond[11]=(((cj5*x542))+((new_r10*x540))+(((-1.0)*new_r20*x538))+(((-1.0)*x543)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x547=IKPowWithIntegerCheck(sj5,-1);\nif(!x547.valid){\ncontinue;\n}\nIkReal x546=x547.value;\nCheckValue<IkReal> x548=IKPowWithIntegerCheck(sj4,-1);\nif(!x548.valid){\ncontinue;\n}\nif( IKabs((x546*(x548.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x546)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x546*(x548.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))))+IKsqr(((-1.0)*new_r20*x546))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((x546*(x548.value)*(((((-1.0)*new_r00*sj5))+(((-1.0)*cj4*cj5*new_r20))))), ((-1.0)*new_r20*x546));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x549=IKsin(j6);\nIkReal x550=IKcos(j6);\nIkReal x551=((1.0)*sj5);\nIkReal x552=((1.0)*sj4);\nIkReal x553=(cj5*sj4);\nIkReal x554=(cj4*new_r01);\nIkReal x555=(cj4*new_r00);\nIkReal x556=((1.0)*x550);\nIkReal x557=(cj5*x549);\nIkReal x558=((1.0)*x549);\nevalcond[0]=(((sj5*x550))+new_r20);\nevalcond[1]=((((-1.0)*x549*x551))+new_r21);\nevalcond[2]=(((new_r11*sj4))+x557+x554);\nevalcond[3]=(((cj4*new_r10))+(((-1.0)*new_r00*x552))+(((-1.0)*x558)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*new_r01*x552))+(((-1.0)*x556)));\nevalcond[5]=(((sj4*x550))+((cj4*x557))+new_r01);\nevalcond[6]=((((-1.0)*cj5*x556))+((new_r10*sj4))+x555);\nevalcond[7]=((((-1.0)*cj4*cj5*x556))+new_r00+((sj4*x549)));\nevalcond[8]=(((x549*x553))+new_r11+(((-1.0)*cj4*x556)));\nevalcond[9]=(new_r10+(((-1.0)*cj5*x550*x552))+(((-1.0)*cj4*x558)));\nevalcond[10]=(((new_r11*x553))+((cj5*x554))+(((-1.0)*new_r21*x551))+x549);\nevalcond[11]=(((cj5*x555))+((new_r10*x553))+(((-1.0)*x556))+(((-1.0)*new_r20*x551)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x559=IKPowWithIntegerCheck(IKsign(sj5),-1);\nif(!x559.valid){\ncontinue;\n}\nCheckValue<IkReal> x560 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x560.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x559.value)))+(x560.value));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x561=IKsin(j6);\nIkReal x562=IKcos(j6);\nIkReal x563=((1.0)*sj5);\nIkReal x564=((1.0)*sj4);\nIkReal x565=(cj5*sj4);\nIkReal x566=(cj4*new_r01);\nIkReal x567=(cj4*new_r00);\nIkReal x568=((1.0)*x562);\nIkReal x569=(cj5*x561);\nIkReal x570=((1.0)*x561);\nevalcond[0]=(new_r20+((sj5*x562)));\nevalcond[1]=(new_r21+(((-1.0)*x561*x563)));\nevalcond[2]=(((new_r11*sj4))+x569+x566);\nevalcond[3]=((((-1.0)*new_r00*x564))+((cj4*new_r10))+(((-1.0)*x570)));\nevalcond[4]=(((cj4*new_r11))+(((-1.0)*x568))+(((-1.0)*new_r01*x564)));\nevalcond[5]=(((sj4*x562))+new_r01+((cj4*x569)));\nevalcond[6]=(((new_r10*sj4))+(((-1.0)*cj5*x568))+x567);\nevalcond[7]=((((-1.0)*cj4*cj5*x568))+((sj4*x561))+new_r00);\nevalcond[8]=((((-1.0)*cj4*x568))+((x561*x565))+new_r11);\nevalcond[9]=((((-1.0)*cj4*x570))+(((-1.0)*cj5*x562*x564))+new_r10);\nevalcond[10]=(x561+((new_r11*x565))+((cj5*x566))+(((-1.0)*new_r21*x563)));\nevalcond[11]=((((-1.0)*new_r20*x563))+((new_r10*x565))+((cj5*x567))+(((-1.0)*x568)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\n}};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"1327c54bf609b286bd81f3d4c134a061\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\nchar* ComputeFkWrapper(const IkReal* j) {\n    IkReal eetrans[3];\n    IkReal eerot[9];\n    IkReal res[3 + 9];\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n\nstd::vector<IkReal> TrueComputeIk(int argc, char** argv)\n{\n    std::vector<IkReal> solvalues(GetNumJoints());\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return solvalues;\n}\n"]}