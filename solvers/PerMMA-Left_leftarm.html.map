{"version":3,"file":"./solvers/PerMMA-Left_leftarm.html","sources":["./solvers/PerMMA-Left_leftarm.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AA3LA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;;;;;AA6LA;;;;;AA4qHA;AAAA;;;;;;;;;;;;;;;AAIA;AACA;AACA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-05-22 19:42:31.703880\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42;\nx0=IKsin(j[0]);\nx1=IKcos(j[0]);\nx2=IKcos(j[3]);\nx3=IKsin(j[3]);\nx4=IKcos(j[1]);\nx5=IKcos(j[2]);\nx6=IKsin(j[1]);\nx7=IKsin(j[2]);\nx8=IKsin(j[4]);\nx9=IKcos(j[4]);\nx10=IKsin(j[5]);\nx11=IKcos(j[5]);\nx12=((0.331)*x5);\nx13=((1.0)*x9);\nx14=((1.0)*x7);\nx15=((1.0)*x0);\nx16=((1.0)*x8);\nx17=((1.0)*x5);\nx18=(x1*x3);\nx19=(x0*x4);\nx20=(x1*x4);\nx21=(x5*x6);\nx22=(x1*x6);\nx23=(x4*x7);\nx24=(x17*x4);\nx25=((0.331)*x6*x7);\nx26=(x0*x14*x6);\nx27=(x17*x20);\nx28=(x21+x23);\nx29=((((-1.0)*x24))+((x6*x7)));\nx30=((((-1.0)*x14*x6))+x24);\nx31=(x2*x29);\nx32=(((x19*x5))+(((-1.0)*x26)));\nx33=(((x22*x7))+(((-1.0)*x27)));\nx34=(x3*x30*x9);\nx35=((((-1.0)*x15*x21))+(((-1.0)*x14*x19)));\nx36=(((x14*x20))+((x17*x22)));\nx37=(x32*x8);\nx38=(x33*x8);\nx39=(x2*x35);\nx40=(((x1*x2))+((x3*x35)));\nx41=(((x0*x2))+((x3*x36)));\nx42=(((x2*x36))+(((-1.0)*x15*x3)));\neerot[0]=(((x11*((x37+((x40*x9))))))+((x10*(((((-1.0)*x18))+x39)))));\neerot[1]=(((x9*((x26+(((-1.0)*x15*x4*x5))))))+((x40*x8)));\neerot[2]=(((x11*(((((-1.0)*x18))+x39))))+((x10*(((((-1.0)*x16*x32))+(((-1.0)*x13*x40)))))));\neetrans[0]=((0.045416)+(((-0.10015)*x1))+((x0*x25))+(((-1.0)*x12*x19))+(((-0.405)*x19)));\neerot[3]=(((x10*x31))+((x11*(((((-1.0)*x16*x28))+(((-1.0)*x13*x3*x30)))))));\neerot[4]=(((x29*x3*x8))+((x28*x9)));\neerot[5]=(((x11*x31))+((x10*((x34+((x28*x8)))))));\neetrans[1]=((0.302408)+(((0.331)*x23))+(((0.405)*x6))+((x12*x6)));\neerot[6]=(((x11*((((x41*x9))+x38))))+((x10*x42)));\neerot[7]=(((x41*x8))+((x9*(((((-1.0)*x14*x22))+x27)))));\neerot[8]=(((x11*x42))+((x10*(((((-1.0)*x16*x33))+(((-1.0)*x13*x41)))))));\neetrans[2]=((0.467052)+(((-0.10015)*x0))+(((-0.331)*x22*x7))+(((0.405)*x20))+((x12*x20)));\n}\n\nIKFAST_API int GetNumFreeParameters() { return 0; }\nIKFAST_API int* GetFreeParameters() { return NULL; }\nIKFAST_API int GetNumJoints() { return 6; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=r00;\nnew_r01=r02;\nnew_r02=((-1.0)*r01);\nnew_px=((-0.045416)+px);\nnew_r10=r20;\nnew_r11=r22;\nnew_r12=((-1.0)*r21);\nnew_py=((-0.467052)+pz);\nnew_r20=((-1.0)*r10);\nnew_r21=((-1.0)*r12);\nnew_r22=r11;\nnew_pz=((0.302408)+(((-1.0)*py)));\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x43=((1.0)*px);\nIkReal x44=((1.0)*pz);\nIkReal x45=((1.0)*py);\npp=((px*px)+(py*py)+(pz*pz));\nnpx=(((px*r00))+((py*r10))+((pz*r20)));\nnpy=(((px*r01))+((py*r11))+((pz*r21)));\nnpz=(((px*r02))+((py*r12))+((pz*r22)));\nrxp0_0=((((-1.0)*r20*x45))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x44)));\nrxp0_2=((((-1.0)*r10*x43))+((py*r00)));\nrxp1_0=((((-1.0)*r21*x45))+((pz*r11)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x44)));\nrxp1_2=((((-1.0)*r11*x43))+((py*r01)));\nrxp2_0=((((-1.0)*r22*x45))+((pz*r12)));\nrxp2_1=((((-1.0)*r02*x44))+((px*r22)));\nrxp2_2=((((-1.0)*r12*x43))+((py*r02)));\n{\nIkReal j3array[2], cj3array[2], sj3array[2];\nbool j3valid[2]={false};\n_nj3 = 2;\ncj3array[0]=((-1.05783455484689)+(((3.72981239043676)*pp)));\nif( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j3valid[0] = j3valid[1] = true;\n    j3array[0] = IKacos(cj3array[0]);\n    sj3array[0] = IKsin(j3array[0]);\n    cj3array[1] = cj3array[0];\n    j3array[1] = -j3array[0];\n    sj3array[1] = -sj3array[0];\n}\nelse if( isnan(cj3array[0]) )\n{\n    // probably any value will work\n    j3valid[0] = true;\n    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;\n}\nfor(int ij3 = 0; ij3 < 2; ++ij3)\n{\nif( !j3valid[ij3] )\n{\n    continue;\n}\n_ij3[0] = ij3; _ij3[1] = -1;\nfor(int iij3 = ij3+1; iij3 < 2; ++iij3)\n{\nif( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )\n{\n    j3valid[iij3]=false; _ij3[1] = iij3; break; \n}\n}\nj3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];\n\n{\nIkReal j1eval[2];\nj1eval[0]=((px*px)+(py*py));\nj1eval[1]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j2eval[2];\nj2eval[0]=((((3.02114803625378)*(IKabs(((0.405)+(((0.331)*cj3)))))))+(IKabs(sj3)));\nj2eval[1]=((1.49711119832787)+(sj3*sj3)+(((2.44712990936556)*cj3))+(cj3*cj3));\nif( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1, j2]\n\n} else\n{\n{\nIkReal j2array[2], cj2array[2], sj2array[2];\nbool j2valid[2]={false};\n_nj2 = 2;\nIkReal x46=((0.405)+(((0.331)*cj3)));\nCheckValue<IkReal> x49 = IKatan2WithCheck(IkReal(((0.331)*sj3)),x46,IKFAST_ATAN2_MAGTHRESH);\nif(!x49.valid){\ncontinue;\n}\nIkReal x47=((1.0)*(x49.value));\nif((((x46*x46)+(((0.109561)*(sj3*sj3))))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x50=IKPowWithIntegerCheck(IKabs(IKsqrt(((x46*x46)+(((0.109561)*(sj3*sj3)))))),-1);\nif(!x50.valid){\ncontinue;\n}\nif( ((pz*(x50.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x50.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x48=IKasin((pz*(x50.value)));\nj2array[0]=((((-1.0)*x48))+(((-1.0)*x47)));\nsj2array[0]=IKsin(j2array[0]);\ncj2array[0]=IKcos(j2array[0]);\nj2array[1]=((3.14159265358979)+(((-1.0)*x47))+x48);\nsj2array[1]=IKsin(j2array[1]);\ncj2array[1]=IKcos(j2array[1]);\nif( j2array[0] > IKPI )\n{\n    j2array[0]-=IK2PI;\n}\nelse if( j2array[0] < -IKPI )\n{    j2array[0]+=IK2PI;\n}\nj2valid[0] = true;\nif( j2array[1] > IKPI )\n{\n    j2array[1]-=IK2PI;\n}\nelse if( j2array[1] < -IKPI )\n{    j2array[1]+=IK2PI;\n}\nj2valid[1] = true;\nfor(int ij2 = 0; ij2 < 2; ++ij2)\n{\nif( !j2valid[ij2] )\n{\n    continue;\n}\n_ij2[0] = ij2; _ij2[1] = -1;\nfor(int iij2 = ij2+1; iij2 < 2; ++iij2)\n{\nif( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )\n{\n    j2valid[iij2]=false; _ij2[1] = iij2; break; \n}\n}\nj2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];\n\n{\nIkReal j1eval[3];\nIkReal x51=pz*pz;\nIkReal x52=(pp*sj2);\nIkReal x53=((6620.0)*sj3);\nIkReal x54=((2003.0)*sj2);\nIkReal x55=((20000.0)*cj2*pz);\nIkReal x56=(sj2*x51);\nj1eval[0]=(x52+(((-1.0)*x56)));\nj1eval[1]=IKsign(((((20000.0)*x52))+(((-20000.0)*x56))));\nj1eval[2]=((IKabs((((px*x55))+((px*x53))+(((-1.0)*py*x54)))))+(IKabs(((((-1.0)*px*x54))+(((-1.0)*py*x55))+(((-1.0)*py*x53))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[3];\nIkReal x57=pz*pz;\nIkReal x58=((2003.0)*cj2);\nIkReal x59=((6620.0)*cj3);\nIkReal x60=(cj2*pp);\nIkReal x61=((20000.0)*pz*sj2);\nIkReal x62=(cj2*x57);\nj1eval[0]=(x60+(((-1.0)*x62)));\nj1eval[1]=IKsign(((((20000.0)*x60))+(((-20000.0)*x62))));\nj1eval[2]=((IKabs(((((-1.0)*px*x61))+(((-1.0)*px*x59))+(((-8100.0)*px))+(((-1.0)*py*x58)))))+(IKabs(((((-1.0)*px*x58))+(((8100.0)*py))+((py*x61))+((py*x59))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[3];\nIkReal x63=pz*pz;\nIkReal x64=((2000000.0)*pp);\nIkReal x65=((1620000.0)*cj2);\nIkReal x66=((162243.0)*cj2);\nIkReal x67=((1620000.0)*pz*sj2);\nj1eval[0]=(((cj2*pp))+(((-1.0)*cj2*x63)));\nj1eval[1]=((IKabs(((((-88867.955)*px))+(((-1.0)*px*x67))+(((-1.0)*px*x64))+(((-1.0)*py*x66)))))+(IKabs(((((-1.0)*px*x66))+((py*x67))+((py*x64))+(((88867.955)*py))))));\nj1eval[2]=IKsign((((pp*x65))+(((-1.0)*x63*x65))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x68=((1.0)*pp);\nIkReal x69=((0.405)+(((0.331)*cj3))+pz);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.2836160225)+(((-1.0)*x68))+(((0.26811)*cj3)));\nevalcond[2]=x69;\nevalcond[3]=x69;\nevalcond[4]=((-0.0444339775)+(((-0.81)*pz))+(((-1.0)*x68)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[3];\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nIkReal x70=pz*pz;\nIkReal x71=((6620.0)*sj3);\nj1eval[0]=(pp+(((-1.0)*x70)));\nj1eval[1]=IKsign(((((-20000.0)*x70))+(((20000.0)*pp))));\nj1eval[2]=((IKabs(((((-1.0)*py*x71))+(((-2003.0)*px)))))+(IKabs((((px*x71))+(((-2003.0)*py))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x72=((6620.0)*sj3);\nCheckValue<IkReal> x73 = IKatan2WithCheck(IkReal((((px*x72))+(((-2003.0)*py)))),((((-1.0)*py*x72))+(((-2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x73.valid){\ncontinue;\n}\nCheckValue<IkReal> x74=IKPowWithIntegerCheck(IKsign(((((-20000.0)*(pz*pz)))+(((20000.0)*pp)))),-1);\nif(!x74.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x73.value)+(((1.5707963267949)*(x74.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[2];\nIkReal x75=IKcos(j1);\nIkReal x76=IKsin(j1);\nevalcond[0]=((0.10015)+((py*x76))+((px*x75)));\nevalcond[1]=(((py*x75))+(((-1.0)*px*x76))+(((0.331)*sj3)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x347=((0.331)*cj3);\nIkReal x348=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.2836160225)+(((-1.0)*x348))+(((0.26811)*cj3)));\nevalcond[2]=((-0.405)+pz+(((-1.0)*x347)));\nevalcond[3]=((0.405)+x347+(((-1.0)*pz)));\nevalcond[4]=((-0.0444339775)+(((0.81)*pz))+(((-1.0)*x348)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[3];\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nIkReal x349=pz*pz;\nIkReal x350=((6620.0)*sj3);\nj1eval[0]=(x349+(((-1.0)*pp)));\nj1eval[1]=IKsign(((((20000.0)*x349))+(((-20000.0)*pp))));\nj1eval[2]=((IKabs((((px*x350))+(((2003.0)*py)))))+(IKabs(((((-1.0)*py*x350))+(((2003.0)*px))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x351=((6620.0)*sj3);\nCheckValue<IkReal> x352 = IKatan2WithCheck(IkReal((((px*x351))+(((2003.0)*py)))),((((-1.0)*py*x351))+(((2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x352.valid){\ncontinue;\n}\nCheckValue<IkReal> x353=IKPowWithIntegerCheck(IKsign(((((-20000.0)*pp))+(((20000.0)*(pz*pz))))),-1);\nif(!x353.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x352.value)+(((1.5707963267949)*(x353.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[2];\nIkReal x354=IKsin(j1);\nIkReal x355=IKcos(j1);\nevalcond[0]=((0.10015)+((px*x355))+((py*x354)));\nevalcond[1]=(((px*x354))+(((-1.0)*py*x355))+(((0.331)*sj3)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x356=(pz+(((0.331)*sj3)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));\nevalcond[1]=((0.2836160225)+(((-1.0)*pp))+(((0.26811)*cj3)));\nevalcond[2]=x356;\nevalcond[3]=x356;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[3];\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x357=pz*pz;\nIkReal x358=((6620.0)*cj3);\nj1eval[0]=(x357+(((-1.0)*pp)));\nj1eval[1]=IKsign(((((-20000.0)*pp))+(((20000.0)*x357))));\nj1eval[2]=((IKabs(((((-8100.0)*py))+(((-1.0)*py*x358))+(((2003.0)*px)))))+(IKabs((((px*x358))+(((8100.0)*px))+(((2003.0)*py))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[3];\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x359=pz*pz;\nIkReal x360=((2000000.0)*pp);\nj1eval[0]=((((-1.0)*x359))+pp);\nj1eval[1]=IKsign(((((-1620000.0)*x359))+(((1620000.0)*pp))));\nj1eval[2]=((IKabs((((py*x360))+(((-162243.0)*px))+(((88867.955)*py)))))+(IKabs(((((-88867.955)*px))+(((-162243.0)*py))+(((-1.0)*px*x360))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x361=((2000000.0)*pp);\nCheckValue<IkReal> x362 = IKatan2WithCheck(IkReal(((((-88867.955)*px))+(((-162243.0)*py))+(((-1.0)*px*x361)))),(((py*x361))+(((-162243.0)*px))+(((88867.955)*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x362.valid){\ncontinue;\n}\nCheckValue<IkReal> x363=IKPowWithIntegerCheck(IKsign(((((-1620000.0)*(pz*pz)))+(((1620000.0)*pp)))),-1);\nif(!x363.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x362.value)+(((1.5707963267949)*(x363.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[3];\nIkReal x364=IKsin(j1);\nIkReal x365=IKcos(j1);\nIkReal x366=(px*x364);\nIkReal x367=(py*x365);\nevalcond[0]=((0.10015)+((py*x364))+((px*x365)));\nevalcond[1]=((0.405)+(((-1.0)*x367))+(((0.331)*cj3))+x366);\nevalcond[2]=((-0.0444339775)+(((-1.0)*pp))+(((0.81)*x367))+(((-0.81)*x366)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x368=((6620.0)*cj3);\nCheckValue<IkReal> x369 = IKatan2WithCheck(IkReal(((((8100.0)*px))+((px*x368))+(((2003.0)*py)))),((((-8100.0)*py))+(((-1.0)*py*x368))+(((2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x369.valid){\ncontinue;\n}\nCheckValue<IkReal> x370=IKPowWithIntegerCheck(IKsign(((((-20000.0)*pp))+(((20000.0)*(pz*pz))))),-1);\nif(!x370.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x369.value)+(((1.5707963267949)*(x370.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[3];\nIkReal x371=IKsin(j1);\nIkReal x372=IKcos(j1);\nIkReal x373=(px*x371);\nIkReal x374=(py*x372);\nevalcond[0]=((0.10015)+((px*x372))+((py*x371)));\nevalcond[1]=((0.405)+(((-1.0)*x374))+(((0.331)*cj3))+x373);\nevalcond[2]=((-0.0444339775)+(((-0.81)*x373))+(((-1.0)*pp))+(((0.81)*x374)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x375=((0.331)*sj3);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.2836160225)+(((-1.0)*pp))+(((0.26811)*cj3)));\nevalcond[2]=((((-1.0)*x375))+pz);\nevalcond[3]=(x375+(((-1.0)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[3];\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x376=pz*pz;\nIkReal x377=((6620.0)*cj3);\nj1eval[0]=((((-1.0)*x376))+pp);\nj1eval[1]=((IKabs(((((8100.0)*px))+((px*x377))+(((-2003.0)*py)))))+(IKabs(((((-8100.0)*py))+(((-1.0)*py*x377))+(((-2003.0)*px))))));\nj1eval[2]=IKsign(((((20000.0)*pp))+(((-20000.0)*x376))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[3];\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x378=pz*pz;\nIkReal x379=((2000000.0)*pp);\nj1eval[0]=(x378+(((-1.0)*pp)));\nj1eval[1]=((IKabs(((((-88867.955)*px))+(((162243.0)*py))+(((-1.0)*px*x379)))))+(IKabs(((((162243.0)*px))+((py*x379))+(((88867.955)*py))))));\nj1eval[2]=IKsign(((((1620000.0)*x378))+(((-1620000.0)*pp))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x380=((2000000.0)*pp);\nCheckValue<IkReal> x381=IKPowWithIntegerCheck(IKsign(((((1620000.0)*(pz*pz)))+(((-1620000.0)*pp)))),-1);\nif(!x381.valid){\ncontinue;\n}\nCheckValue<IkReal> x382 = IKatan2WithCheck(IkReal(((((-88867.955)*px))+(((162243.0)*py))+(((-1.0)*px*x380)))),((((162243.0)*px))+((py*x380))+(((88867.955)*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x382.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x381.value)))+(x382.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[3];\nIkReal x383=IKcos(j1);\nIkReal x384=IKsin(j1);\nIkReal x385=(px*x384);\nIkReal x386=(py*x383);\nevalcond[0]=((0.10015)+((px*x383))+((py*x384)));\nevalcond[1]=((0.405)+(((0.331)*cj3))+x386+(((-1.0)*x385)));\nevalcond[2]=((-0.0444339775)+(((0.81)*x385))+(((-1.0)*pp))+(((-0.81)*x386)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x387=((6620.0)*cj3);\nCheckValue<IkReal> x388 = IKatan2WithCheck(IkReal((((px*x387))+(((8100.0)*px))+(((-2003.0)*py)))),((((-1.0)*py*x387))+(((-8100.0)*py))+(((-2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x388.valid){\ncontinue;\n}\nCheckValue<IkReal> x389=IKPowWithIntegerCheck(IKsign(((((-20000.0)*(pz*pz)))+(((20000.0)*pp)))),-1);\nif(!x389.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x388.value)+(((1.5707963267949)*(x389.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[3];\nIkReal x390=IKcos(j1);\nIkReal x391=IKsin(j1);\nIkReal x392=(px*x391);\nIkReal x393=(py*x390);\nevalcond[0]=((0.10015)+((py*x391))+((px*x390)));\nevalcond[1]=((0.405)+(((-1.0)*x392))+(((0.331)*cj3))+x393);\nevalcond[2]=((-0.0444339775)+(((-0.81)*x393))+(((-1.0)*pp))+(((0.81)*x392)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x394=((2000000.0)*pp);\nIkReal x395=((1620000.0)*cj2);\nIkReal x396=((162243.0)*cj2);\nIkReal x397=((1620000.0)*pz*sj2);\nCheckValue<IkReal> x398 = IKatan2WithCheck(IkReal(((((-88867.955)*px))+(((-1.0)*py*x396))+(((-1.0)*px*x394))+(((-1.0)*px*x397)))),(((py*x394))+((py*x397))+(((-1.0)*px*x396))+(((88867.955)*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x398.valid){\ncontinue;\n}\nCheckValue<IkReal> x399=IKPowWithIntegerCheck(IKsign(((((-1.0)*x395*(pz*pz)))+((pp*x395)))),-1);\nif(!x399.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x398.value)+(((1.5707963267949)*(x399.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x400=IKcos(j1);\nIkReal x401=IKsin(j1);\nIkReal x402=((0.331)*sj3);\nIkReal x403=((0.331)*cj3);\nIkReal x404=((0.81)*cj2);\nIkReal x405=(pz*sj2);\nIkReal x406=(px*x401);\nIkReal x407=(py*x400);\nevalcond[0]=((0.10015)+((py*x401))+((px*x400)));\nevalcond[1]=(((sj2*x407))+x402+((cj2*pz))+(((-1.0)*sj2*x406)));\nevalcond[2]=((0.405)+(((-1.0)*cj2*x407))+x403+x405+((cj2*x406)));\nevalcond[3]=((-0.0444339775)+((x404*x407))+(((-0.81)*x405))+(((-1.0)*pp))+(((-1.0)*x404*x406)));\nevalcond[4]=((((0.405)*cj2))+x406+(((-1.0)*sj2*x402))+((cj2*x403))+(((-1.0)*x407)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x408=((2003.0)*cj2);\nIkReal x409=((6620.0)*cj3);\nIkReal x410=((20000.0)*cj2);\nIkReal x411=((20000.0)*pz*sj2);\nCheckValue<IkReal> x412 = IKatan2WithCheck(IkReal(((((-1.0)*px*x411))+(((-1.0)*px*x409))+(((-8100.0)*px))+(((-1.0)*py*x408)))),(((py*x411))+((py*x409))+(((8100.0)*py))+(((-1.0)*px*x408))),IKFAST_ATAN2_MAGTHRESH);\nif(!x412.valid){\ncontinue;\n}\nCheckValue<IkReal> x413=IKPowWithIntegerCheck(IKsign(((((-1.0)*x410*(pz*pz)))+((pp*x410)))),-1);\nif(!x413.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x412.value)+(((1.5707963267949)*(x413.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x414=IKcos(j1);\nIkReal x415=IKsin(j1);\nIkReal x416=((0.331)*sj3);\nIkReal x417=((0.331)*cj3);\nIkReal x418=((0.81)*cj2);\nIkReal x419=(pz*sj2);\nIkReal x420=(px*x415);\nIkReal x421=(py*x414);\nevalcond[0]=((0.10015)+((py*x415))+((px*x414)));\nevalcond[1]=(x416+((cj2*pz))+(((-1.0)*sj2*x420))+((sj2*x421)));\nevalcond[2]=((0.405)+x417+x419+((cj2*x420))+(((-1.0)*cj2*x421)));\nevalcond[3]=((-0.0444339775)+(((-0.81)*x419))+((x418*x421))+(((-1.0)*pp))+(((-1.0)*x418*x420)));\nevalcond[4]=((((-1.0)*x421))+(((0.405)*cj2))+x420+((cj2*x417))+(((-1.0)*sj2*x416)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x422=((20000.0)*sj2);\nIkReal x423=((6620.0)*sj3);\nIkReal x424=((2003.0)*sj2);\nIkReal x425=((20000.0)*cj2*pz);\nCheckValue<IkReal> x426 = IKatan2WithCheck(IkReal(((((-1.0)*py*x424))+((px*x425))+((px*x423)))),((((-1.0)*px*x424))+(((-1.0)*py*x425))+(((-1.0)*py*x423))),IKFAST_ATAN2_MAGTHRESH);\nif(!x426.valid){\ncontinue;\n}\nCheckValue<IkReal> x427=IKPowWithIntegerCheck(IKsign((((pp*x422))+(((-1.0)*x422*(pz*pz))))),-1);\nif(!x427.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x426.value)+(((1.5707963267949)*(x427.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x428=IKcos(j1);\nIkReal x429=IKsin(j1);\nIkReal x430=((0.331)*sj3);\nIkReal x431=((0.331)*cj3);\nIkReal x432=((0.81)*cj2);\nIkReal x433=(pz*sj2);\nIkReal x434=(px*x429);\nIkReal x435=(py*x428);\nevalcond[0]=((0.10015)+((py*x429))+((px*x428)));\nevalcond[1]=(x430+((sj2*x435))+(((-1.0)*sj2*x434))+((cj2*pz)));\nevalcond[2]=((0.405)+x431+x433+((cj2*x434))+(((-1.0)*cj2*x435)));\nevalcond[3]=((-0.0444339775)+(((-0.81)*x433))+(((-1.0)*x432*x434))+(((-1.0)*pp))+((x432*x435)));\nevalcond[4]=((((-1.0)*x435))+(((0.405)*cj2))+x434+((cj2*x431))+(((-1.0)*sj2*x430)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x438 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x438.valid){\ncontinue;\n}\nIkReal x436=((1.0)*(x438.value));\nif((((px*px)+(py*py))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x439=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);\nif(!x439.valid){\ncontinue;\n}\nif( (((0.10015)*(x439.value))) < -1-IKFAST_SINCOS_THRESH || (((0.10015)*(x439.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x437=IKasin(((0.10015)*(x439.value)));\nj1array[0]=((((-1.0)*x436))+(((-1.0)*x437)));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nj1array[1]=((3.14159265358979)+(((-1.0)*x436))+x437);\nsj1array[1]=IKsin(j1array[1]);\ncj1array[1]=IKcos(j1array[1]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nif( j1array[1] > IKPI )\n{\n    j1array[1]-=IK2PI;\n}\nelse if( j1array[1] < -IKPI )\n{    j1array[1]+=IK2PI;\n}\nj1valid[1] = true;\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n\n{\nIkReal j2eval[3];\nIkReal x440=((331000.0)*sj3);\nIkReal x441=(cj1*py);\nIkReal x442=((331000.0)*cj3);\nIkReal x443=((331000.0)*px*sj1);\nj2eval[0]=((1.02042445265003)+cj3);\nj2eval[1]=IKsign(((273586.0)+(((268110.0)*cj3))));\nj2eval[2]=((IKabs(((((-405000.0)*px*sj1))+(((405000.0)*x441))+(((-1.0)*px*sj1*x442))+((x441*x442))+(((-1.0)*pz*x440)))))+(IKabs((((px*sj1*x440))+(((-405000.0)*pz))+(((-1.0)*pz*x442))+(((-1.0)*x440*x441))))));\nif( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j2eval[3];\nIkReal x444=((1000.0)*pz);\nIkReal x445=(cj1*py);\nIkReal x446=(px*sj1);\nIkReal x447=((331.0)*cj3);\nIkReal x448=(pz*sj3);\nj2eval[0]=((((1.22356495468278)*x446))+(((-1.0)*cj3*x445))+(((-1.0)*x448))+(((-1.22356495468278)*x445))+((cj3*x446)));\nj2eval[1]=IKsign((((x446*x447))+(((405.0)*x446))+(((-331.0)*x448))+(((-1.0)*x445*x447))+(((-405.0)*x445))));\nj2eval[2]=((IKabs(((((-1.0)*x444*x446))+(((134.055)*sj3))+((x444*x445))+(((109.561)*cj3*sj3)))))+(IKabs(((-164.025)+((pz*x444))+(((-268.11)*cj3))+(((-109.561)*(cj3*cj3)))))));\nif( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j2eval[3];\nIkReal x449=(px*sj1);\nIkReal x450=((33100.0)*pp);\nIkReal x451=(cj1*py);\nIkReal x452=((26811.0)*cj3);\nIkReal x453=((81000.0)*pz);\nIkReal x454=(pz*sj3);\nj2eval[0]=((((-1.0)*cj3*x449))+(((1.22356495468278)*x451))+(((-1.22356495468278)*x449))+((cj3*x451))+x454);\nj2eval[1]=IKsign(((((32805.0)*x451))+(((-32805.0)*x449))+(((26811.0)*x454))+((x451*x452))+(((-1.0)*x449*x452))));\nj2eval[2]=((IKabs(((1799.57608875)+(((1470.76465525)*cj3))+((cj3*x450))+(((-1.0)*pz*x453))+(((40500.0)*pp)))))+(IKabs(((((-1470.76465525)*sj3))+(((-1.0)*sj3*x450))+((x449*x453))+(((-1.0)*x451*x453))))));\nif( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j2]\n\n} else\n{\n{\nIkReal j2array[1], cj2array[1], sj2array[1];\nbool j2valid[1]={false};\n_nj2 = 1;\nIkReal x455=(px*sj1);\nIkReal x456=(cj1*py);\nIkReal x457=((26811.0)*cj3);\nIkReal x458=((33100.0)*pp);\nIkReal x459=((81000.0)*pz);\nCheckValue<IkReal> x460=IKPowWithIntegerCheck(IKsign(((((-32805.0)*x455))+(((26811.0)*pz*sj3))+(((32805.0)*x456))+(((-1.0)*x455*x457))+((x456*x457)))),-1);\nif(!x460.valid){\ncontinue;\n}\nCheckValue<IkReal> x461 = IKatan2WithCheck(IkReal(((((-1470.76465525)*sj3))+((x455*x459))+(((-1.0)*x456*x459))+(((-1.0)*sj3*x458)))),((1799.57608875)+(((1470.76465525)*cj3))+((cj3*x458))+(((-1.0)*pz*x459))+(((40500.0)*pp))),IKFAST_ATAN2_MAGTHRESH);\nif(!x461.valid){\ncontinue;\n}\nj2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x460.value)))+(x461.value));\nsj2array[0]=IKsin(j2array[0]);\ncj2array[0]=IKcos(j2array[0]);\nif( j2array[0] > IKPI )\n{\n    j2array[0]-=IK2PI;\n}\nelse if( j2array[0] < -IKPI )\n{    j2array[0]+=IK2PI;\n}\nj2valid[0] = true;\nfor(int ij2 = 0; ij2 < 1; ++ij2)\n{\nif( !j2valid[ij2] )\n{\n    continue;\n}\n_ij2[0] = ij2; _ij2[1] = -1;\nfor(int iij2 = ij2+1; iij2 < 1; ++iij2)\n{\nif( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )\n{\n    j2valid[iij2]=false; _ij2[1] = iij2; break; \n}\n}\nj2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];\n{\nIkReal evalcond[5];\nIkReal x462=IKsin(j2);\nIkReal x463=IKcos(j2);\nIkReal x464=(cj1*py);\nIkReal x465=((0.331)*sj3);\nIkReal x466=(px*sj1);\nIkReal x467=((0.331)*cj3);\nIkReal x468=((0.81)*x463);\nIkReal x469=(pz*x462);\nevalcond[0]=(((x463*x465))+(((0.405)*x462))+pz+((x462*x467)));\nevalcond[1]=((((-1.0)*x462*x466))+x465+((pz*x463))+((x462*x464)));\nevalcond[2]=((0.405)+((x463*x466))+x469+x467+(((-1.0)*x463*x464)));\nevalcond[3]=((-0.0444339775)+(((-1.0)*x466*x468))+(((-1.0)*pp))+(((-0.81)*x469))+((x464*x468)));\nevalcond[4]=((((-1.0)*x462*x465))+((x463*x467))+(((-1.0)*x464))+(((0.405)*x463))+x466);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j2array[1], cj2array[1], sj2array[1];\nbool j2valid[1]={false};\n_nj2 = 1;\nIkReal x470=((331.0)*cj3);\nIkReal x471=(px*sj1);\nIkReal x472=(cj1*py);\nIkReal x473=((1000.0)*pz);\nCheckValue<IkReal> x474 = IKatan2WithCheck(IkReal((((x472*x473))+(((134.055)*sj3))+(((-1.0)*x471*x473))+(((109.561)*cj3*sj3)))),((-164.025)+((pz*x473))+(((-268.11)*cj3))+(((-109.561)*(cj3*cj3)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x474.valid){\ncontinue;\n}\nCheckValue<IkReal> x475=IKPowWithIntegerCheck(IKsign(((((-405.0)*x472))+(((-331.0)*pz*sj3))+((x470*x471))+(((405.0)*x471))+(((-1.0)*x470*x472)))),-1);\nif(!x475.valid){\ncontinue;\n}\nj2array[0]=((-1.5707963267949)+(x474.value)+(((1.5707963267949)*(x475.value))));\nsj2array[0]=IKsin(j2array[0]);\ncj2array[0]=IKcos(j2array[0]);\nif( j2array[0] > IKPI )\n{\n    j2array[0]-=IK2PI;\n}\nelse if( j2array[0] < -IKPI )\n{    j2array[0]+=IK2PI;\n}\nj2valid[0] = true;\nfor(int ij2 = 0; ij2 < 1; ++ij2)\n{\nif( !j2valid[ij2] )\n{\n    continue;\n}\n_ij2[0] = ij2; _ij2[1] = -1;\nfor(int iij2 = ij2+1; iij2 < 1; ++iij2)\n{\nif( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )\n{\n    j2valid[iij2]=false; _ij2[1] = iij2; break; \n}\n}\nj2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];\n{\nIkReal evalcond[5];\nIkReal x476=IKsin(j2);\nIkReal x477=IKcos(j2);\nIkReal x478=(cj1*py);\nIkReal x479=((0.331)*sj3);\nIkReal x480=(px*sj1);\nIkReal x481=((0.331)*cj3);\nIkReal x482=((0.81)*x477);\nIkReal x483=(pz*x476);\nevalcond[0]=(((x476*x481))+pz+(((0.405)*x476))+((x477*x479)));\nevalcond[1]=((((-1.0)*x476*x480))+x479+((pz*x477))+((x476*x478)));\nevalcond[2]=((0.405)+(((-1.0)*x477*x478))+x481+x483+((x477*x480)));\nevalcond[3]=((-0.0444339775)+(((-0.81)*x483))+(((-1.0)*pp))+((x478*x482))+(((-1.0)*x480*x482)));\nevalcond[4]=((((-1.0)*x476*x479))+(((-1.0)*x478))+x480+(((0.405)*x477))+((x477*x481)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j2array[1], cj2array[1], sj2array[1];\nbool j2valid[1]={false};\n_nj2 = 1;\nIkReal x484=((331000.0)*sj3);\nIkReal x485=(cj1*py);\nIkReal x486=((331000.0)*cj3);\nIkReal x487=((331000.0)*px*sj1);\nCheckValue<IkReal> x488=IKPowWithIntegerCheck(IKsign(((273586.0)+(((268110.0)*cj3)))),-1);\nif(!x488.valid){\ncontinue;\n}\nCheckValue<IkReal> x489 = IKatan2WithCheck(IkReal(((((-1.0)*x484*x485))+(((-1.0)*pz*x486))+((px*sj1*x484))+(((-405000.0)*pz)))),((((-1.0)*pz*x484))+((x485*x486))+(((-405000.0)*px*sj1))+(((-1.0)*px*sj1*x486))+(((405000.0)*x485))),IKFAST_ATAN2_MAGTHRESH);\nif(!x489.valid){\ncontinue;\n}\nj2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x488.value)))+(x489.value));\nsj2array[0]=IKsin(j2array[0]);\ncj2array[0]=IKcos(j2array[0]);\nif( j2array[0] > IKPI )\n{\n    j2array[0]-=IK2PI;\n}\nelse if( j2array[0] < -IKPI )\n{    j2array[0]+=IK2PI;\n}\nj2valid[0] = true;\nfor(int ij2 = 0; ij2 < 1; ++ij2)\n{\nif( !j2valid[ij2] )\n{\n    continue;\n}\n_ij2[0] = ij2; _ij2[1] = -1;\nfor(int iij2 = ij2+1; iij2 < 1; ++iij2)\n{\nif( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )\n{\n    j2valid[iij2]=false; _ij2[1] = iij2; break; \n}\n}\nj2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];\n{\nIkReal evalcond[5];\nIkReal x490=IKsin(j2);\nIkReal x491=IKcos(j2);\nIkReal x492=(cj1*py);\nIkReal x493=((0.331)*sj3);\nIkReal x494=(px*sj1);\nIkReal x495=((0.331)*cj3);\nIkReal x496=((0.81)*x491);\nIkReal x497=(pz*x490);\nevalcond[0]=((((0.405)*x490))+((x491*x493))+((x490*x495))+pz);\nevalcond[1]=(((pz*x491))+((x490*x492))+x493+(((-1.0)*x490*x494)));\nevalcond[2]=((0.405)+((x491*x494))+(((-1.0)*x491*x492))+x497+x495);\nevalcond[3]=((-0.0444339775)+(((-1.0)*x494*x496))+(((-0.81)*x497))+(((-1.0)*pp))+((x492*x496)));\nevalcond[4]=((((0.405)*x491))+((x491*x495))+(((-1.0)*x490*x493))+(((-1.0)*x492))+x494);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\nreturn solutions.GetNumSolutions()>0;\n}\ninline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {\nfor(int rotationiter = 0; rotationiter < 1; ++rotationiter) {\nIkReal x77=((1.0)*cj2);\nIkReal x78=((1.0)*sj1);\nIkReal x79=(cj1*r10);\nIkReal x80=(cj1*r11);\nIkReal x81=(cj3*sj2);\nIkReal x82=(cj1*r12);\nIkReal x83=(r02*x78);\nIkReal x84=(((sj2*sj3))+(((-1.0)*cj3*x77)));\nIkReal x85=(((cj2*sj3))+x81);\nIkReal x86=(cj1*x84);\nIkReal x87=((((-1.0)*sj3*x77))+(((-1.0)*x81)));\nIkReal x88=(x78*x87);\nnew_r00=(((x79*x87))+((r20*x84))+(((-1.0)*r00*x88)));\nnew_r01=(((r21*x84))+((x80*x87))+(((-1.0)*r01*x88)));\nnew_r02=((((-1.0)*x83*x87))+((x82*x87))+((r22*x84)));\nnew_r10=(((r10*sj1))+((cj1*r00)));\nnew_r11=(((cj1*r01))+((r11*sj1)));\nnew_r12=(((cj1*r02))+((r12*sj1)));\nnew_r20=(((x79*x84))+(((-1.0)*r00*x78*x84))+((r20*x85)));\nnew_r21=(((r21*x85))+((x80*x84))+(((-1.0)*r01*x78*x84)));\nnew_r22=((((-1.0)*x83*x84))+((x82*x84))+((r22*x85)));\n{\nIkReal j5array[2], cj5array[2], sj5array[2];\nbool j5valid[2]={false};\n_nj5 = 2;\ncj5array[0]=new_r22;\nif( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j5valid[0] = j5valid[1] = true;\n    j5array[0] = IKacos(cj5array[0]);\n    sj5array[0] = IKsin(j5array[0]);\n    cj5array[1] = cj5array[0];\n    j5array[1] = -j5array[0];\n    sj5array[1] = -sj5array[0];\n}\nelse if( isnan(cj5array[0]) )\n{\n    // probably any value will work\n    j5valid[0] = true;\n    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;\n}\nfor(int ij5 = 0; ij5 < 2; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 2; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n\n{\nIkReal j4eval[2];\nIkReal x89=((1.0)*cj2);\nIkReal x90=((1.0)*sj1);\nIkReal x91=(cj1*r10);\nIkReal x92=(cj1*r11);\nIkReal x93=(cj3*sj2);\nIkReal x94=(cj1*r12);\nIkReal x95=(r02*x90);\nIkReal x96=x84;\nIkReal x97=(((cj2*sj3))+x93);\nIkReal x98=(cj1*x96);\nIkReal x99=x87;\nIkReal x100=(x90*x99);\nnew_r00=((((-1.0)*r00*x100))+((r20*x96))+((x91*x99)));\nnew_r01=(((r21*x96))+(((-1.0)*r01*x100))+((x92*x99)));\nnew_r02=((((-1.0)*x95*x99))+((r22*x96))+((x94*x99)));\nnew_r10=(((r10*sj1))+((cj1*r00)));\nnew_r11=(((cj1*r01))+((r11*sj1)));\nnew_r12=(((cj1*r02))+((r12*sj1)));\nnew_r20=(((r20*x97))+(((-1.0)*r00*x90*x96))+((x91*x96)));\nnew_r21=(((r21*x97))+((x92*x96))+(((-1.0)*r01*x90*x96)));\nnew_r22=((((-1.0)*x95*x96))+((r22*x97))+((x94*x96)));\nj4eval[0]=sj5;\nj4eval[1]=IKsign(sj5);\nif( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j4eval[1];\nIkReal x101=((1.0)*cj2);\nIkReal x102=((1.0)*sj1);\nIkReal x103=(cj1*r10);\nIkReal x104=(cj1*r11);\nIkReal x105=(cj3*sj2);\nIkReal x106=(cj1*r12);\nIkReal x107=(r02*x102);\nIkReal x108=x84;\nIkReal x109=(((cj2*sj3))+x105);\nIkReal x110=(cj1*x108);\nIkReal x111=x87;\nIkReal x112=(x102*x111);\nnew_r00=((((-1.0)*r00*x112))+((x103*x111))+((r20*x108)));\nnew_r01=((((-1.0)*r01*x112))+((r21*x108))+((x104*x111)));\nnew_r02=(((r22*x108))+((x106*x111))+(((-1.0)*x107*x111)));\nnew_r10=(((r10*sj1))+((cj1*r00)));\nnew_r11=(((cj1*r01))+((r11*sj1)));\nnew_r12=(((cj1*r02))+((r12*sj1)));\nnew_r20=((((-1.0)*r00*x102*x108))+((r20*x109))+((x103*x108)));\nnew_r21=(((r21*x109))+(((-1.0)*r01*x102*x108))+((x104*x108)));\nnew_r22=(((x106*x108))+((r22*x109))+(((-1.0)*x107*x108)));\nj4eval[0]=sj5;\nif( IKabs(j4eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r12;\nevalcond[3]=new_r21;\nevalcond[4]=new_r02;\nevalcond[5]=new_r20;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j4array[2], cj4array[2], sj4array[2];\nbool j4valid[2]={false};\n_nj4 = 2;\nCheckValue<IkReal> x114 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x114.valid){\ncontinue;\n}\nIkReal x113=x114.value;\nj4array[0]=((-1.0)*x113);\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nj4array[1]=((3.14159265358979)+(((-1.0)*x113)));\nsj4array[1]=IKsin(j4array[1]);\ncj4array[1]=IKcos(j4array[1]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nif( j4array[1] > IKPI )\n{\n    j4array[1]-=IK2PI;\n}\nelse if( j4array[1] < -IKPI )\n{    j4array[1]+=IK2PI;\n}\nj4valid[1] = true;\nfor(int ij4 = 0; ij4 < 2; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 2; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[1];\nevalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x115=((1.0)*cj4);\nif( IKabs(((((-1.0)*new_r00*x115))+((new_r01*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x115))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x115))+((new_r01*sj4))))+IKsqr(((((-1.0)*new_r01*x115))+(((-1.0)*new_r00*sj4))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((((-1.0)*new_r00*x115))+((new_r01*sj4))), ((((-1.0)*new_r01*x115))+(((-1.0)*new_r00*sj4))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x116=IKsin(j6);\nIkReal x117=IKcos(j6);\nIkReal x118=((1.0)*sj4);\nIkReal x119=(sj4*x117);\nIkReal x120=(cj4*x116);\nIkReal x121=((1.0)*x117);\nIkReal x122=(x120+x119);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x116);\nevalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+x117);\nevalcond[2]=((((-1.0)*new_r01*x118))+((cj4*new_r11))+x116);\nevalcond[3]=(x122+new_r00);\nevalcond[4]=(x122+new_r11);\nevalcond[5]=((((-1.0)*x116*x118))+((cj4*x117))+new_r01);\nevalcond[6]=(((sj4*x116))+(((-1.0)*cj4*x121))+new_r10);\nevalcond[7]=((((-1.0)*new_r00*x118))+((cj4*new_r10))+(((-1.0)*x121)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r12;\nevalcond[3]=new_r21;\nevalcond[4]=new_r02;\nevalcond[5]=new_r20;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j4array[2], cj4array[2], sj4array[2];\nbool j4valid[2]={false};\n_nj4 = 2;\nCheckValue<IkReal> x124 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x124.valid){\ncontinue;\n}\nIkReal x123=x124.value;\nj4array[0]=((-1.0)*x123);\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nj4array[1]=((3.14159265358979)+(((-1.0)*x123)));\nsj4array[1]=IKsin(j4array[1]);\ncj4array[1]=IKcos(j4array[1]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nif( j4array[1] > IKPI )\n{\n    j4array[1]-=IK2PI;\n}\nelse if( j4array[1] < -IKPI )\n{    j4array[1]+=IK2PI;\n}\nj4valid[1] = true;\nfor(int ij4 = 0; ij4 < 2; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 2; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[1];\nevalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x125=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x125)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r00*sj4))+(((-1.0)*cj4*x125)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x125))))+IKsqr((((new_r00*sj4))+(((-1.0)*cj4*x125))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x125))), (((new_r00*sj4))+(((-1.0)*cj4*x125))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x126=IKcos(j6);\nIkReal x127=IKsin(j6);\nIkReal x128=((1.0)*sj4);\nIkReal x129=(cj4*x126);\nIkReal x130=(sj4*x127);\nIkReal x131=(sj4*x126);\nIkReal x132=(cj4*x127);\nIkReal x133=(x130+x129);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x127);\nevalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+x126);\nevalcond[2]=(((cj4*new_r10))+(((-1.0)*new_r00*x128))+x126);\nevalcond[3]=(x133+new_r01);\nevalcond[4]=(x133+new_r10);\nevalcond[5]=((((-1.0)*x126*x128))+x132+new_r00);\nevalcond[6]=(x131+(((-1.0)*x132))+new_r11);\nevalcond[7]=((((-1.0)*new_r01*x128))+((cj4*new_r11))+(((-1.0)*x127)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j4, j6]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j4array[1], cj4array[1], sj4array[1];\nbool j4valid[1]={false};\n_nj4 = 1;\nCheckValue<IkReal> x135=IKPowWithIntegerCheck(sj5,-1);\nif(!x135.valid){\ncontinue;\n}\nIkReal x134=x135.value;\nCheckValue<IkReal> x136=IKPowWithIntegerCheck(new_r02,-1);\nif(!x136.valid){\ncontinue;\n}\nif( IKabs((x134*(x136.value)*(((1.0)+(((-1.0)*(cj5*cj5)))+(((-1.0)*(new_r12*new_r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x134)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x134*(x136.value)*(((1.0)+(((-1.0)*(cj5*cj5)))+(((-1.0)*(new_r12*new_r12)))))))+IKsqr(((-1.0)*new_r12*x134))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj4array[0]=IKatan2((x134*(x136.value)*(((1.0)+(((-1.0)*(cj5*cj5)))+(((-1.0)*(new_r12*new_r12)))))), ((-1.0)*new_r12*x134));\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nfor(int ij4 = 0; ij4 < 1; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 1; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[8];\nIkReal x137=IKcos(j4);\nIkReal x138=IKsin(j4);\nIkReal x139=(sj5*x138);\nIkReal x140=(sj5*x137);\nIkReal x141=(new_r12*x137);\nIkReal x142=((1.0)*new_r02*x138);\nevalcond[0]=(x140+new_r12);\nevalcond[1]=((((-1.0)*x139))+new_r02);\nevalcond[2]=(((new_r12*x138))+((new_r02*x137)));\nevalcond[3]=((((-1.0)*x142))+sj5+x141);\nevalcond[4]=(((cj5*x141))+((new_r22*sj5))+(((-1.0)*cj5*x142)));\nevalcond[5]=(((new_r00*x139))+((cj5*new_r20))+(((-1.0)*new_r10*x140)));\nevalcond[6]=(((new_r01*x139))+((cj5*new_r21))+(((-1.0)*new_r11*x140)));\nevalcond[7]=((-1.0)+((cj5*new_r22))+((new_r02*x139))+(((-1.0)*new_r12*x140)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6eval[2];\nIkReal x143=((1.0)*cj2);\nIkReal x144=((1.0)*sj1);\nIkReal x145=(cj1*r10);\nIkReal x146=(cj1*r11);\nIkReal x147=(cj3*sj2);\nIkReal x148=(cj1*r12);\nIkReal x149=(r02*x144);\nIkReal x150=x84;\nIkReal x151=(((cj2*sj3))+x147);\nIkReal x152=(cj1*x150);\nIkReal x153=x87;\nIkReal x154=(x144*x153);\nnew_r00=(((r20*x150))+(((-1.0)*r00*x154))+((x145*x153)));\nnew_r01=((((-1.0)*r01*x154))+((x146*x153))+((r21*x150)));\nnew_r02=(((x148*x153))+(((-1.0)*x149*x153))+((r22*x150)));\nnew_r10=(((r10*sj1))+((cj1*r00)));\nnew_r11=(((cj1*r01))+((r11*sj1)));\nnew_r12=(((cj1*r02))+((r12*sj1)));\nnew_r20=((((-1.0)*r00*x144*x150))+((r20*x151))+((x145*x150)));\nnew_r21=((((-1.0)*r01*x144*x150))+((x146*x150))+((r21*x151)));\nnew_r22=(((x148*x150))+(((-1.0)*x149*x150))+((r22*x151)));\nj6eval[0]=sj5;\nj6eval[1]=IKsign(sj5);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[1];\nIkReal x155=((1.0)*cj2);\nIkReal x156=((1.0)*sj1);\nIkReal x157=(cj1*r10);\nIkReal x158=(cj1*r11);\nIkReal x159=(cj3*sj2);\nIkReal x160=(cj1*r12);\nIkReal x161=(r02*x156);\nIkReal x162=x84;\nIkReal x163=(((cj2*sj3))+x159);\nIkReal x164=(cj1*x162);\nIkReal x165=x87;\nIkReal x166=(x156*x165);\nnew_r00=(((x157*x165))+((r20*x162))+(((-1.0)*r00*x166)));\nnew_r01=((((-1.0)*r01*x166))+((r21*x162))+((x158*x165)));\nnew_r02=(((r22*x162))+(((-1.0)*x161*x165))+((x160*x165)));\nnew_r10=(((r10*sj1))+((cj1*r00)));\nnew_r11=(((cj1*r01))+((r11*sj1)));\nnew_r12=(((cj1*r02))+((r12*sj1)));\nnew_r20=(((x157*x162))+((r20*x163))+(((-1.0)*r00*x156*x162)));\nnew_r21=((((-1.0)*r01*x156*x162))+((r21*x163))+((x158*x162)));\nnew_r22=(((r22*x163))+(((-1.0)*x161*x162))+((x160*x162)));\nj6eval[0]=sj5;\nif( IKabs(j6eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[2];\nIkReal x167=((1.0)*cj2);\nIkReal x168=((1.0)*sj1);\nIkReal x169=(cj1*r10);\nIkReal x170=(cj1*r11);\nIkReal x171=(cj3*sj2);\nIkReal x172=(cj1*r12);\nIkReal x173=(r02*x168);\nIkReal x174=x84;\nIkReal x175=(((cj2*sj3))+x171);\nIkReal x176=(cj1*x174);\nIkReal x177=x87;\nIkReal x178=(x168*x177);\nnew_r00=(((x169*x177))+(((-1.0)*r00*x178))+((r20*x174)));\nnew_r01=((((-1.0)*r01*x178))+((r21*x174))+((x170*x177)));\nnew_r02=(((r22*x174))+((x172*x177))+(((-1.0)*x173*x177)));\nnew_r10=(((r10*sj1))+((cj1*r00)));\nnew_r11=(((cj1*r01))+((r11*sj1)));\nnew_r12=(((cj1*r02))+((r12*sj1)));\nnew_r20=(((x169*x174))+((r20*x175))+(((-1.0)*r00*x168*x174)));\nnew_r21=((((-1.0)*r01*x168*x174))+((r21*x175))+((x170*x174)));\nnew_r22=(((r22*x175))+((x172*x174))+(((-1.0)*x173*x174)));\nj6eval[0]=sj5;\nj6eval[1]=sj4;\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[10];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x179=(((new_r12*sj4))+((cj4*new_r02)));\nIkReal x180=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r12;\nevalcond[3]=new_r21;\nevalcond[4]=new_r02;\nevalcond[5]=new_r20;\nevalcond[6]=x179;\nevalcond[7]=x179;\nevalcond[8]=x180;\nevalcond[9]=x180;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x181=((1.0)*cj4);\nif( IKabs((((new_r01*sj4))+(((-1.0)*new_r00*x181)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x181))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r01*sj4))+(((-1.0)*new_r00*x181))))+IKsqr(((((-1.0)*new_r01*x181))+(((-1.0)*new_r00*sj4))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((((new_r01*sj4))+(((-1.0)*new_r00*x181))), ((((-1.0)*new_r01*x181))+(((-1.0)*new_r00*sj4))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x182=IKsin(j6);\nIkReal x183=IKcos(j6);\nIkReal x184=((1.0)*sj4);\nIkReal x185=(sj4*x183);\nIkReal x186=(cj4*x182);\nIkReal x187=((1.0)*x183);\nIkReal x188=(x185+x186);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x182);\nevalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+x183);\nevalcond[2]=(((cj4*new_r11))+x182+(((-1.0)*new_r01*x184)));\nevalcond[3]=(x188+new_r00);\nevalcond[4]=(x188+new_r11);\nevalcond[5]=(new_r01+(((-1.0)*x182*x184))+((cj4*x183)));\nevalcond[6]=((((-1.0)*cj4*x187))+((sj4*x182))+new_r10);\nevalcond[7]=(((cj4*new_r10))+(((-1.0)*x187))+(((-1.0)*new_r00*x184)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x189=(new_r02*sj4);\nIkReal x190=(cj4*new_r12);\nIkReal x191=(((new_r12*sj4))+((cj4*new_r02)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r12;\nevalcond[3]=new_r21;\nevalcond[4]=new_r02;\nevalcond[5]=new_r20;\nevalcond[6]=x191;\nevalcond[7]=x191;\nevalcond[8]=((((-1.0)*x189))+x190);\nevalcond[9]=((((-1.0)*x190))+x189);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x192=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x192)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*x192))+((new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x192))))+IKsqr(((((-1.0)*cj4*x192))+((new_r00*sj4))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x192))), ((((-1.0)*cj4*x192))+((new_r00*sj4))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x193=IKcos(j6);\nIkReal x194=IKsin(j6);\nIkReal x195=((1.0)*sj4);\nIkReal x196=(cj4*x193);\nIkReal x197=(sj4*x194);\nIkReal x198=(sj4*x193);\nIkReal x199=(cj4*x194);\nIkReal x200=(x197+x196);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x194);\nevalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+x193);\nevalcond[2]=(((cj4*new_r10))+x193+(((-1.0)*new_r00*x195)));\nevalcond[3]=(x200+new_r01);\nevalcond[4]=(x200+new_r10);\nevalcond[5]=(x199+new_r00+(((-1.0)*x193*x195)));\nevalcond[6]=((((-1.0)*x199))+x198+new_r11);\nevalcond[7]=(((cj4*new_r11))+(((-1.0)*x194))+(((-1.0)*new_r01*x195)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x201=(new_r22+(((-1.0)*cj5)));\nIkReal x202=(sj5+new_r12);\nIkReal x203=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));\nevalcond[1]=x201;\nevalcond[2]=x201;\nevalcond[3]=x202;\nevalcond[4]=new_r02;\nevalcond[5]=x202;\nevalcond[6]=(((cj5*new_r12))+((new_r22*sj5)));\nevalcond[7]=(((cj5*new_r20))+(((-1.0)*new_r10*x203)));\nevalcond[8]=(((cj5*new_r21))+(((-1.0)*new_r11*x203)));\nevalcond[9]=((-1.0)+(((-1.0)*new_r12*x203))+((cj5*new_r22)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x204=IKcos(j6);\nIkReal x205=IKsin(j6);\nIkReal x206=((1.0)*new_r12);\nIkReal x207=((1.0)*x204);\nevalcond[0]=(x205+new_r00);\nevalcond[1]=(x204+new_r01);\nevalcond[2]=(((new_r12*x204))+new_r20);\nevalcond[3]=(((new_r22*x205))+new_r11);\nevalcond[4]=((((-1.0)*x205*x206))+new_r21);\nevalcond[5]=((((-1.0)*new_r22*x207))+new_r10);\nevalcond[6]=((((-1.0)*new_r21*x206))+x205+((new_r11*new_r22)));\nevalcond[7]=((((-1.0)*new_r20*x206))+(((-1.0)*x207))+((new_r10*new_r22)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x208=(new_r22+(((-1.0)*cj5)));\nIkReal x209=((1.0)*cj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));\nevalcond[1]=x208;\nevalcond[2]=x208;\nevalcond[3]=((((-1.0)*sj5))+new_r12);\nevalcond[4]=new_r02;\nevalcond[5]=(sj5+(((-1.0)*new_r12)));\nevalcond[6]=((((-1.0)*new_r12*x209))+((new_r22*sj5)));\nevalcond[7]=(((new_r10*sj5))+((cj5*new_r20)));\nevalcond[8]=(((new_r11*sj5))+((cj5*new_r21)));\nevalcond[9]=((-1.0)+((new_r12*sj5))+((cj5*new_r22)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r00, new_r01);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x210=IKsin(j6);\nIkReal x211=IKcos(j6);\nIkReal x212=((1.0)*new_r22);\nIkReal x213=((1.0)*x211);\nevalcond[0]=(new_r21+((new_r12*x210)));\nevalcond[1]=(x210+(((-1.0)*new_r00)));\nevalcond[2]=(x211+(((-1.0)*new_r01)));\nevalcond[3]=(((new_r22*x211))+new_r10);\nevalcond[4]=((((-1.0)*new_r12*x213))+new_r20);\nevalcond[5]=((((-1.0)*x210*x212))+new_r11);\nevalcond[6]=((((-1.0)*new_r11*x212))+((new_r12*new_r21))+x210);\nevalcond[7]=((((-1.0)*new_r10*x212))+((new_r12*new_r20))+(((-1.0)*x213)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j6]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x215=IKPowWithIntegerCheck(sj5,-1);\nif(!x215.valid){\ncontinue;\n}\nIkReal x214=x215.value;\nCheckValue<IkReal> x216=IKPowWithIntegerCheck(sj4,-1);\nif(!x216.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r21*x214)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x214*(x216.value)*(((((-1.0)*new_r11*sj5))+((cj4*cj5*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x214))+IKsqr((x214*(x216.value)*(((((-1.0)*new_r11*sj5))+((cj4*cj5*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r21*x214), (x214*(x216.value)*(((((-1.0)*new_r11*sj5))+((cj4*cj5*new_r21))))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x217=IKsin(j6);\nIkReal x218=IKcos(j6);\nIkReal x219=(cj4*cj5);\nIkReal x220=((1.0)*sj4);\nIkReal x221=(cj5*x217);\nIkReal x222=((1.0)*x218);\nIkReal x223=(sj4*x218);\nevalcond[0]=(((sj5*x217))+new_r21);\nevalcond[1]=((((-1.0)*sj5*x222))+new_r20);\nevalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+x217);\nevalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+x218);\nevalcond[4]=(((cj4*x217))+((cj5*x223))+new_r00);\nevalcond[5]=(x223+new_r11+((x217*x219)));\nevalcond[6]=((((-1.0)*new_r01*x220))+((cj4*new_r11))+x221);\nevalcond[7]=(((cj4*x218))+(((-1.0)*x220*x221))+new_r01);\nevalcond[8]=((((-1.0)*x219*x222))+new_r10+((sj4*x217)));\nevalcond[9]=((((-1.0)*cj5*x222))+((cj4*new_r10))+(((-1.0)*new_r00*x220)));\nevalcond[10]=(x217+(((-1.0)*cj5*new_r01*x220))+((new_r21*sj5))+((new_r11*x219)));\nevalcond[11]=(((new_r20*sj5))+(((-1.0)*cj5*new_r00*x220))+((new_r10*x219))+(((-1.0)*x222)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x224=IKPowWithIntegerCheck(sj5,-1);\nif(!x224.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r21*(x224.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x224.value)))+IKsqr(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*sj4))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r21*(x224.value)), ((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*sj4))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x225=IKsin(j6);\nIkReal x226=IKcos(j6);\nIkReal x227=(cj4*cj5);\nIkReal x228=((1.0)*sj4);\nIkReal x229=(cj5*x225);\nIkReal x230=((1.0)*x226);\nIkReal x231=(sj4*x226);\nevalcond[0]=(((sj5*x225))+new_r21);\nevalcond[1]=((((-1.0)*sj5*x230))+new_r20);\nevalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+x225);\nevalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+x226);\nevalcond[4]=(((cj5*x231))+((cj4*x225))+new_r00);\nevalcond[5]=(((x225*x227))+x231+new_r11);\nevalcond[6]=((((-1.0)*new_r01*x228))+((cj4*new_r11))+x229);\nevalcond[7]=((((-1.0)*x228*x229))+((cj4*x226))+new_r01);\nevalcond[8]=(((sj4*x225))+(((-1.0)*x227*x230))+new_r10);\nevalcond[9]=(((cj4*new_r10))+(((-1.0)*cj5*x230))+(((-1.0)*new_r00*x228)));\nevalcond[10]=(x225+(((-1.0)*cj5*new_r01*x228))+((new_r11*x227))+((new_r21*sj5)));\nevalcond[11]=(((new_r20*sj5))+(((-1.0)*x230))+(((-1.0)*cj5*new_r00*x228))+((new_r10*x227)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x232 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x232.valid){\ncontinue;\n}\nCheckValue<IkReal> x233=IKPowWithIntegerCheck(IKsign(sj5),-1);\nif(!x233.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x232.value)+(((1.5707963267949)*(x233.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x234=IKsin(j6);\nIkReal x235=IKcos(j6);\nIkReal x236=(cj4*cj5);\nIkReal x237=((1.0)*sj4);\nIkReal x238=(cj5*x234);\nIkReal x239=((1.0)*x235);\nIkReal x240=(sj4*x235);\nevalcond[0]=(new_r21+((sj5*x234)));\nevalcond[1]=((((-1.0)*sj5*x239))+new_r20);\nevalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+x234);\nevalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+x235);\nevalcond[4]=(((cj5*x240))+((cj4*x234))+new_r00);\nevalcond[5]=(((x234*x236))+x240+new_r11);\nevalcond[6]=(((cj4*new_r11))+x238+(((-1.0)*new_r01*x237)));\nevalcond[7]=(((cj4*x235))+new_r01+(((-1.0)*x237*x238)));\nevalcond[8]=(((sj4*x234))+(((-1.0)*x236*x239))+new_r10);\nevalcond[9]=(((cj4*new_r10))+(((-1.0)*cj5*x239))+(((-1.0)*new_r00*x237)));\nevalcond[10]=(((new_r11*x236))+(((-1.0)*cj5*new_r01*x237))+x234+((new_r21*sj5)));\nevalcond[11]=(((new_r10*x236))+((new_r20*sj5))+(((-1.0)*cj5*new_r00*x237))+(((-1.0)*x239)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j4array[1], cj4array[1], sj4array[1];\nbool j4valid[1]={false};\n_nj4 = 1;\nCheckValue<IkReal> x241=IKPowWithIntegerCheck(IKsign(sj5),-1);\nif(!x241.valid){\ncontinue;\n}\nCheckValue<IkReal> x242 = IKatan2WithCheck(IkReal(new_r02),((-1.0)*new_r12),IKFAST_ATAN2_MAGTHRESH);\nif(!x242.valid){\ncontinue;\n}\nj4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x241.value)))+(x242.value));\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nfor(int ij4 = 0; ij4 < 1; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 1; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[8];\nIkReal x243=IKcos(j4);\nIkReal x244=IKsin(j4);\nIkReal x245=(sj5*x244);\nIkReal x246=(sj5*x243);\nIkReal x247=(new_r12*x243);\nIkReal x248=((1.0)*new_r02*x244);\nevalcond[0]=(x246+new_r12);\nevalcond[1]=((((-1.0)*x245))+new_r02);\nevalcond[2]=(((new_r12*x244))+((new_r02*x243)));\nevalcond[3]=(sj5+x247+(((-1.0)*x248)));\nevalcond[4]=((((-1.0)*cj5*x248))+((cj5*x247))+((new_r22*sj5)));\nevalcond[5]=(((cj5*new_r20))+((new_r00*x245))+(((-1.0)*new_r10*x246)));\nevalcond[6]=(((cj5*new_r21))+(((-1.0)*new_r11*x246))+((new_r01*x245)));\nevalcond[7]=((-1.0)+((cj5*new_r22))+(((-1.0)*new_r12*x246))+((new_r02*x245)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6eval[2];\nIkReal x249=((1.0)*cj2);\nIkReal x250=((1.0)*sj1);\nIkReal x251=(cj1*r10);\nIkReal x252=(cj1*r11);\nIkReal x253=(cj3*sj2);\nIkReal x254=(cj1*r12);\nIkReal x255=(r02*x250);\nIkReal x256=x84;\nIkReal x257=(((cj2*sj3))+x253);\nIkReal x258=(cj1*x256);\nIkReal x259=x87;\nIkReal x260=(x250*x259);\nnew_r00=(((r20*x256))+((x251*x259))+(((-1.0)*r00*x260)));\nnew_r01=(((r21*x256))+(((-1.0)*r01*x260))+((x252*x259)));\nnew_r02=((((-1.0)*x255*x259))+((x254*x259))+((r22*x256)));\nnew_r10=(((r10*sj1))+((cj1*r00)));\nnew_r11=(((cj1*r01))+((r11*sj1)));\nnew_r12=(((cj1*r02))+((r12*sj1)));\nnew_r20=(((r20*x257))+((x251*x256))+(((-1.0)*r00*x250*x256)));\nnew_r21=(((r21*x257))+(((-1.0)*r01*x250*x256))+((x252*x256)));\nnew_r22=((((-1.0)*x255*x256))+((x254*x256))+((r22*x257)));\nj6eval[0]=sj5;\nj6eval[1]=IKsign(sj5);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[1];\nIkReal x261=((1.0)*cj2);\nIkReal x262=((1.0)*sj1);\nIkReal x263=(cj1*r10);\nIkReal x264=(cj1*r11);\nIkReal x265=(cj3*sj2);\nIkReal x266=(cj1*r12);\nIkReal x267=(r02*x262);\nIkReal x268=x84;\nIkReal x269=(((cj2*sj3))+x265);\nIkReal x270=(cj1*x268);\nIkReal x271=x87;\nIkReal x272=(x262*x271);\nnew_r00=(((x263*x271))+(((-1.0)*r00*x272))+((r20*x268)));\nnew_r01=(((x264*x271))+(((-1.0)*r01*x272))+((r21*x268)));\nnew_r02=(((x266*x271))+((r22*x268))+(((-1.0)*x267*x271)));\nnew_r10=(((r10*sj1))+((cj1*r00)));\nnew_r11=(((cj1*r01))+((r11*sj1)));\nnew_r12=(((cj1*r02))+((r12*sj1)));\nnew_r20=((((-1.0)*r00*x262*x268))+((x263*x268))+((r20*x269)));\nnew_r21=(((x264*x268))+(((-1.0)*r01*x262*x268))+((r21*x269)));\nnew_r22=(((x266*x268))+((r22*x269))+(((-1.0)*x267*x268)));\nj6eval[0]=sj5;\nif( IKabs(j6eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[2];\nIkReal x273=((1.0)*cj2);\nIkReal x274=((1.0)*sj1);\nIkReal x275=(cj1*r10);\nIkReal x276=(cj1*r11);\nIkReal x277=(cj3*sj2);\nIkReal x278=(cj1*r12);\nIkReal x279=(r02*x274);\nIkReal x280=x84;\nIkReal x281=(((cj2*sj3))+x277);\nIkReal x282=(cj1*x280);\nIkReal x283=x87;\nIkReal x284=(x274*x283);\nnew_r00=(((x275*x283))+(((-1.0)*r00*x284))+((r20*x280)));\nnew_r01=(((r21*x280))+(((-1.0)*r01*x284))+((x276*x283)));\nnew_r02=(((x278*x283))+((r22*x280))+(((-1.0)*x279*x283)));\nnew_r10=(((r10*sj1))+((cj1*r00)));\nnew_r11=(((cj1*r01))+((r11*sj1)));\nnew_r12=(((cj1*r02))+((r12*sj1)));\nnew_r20=(((x275*x280))+(((-1.0)*r00*x274*x280))+((r20*x281)));\nnew_r21=((((-1.0)*r01*x274*x280))+((r21*x281))+((x276*x280)));\nnew_r22=(((x278*x280))+((r22*x281))+(((-1.0)*x279*x280)));\nj6eval[0]=sj5;\nj6eval[1]=sj4;\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[10];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x285=(((new_r12*sj4))+((cj4*new_r02)));\nIkReal x286=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r12;\nevalcond[3]=new_r21;\nevalcond[4]=new_r02;\nevalcond[5]=new_r20;\nevalcond[6]=x285;\nevalcond[7]=x285;\nevalcond[8]=x286;\nevalcond[9]=x286;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x287=((1.0)*cj4);\nif( IKabs((((new_r01*sj4))+(((-1.0)*new_r00*x287)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x287))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r01*sj4))+(((-1.0)*new_r00*x287))))+IKsqr(((((-1.0)*new_r01*x287))+(((-1.0)*new_r00*sj4))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((((new_r01*sj4))+(((-1.0)*new_r00*x287))), ((((-1.0)*new_r01*x287))+(((-1.0)*new_r00*sj4))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x288=IKsin(j6);\nIkReal x289=IKcos(j6);\nIkReal x290=((1.0)*sj4);\nIkReal x291=(sj4*x289);\nIkReal x292=(cj4*x288);\nIkReal x293=((1.0)*x289);\nIkReal x294=(x291+x292);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x288);\nevalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+x289);\nevalcond[2]=((((-1.0)*new_r01*x290))+((cj4*new_r11))+x288);\nevalcond[3]=(x294+new_r00);\nevalcond[4]=(x294+new_r11);\nevalcond[5]=((((-1.0)*x288*x290))+new_r01+((cj4*x289)));\nevalcond[6]=((((-1.0)*cj4*x293))+new_r10+((sj4*x288)));\nevalcond[7]=(((cj4*new_r10))+(((-1.0)*x293))+(((-1.0)*new_r00*x290)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x295=(new_r02*sj4);\nIkReal x296=(cj4*new_r12);\nIkReal x297=(((new_r12*sj4))+((cj4*new_r02)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r12;\nevalcond[3]=new_r21;\nevalcond[4]=new_r02;\nevalcond[5]=new_r20;\nevalcond[6]=x297;\nevalcond[7]=x297;\nevalcond[8]=((((-1.0)*x295))+x296);\nevalcond[9]=((((-1.0)*x296))+x295);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x298=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x298)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*x298))+((new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x298))))+IKsqr(((((-1.0)*cj4*x298))+((new_r00*sj4))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x298))), ((((-1.0)*cj4*x298))+((new_r00*sj4))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x299=IKcos(j6);\nIkReal x300=IKsin(j6);\nIkReal x301=((1.0)*sj4);\nIkReal x302=(cj4*x299);\nIkReal x303=(sj4*x300);\nIkReal x304=(sj4*x299);\nIkReal x305=(cj4*x300);\nIkReal x306=(x302+x303);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x300);\nevalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+x299);\nevalcond[2]=(((cj4*new_r10))+x299+(((-1.0)*new_r00*x301)));\nevalcond[3]=(x306+new_r01);\nevalcond[4]=(x306+new_r10);\nevalcond[5]=(x305+(((-1.0)*x299*x301))+new_r00);\nevalcond[6]=((((-1.0)*x305))+x304+new_r11);\nevalcond[7]=(((cj4*new_r11))+(((-1.0)*x300))+(((-1.0)*new_r01*x301)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x307=(new_r22+(((-1.0)*cj5)));\nIkReal x308=(sj5+new_r12);\nIkReal x309=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));\nevalcond[1]=x307;\nevalcond[2]=x307;\nevalcond[3]=x308;\nevalcond[4]=new_r02;\nevalcond[5]=x308;\nevalcond[6]=(((cj5*new_r12))+((new_r22*sj5)));\nevalcond[7]=(((cj5*new_r20))+(((-1.0)*new_r10*x309)));\nevalcond[8]=(((cj5*new_r21))+(((-1.0)*new_r11*x309)));\nevalcond[9]=((-1.0)+((cj5*new_r22))+(((-1.0)*new_r12*x309)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x310=IKcos(j6);\nIkReal x311=IKsin(j6);\nIkReal x312=((1.0)*new_r12);\nIkReal x313=((1.0)*x310);\nevalcond[0]=(x311+new_r00);\nevalcond[1]=(x310+new_r01);\nevalcond[2]=(((new_r12*x310))+new_r20);\nevalcond[3]=(new_r11+((new_r22*x311)));\nevalcond[4]=(new_r21+(((-1.0)*x311*x312)));\nevalcond[5]=((((-1.0)*new_r22*x313))+new_r10);\nevalcond[6]=((((-1.0)*new_r21*x312))+x311+((new_r11*new_r22)));\nevalcond[7]=((((-1.0)*new_r20*x312))+(((-1.0)*x313))+((new_r10*new_r22)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x314=(new_r22+(((-1.0)*cj5)));\nIkReal x315=((1.0)*cj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));\nevalcond[1]=x314;\nevalcond[2]=x314;\nevalcond[3]=((((-1.0)*sj5))+new_r12);\nevalcond[4]=new_r02;\nevalcond[5]=(sj5+(((-1.0)*new_r12)));\nevalcond[6]=((((-1.0)*new_r12*x315))+((new_r22*sj5)));\nevalcond[7]=(((new_r10*sj5))+((cj5*new_r20)));\nevalcond[8]=(((new_r11*sj5))+((cj5*new_r21)));\nevalcond[9]=((-1.0)+((new_r12*sj5))+((cj5*new_r22)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r00, new_r01);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x316=IKsin(j6);\nIkReal x317=IKcos(j6);\nIkReal x318=((1.0)*new_r22);\nIkReal x319=((1.0)*x317);\nevalcond[0]=(((new_r12*x316))+new_r21);\nevalcond[1]=(x316+(((-1.0)*new_r00)));\nevalcond[2]=(x317+(((-1.0)*new_r01)));\nevalcond[3]=(new_r10+((new_r22*x317)));\nevalcond[4]=((((-1.0)*new_r12*x319))+new_r20);\nevalcond[5]=(new_r11+(((-1.0)*x316*x318)));\nevalcond[6]=((((-1.0)*new_r11*x318))+x316+((new_r12*new_r21)));\nevalcond[7]=(((new_r12*new_r20))+(((-1.0)*new_r10*x318))+(((-1.0)*x319)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j6]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x321=IKPowWithIntegerCheck(sj5,-1);\nif(!x321.valid){\ncontinue;\n}\nIkReal x320=x321.value;\nCheckValue<IkReal> x322=IKPowWithIntegerCheck(sj4,-1);\nif(!x322.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r21*x320)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x320*(x322.value)*(((((-1.0)*new_r11*sj5))+((cj4*cj5*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x320))+IKsqr((x320*(x322.value)*(((((-1.0)*new_r11*sj5))+((cj4*cj5*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r21*x320), (x320*(x322.value)*(((((-1.0)*new_r11*sj5))+((cj4*cj5*new_r21))))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x323=IKsin(j6);\nIkReal x324=IKcos(j6);\nIkReal x325=(cj4*cj5);\nIkReal x326=((1.0)*sj4);\nIkReal x327=(cj5*x323);\nIkReal x328=((1.0)*x324);\nIkReal x329=(sj4*x324);\nevalcond[0]=(((sj5*x323))+new_r21);\nevalcond[1]=(new_r20+(((-1.0)*sj5*x328)));\nevalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+x323);\nevalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+x324);\nevalcond[4]=(((cj5*x329))+((cj4*x323))+new_r00);\nevalcond[5]=(((x323*x325))+x329+new_r11);\nevalcond[6]=(((cj4*new_r11))+x327+(((-1.0)*new_r01*x326)));\nevalcond[7]=((((-1.0)*x326*x327))+((cj4*x324))+new_r01);\nevalcond[8]=(((sj4*x323))+(((-1.0)*x325*x328))+new_r10);\nevalcond[9]=(((cj4*new_r10))+(((-1.0)*new_r00*x326))+(((-1.0)*cj5*x328)));\nevalcond[10]=(x323+((new_r21*sj5))+(((-1.0)*cj5*new_r01*x326))+((new_r11*x325)));\nevalcond[11]=(((new_r20*sj5))+(((-1.0)*x328))+(((-1.0)*cj5*new_r00*x326))+((new_r10*x325)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x330=IKPowWithIntegerCheck(sj5,-1);\nif(!x330.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r21*(x330.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x330.value)))+IKsqr(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*sj4))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r21*(x330.value)), ((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*sj4))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x331=IKsin(j6);\nIkReal x332=IKcos(j6);\nIkReal x333=(cj4*cj5);\nIkReal x334=((1.0)*sj4);\nIkReal x335=(cj5*x331);\nIkReal x336=((1.0)*x332);\nIkReal x337=(sj4*x332);\nevalcond[0]=(((sj5*x331))+new_r21);\nevalcond[1]=((((-1.0)*sj5*x336))+new_r20);\nevalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+x331);\nevalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+x332);\nevalcond[4]=(((cj4*x331))+((cj5*x337))+new_r00);\nevalcond[5]=(((x331*x333))+x337+new_r11);\nevalcond[6]=(((cj4*new_r11))+x335+(((-1.0)*new_r01*x334)));\nevalcond[7]=(((cj4*x332))+new_r01+(((-1.0)*x334*x335)));\nevalcond[8]=((((-1.0)*x333*x336))+((sj4*x331))+new_r10);\nevalcond[9]=(((cj4*new_r10))+(((-1.0)*cj5*x336))+(((-1.0)*new_r00*x334)));\nevalcond[10]=(((new_r11*x333))+x331+(((-1.0)*cj5*new_r01*x334))+((new_r21*sj5)));\nevalcond[11]=(((new_r20*sj5))+((new_r10*x333))+(((-1.0)*x336))+(((-1.0)*cj5*new_r00*x334)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x338 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x338.valid){\ncontinue;\n}\nCheckValue<IkReal> x339=IKPowWithIntegerCheck(IKsign(sj5),-1);\nif(!x339.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x338.value)+(((1.5707963267949)*(x339.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x340=IKsin(j6);\nIkReal x341=IKcos(j6);\nIkReal x342=(cj4*cj5);\nIkReal x343=((1.0)*sj4);\nIkReal x344=(cj5*x340);\nIkReal x345=((1.0)*x341);\nIkReal x346=(sj4*x341);\nevalcond[0]=(((sj5*x340))+new_r21);\nevalcond[1]=((((-1.0)*sj5*x345))+new_r20);\nevalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+x340);\nevalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+x341);\nevalcond[4]=(((cj4*x340))+((cj5*x346))+new_r00);\nevalcond[5]=(x346+new_r11+((x340*x342)));\nevalcond[6]=(((cj4*new_r11))+x344+(((-1.0)*new_r01*x343)));\nevalcond[7]=(((cj4*x341))+(((-1.0)*x343*x344))+new_r01);\nevalcond[8]=(((sj4*x340))+new_r10+(((-1.0)*x342*x345)));\nevalcond[9]=(((cj4*new_r10))+(((-1.0)*cj5*x345))+(((-1.0)*new_r00*x343)));\nevalcond[10]=(((new_r11*x342))+(((-1.0)*cj5*new_r01*x343))+x340+((new_r21*sj5)));\nevalcond[11]=((((-1.0)*cj5*new_r00*x343))+((new_r20*sj5))+((new_r10*x342))+(((-1.0)*x345)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j1;\nvinfos[0].indices[0] = _ij1[0];\nvinfos[0].indices[1] = _ij1[1];\nvinfos[0].maxsolutions = _nj1;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j2;\nvinfos[1].indices[0] = _ij2[0];\nvinfos[1].indices[1] = _ij2[1];\nvinfos[1].maxsolutions = _nj2;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j3;\nvinfos[2].indices[0] = _ij3[0];\nvinfos[2].indices[1] = _ij3[1];\nvinfos[2].maxsolutions = _nj3;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j4;\nvinfos[3].indices[0] = _ij4[0];\nvinfos[3].indices[1] = _ij4[1];\nvinfos[3].maxsolutions = _nj4;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j5;\nvinfos[4].indices[0] = _ij5[0];\nvinfos[4].indices[1] = _ij5[1];\nvinfos[4].maxsolutions = _nj5;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j6;\nvinfos[5].indices[0] = _ij6[0];\nvinfos[5].indices[1] = _ij6[1];\nvinfos[5].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\n}};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"932c89545e6a1721f49778d9ea6940ca\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\n#include \"emscripten.h\"\n\nextern \"C\" {\n\nint EMSCRIPTEN_KEEPALIVE _GetNumJoints() {\n    return GetNumJoints();\n}\n\nchar* EMSCRIPTEN_KEEPALIVE _ComputeFk(const IkReal* j) {\n    IkReal eetrans[3] = {0};\n    IkReal eerot[9] = {0};\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n//\n//std::vector<IkReal> TrueComputeIk(int argc, char** argv) {\n//    std::vector<IkReal> solvalues(GetNumJoints());\n//    if( argc != 12+GetNumFreeParameters()+1 ) {\n//        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n//               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n//               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n//               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n//    }\n//\n//    IkSolutionList<IkReal> solutions;\n//    std::vector<IkReal> vfree(GetNumFreeParameters());\n//    IkReal eerot[9],eetrans[3];\n//    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n//    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n//    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n//    for(std::size_t i = 0; i < vfree.size(); ++i)\n//        vfree[i] = atof(argv[13+i]);\n//    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n//\n//    if( !bSuccess ) {\n//        fprintf(stderr,\"Failed to get ik solution\\n\");\n//    }\n//\n//    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n//    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n//        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n//        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n//        std::vector<IkReal> vsolfree(sol.GetFree().size());\n//        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n//        for( std::size_t j = 0; j < solvalues.size(); ++j)\n//            printf(\"%.15f, \", solvalues[j]);\n//        printf(\"\\n\");\n//    }\n//    return solvalues;\n//}\n\n}\n"]}