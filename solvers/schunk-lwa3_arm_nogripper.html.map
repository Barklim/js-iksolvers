{"version":3,"file":"./solvers/schunk-lwa3_arm_nogripper.html","sources":["./solvers/schunk-lwa3_arm_nogripper.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAIA;;;;;;;;;;;;;;;AAiqVA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;AA33VA;AAAA;AAAA;;;;;;;;AAFA;AAAA;AAAA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-05-22 19:38:19.412557\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62;\nx0=IKcos(j[0]);\nx1=IKcos(j[1]);\nx2=IKcos(j[2]);\nx3=IKsin(j[0]);\nx4=IKsin(j[2]);\nx5=IKsin(j[3]);\nx6=IKcos(j[3]);\nx7=IKsin(j[1]);\nx8=IKcos(j[4]);\nx9=IKsin(j[4]);\nx10=IKsin(j[6]);\nx11=IKsin(j[5]);\nx12=IKcos(j[5]);\nx13=IKcos(j[6]);\nx14=((0.1825)*x5);\nx15=((0.1825)*x8);\nx16=((0.2765)*x6);\nx17=((0.1825)*x6);\nx18=((1.0)*x5);\nx19=((1.0)*x6);\nx20=((1.0)*x4);\nx21=((0.2765)*x0);\nx22=((0.1825)*x9);\nx23=((1.0)*x12);\nx24=((1.0)*x3);\nx25=((1.0)*x8);\nx26=((0.2765)*x3);\nx27=((1.0)*x11);\nx28=((1.0)*x9);\nx29=(x3*x7);\nx30=(x2*x7);\nx31=(x1*x2);\nx32=(x0*x7);\nx33=(x20*x3);\nx34=(x18*x32);\nx35=(x18*x29);\nx36=(x20*x7*x9);\nx37=((((-1.0)*x33))+((x0*x31)));\nx38=(((x0*x4))+((x3*x31)));\nx39=((((-1.0)*x1*x33))+((x0*x2)));\nx40=((((-1.0)*x18*x30))+((x1*x6)));\nx41=(((x1*x5))+((x30*x6)));\nx42=((((-1.0)*x0*x31))+x33);\nx43=((((-1.0)*x0*x1*x20))+(((-1.0)*x2*x24)));\nx44=((((-1.0)*x0*x20))+(((-1.0)*x24*x31)));\nx45=(x41*x8);\nx46=(x37*x6);\nx47=(x44*x5);\nx48=(x43*x9);\nx49=((((-1.0)*x34))+x46);\nx50=((((-1.0)*x35))+((x38*x6)));\nx51=((((-1.0)*x36))+x45);\nx52=(((x42*x5))+(((-1.0)*x19*x32)));\nx53=((((-1.0)*x19*x29))+x47);\nx54=(((x9*(((((-1.0)*x1*x18))+(((-1.0)*x19*x30))))))+(((-1.0)*x20*x7*x8)));\nx55=(x50*x8);\nx56=(x11*x52);\nx57=(x11*x53);\nx58=(x55+((x39*x9)));\nx59=(((x9*(((((-1.0)*x19*x38))+x35))))+((x39*x8)));\nx60=(((x49*x8))+x48);\nx61=(x12*x58);\nx62=(((x9*(((((-1.0)*x46))+x34))))+((x43*x8)));\neerot[0]=(((x13*((((x12*x60))+x56))))+((x10*x62)));\neerot[1]=(((x13*x62))+((x10*(((((-1.0)*x27*x52))+(((-1.0)*x23*x60)))))));\neerot[2]=(((x12*x52))+((x11*(((((-1.0)*x25*x49))+(((-1.0)*x28*x43)))))));\nIkReal x63=((1.0)*x32);\neetrans[0]=((((-0.328)*x32))+(((-1.0)*x16*x63))+((x11*(((((-1.0)*x15*x49))+(((-1.0)*x22*x43))))))+((x12*(((((-1.0)*x17*x63))+((x14*x42))))))+((x5*(((((-1.0)*x21*x31))+((x26*x4)))))));\neerot[3]=(((x13*((x57+x61))))+((x10*x59)));\neerot[4]=(((x13*x59))+((x10*(((((-1.0)*x27*x53))+(((-1.0)*x23*x58)))))));\neerot[5]=(((x12*x53))+((x11*(((((-1.0)*x28*x39))+(((-1.0)*x25*x50)))))));\nIkReal x64=((1.0)*x29);\neetrans[1]=((((-1.0)*x16*x64))+((x11*(((((-1.0)*x22*x39))+(((-1.0)*x15*x50))))))+((x5*(((((-1.0)*x21*x4))+(((-1.0)*x26*x31))))))+((x12*(((((-1.0)*x17*x64))+((x14*x44))))))+(((-0.328)*x29)));\neerot[6]=(((x13*((((x12*x51))+((x11*x40))))))+((x10*x54)));\neerot[7]=(((x13*x54))+((x10*(((((-1.0)*x27*x40))+(((-1.0)*x23*x51)))))));\neerot[8]=(((x11*(((((-1.0)*x25*x41))+x36))))+((x12*x40)));\neetrans[2]=((0.3)+((x1*x16))+((x11*(((((-1.0)*x15*x41))+((x22*x4*x7))))))+(((-0.2765)*x30*x5))+(((0.328)*x1))+((x12*((((x1*x17))+(((-1.0)*x14*x30)))))));\n}\n\nIKFAST_API int GetNumFreeParameters() { return 1; }\nIKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }\nIKFAST_API int GetNumJoints() { return 7; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j2,cj2,sj2,htj2,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij2[2], _nj2;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij2[0] = -1; _ij2[1] = -1; _nj2 = 0; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nj2=pfree[0]; cj2=cos(pfree[0]); sj2=sin(pfree[0]), htj2=tan(pfree[0]*0.5);\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=r00;\nnew_r01=r01;\nnew_r02=r02;\nnew_px=((((-0.1825)*r02))+px);\nnew_r10=r10;\nnew_r11=r11;\nnew_r12=r12;\nnew_py=((((-0.1825)*r12))+py);\nnew_r20=r20;\nnew_r21=r21;\nnew_r22=r22;\nnew_pz=((-0.3)+pz+(((-0.1825)*r22)));\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x65=((1.0)*px);\nIkReal x66=((1.0)*pz);\nIkReal x67=((1.0)*py);\npp=((px*px)+(py*py)+(pz*pz));\nnpx=(((px*r00))+((py*r10))+((pz*r20)));\nnpy=(((px*r01))+((py*r11))+((pz*r21)));\nnpz=(((px*r02))+((py*r12))+((pz*r22)));\nrxp0_0=((((-1.0)*r20*x67))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x66)));\nrxp0_2=((((-1.0)*r10*x65))+((py*r00)));\nrxp1_0=((((-1.0)*r21*x67))+((pz*r11)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x66)));\nrxp1_2=((((-1.0)*r11*x65))+((py*r01)));\nrxp2_0=(((pz*r12))+(((-1.0)*r22*x67)));\nrxp2_1=(((px*r22))+(((-1.0)*r02*x66)));\nrxp2_2=((((-1.0)*r12*x65))+((py*r02)));\n{\nIkReal j3array[2], cj3array[2], sj3array[2];\nbool j3valid[2]={false};\n_nj3 = 2;\ncj3array[0]=((-1.01462229303577)+(((5.5131654390685)*pp)));\nif( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j3valid[0] = j3valid[1] = true;\n    j3array[0] = IKacos(cj3array[0]);\n    sj3array[0] = IKsin(j3array[0]);\n    cj3array[1] = cj3array[0];\n    j3array[1] = -j3array[0];\n    sj3array[1] = -sj3array[0];\n}\nelse if( isnan(cj3array[0]) )\n{\n    // probably any value will work\n    j3valid[0] = true;\n    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;\n}\nfor(int ij3 = 0; ij3 < 2; ++ij3)\n{\nif( !j3valid[ij3] )\n{\n    continue;\n}\n_ij3[0] = ij3; _ij3[1] = -1;\nfor(int iij3 = ij3+1; iij3 < 2; ++iij3)\n{\nif( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )\n{\n    j3valid[iij3]=false; _ij3[1] = iij3; break; \n}\n}\nj3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];\n\n{\nIkReal j0eval[2];\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nj0eval[1]=((px*px)+(py*py));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nj1eval[0]=((1.40720515092754)+(cj3*cj3)+(((2.37251356238698)*cj3))+(((cj2*cj2)*(sj3*sj3))));\nj1eval[1]=((((3.61663652802893)*(IKabs(((0.328)+(((0.2765)*cj3)))))))+(IKabs((cj2*sj3))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[2];\nIkReal x68=sj2*sj2;\nIkReal x69=cj2*cj2;\nIkReal x70=py*py;\nIkReal x71=px*px;\nIkReal x72=py*py*py*py;\nIkReal x73=sj2*sj2*sj2*sj2;\nIkReal x74=cj2*cj2*cj2*cj2;\nIkReal x75=(px*py);\nIkReal x76=((1.0)*x70);\nIkReal x77=(x70*x71);\nIkReal x78=((2.0)*x68*x69);\nj0eval[0]=((IKabs(((((-1.0)*x69*x76))+(((-1.0)*x68*x76)))))+(IKabs((((x69*x75))+((x68*x75))))));\nj0eval[1]=(((x72*x78))+((x72*x73))+((x72*x74))+((x73*x77))+((x74*x77))+((x77*x78)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0, j1]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x79=py*py;\nIkReal x80=sj2*sj2;\nIkReal x81=cj2*cj2;\nIkReal x82=(px*py);\nIkReal x83=((1.0)*x79);\nIkReal x84=(((x81*x82))+((x80*x82)));\nIkReal x85=((((-1.0)*x81*x83))+(((-1.0)*x80*x83)));\nCheckValue<IkReal> x88 = IKatan2WithCheck(IkReal(x85),x84,IKFAST_ATAN2_MAGTHRESH);\nif(!x88.valid){\ncontinue;\n}\nIkReal x86=((1.0)*(x88.value));\nif((((x84*x84)+(x85*x85))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x89=IKPowWithIntegerCheck(IKabs(IKsqrt(((x84*x84)+(x85*x85)))),-1);\nif(!x89.valid){\ncontinue;\n}\nif( (((0.2765)*py*sj2*sj3*(x89.value))) < -1-IKFAST_SINCOS_THRESH || (((0.2765)*py*sj2*sj3*(x89.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x87=IKasin(((0.2765)*py*sj2*sj3*(x89.value)));\nj0array[0]=(x87+(((-1.0)*x86)));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x87))+(((-1.0)*x86)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x90=px*px;\nIkReal x91=IKsin(j0);\nIkReal x92=IKcos(j0);\nIkReal x93=cj2*cj2;\nIkReal x94=sj2*sj2;\nIkReal x95=((1.0)*px);\nIkReal x96=((0.2765)*sj2*sj3);\nevalcond[0]=((((-1.0)*x91*x95))+((py*x92))+x96);\nevalcond[1]=(((x91*((((x90*x93))+((x90*x94))))))+((x92*(((((-1.0)*py*x94*x95))+(((-1.0)*py*x93*x95))))))+(((-1.0)*px*x96)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j1eval[3];\nIkReal x97=(py*sj0);\nIkReal x98=((2000.0)*pz);\nIkReal x99=(cj0*px);\nIkReal x100=((553.0)*cj3);\nIkReal x101=(cj2*sj3);\nIkReal x102=((1.0)*cj3);\nj1eval[0]=((((-1.0)*x102*x97))+(((-1.0)*x102*x99))+((pz*x101))+(((-1.18625678119349)*x99))+(((-1.18625678119349)*x97)));\nj1eval[1]=IKsign(((((553.0)*pz*x101))+(((-656.0)*x97))+(((-656.0)*x99))+(((-1.0)*x100*x97))+(((-1.0)*x100*x99))));\nj1eval[2]=((IKabs(((((152.9045)*cj3*x101))+(((-1.0)*x98*x99))+(((181.384)*x101))+(((-1.0)*x97*x98)))))+(IKabs(((215.168)+(((-1.0)*pz*x98))+(((152.9045)*(cj3*cj3)))+(((362.768)*cj3))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[3];\nIkReal x103=cj2*cj2;\nIkReal x104=cj3*cj3;\nIkReal x105=(py*sj0);\nIkReal x106=((1106000.0)*cj3);\nIkReal x107=(cj0*px);\nIkReal x108=((305809.0)*x104);\nIkReal x109=((1106000.0)*cj2*sj3);\nj1eval[0]=((1.40720515092754)+(((-1.0)*x103*x104))+(((2.37251356238698)*cj3))+x104+x103);\nj1eval[1]=IKsign(((430336.0)+(((725536.0)*cj3))+(((305809.0)*x103))+x108+(((-1.0)*x103*x108))));\nj1eval[2]=((IKabs((((pz*x106))+(((-1.0)*x107*x109))+(((1312000.0)*pz))+(((-1.0)*x105*x109)))))+(IKabs(((((-1.0)*pz*x109))+(((-1312000.0)*x107))+(((-1312000.0)*x105))+(((-1.0)*x106*x107))+(((-1.0)*x105*x106))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nIkReal x110=(cj0*px);\nIkReal x111=(cj3*pz);\nIkReal x112=(py*sj0);\nIkReal x113=(cj2*sj3);\nIkReal x114=((553.0)*x113);\nj1eval[0]=(((x110*x113))+((x112*x113))+(((1.18625678119349)*pz))+x111);\nj1eval[1]=IKsign((((x110*x114))+((x112*x114))+(((656.0)*pz))+(((553.0)*x111))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x115=((0.2765)*sj3);\nIkReal x116=(cj0*py);\nIkReal x117=(px*sj0);\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j2), 6.28318530717959))))));\nevalcond[1]=((0.18403625)+(((0.181384)*cj3))+(((-1.0)*pp)));\nevalcond[2]=(x116+x115+(((-1.0)*x117)));\nevalcond[3]=((((-1.0)*x115))+x117+(((-1.0)*x116)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x118=((-1.0)*py);\npz=0;\nj2=1.5707963267949;\nsj2=1.0;\ncj2=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x118);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x118);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x118);\nrxp2_1=(px*r22);\nj1eval[0]=((-1.18625678119349)+(((-1.0)*cj3)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[1];\nIkReal x119=((-1.0)*py);\npz=0;\nj2=1.5707963267949;\nsj2=1.0;\ncj2=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x119);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x119);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x119);\nrxp2_1=(px*r22);\nj1eval[0]=(((cj0*px))+((py*sj0)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x121 = ((px*px)+(py*py));\nif(IKabs(x121)==0){\ncontinue;\n}\nIkReal x120=pow(x121,-0.5);\nCheckValue<IkReal> x122 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x122.valid){\ncontinue;\n}\nIkReal gconst0=((-1.0)*(x122.value));\nIkReal gconst1=((-1.0)*px*x120);\nIkReal gconst2=(py*x120);\nIkReal x123=((0.2765)*sj3);\nIkReal x124=(gconst2*py);\nIkReal x125=(gconst1*px);\nCheckValue<IkReal> x126 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x126.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x126.value)+j0)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((-1.0)*(px*px)))+(((0.181384)*cj3))+(((-1.0)*(py*py))));\nevalcond[2]=(x124+x123+(((-1.0)*x125)));\nevalcond[3]=((((-1.0)*x123))+x125+(((-1.0)*x124)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x127=((-1.0)*py);\nCheckValue<IkReal> x131 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x131.valid){\ncontinue;\n}\nIkReal x128=((-1.0)*(x131.value));\nIkReal x129=((px*px)+(py*py));\nIkReal x130=x120;\npz=0;\nj2=1.5707963267949;\nsj2=1.0;\ncj2=0;\npp=x129;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x127);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x127);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x127);\nrxp2_1=(px*r22);\nsj0=gconst1;\ncj0=gconst2;\nj0=x128;\nIkReal gconst0=x128;\nIkReal gconst1=((-1.0)*px*x130);\nIkReal gconst2=(py*x130);\nj1eval[0]=((-1.18625678119349)+(((-1.0)*cj3)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[1];\nIkReal x132=((-1.0)*py);\nCheckValue<IkReal> x136 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x136.valid){\ncontinue;\n}\nIkReal x133=((-1.0)*(x136.value));\nIkReal x134=((px*px)+(py*py));\nIkReal x135=x120;\npz=0;\nj2=1.5707963267949;\nsj2=1.0;\ncj2=0;\npp=x134;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x132);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x132);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x132);\nrxp2_1=(px*r22);\nsj0=gconst1;\ncj0=gconst2;\nj0=x133;\nIkReal gconst0=x133;\nIkReal gconst1=((-1.0)*px*x135);\nIkReal gconst2=(py*x135);\nj1eval[0]=0;\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x138=IKPowWithIntegerCheck((((gconst2*px))+((gconst1*py))),-1);\nif(!x138.valid){\ncontinue;\n}\nIkReal x137=x138.value;\nsj1array[0]=((((-0.2765)*cj3*x137))+(((-0.328)*x137)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x139=IKcos(j1);\nIkReal x140=IKsin(j1);\nIkReal x141=px*px;\nIkReal x142=py*py;\nIkReal x143=(gconst1*py);\nIkReal x144=((1.0)*gconst2*px);\nIkReal x145=((1.52439024390244)*x139);\nIkReal x146=((0.656)*x140);\nevalcond[0]=((((-1.0)*x139*x144))+(((-1.0)*x139*x143)));\nevalcond[1]=((((-1.0)*x144))+(((-0.2765)*cj3*x140))+(((-1.0)*x143))+(((-0.328)*x140)));\nevalcond[2]=(((x142*x145))+((x141*x145))+(((0.0474569359756098)*x139)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x143*x146))+(((-1.0)*gconst2*px*x146))+(((-1.0)*x142))+(((-1.0)*x141)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x449=IKPowWithIntegerCheck(((-0.328)+(((-0.2765)*cj3))),-1);\nif(!x449.valid){\ncontinue;\n}\nIkReal x448=x449.value;\nsj1array[0]=(((gconst1*py*x448))+((gconst2*px*x448)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x450=IKcos(j1);\nIkReal x451=IKsin(j1);\nIkReal x452=px*px;\nIkReal x453=py*py;\nIkReal x454=(gconst2*px);\nIkReal x455=((1.0)*x450);\nIkReal x456=((1.52439024390244)*x450);\nIkReal x457=(gconst1*py*x451);\nevalcond[0]=((((-1.0)*x454*x455))+(((-1.0)*gconst1*py*x455)));\nevalcond[1]=((0.328)+(((0.2765)*cj3))+x457+((x451*x454)));\nevalcond[2]=(((x452*x456))+((x453*x456))+(((0.0474569359756098)*x450)));\nevalcond[3]=((-0.03113175)+(((-0.656)*x457))+(((-1.0)*x452))+(((-1.0)*x453))+(((-0.656)*x451*x454)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x459 = ((px*px)+(py*py));\nif(IKabs(x459)==0){\ncontinue;\n}\nIkReal x458=pow(x459,-0.5);\nCheckValue<IkReal> x460 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x460.valid){\ncontinue;\n}\nIkReal gconst3=((3.14159265358979)+(((-1.0)*(x460.value))));\nIkReal gconst4=((1.0)*px*x458);\nIkReal gconst5=((-1.0)*py*x458);\nIkReal x461=((0.2765)*sj3);\nIkReal x462=(gconst4*px);\nIkReal x463=(gconst5*py);\nCheckValue<IkReal> x464 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x464.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x464.value)+j0)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((-1.0)*(px*px)))+(((0.181384)*cj3))+(((-1.0)*(py*py))));\nevalcond[2]=((((-1.0)*x462))+x463+x461);\nevalcond[3]=((((-1.0)*x463))+(((-1.0)*x461))+x462);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nCheckValue<IkReal> x469 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x469.valid){\ncontinue;\n}\nIkReal x465=((1.0)*(x469.value));\nIkReal x466=((-1.0)*py);\nIkReal x467=((px*px)+(py*py));\nIkReal x468=x458;\npz=0;\nj2=1.5707963267949;\nsj2=1.0;\ncj2=0;\npp=x467;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x466);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x466);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x466);\nrxp2_1=(px*r22);\nsj0=gconst4;\ncj0=gconst5;\nj0=((3.14159265)+(((-1.0)*x465)));\nIkReal gconst3=((3.14159265358979)+(((-1.0)*x465)));\nIkReal gconst4=((1.0)*px*x468);\nIkReal gconst5=(x466*x468);\nj1eval[0]=((-1.18625678119349)+(((-1.0)*cj3)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[1];\nCheckValue<IkReal> x474 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x474.valid){\ncontinue;\n}\nIkReal x470=((1.0)*(x474.value));\nIkReal x471=((-1.0)*py);\nIkReal x472=((px*px)+(py*py));\nIkReal x473=x458;\npz=0;\nj2=1.5707963267949;\nsj2=1.0;\ncj2=0;\npp=x472;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x471);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x471);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x471);\nrxp2_1=(px*r22);\nsj0=gconst4;\ncj0=gconst5;\nj0=((3.14159265)+(((-1.0)*x470)));\nIkReal gconst3=((3.14159265358979)+(((-1.0)*x470)));\nIkReal gconst4=((1.0)*px*x473);\nIkReal gconst5=(x471*x473);\nj1eval[0]=0;\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x476=IKPowWithIntegerCheck((((gconst5*px))+((gconst4*py))),-1);\nif(!x476.valid){\ncontinue;\n}\nIkReal x475=x476.value;\nsj1array[0]=((((-0.2765)*cj3*x475))+(((-0.328)*x475)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x477=IKcos(j1);\nIkReal x478=IKsin(j1);\nIkReal x479=px*px;\nIkReal x480=py*py;\nIkReal x481=(gconst4*py);\nIkReal x482=(gconst5*px);\nIkReal x483=((0.656)*x478);\nIkReal x484=((1.52439024390244)*x477);\nIkReal x485=((1.0)*x477);\nevalcond[0]=((((-1.0)*x481*x485))+(((-1.0)*x482*x485)));\nevalcond[1]=((((-1.0)*x482))+(((-1.0)*x481))+(((-0.2765)*cj3*x478))+(((-0.328)*x478)));\nevalcond[2]=((((0.0474569359756098)*x477))+((x480*x484))+((x479*x484)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x480))+(((-1.0)*x479))+(((-1.0)*x481*x483))+(((-1.0)*x482*x483)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x487=IKPowWithIntegerCheck(((-0.328)+(((-0.2765)*cj3))),-1);\nif(!x487.valid){\ncontinue;\n}\nIkReal x486=x487.value;\nsj1array[0]=(((gconst5*px*x486))+((gconst4*py*x486)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x488=IKcos(j1);\nIkReal x489=IKsin(j1);\nIkReal x490=px*px;\nIkReal x491=py*py;\nIkReal x492=(gconst5*px);\nIkReal x493=((1.52439024390244)*x488);\nIkReal x494=((1.0)*x488);\nIkReal x495=(gconst4*py*x489);\nevalcond[0]=((((-1.0)*gconst4*py*x494))+(((-1.0)*x492*x494)));\nevalcond[1]=((0.328)+(((0.2765)*cj3))+((x489*x492))+x495);\nevalcond[2]=(((x491*x493))+((x490*x493))+(((0.0474569359756098)*x488)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x490))+(((-1.0)*x491))+(((-0.656)*x489*x492))+(((-0.656)*x495)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x497=IKPowWithIntegerCheck((((cj0*px))+((py*sj0))),-1);\nif(!x497.valid){\ncontinue;\n}\nIkReal x496=x497.value;\nsj1array[0]=((((-0.328)*x496))+(((-0.2765)*cj3*x496)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x498=IKcos(j1);\nIkReal x499=IKsin(j1);\nIkReal x500=px*px;\nIkReal x501=py*py;\nIkReal x502=(cj0*px);\nIkReal x503=(py*sj0);\nIkReal x504=((0.656)*x499);\nIkReal x505=((1.52439024390244)*x498);\nIkReal x506=((1.0)*x498);\nevalcond[0]=((((-1.0)*x502*x506))+(((-1.0)*x503*x506)));\nevalcond[1]=((((-1.0)*x502))+(((-1.0)*x503))+(((-0.328)*x499))+(((-0.2765)*cj3*x499)));\nevalcond[2]=(((x500*x505))+((x501*x505))+(((0.0474569359756098)*x498)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x502*x504))+(((-1.0)*x503*x504))+(((-1.0)*x501))+(((-1.0)*x500)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x508=IKPowWithIntegerCheck(((-0.328)+(((-0.2765)*cj3))),-1);\nif(!x508.valid){\ncontinue;\n}\nIkReal x507=x508.value;\nsj1array[0]=(((py*sj0*x507))+((cj0*px*x507)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x509=IKcos(j1);\nIkReal x510=IKsin(j1);\nIkReal x511=px*px;\nIkReal x512=py*py;\nIkReal x513=(py*sj0);\nIkReal x514=(cj0*px);\nIkReal x515=((1.0)*x509);\nIkReal x516=((0.656)*x510);\nIkReal x517=((1.52439024390244)*x509);\nevalcond[0]=((((-1.0)*x514*x515))+(((-1.0)*x513*x515)));\nevalcond[1]=((0.328)+((x510*x513))+((x510*x514))+(((0.2765)*cj3)));\nevalcond[2]=(((x511*x517))+((x512*x517))+(((0.0474569359756098)*x509)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x514*x516))+(((-1.0)*x511))+(((-1.0)*x512))+(((-1.0)*x513*x516)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x518=((((-0.2765)*sj3))+(((-1.0)*px*sj0))+((cj0*py)));\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j2), 6.28318530717959))))));\nevalcond[1]=((0.18403625)+(((0.181384)*cj3))+(((-1.0)*pp)));\nevalcond[2]=x518;\nevalcond[3]=x518;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x519=((-1.0)*py);\npz=0;\nj2=-1.5707963267949;\nsj2=-1.0;\ncj2=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x519);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x519);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x519);\nrxp2_1=(px*r22);\nj1eval[0]=((-1.18625678119349)+(((-1.0)*cj3)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[1];\nIkReal x520=((-1.0)*py);\npz=0;\nj2=-1.5707963267949;\nsj2=-1.0;\ncj2=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x520);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x520);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x520);\nrxp2_1=(px*r22);\nj1eval[0]=(((cj0*px))+((py*sj0)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x522 = ((px*px)+(py*py));\nif(IKabs(x522)==0){\ncontinue;\n}\nIkReal x521=pow(x522,-0.5);\nCheckValue<IkReal> x523 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x523.valid){\ncontinue;\n}\nIkReal gconst6=((-1.0)*(x523.value));\nIkReal gconst7=((-1.0)*px*x521);\nIkReal gconst8=(py*x521);\nIkReal x524=((((-0.2765)*sj3))+((gconst8*py))+(((-1.0)*gconst7*px)));\nCheckValue<IkReal> x525 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x525.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x525.value)+j0)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((-1.0)*(px*px)))+(((0.181384)*cj3))+(((-1.0)*(py*py))));\nevalcond[2]=x524;\nevalcond[3]=x524;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x526=((-1.0)*py);\nCheckValue<IkReal> x530 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x530.valid){\ncontinue;\n}\nIkReal x527=((-1.0)*(x530.value));\nIkReal x528=((px*px)+(py*py));\nIkReal x529=x521;\npz=0;\nj2=-1.5707963267949;\nsj2=-1.0;\ncj2=0;\npp=x528;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x526);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x526);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x526);\nrxp2_1=(px*r22);\nsj0=gconst7;\ncj0=gconst8;\nj0=x527;\nIkReal gconst6=x527;\nIkReal gconst7=((-1.0)*px*x529);\nIkReal gconst8=(py*x529);\nj1eval[0]=((-1.18625678119349)+(((-1.0)*cj3)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[1];\nIkReal x531=((-1.0)*py);\nCheckValue<IkReal> x535 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x535.valid){\ncontinue;\n}\nIkReal x532=((-1.0)*(x535.value));\nIkReal x533=((px*px)+(py*py));\nIkReal x534=x521;\npz=0;\nj2=-1.5707963267949;\nsj2=-1.0;\ncj2=0;\npp=x533;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x531);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x531);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x531);\nrxp2_1=(px*r22);\nsj0=gconst7;\ncj0=gconst8;\nj0=x532;\nIkReal gconst6=x532;\nIkReal gconst7=((-1.0)*px*x534);\nIkReal gconst8=(py*x534);\nj1eval[0]=0;\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x537=IKPowWithIntegerCheck((((gconst8*px))+((gconst7*py))),-1);\nif(!x537.valid){\ncontinue;\n}\nIkReal x536=x537.value;\nsj1array[0]=((((-0.2765)*cj3*x536))+(((-0.328)*x536)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x538=IKcos(j1);\nIkReal x539=IKsin(j1);\nIkReal x540=px*px;\nIkReal x541=py*py;\nIkReal x542=(gconst8*px);\nIkReal x543=(gconst7*py);\nIkReal x544=((0.656)*x539);\nIkReal x545=((1.52439024390244)*x538);\nevalcond[0]=(((x538*x543))+((x538*x542)));\nevalcond[1]=((((-1.0)*x543))+(((-1.0)*x542))+(((-0.2765)*cj3*x539))+(((-0.328)*x539)));\nevalcond[2]=(((x541*x545))+((x540*x545))+(((0.0474569359756098)*x538)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x542*x544))+(((-1.0)*x540))+(((-1.0)*x541))+(((-1.0)*x543*x544)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x547=IKPowWithIntegerCheck(((-0.328)+(((-0.2765)*cj3))),-1);\nif(!x547.valid){\ncontinue;\n}\nIkReal x546=x547.value;\nsj1array[0]=(((gconst7*py*x546))+((gconst8*px*x546)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x548=IKcos(j1);\nIkReal x549=IKsin(j1);\nIkReal x550=px*px;\nIkReal x551=py*py;\nIkReal x552=(gconst8*px);\nIkReal x553=((1.52439024390244)*x548);\nIkReal x554=(gconst7*py*x549);\nevalcond[0]=(((x548*x552))+((gconst7*py*x548)));\nevalcond[1]=((0.328)+(((0.2765)*cj3))+x554+((x549*x552)));\nevalcond[2]=((((0.0474569359756098)*x548))+((x550*x553))+((x551*x553)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x551))+(((-1.0)*x550))+(((-0.656)*x549*x552))+(((-0.656)*x554)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x556 = ((px*px)+(py*py));\nif(IKabs(x556)==0){\ncontinue;\n}\nIkReal x555=pow(x556,-0.5);\nCheckValue<IkReal> x557 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x557.valid){\ncontinue;\n}\nIkReal gconst9=((3.14159265358979)+(((-1.0)*(x557.value))));\nIkReal gconst10=((1.0)*px*x555);\nIkReal gconst11=((-1.0)*py*x555);\nIkReal x558=((((-0.2765)*sj3))+(((-1.0)*gconst10*px))+((gconst11*py)));\nCheckValue<IkReal> x559 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x559.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x559.value)+j0)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((-1.0)*(px*px)))+(((0.181384)*cj3))+(((-1.0)*(py*py))));\nevalcond[2]=x558;\nevalcond[3]=x558;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nCheckValue<IkReal> x564 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x564.valid){\ncontinue;\n}\nIkReal x560=((1.0)*(x564.value));\nIkReal x561=((-1.0)*py);\nIkReal x562=((px*px)+(py*py));\nIkReal x563=x555;\npz=0;\nj2=-1.5707963267949;\nsj2=-1.0;\ncj2=0;\npp=x562;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x561);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x561);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x561);\nrxp2_1=(px*r22);\nsj0=gconst10;\ncj0=gconst11;\nj0=((3.14159265)+(((-1.0)*x560)));\nIkReal gconst9=((3.14159265358979)+(((-1.0)*x560)));\nIkReal gconst10=((1.0)*px*x563);\nIkReal gconst11=(x561*x563);\nj1eval[0]=((-1.18625678119349)+(((-1.0)*cj3)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[1];\nCheckValue<IkReal> x569 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x569.valid){\ncontinue;\n}\nIkReal x565=((1.0)*(x569.value));\nIkReal x566=((-1.0)*py);\nIkReal x567=((px*px)+(py*py));\nIkReal x568=x555;\npz=0;\nj2=-1.5707963267949;\nsj2=-1.0;\ncj2=0;\npp=x567;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x566);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x566);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x566);\nrxp2_1=(px*r22);\nsj0=gconst10;\ncj0=gconst11;\nj0=((3.14159265)+(((-1.0)*x565)));\nIkReal gconst9=((3.14159265358979)+(((-1.0)*x565)));\nIkReal gconst10=((1.0)*px*x568);\nIkReal gconst11=(x566*x568);\nj1eval[0]=0;\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x571=IKPowWithIntegerCheck((((gconst10*py))+((gconst11*px))),-1);\nif(!x571.valid){\ncontinue;\n}\nIkReal x570=x571.value;\nsj1array[0]=((((-0.328)*x570))+(((-0.2765)*cj3*x570)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x572=IKcos(j1);\nIkReal x573=IKsin(j1);\nIkReal x574=px*px;\nIkReal x575=py*py;\nIkReal x576=(gconst10*py);\nIkReal x577=(gconst11*px);\nIkReal x578=((1.52439024390244)*x572);\nIkReal x579=((0.656)*x573);\nevalcond[0]=(((x572*x577))+((x572*x576)));\nevalcond[1]=((((-0.328)*x573))+(((-1.0)*x576))+(((-1.0)*x577))+(((-0.2765)*cj3*x573)));\nevalcond[2]=(((x574*x578))+(((0.0474569359756098)*x572))+((x575*x578)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x577*x579))+(((-1.0)*x576*x579))+(((-1.0)*x575))+(((-1.0)*x574)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x581=IKPowWithIntegerCheck(((-0.328)+(((-0.2765)*cj3))),-1);\nif(!x581.valid){\ncontinue;\n}\nIkReal x580=x581.value;\nsj1array[0]=(((gconst11*px*x580))+((gconst10*py*x580)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x582=IKcos(j1);\nIkReal x583=IKsin(j1);\nIkReal x584=px*px;\nIkReal x585=py*py;\nIkReal x586=(gconst10*py);\nIkReal x587=(gconst11*px);\nIkReal x588=((1.52439024390244)*x582);\nIkReal x589=((0.656)*x583);\nevalcond[0]=(((x582*x587))+((x582*x586)));\nevalcond[1]=((0.328)+((x583*x587))+((x583*x586))+(((0.2765)*cj3)));\nevalcond[2]=(((x584*x588))+((x585*x588))+(((0.0474569359756098)*x582)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x585))+(((-1.0)*x584))+(((-1.0)*x586*x589))+(((-1.0)*x587*x589)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x591=IKPowWithIntegerCheck((((cj0*px))+((py*sj0))),-1);\nif(!x591.valid){\ncontinue;\n}\nIkReal x590=x591.value;\nsj1array[0]=((((-0.2765)*cj3*x590))+(((-0.328)*x590)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x592=IKcos(j1);\nIkReal x593=IKsin(j1);\nIkReal x594=px*px;\nIkReal x595=py*py;\nIkReal x596=(cj0*px);\nIkReal x597=(py*sj0);\nIkReal x598=((0.656)*x593);\nIkReal x599=((1.52439024390244)*x592);\nevalcond[0]=(((x592*x597))+((x592*x596)));\nevalcond[1]=((((-1.0)*x597))+(((-1.0)*x596))+(((-0.2765)*cj3*x593))+(((-0.328)*x593)));\nevalcond[2]=((((0.0474569359756098)*x592))+((x594*x599))+((x595*x599)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x597*x598))+(((-1.0)*x596*x598))+(((-1.0)*x595))+(((-1.0)*x594)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x601=IKPowWithIntegerCheck(((-0.328)+(((-0.2765)*cj3))),-1);\nif(!x601.valid){\ncontinue;\n}\nIkReal x600=x601.value;\nsj1array[0]=(((cj0*px*x600))+((py*sj0*x600)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x602=IKcos(j1);\nIkReal x603=IKsin(j1);\nIkReal x604=px*px;\nIkReal x605=py*py;\nIkReal x606=((1.52439024390244)*x602);\nIkReal x607=(py*sj0*x603);\nIkReal x608=(cj0*px*x603);\nevalcond[0]=(((cj0*px*x602))+((py*sj0*x602)));\nevalcond[1]=((0.328)+(((0.2765)*cj3))+x607+x608);\nevalcond[2]=(((x605*x606))+((x604*x606))+(((0.0474569359756098)*x602)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x605))+(((-1.0)*x604))+(((-0.656)*x608))+(((-0.656)*x607)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));\nevalcond[1]=((0.36542025)+(((-1.0)*pp)));\nevalcond[2]=((((-1.0)*px*sj0))+((cj0*py)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nsj1array[0]=((((-1.65425971877585)*py*sj0))+(((-1.65425971877585)*cj0*px)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x609=IKsin(j1);\nIkReal x610=IKcos(j1);\nCheckValue<IkReal> x617=IKPowWithIntegerCheck(cj0,-1);\nif(!x617.valid){\ncontinue;\n}\nIkReal x611=x617.value;\nIkReal x612=sj0*sj0;\nIkReal x613=(x611*x612);\nIkReal x614=(py*sj0*x609);\nIkReal x615=((1.0)*px*x610);\nIkReal x616=(cj0*px*x609);\nevalcond[0]=((0.6045)*x610);\nevalcond[1]=((0.6045)+x614+x616);\nevalcond[2]=((-0.396552)+(((-0.656)*x616))+(((-0.656)*x614)));\nevalcond[3]=((((-1.0)*sj2*x613*x615))+(((-1.0)*cj0*sj2*x615)));\nevalcond[4]=((((-1.0)*cj0*cj2*x615))+(((-1.0)*cj2*x613*x615)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j3, 6.28318530717959)))))+(IKabs(pz)));\nevalcond[1]=((0.00265225)+(((-1.0)*pp)));\nevalcond[2]=((((-1.0)*px*sj0))+((cj0*py)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nsj1array[0]=((((-19.4174757281553)*py*sj0))+(((-19.4174757281553)*cj0*px)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x618=IKsin(j1);\nIkReal x619=IKcos(j1);\nCheckValue<IkReal> x626=IKPowWithIntegerCheck(cj0,-1);\nif(!x626.valid){\ncontinue;\n}\nIkReal x620=x626.value;\nIkReal x621=sj0*sj0;\nIkReal x622=(cj0*px);\nIkReal x623=((1.0)*x619);\nIkReal x624=(py*sj0*x618);\nIkReal x625=(px*x620*x621*x623);\nevalcond[0]=((0.0515)*x619);\nevalcond[1]=((0.0515)+((x618*x622))+x624);\nevalcond[2]=((-0.033784)+(((-0.656)*x624))+(((-0.656)*x618*x622)));\nevalcond[3]=((((-1.0)*sj2*x622*x623))+(((-1.0)*sj2*x625)));\nevalcond[4]=((((-1.0)*cj2*x625))+(((-1.0)*cj2*x622*x623)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x627=py*py;\nIkReal x628=cj0*cj0;\nIkReal x629=(cj0*px);\nIkReal x630=(py*sj0);\nIkReal x631=((2000.0)*pz);\nIkReal x632=(cj2*sj3);\nIkReal x633=((2000.0)*x627);\nCheckValue<IkReal> x634=IKPowWithIntegerCheck(IKsign(((((553.0)*x630*x632))+(((656.0)*pz))+(((553.0)*cj3*pz))+(((553.0)*x629*x632)))),-1);\nif(!x634.valid){\ncontinue;\n}\nCheckValue<IkReal> x635 = IKatan2WithCheck(IkReal(((((-1.0)*x629*x631))+(((-1.0)*x630*x631))+(((-181.384)*x632))+(((-152.9045)*cj3*x632)))),((215.168)+((x628*x633))+(((152.9045)*(cj3*cj3)))+(((-4000.0)*x629*x630))+(((-1.0)*x633))+(((-2000.0)*x628*(px*px)))+(((362.768)*cj3))),IKFAST_ATAN2_MAGTHRESH);\nif(!x635.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x634.value)))+(x635.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x636=IKcos(j1);\nIkReal x637=IKsin(j1);\nIkReal x638=((0.2765)*cj3);\nIkReal x639=(cj0*px);\nIkReal x640=((1.0)*sj0);\nIkReal x641=(py*sj0);\nIkReal x642=((1.0)*pz);\nIkReal x643=((0.2765)*sj3);\nIkReal x644=(cj0*py);\nIkReal x645=((0.656)*x637);\nIkReal x646=((1.0)*x636);\nIkReal x647=(py*x636);\nIkReal x648=(cj2*x637);\nevalcond[0]=(((x636*x638))+(((0.328)*x636))+(((-1.0)*x642))+(((-1.0)*x643*x648)));\nevalcond[1]=((0.328)+((x637*x641))+x638+(((-1.0)*x636*x642))+((x637*x639)));\nevalcond[2]=((-0.03113175)+(((-1.0)*x641*x645))+(((-1.0)*x639*x645))+(((0.656)*pz*x636))+(((-1.0)*pp)));\nevalcond[3]=((((-0.328)*x637))+(((-1.0)*x637*x638))+(((-1.0)*cj2*x636*x643))+(((-1.0)*x639))+(((-1.0)*py*x640)));\nevalcond[4]=((((-1.0)*cj2*px*x640))+(((-1.0)*sj2*x640*x647))+(((-1.0)*sj2*x637*x642))+((cj2*x644))+(((-1.0)*sj2*x639*x646)));\nevalcond[5]=((((-1.0)*x642*x648))+((px*sj0*sj2))+(((-1.0)*x643))+(((-1.0)*sj2*x644))+(((-1.0)*cj2*x639*x646))+(((-1.0)*cj2*x640*x647)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x649=cj2*cj2;\nIkReal x650=cj3*cj3;\nIkReal x651=(py*sj0);\nIkReal x652=((1106000.0)*cj3);\nIkReal x653=(cj0*px);\nIkReal x654=((305809.0)*x650);\nIkReal x655=((1106000.0)*cj2*sj3);\nCheckValue<IkReal> x656 = IKatan2WithCheck(IkReal(((((-1.0)*x651*x652))+(((-1312000.0)*x651))+(((-1312000.0)*x653))+(((-1.0)*pz*x655))+(((-1.0)*x652*x653)))),((((-1.0)*x651*x655))+((pz*x652))+(((1312000.0)*pz))+(((-1.0)*x653*x655))),IKFAST_ATAN2_MAGTHRESH);\nif(!x656.valid){\ncontinue;\n}\nCheckValue<IkReal> x657=IKPowWithIntegerCheck(IKsign(((430336.0)+(((725536.0)*cj3))+(((305809.0)*x649))+x654+(((-1.0)*x649*x654)))),-1);\nif(!x657.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x656.value)+(((1.5707963267949)*(x657.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x658=IKcos(j1);\nIkReal x659=IKsin(j1);\nIkReal x660=((0.2765)*cj3);\nIkReal x661=(cj0*px);\nIkReal x662=((1.0)*sj0);\nIkReal x663=(py*sj0);\nIkReal x664=((1.0)*pz);\nIkReal x665=((0.2765)*sj3);\nIkReal x666=(cj0*py);\nIkReal x667=((0.656)*x659);\nIkReal x668=((1.0)*x658);\nIkReal x669=(py*x658);\nIkReal x670=(cj2*x659);\nevalcond[0]=((((-1.0)*x665*x670))+(((0.328)*x658))+(((-1.0)*x664))+((x658*x660)));\nevalcond[1]=((0.328)+(((-1.0)*x658*x664))+x660+((x659*x661))+((x659*x663)));\nevalcond[2]=((-0.03113175)+(((-1.0)*x663*x667))+(((-1.0)*x661*x667))+(((-1.0)*pp))+(((0.656)*pz*x658)));\nevalcond[3]=((((-1.0)*x659*x660))+(((-1.0)*cj2*x658*x665))+(((-1.0)*x661))+(((-1.0)*py*x662))+(((-0.328)*x659)));\nevalcond[4]=(((cj2*x666))+(((-1.0)*sj2*x659*x664))+(((-1.0)*cj2*px*x662))+(((-1.0)*sj2*x661*x668))+(((-1.0)*sj2*x662*x669)));\nevalcond[5]=((((-1.0)*cj2*x662*x669))+(((-1.0)*sj2*x666))+((px*sj0*sj2))+(((-1.0)*x664*x670))+(((-1.0)*cj2*x661*x668))+(((-1.0)*x665)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x671=(cj0*px);\nIkReal x672=((553.0)*cj3);\nIkReal x673=(cj2*sj3);\nIkReal x674=(py*sj0);\nIkReal x675=((2000.0)*pz);\nCheckValue<IkReal> x676 = IKatan2WithCheck(IkReal(((215.168)+(((152.9045)*(cj3*cj3)))+(((-1.0)*pz*x675))+(((362.768)*cj3)))),((((152.9045)*cj3*x673))+(((181.384)*x673))+(((-1.0)*x671*x675))+(((-1.0)*x674*x675))),IKFAST_ATAN2_MAGTHRESH);\nif(!x676.valid){\ncontinue;\n}\nCheckValue<IkReal> x677=IKPowWithIntegerCheck(IKsign(((((-656.0)*x674))+(((-656.0)*x671))+(((-1.0)*x671*x672))+(((-1.0)*x672*x674))+(((553.0)*pz*x673)))),-1);\nif(!x677.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x676.value)+(((1.5707963267949)*(x677.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x678=IKcos(j1);\nIkReal x679=IKsin(j1);\nIkReal x680=((0.2765)*cj3);\nIkReal x681=(cj0*px);\nIkReal x682=((1.0)*sj0);\nIkReal x683=(py*sj0);\nIkReal x684=((1.0)*pz);\nIkReal x685=((0.2765)*sj3);\nIkReal x686=(cj0*py);\nIkReal x687=((0.656)*x679);\nIkReal x688=((1.0)*x678);\nIkReal x689=(py*x678);\nIkReal x690=(cj2*x679);\nevalcond[0]=(((x678*x680))+(((-1.0)*x684))+(((-1.0)*x685*x690))+(((0.328)*x678)));\nevalcond[1]=((0.328)+(((-1.0)*x678*x684))+((x679*x683))+((x679*x681))+x680);\nevalcond[2]=((-0.03113175)+(((-1.0)*x681*x687))+(((-1.0)*pp))+(((0.656)*pz*x678))+(((-1.0)*x683*x687)));\nevalcond[3]=((((-0.328)*x679))+(((-1.0)*x679*x680))+(((-1.0)*cj2*x678*x685))+(((-1.0)*py*x682))+(((-1.0)*x681)));\nevalcond[4]=((((-1.0)*sj2*x682*x689))+(((-1.0)*sj2*x679*x684))+(((-1.0)*sj2*x681*x688))+(((-1.0)*cj2*px*x682))+((cj2*x686)));\nevalcond[5]=((((-1.0)*x684*x690))+(((-1.0)*x685))+((px*sj0*sj2))+(((-1.0)*cj2*x681*x688))+(((-1.0)*cj2*x682*x689))+(((-1.0)*sj2*x686)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nIkReal x691=((0.328)+(((0.2765)*cj3)));\nCheckValue<IkReal> x694 = IKatan2WithCheck(IkReal(x691),((-0.2765)*cj2*sj3),IKFAST_ATAN2_MAGTHRESH);\nif(!x694.valid){\ncontinue;\n}\nIkReal x692=((1.0)*(x694.value));\nif((((x691*x691)+(((0.07645225)*(cj2*cj2)*(sj3*sj3))))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x695=IKPowWithIntegerCheck(IKabs(IKsqrt(((x691*x691)+(((0.07645225)*(cj2*cj2)*(sj3*sj3)))))),-1);\nif(!x695.valid){\ncontinue;\n}\nif( ((pz*(x695.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x695.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x693=IKasin((pz*(x695.value)));\nj1array[0]=(x693+(((-1.0)*x692)));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nj1array[1]=((3.14159265358979)+(((-1.0)*x692))+(((-1.0)*x693)));\nsj1array[1]=IKsin(j1array[1]);\ncj1array[1]=IKcos(j1array[1]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nif( j1array[1] > IKPI )\n{\n    j1array[1]-=IK2PI;\n}\nelse if( j1array[1] < -IKPI )\n{    j1array[1]+=IK2PI;\n}\nj1valid[1] = true;\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n\n{\nIkReal j0eval[3];\nIkReal x696=pz*pz;\nIkReal x697=((553.0)*cj3);\nIkReal x698=(pp*sj1);\nIkReal x699=((2000.0)*cj1*pz);\nIkReal x700=(sj1*x696);\nIkReal x701=((553.0)*sj1*sj2*sj3);\nj0eval[0]=((((-1.0)*x700))+x698);\nj0eval[1]=((IKabs(((((-1.0)*py*x701))+(((-1.0)*px*x697))+((px*x699))+(((-656.0)*px)))))+(IKabs((((py*x699))+(((-656.0)*py))+((px*x701))+(((-1.0)*py*x697))))));\nj0eval[2]=IKsign(((((2000.0)*x698))+(((-2000.0)*x700))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nIkReal x702=pz*pz;\nIkReal x703=(pp*sj1);\nIkReal x704=((125000.0)*pp);\nIkReal x705=(sj1*x702);\nIkReal x706=((82000.0)*cj1*pz);\nIkReal x707=((22673.0)*sj1*sj2*sj3);\nj0eval[0]=((((-1.0)*x705))+x703);\nj0eval[1]=IKsign(((((82000.0)*x703))+(((-82000.0)*x705))));\nj0eval[2]=((IKabs(((((-1.0)*py*x704))+(((-3891.46875)*py))+((px*x707))+((py*x706)))))+(IKabs(((((-1.0)*py*x707))+(((-3891.46875)*px))+(((-1.0)*px*x704))+((px*x706))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nIkReal x708=pz*pz;\nIkReal x709=(px*sj1);\nIkReal x710=((553.0)*cj3);\nIkReal x711=(py*sj1);\nIkReal x712=((553.0)*sj3);\nIkReal x713=(cj1*cj2);\nj0eval[0]=((((-1.0)*x708))+pp);\nj0eval[1]=IKsign(((((-2000.0)*x708))+(((2000.0)*pp))));\nj0eval[2]=((IKabs(((((-1.0)*py*x712*x713))+(((-1.0)*x710*x711))+((px*sj2*x712))+(((-656.0)*x711)))))+(IKabs(((((-1.0)*x709*x710))+(((-1.0)*px*x712*x713))+(((-1.0)*py*sj2*x712))+(((-656.0)*x709))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x714=((1.0)*pp);\nIkReal x715=((0.328)+(((0.2765)*cj3))+(((-1.0)*pz)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((0.181384)*cj3))+(((-1.0)*x714)));\nevalcond[2]=x715;\nevalcond[3]=x715;\nevalcond[4]=((-0.03113175)+(((-1.0)*x714))+(((0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nIkReal x716=pz*pz;\nIkReal x717=(px*sj3);\nIkReal x718=((1.0)*py*sj3);\nj0eval[0]=((((-1.0)*x716))+pp);\nj0eval[1]=IKsign(((((-2000.0)*x716))+(((2000.0)*pp))));\nj0eval[2]=((IKabs(((((-1.0)*cj2*x717))+(((-1.0)*sj2*x718)))))+(IKabs(((((-1.0)*cj2*x718))+((sj2*x717))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nIkReal x719=cj2*cj2;\nIkReal x720=pz*pz;\nIkReal x721=((1.0)*cj2);\nIkReal x722=(px*sj3);\nIkReal x723=(py*sj3);\nIkReal x724=(cj2*x720);\nj0eval[0]=((((-1.0)*pp*x721))+x724);\nj0eval[1]=((IKabs((((cj2*sj2*x723))+((x719*x722)))))+(IKabs((((x719*x723))+(((-1.0)*sj2*x721*x722))))));\nj0eval[2]=IKsign(((((-2000.0)*cj2*pp))+(((2000.0)*x724))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nIkReal x725=pz*pz;\nIkReal x726=cj2*cj2;\nIkReal x727=(pp*sj2);\nIkReal x728=(sj3*x726);\nIkReal x729=(cj2*sj2*sj3);\nIkReal x730=(sj2*x725);\nj0eval[0]=((((-1.0)*x727))+x730);\nj0eval[1]=IKsign(((((-2000.0)*x727))+(((2000.0)*x730))));\nj0eval[2]=((IKabs((((py*x729))+((px*x728))+(((-1.0)*px*sj3)))))+(IKabs(((((-1.0)*py*x728))+((px*x729))+((py*sj3))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x731=((1.0)*pp);\nIkReal x732=x715;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((0.181384)*cj3))+(((-1.0)*x731)));\nevalcond[2]=x732;\nevalcond[3]=x732;\nevalcond[4]=((-0.03113175)+(((-1.0)*x731))+(((0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[4];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x733=pz*pz;\nj0eval[0]=((((-1.0)*pp))+x733);\nj0eval[1]=IKsign(((((2000.0)*x733))+(((-2000.0)*pp))));\nj0eval[2]=305809.0;\nj0eval[3]=sj3;\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x734=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.36542025)+(((-1.0)*x734)));\nevalcond[2]=((0.6045)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x734))+(((0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=1.0;\nj2=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x736 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x736.valid){\ncontinue;\n}\nIkReal x735=x736.value;\nj0array[0]=((-1.0)*x735);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x735)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x737=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.00265225)+(((-1.0)*x737)));\nevalcond[2]=((0.0515)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x737))+(((0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=1.0;\nj2=0;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x739 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x739.valid){\ncontinue;\n}\nIkReal x738=x739.value;\nj0array[0]=((-1.0)*x738);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x738)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x740=((553.0)*sj3);\nCheckValue<IkReal> x741 = IKatan2WithCheck(IkReal((py*x740)),(px*x740),IKFAST_ATAN2_MAGTHRESH);\nif(!x741.valid){\ncontinue;\n}\nCheckValue<IkReal> x742=IKPowWithIntegerCheck(IKsign(((((2000.0)*(pz*pz)))+(((-2000.0)*pp)))),-1);\nif(!x742.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x741.value)+(((1.5707963267949)*(x742.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x743=IKcos(j0);\nIkReal x744=IKsin(j0);\nIkReal x745=((1.0)*x744);\nevalcond[0]=(((py*x743))+(((-1.0)*px*x745)));\nevalcond[1]=((((-0.2765)*sj3))+(((-1.0)*px*x743))+(((-1.0)*py*x745)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x746=((1.0)*pp);\nIkReal x747=x715;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((0.181384)*cj3))+(((-1.0)*x746)));\nevalcond[2]=x747;\nevalcond[3]=x747;\nevalcond[4]=((-0.03113175)+(((0.656)*pz))+(((-1.0)*x746)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[4];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x748=pz*pz;\nj0eval[0]=(pp+(((-1.0)*x748)));\nj0eval[1]=IKsign(((((-2000.0)*x748))+(((2000.0)*pp))));\nj0eval[2]=305809.0;\nj0eval[3]=sj3;\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x749=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.36542025)+(((-1.0)*x749)));\nevalcond[2]=((0.6045)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((0.656)*pz))+(((-1.0)*x749)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x751 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x751.valid){\ncontinue;\n}\nIkReal x750=x751.value;\nj0array[0]=((-1.0)*x750);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x750)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x752=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.00265225)+(((-1.0)*x752)));\nevalcond[2]=((0.0515)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((0.656)*pz))+(((-1.0)*x752)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x754 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x754.valid){\ncontinue;\n}\nIkReal x753=x754.value;\nj0array[0]=((-1.0)*x753);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x753)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x755=((553.0)*sj3);\nCheckValue<IkReal> x756=IKPowWithIntegerCheck(IKsign(((((2000.0)*pp))+(((-2000.0)*(pz*pz))))),-1);\nif(!x756.valid){\ncontinue;\n}\nCheckValue<IkReal> x757 = IKatan2WithCheck(IkReal((py*x755)),(px*x755),IKFAST_ATAN2_MAGTHRESH);\nif(!x757.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x756.value)))+(x757.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x758=IKcos(j0);\nIkReal x759=IKsin(j0);\nIkReal x760=((1.0)*x759);\nevalcond[0]=(((py*x758))+(((-1.0)*px*x760)));\nevalcond[1]=((((-1.0)*py*x760))+(((0.2765)*sj3))+(((-1.0)*px*x758)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x761=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.36542025)+(((-1.0)*x761)));\nevalcond[2]=((0.6045)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x761))+(((0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nIkReal x762=((1.0)*px);\nj0eval[0]=((IKabs((((cj2*py))+(((-1.0)*sj2*x762)))))+(IKabs(((((-1.0)*cj2*x762))+(((-1.0)*py*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nIkReal x763=((1.0)*py);\nj0eval[0]=((IKabs(((((-1.0)*cj2*px))+(((-1.0)*sj2*x763)))))+(IKabs(((((-1.0)*cj2*x763))+((px*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x764=((1.0)*cj2);\nCheckValue<IkReal> x766 = IKatan2WithCheck(IkReal(((((-1.0)*px*x764))+(((-1.0)*py*sj2)))),((((-1.0)*py*x764))+((px*sj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x766.valid){\ncontinue;\n}\nIkReal x765=x766.value;\nj0array[0]=((-1.0)*x765);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x765)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x767=IKcos(j0);\nIkReal x768=IKsin(j0);\nIkReal x769=((1.0)*px);\nIkReal x770=(py*x767);\nIkReal x771=((1.0)*py*x768);\nevalcond[0]=(x770+(((-1.0)*x768*x769)));\nevalcond[1]=((((-1.0)*x767*x769))+(((-1.0)*x771)));\nevalcond[2]=((((-1.0)*sj2*x771))+(((-1.0)*cj2*x768*x769))+((cj2*x770))+(((-1.0)*sj2*x767*x769)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x772=((1.0)*px);\nCheckValue<IkReal> x774 = IKatan2WithCheck(IkReal(((((-1.0)*sj2*x772))+((cj2*py)))),((((-1.0)*py*sj2))+(((-1.0)*cj2*x772))),IKFAST_ATAN2_MAGTHRESH);\nif(!x774.valid){\ncontinue;\n}\nIkReal x773=x774.value;\nj0array[0]=((-1.0)*x773);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x773)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x775=IKcos(j0);\nIkReal x776=IKsin(j0);\nIkReal x777=((1.0)*x775);\nIkReal x778=(px*x776);\nIkReal x779=((1.0)*py*x776);\nevalcond[0]=((((-1.0)*x778))+((py*x775)));\nevalcond[1]=((((-1.0)*px*x777))+(((-1.0)*x779)));\nevalcond[2]=((((-1.0)*py*sj2*x777))+(((-1.0)*cj2*px*x777))+((sj2*x778))+(((-1.0)*cj2*x779)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x781 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x781.valid){\ncontinue;\n}\nIkReal x780=x781.value;\nj0array[0]=((-1.0)*x780);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x780)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x782=IKcos(j0);\nIkReal x783=IKsin(j0);\nIkReal x784=((1.0)*px);\nIkReal x785=(cj2*x783);\nIkReal x786=(py*x782);\nIkReal x787=((1.0)*py*x783);\nevalcond[0]=((((-1.0)*x787))+(((-1.0)*x782*x784)));\nevalcond[1]=((((-1.0)*sj2*x782*x784))+(((-1.0)*x784*x785))+(((-1.0)*sj2*x787))+((cj2*x786)));\nevalcond[2]=((((-1.0)*sj2*x786))+((px*sj2*x783))+(((-1.0)*cj2*x782*x784))+(((-1.0)*py*x785)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x788=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.00265225)+(((-1.0)*x788)));\nevalcond[2]=((0.0515)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x788))+(((0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nIkReal x789=((1.0)*px);\nj0eval[0]=((IKabs(((((-1.0)*cj2*x789))+(((-1.0)*py*sj2)))))+(IKabs((((cj2*py))+(((-1.0)*sj2*x789))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nIkReal x790=((1.0)*py);\nj0eval[0]=((IKabs(((((-1.0)*cj2*px))+(((-1.0)*sj2*x790)))))+(IKabs(((((-1.0)*cj2*x790))+((px*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x791=((1.0)*cj2);\nCheckValue<IkReal> x793 = IKatan2WithCheck(IkReal(((((-1.0)*px*x791))+(((-1.0)*py*sj2)))),(((px*sj2))+(((-1.0)*py*x791))),IKFAST_ATAN2_MAGTHRESH);\nif(!x793.valid){\ncontinue;\n}\nIkReal x792=x793.value;\nj0array[0]=((-1.0)*x792);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x792)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x794=IKcos(j0);\nIkReal x795=IKsin(j0);\nIkReal x796=((1.0)*px);\nIkReal x797=(py*x794);\nIkReal x798=((1.0)*py*x795);\nevalcond[0]=((((-1.0)*x795*x796))+x797);\nevalcond[1]=((((-1.0)*x794*x796))+(((-1.0)*x798)));\nevalcond[2]=((((-1.0)*cj2*x795*x796))+(((-1.0)*sj2*x794*x796))+(((-1.0)*sj2*x798))+((cj2*x797)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nIkReal x799=((1.0)*px);\nCheckValue<IkReal> x801 = IKatan2WithCheck(IkReal((((cj2*py))+(((-1.0)*sj2*x799)))),((((-1.0)*cj2*x799))+(((-1.0)*py*sj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x801.valid){\ncontinue;\n}\nIkReal x800=x801.value;\nj0array[0]=((-1.0)*x800);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x800)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x802=IKcos(j0);\nIkReal x803=IKsin(j0);\nIkReal x804=((1.0)*x802);\nIkReal x805=(px*x803);\nIkReal x806=((1.0)*py*x803);\nevalcond[0]=((((-1.0)*x805))+((py*x802)));\nevalcond[1]=((((-1.0)*px*x804))+(((-1.0)*x806)));\nevalcond[2]=(((sj2*x805))+(((-1.0)*py*sj2*x804))+(((-1.0)*cj2*x806))+(((-1.0)*cj2*px*x804)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x808 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x808.valid){\ncontinue;\n}\nIkReal x807=x808.value;\nj0array[0]=((-1.0)*x807);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x807)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x809=IKcos(j0);\nIkReal x810=IKsin(j0);\nIkReal x811=((1.0)*px);\nIkReal x812=(cj2*x810);\nIkReal x813=(py*x809);\nIkReal x814=((1.0)*py*x810);\nevalcond[0]=((((-1.0)*x809*x811))+(((-1.0)*x814)));\nevalcond[1]=((((-1.0)*x811*x812))+(((-1.0)*sj2*x809*x811))+(((-1.0)*sj2*x814))+((cj2*x813)));\nevalcond[2]=((((-1.0)*cj2*x809*x811))+(((-1.0)*sj2*x813))+((px*sj2*x810))+(((-1.0)*py*x812)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x815=((1.0)*pp);\nIkReal x816=x715;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((-1.0)*x815))+(((0.181384)*cj3)));\nevalcond[2]=x816;\nevalcond[3]=x816;\nevalcond[4]=((-0.03113175)+(((-1.0)*x815))+(((0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[4];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nIkReal x817=pz*pz;\nj0eval[0]=((((-1.0)*x817))+pp);\nj0eval[1]=IKsign(((((-2000.0)*x817))+(((2000.0)*pp))));\nj0eval[2]=305809.0;\nj0eval[3]=sj3;\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x818=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.36542025)+(((-1.0)*x818)));\nevalcond[2]=((0.6045)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x818))+(((0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x820 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x820.valid){\ncontinue;\n}\nIkReal x819=x820.value;\nj0array[0]=((-1.0)*x819);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x819)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x821=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.00265225)+(((-1.0)*x821)));\nevalcond[2]=((0.0515)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x821))+(((0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x823 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x823.valid){\ncontinue;\n}\nIkReal x822=x823.value;\nj0array[0]=((-1.0)*x822);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x822)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nCheckValue<IkReal> x824=IKPowWithIntegerCheck(IKsign(((((2000.0)*pp))+(((-2000.0)*(pz*pz))))),-1);\nif(!x824.valid){\ncontinue;\n}\nCheckValue<IkReal> x825 = IKatan2WithCheck(IkReal(((553.0)*px*sj3)),((-553.0)*py*sj3),IKFAST_ATAN2_MAGTHRESH);\nif(!x825.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x824.value)))+(x825.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x826=IKcos(j0);\nIkReal x827=IKsin(j0);\nIkReal x828=((1.0)*px);\nevalcond[0]=((((-1.0)*x826*x828))+(((-1.0)*py*x827)));\nevalcond[1]=(((py*x826))+(((-1.0)*x827*x828))+(((0.2765)*sj3)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x829=((1.0)*pp);\nIkReal x830=x715;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((-1.0)*x829))+(((0.181384)*cj3)));\nevalcond[2]=x830;\nevalcond[3]=x830;\nevalcond[4]=((-0.03113175)+(((-1.0)*x829))+(((0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[4];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nIkReal x831=pz*pz;\nj0eval[0]=((((-1.0)*pp))+x831);\nj0eval[1]=IKsign(((((2000.0)*x831))+(((-2000.0)*pp))));\nj0eval[2]=305809.0;\nj0eval[3]=sj3;\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x832=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.36542025)+(((-1.0)*x832)));\nevalcond[2]=((0.6045)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x832))+(((0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x834 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x834.valid){\ncontinue;\n}\nIkReal x833=x834.value;\nj0array[0]=((-1.0)*x833);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x833)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x835=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.00265225)+(((-1.0)*x835)));\nevalcond[2]=((0.0515)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x835))+(((0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=1.0;\nj1=0;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x837 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x837.valid){\ncontinue;\n}\nIkReal x836=x837.value;\nj0array[0]=((-1.0)*x836);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x836)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nCheckValue<IkReal> x838=IKPowWithIntegerCheck(IKsign(((((2000.0)*(pz*pz)))+(((-2000.0)*pp)))),-1);\nif(!x838.valid){\ncontinue;\n}\nCheckValue<IkReal> x839 = IKatan2WithCheck(IkReal(((553.0)*px*sj3)),((-553.0)*py*sj3),IKFAST_ATAN2_MAGTHRESH);\nif(!x839.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x838.value)))+(x839.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x840=IKcos(j0);\nIkReal x841=IKsin(j0);\nIkReal x842=((1.0)*px);\nevalcond[0]=((((-1.0)*x840*x842))+(((-1.0)*py*x841)));\nevalcond[1]=((((-0.2765)*sj3))+(((-1.0)*x841*x842))+((py*x840)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x843=cj2*cj2;\nIkReal x844=((553.0)*sj3);\nIkReal x845=(cj2*sj2);\nIkReal x846=((2000.0)*sj2);\nCheckValue<IkReal> x847 = IKatan2WithCheck(IkReal((((py*x844*x845))+(((-1.0)*px*x844))+((px*x843*x844)))),((((-1.0)*py*x843*x844))+((py*x844))+((px*x844*x845))),IKFAST_ATAN2_MAGTHRESH);\nif(!x847.valid){\ncontinue;\n}\nCheckValue<IkReal> x848=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp*x846))+((x846*(pz*pz))))),-1);\nif(!x848.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x847.value)+(((1.5707963267949)*(x848.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x849=IKcos(j0);\nIkReal x850=IKsin(j0);\nIkReal x851=((1.0)*px);\nIkReal x852=((0.2765)*sj3);\nIkReal x853=(cj2*x850);\nIkReal x854=(py*x849);\nIkReal x855=((1.0)*py*x850);\nevalcond[0]=(((sj2*x852))+(((-1.0)*x850*x851))+x854);\nevalcond[1]=((((-1.0)*x855))+(((-1.0)*x849*x851))+(((-1.0)*cj2*x852)));\nevalcond[2]=(((cj2*x854))+(((-1.0)*sj2*x849*x851))+(((-1.0)*sj2*x855))+(((-1.0)*x851*x853)));\nevalcond[3]=(((px*sj2*x850))+(((-1.0)*x852))+(((-1.0)*py*x853))+(((-1.0)*sj2*x854))+(((-1.0)*cj2*x849*x851)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x856=cj2*cj2;\nIkReal x857=((2000.0)*cj2);\nIkReal x858=((553.0)*sj3);\nIkReal x859=(cj2*sj2);\nCheckValue<IkReal> x860 = IKatan2WithCheck(IkReal(((((-1.0)*px*x858*x859))+((py*x856*x858)))),(((py*x858*x859))+((px*x856*x858))),IKFAST_ATAN2_MAGTHRESH);\nif(!x860.valid){\ncontinue;\n}\nCheckValue<IkReal> x861=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp*x857))+((x857*(pz*pz))))),-1);\nif(!x861.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x860.value)+(((1.5707963267949)*(x861.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x862=IKcos(j0);\nIkReal x863=IKsin(j0);\nIkReal x864=((1.0)*px);\nIkReal x865=((0.2765)*sj3);\nIkReal x866=(cj2*x863);\nIkReal x867=(py*x862);\nIkReal x868=((1.0)*py*x863);\nevalcond[0]=(((sj2*x865))+x867+(((-1.0)*x863*x864)));\nevalcond[1]=((((-1.0)*x868))+(((-1.0)*cj2*x865))+(((-1.0)*x862*x864)));\nevalcond[2]=(((cj2*x867))+(((-1.0)*sj2*x868))+(((-1.0)*x864*x866))+(((-1.0)*sj2*x862*x864)));\nevalcond[3]=((((-1.0)*x865))+(((-1.0)*sj2*x867))+(((-1.0)*py*x866))+(((-1.0)*cj2*x862*x864))+((px*sj2*x863)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x869=((553.0)*sj3);\nCheckValue<IkReal> x870=IKPowWithIntegerCheck(IKsign(((((2000.0)*pp))+(((-2000.0)*(pz*pz))))),-1);\nif(!x870.valid){\ncontinue;\n}\nCheckValue<IkReal> x871 = IKatan2WithCheck(IkReal(((((-1.0)*cj2*py*x869))+((px*sj2*x869)))),((((-1.0)*cj2*px*x869))+(((-1.0)*py*sj2*x869))),IKFAST_ATAN2_MAGTHRESH);\nif(!x871.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x870.value)))+(x871.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x872=IKcos(j0);\nIkReal x873=IKsin(j0);\nIkReal x874=((1.0)*px);\nIkReal x875=((0.2765)*sj3);\nIkReal x876=(cj2*x873);\nIkReal x877=(py*x872);\nIkReal x878=((1.0)*py*x873);\nevalcond[0]=(((sj2*x875))+(((-1.0)*x873*x874))+x877);\nevalcond[1]=((((-1.0)*x872*x874))+(((-1.0)*cj2*x875))+(((-1.0)*x878)));\nevalcond[2]=(((cj2*x877))+(((-1.0)*sj2*x872*x874))+(((-1.0)*sj2*x878))+(((-1.0)*x874*x876)));\nevalcond[3]=((((-1.0)*sj2*x877))+(((-1.0)*py*x876))+(((-1.0)*cj2*x872*x874))+((px*sj2*x873))+(((-1.0)*x875)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x879=((0.2765)*cj3);\nIkReal x880=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((0.181384)*cj3))+(((-1.0)*x880)));\nevalcond[2]=((-0.328)+(((-1.0)*pz))+(((-1.0)*x879)));\nevalcond[3]=((0.328)+pz+x879);\nevalcond[4]=((-0.03113175)+(((-0.656)*pz))+(((-1.0)*x880)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nIkReal x881=pz*pz;\nIkReal x882=(px*sj3);\nIkReal x883=(py*sj3);\nj0eval[0]=((((-1.0)*x881))+pp);\nj0eval[1]=IKsign(((((-2000.0)*x881))+(((2000.0)*pp))));\nj0eval[2]=((IKabs((((cj2*x883))+((sj2*x882)))))+(IKabs((((cj2*x882))+(((-1.0)*sj2*x883))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nIkReal x884=cj2*cj2;\nIkReal x885=pz*pz;\nIkReal x886=(px*sj3);\nIkReal x887=(cj2*sj2);\nIkReal x888=(py*sj3);\nIkReal x889=(cj2*pp);\nIkReal x890=(cj2*x885);\nj0eval[0]=((((-1.0)*x890))+x889);\nj0eval[1]=((IKabs(((((-1.0)*x887*x888))+((x884*x886)))))+(IKabs((((x886*x887))+((x884*x888))))));\nj0eval[2]=IKsign(((((-2000.0)*x890))+(((2000.0)*x889))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nIkReal x891=cj2*cj2;\nIkReal x892=pz*pz;\nIkReal x893=(pp*sj2);\nIkReal x894=(px*sj3);\nIkReal x895=(cj2*sj2);\nIkReal x896=(py*sj3);\nIkReal x897=(sj2*x892);\nj0eval[0]=((((-1.0)*x897))+x893);\nj0eval[1]=((IKabs((((x895*x896))+(((-1.0)*x891*x894))+x894)))+(IKabs((((x894*x895))+(((-1.0)*x896))+((x891*x896))))));\nj0eval[2]=IKsign(((((-2000.0)*x897))+(((2000.0)*x893))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x898=((0.2765)*cj3);\nIkReal x899=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((-1.0)*x899))+(((0.181384)*cj3)));\nevalcond[2]=((-0.328)+(((-1.0)*x898))+(((-1.0)*pz)));\nevalcond[3]=((0.328)+pz+x898);\nevalcond[4]=((-0.03113175)+(((-1.0)*x899))+(((-0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[4];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=1.0;\nj2=0;\nIkReal x900=pz*pz;\nj0eval[0]=(pp+(((-1.0)*x900)));\nj0eval[1]=IKsign(((((-2000.0)*x900))+(((2000.0)*pp))));\nj0eval[2]=305809.0;\nj0eval[3]=sj3;\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x901=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.36542025)+(((-1.0)*x901)));\nevalcond[2]=((-0.6045)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x901))+(((-0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=1.0;\nj2=0;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x903 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x903.valid){\ncontinue;\n}\nIkReal x902=x903.value;\nj0array[0]=((-1.0)*x902);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x902)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x904=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.00265225)+(((-1.0)*x904)));\nevalcond[2]=((-0.0515)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x904))+(((-0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=1.0;\nj2=0;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x906 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x906.valid){\ncontinue;\n}\nIkReal x905=x906.value;\nj0array[0]=((-1.0)*x905);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x905)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x907=((553.0)*sj3);\nCheckValue<IkReal> x908 = IKatan2WithCheck(IkReal((py*x907)),(px*x907),IKFAST_ATAN2_MAGTHRESH);\nif(!x908.valid){\ncontinue;\n}\nCheckValue<IkReal> x909=IKPowWithIntegerCheck(IKsign(((((2000.0)*pp))+(((-2000.0)*(pz*pz))))),-1);\nif(!x909.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x908.value)+(((1.5707963267949)*(x909.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x910=IKcos(j0);\nIkReal x911=IKsin(j0);\nIkReal x912=((1.0)*x911);\nevalcond[0]=((((-1.0)*px*x912))+((py*x910)));\nevalcond[1]=((((-1.0)*py*x912))+(((0.2765)*sj3))+(((-1.0)*px*x910)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x913=((0.2765)*cj3);\nIkReal x914=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((-1.0)*x914))+(((0.181384)*cj3)));\nevalcond[2]=((-0.328)+(((-1.0)*x913))+(((-1.0)*pz)));\nevalcond[3]=((0.328)+pz+x913);\nevalcond[4]=((-0.03113175)+(((-1.0)*x914))+(((-0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[4];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nIkReal x915=pz*pz;\nj0eval[0]=((((-1.0)*pp))+x915);\nj0eval[1]=IKsign(((((2000.0)*x915))+(((-2000.0)*pp))));\nj0eval[2]=305809.0;\nj0eval[3]=sj3;\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x916=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.36542025)+(((-1.0)*x916)));\nevalcond[2]=((-0.6045)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x916))+(((-0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x918 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x918.valid){\ncontinue;\n}\nIkReal x917=x918.value;\nj0array[0]=((-1.0)*x917);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x917)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x919=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.00265225)+(((-1.0)*x919)));\nevalcond[2]=((-0.0515)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x919))+(((-0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=0;\ncj2=-1.0;\nj2=3.14159265358979;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x921 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x921.valid){\ncontinue;\n}\nIkReal x920=x921.value;\nj0array[0]=((-1.0)*x920);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x920)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x922=((553.0)*sj3);\nCheckValue<IkReal> x923=IKPowWithIntegerCheck(IKsign(((((2000.0)*(pz*pz)))+(((-2000.0)*pp)))),-1);\nif(!x923.valid){\ncontinue;\n}\nCheckValue<IkReal> x924 = IKatan2WithCheck(IkReal((py*x922)),(px*x922),IKFAST_ATAN2_MAGTHRESH);\nif(!x924.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x923.value)))+(x924.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x925=IKcos(j0);\nIkReal x926=IKsin(j0);\nIkReal x927=((1.0)*x926);\nevalcond[0]=((((-1.0)*px*x927))+((py*x925)));\nevalcond[1]=((((-0.2765)*sj3))+(((-1.0)*py*x927))+(((-1.0)*px*x925)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x928=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.36542025)+(((-1.0)*x928)));\nevalcond[2]=((-0.6045)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x928))+(((-0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(((((-1.0)*cj2*px))+((py*sj2)))))+(IKabs((((cj2*py))+((px*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs((((cj2*px))+(((-1.0)*py*sj2)))))+(IKabs((((cj2*py))+((px*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x930 = IKatan2WithCheck(IkReal((((cj2*px))+(((-1.0)*py*sj2)))),(((cj2*py))+((px*sj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x930.valid){\ncontinue;\n}\nIkReal x929=x930.value;\nj0array[0]=((-1.0)*x929);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x929)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x931=IKcos(j0);\nIkReal x932=IKsin(j0);\nIkReal x933=((1.0)*px);\nIkReal x934=(py*x931);\nIkReal x935=(py*x932);\nevalcond[0]=((((-1.0)*x932*x933))+x934);\nevalcond[1]=((((-1.0)*x931*x933))+(((-1.0)*x935)));\nevalcond[2]=((((-1.0)*cj2*x932*x933))+((cj2*x934))+((px*sj2*x931))+((sj2*x935)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x937 = IKatan2WithCheck(IkReal((((cj2*py))+((px*sj2)))),((((-1.0)*cj2*px))+((py*sj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x937.valid){\ncontinue;\n}\nIkReal x936=x937.value;\nj0array[0]=((-1.0)*x936);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x936)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x938=IKcos(j0);\nIkReal x939=IKsin(j0);\nIkReal x940=((1.0)*x938);\nIkReal x941=(py*x939);\nIkReal x942=(px*x939);\nevalcond[0]=((((-1.0)*x942))+((py*x938)));\nevalcond[1]=((((-1.0)*x941))+(((-1.0)*px*x940)));\nevalcond[2]=(((sj2*x942))+((cj2*px*x938))+((cj2*x941))+(((-1.0)*py*sj2*x940)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x944 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x944.valid){\ncontinue;\n}\nIkReal x943=x944.value;\nj0array[0]=((-1.0)*x943);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x943)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x945=IKcos(j0);\nIkReal x946=IKsin(j0);\nIkReal x947=((1.0)*px);\nIkReal x948=(px*sj2);\nIkReal x949=(cj2*x946);\nIkReal x950=(py*x945);\nIkReal x951=(py*x946);\nevalcond[0]=((((-1.0)*x945*x947))+(((-1.0)*x951)));\nevalcond[1]=(((x945*x948))+(((-1.0)*x947*x949))+((cj2*x950))+((sj2*x951)));\nevalcond[2]=(((x946*x948))+((cj2*px*x945))+(((-1.0)*sj2*x950))+((py*x949)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x952=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.00265225)+(((-1.0)*x952)));\nevalcond[2]=((-0.0515)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-0.656)*pz))+(((-1.0)*x952)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(((((-1.0)*cj2*px))+((py*sj2)))))+(IKabs((((cj2*py))+((px*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs((((cj2*px))+(((-1.0)*py*sj2)))))+(IKabs((((cj2*py))+((px*sj2))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x954 = IKatan2WithCheck(IkReal((((cj2*px))+(((-1.0)*py*sj2)))),(((cj2*py))+((px*sj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x954.valid){\ncontinue;\n}\nIkReal x953=x954.value;\nj0array[0]=((-1.0)*x953);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x953)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x955=IKcos(j0);\nIkReal x956=IKsin(j0);\nIkReal x957=((1.0)*px);\nIkReal x958=(py*x955);\nIkReal x959=(py*x956);\nevalcond[0]=((((-1.0)*x956*x957))+x958);\nevalcond[1]=((((-1.0)*x959))+(((-1.0)*x955*x957)));\nevalcond[2]=(((px*sj2*x955))+(((-1.0)*cj2*x956*x957))+((cj2*x958))+((sj2*x959)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x961 = IKatan2WithCheck(IkReal((((cj2*py))+((px*sj2)))),((((-1.0)*cj2*px))+((py*sj2))),IKFAST_ATAN2_MAGTHRESH);\nif(!x961.valid){\ncontinue;\n}\nIkReal x960=x961.value;\nj0array[0]=((-1.0)*x960);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x960)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x962=IKcos(j0);\nIkReal x963=IKsin(j0);\nIkReal x964=((1.0)*x962);\nIkReal x965=(py*x963);\nIkReal x966=(px*x963);\nevalcond[0]=((((-1.0)*x966))+((py*x962)));\nevalcond[1]=((((-1.0)*x965))+(((-1.0)*px*x964)));\nevalcond[2]=(((cj2*px*x962))+(((-1.0)*py*sj2*x964))+((cj2*x965))+((sj2*x966)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x968 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x968.valid){\ncontinue;\n}\nIkReal x967=x968.value;\nj0array[0]=((-1.0)*x967);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x967)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x969=IKcos(j0);\nIkReal x970=IKsin(j0);\nIkReal x971=((1.0)*px);\nIkReal x972=(px*sj2);\nIkReal x973=(cj2*x970);\nIkReal x974=(py*x969);\nIkReal x975=(py*x970);\nevalcond[0]=((((-1.0)*x969*x971))+(((-1.0)*x975)));\nevalcond[1]=(((x969*x972))+(((-1.0)*x971*x973))+((cj2*x974))+((sj2*x975)));\nevalcond[2]=(((cj2*px*x969))+((py*x973))+((x970*x972))+(((-1.0)*sj2*x974)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x976=((0.2765)*cj3);\nIkReal x977=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((0.181384)*cj3))+(((-1.0)*x977)));\nevalcond[2]=((-0.328)+(((-1.0)*pz))+(((-1.0)*x976)));\nevalcond[3]=((0.328)+pz+x976);\nevalcond[4]=((-0.03113175)+(((-0.656)*pz))+(((-1.0)*x977)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[4];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nIkReal x978=pz*pz;\nj0eval[0]=((((-1.0)*x978))+pp);\nj0eval[1]=IKsign(((((2000.0)*pp))+(((-2000.0)*x978))));\nj0eval[2]=305809.0;\nj0eval[3]=sj3;\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x979=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.36542025)+(((-1.0)*x979)));\nevalcond[2]=((-0.6045)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-0.656)*pz))+(((-1.0)*x979)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x981 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x981.valid){\ncontinue;\n}\nIkReal x980=x981.value;\nj0array[0]=((-1.0)*x980);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x980)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x982=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.00265225)+(((-1.0)*x982)));\nevalcond[2]=((-0.0515)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x982))+(((-0.656)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=1.0;\ncj2=0;\nj2=1.5707963267949;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x984 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x984.valid){\ncontinue;\n}\nIkReal x983=x984.value;\nj0array[0]=((-1.0)*x983);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x983)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nCheckValue<IkReal> x985=IKPowWithIntegerCheck(IKsign(((((2000.0)*pp))+(((-2000.0)*(pz*pz))))),-1);\nif(!x985.valid){\ncontinue;\n}\nCheckValue<IkReal> x986 = IKatan2WithCheck(IkReal(((553.0)*px*sj3)),((-553.0)*py*sj3),IKFAST_ATAN2_MAGTHRESH);\nif(!x986.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x985.value)))+(x986.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x987=IKcos(j0);\nIkReal x988=IKsin(j0);\nIkReal x989=((1.0)*px);\nevalcond[0]=((((-1.0)*py*x988))+(((-1.0)*x987*x989)));\nevalcond[1]=((((-1.0)*x988*x989))+(((0.2765)*sj3))+((py*x987)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x990=((0.2765)*cj3);\nIkReal x991=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((0.181384)*cj3))+(((-1.0)*x991)));\nevalcond[2]=((-0.328)+(((-1.0)*pz))+(((-1.0)*x990)));\nevalcond[3]=((0.328)+pz+x990);\nevalcond[4]=((-0.03113175)+(((-0.656)*pz))+(((-1.0)*x991)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[4];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nIkReal x992=pz*pz;\nj0eval[0]=((((-1.0)*pp))+x992);\nj0eval[1]=IKsign(((((2000.0)*x992))+(((-2000.0)*pp))));\nj0eval[2]=305809.0;\nj0eval[3]=sj3;\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x993=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=((0.36542025)+(((-1.0)*x993)));\nevalcond[2]=((-0.6045)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-0.656)*pz))+(((-1.0)*x993)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj3=0;\ncj3=1.0;\nj3=0;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x995 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x995.valid){\ncontinue;\n}\nIkReal x994=x995.value;\nj0array[0]=((-1.0)*x994);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x994)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x996=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=((0.00265225)+(((-1.0)*x996)));\nevalcond[2]=((-0.0515)+(((-1.0)*pz)));\nevalcond[3]=((-0.03113175)+(((-0.656)*pz))+(((-1.0)*x996)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[1];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nsj2=-1.0;\ncj2=0;\nj2=-1.5707963267949;\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nj0eval[0]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  )\n{\ncontinue; // 3 cases reached\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x998 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x998.valid){\ncontinue;\n}\nIkReal x997=x998.value;\nj0array[0]=((-1.0)*x997);\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x997)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nCheckValue<IkReal> x999=IKPowWithIntegerCheck(IKsign(((((2000.0)*(pz*pz)))+(((-2000.0)*pp)))),-1);\nif(!x999.valid){\ncontinue;\n}\nCheckValue<IkReal> x1000 = IKatan2WithCheck(IkReal(((553.0)*px*sj3)),((-553.0)*py*sj3),IKFAST_ATAN2_MAGTHRESH);\nif(!x1000.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x999.value)))+(x1000.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x1001=IKcos(j0);\nIkReal x1002=IKsin(j0);\nIkReal x1003=((1.0)*px);\nevalcond[0]=((((-1.0)*py*x1002))+(((-1.0)*x1001*x1003)));\nevalcond[1]=((((-0.2765)*sj3))+((py*x1001))+(((-1.0)*x1002*x1003)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1004=cj2*cj2;\nIkReal x1005=((553.0)*sj3);\nIkReal x1006=(cj2*sj2);\nIkReal x1007=((2000.0)*sj2);\nCheckValue<IkReal> x1008=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1007*(pz*pz)))+((pp*x1007)))),-1);\nif(!x1008.valid){\ncontinue;\n}\nCheckValue<IkReal> x1009 = IKatan2WithCheck(IkReal((((px*x1005))+((py*x1005*x1006))+(((-1.0)*px*x1004*x1005)))),(((px*x1005*x1006))+(((-1.0)*py*x1005))+((py*x1004*x1005))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1009.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1008.value)))+(x1009.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x1010=IKcos(j0);\nIkReal x1011=IKsin(j0);\nIkReal x1012=((1.0)*px);\nIkReal x1013=((0.2765)*sj3);\nIkReal x1014=(px*sj2);\nIkReal x1015=(cj2*x1011);\nIkReal x1016=(py*x1010);\nIkReal x1017=(py*x1011);\nevalcond[0]=((((-1.0)*x1011*x1012))+x1016+((sj2*x1013)));\nevalcond[1]=((((-1.0)*x1010*x1012))+((cj2*x1013))+(((-1.0)*x1017)));\nevalcond[2]=((((-1.0)*x1012*x1015))+((cj2*x1016))+((sj2*x1017))+((x1010*x1014)));\nevalcond[3]=((((-1.0)*sj2*x1016))+(((-1.0)*x1013))+((py*x1015))+((cj2*px*x1010))+((x1011*x1014)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1018=cj2*cj2;\nIkReal x1019=((2000.0)*cj2);\nIkReal x1020=((553.0)*sj3*x1018);\nIkReal x1021=((553.0)*cj2*sj2*sj3);\nCheckValue<IkReal> x1022 = IKatan2WithCheck(IkReal((((py*x1020))+((px*x1021)))),((((-1.0)*py*x1021))+((px*x1020))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1022.valid){\ncontinue;\n}\nCheckValue<IkReal> x1023=IKPowWithIntegerCheck(IKsign((((pp*x1019))+(((-1.0)*x1019*(pz*pz))))),-1);\nif(!x1023.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1022.value)+(((1.5707963267949)*(x1023.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x1024=IKcos(j0);\nIkReal x1025=IKsin(j0);\nIkReal x1026=((1.0)*px);\nIkReal x1027=((0.2765)*sj3);\nIkReal x1028=(px*sj2);\nIkReal x1029=(cj2*x1025);\nIkReal x1030=(py*x1024);\nIkReal x1031=(py*x1025);\nevalcond[0]=(x1030+(((-1.0)*x1025*x1026))+((sj2*x1027)));\nevalcond[1]=(((cj2*x1027))+(((-1.0)*x1031))+(((-1.0)*x1024*x1026)));\nevalcond[2]=(((cj2*x1030))+(((-1.0)*x1026*x1029))+((sj2*x1031))+((x1024*x1028)));\nevalcond[3]=(((cj2*px*x1024))+((py*x1029))+(((-1.0)*x1027))+((x1025*x1028))+(((-1.0)*sj2*x1030)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1032=((553.0)*sj3);\nCheckValue<IkReal> x1033 = IKatan2WithCheck(IkReal((((cj2*py*x1032))+((px*sj2*x1032)))),((((-1.0)*py*sj2*x1032))+((cj2*px*x1032))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1033.valid){\ncontinue;\n}\nCheckValue<IkReal> x1034=IKPowWithIntegerCheck(IKsign(((((2000.0)*pp))+(((-2000.0)*(pz*pz))))),-1);\nif(!x1034.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1033.value)+(((1.5707963267949)*(x1034.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[4];\nIkReal x1035=IKcos(j0);\nIkReal x1036=IKsin(j0);\nIkReal x1037=((1.0)*px);\nIkReal x1038=((0.2765)*sj3);\nIkReal x1039=(px*sj2);\nIkReal x1040=(cj2*x1036);\nIkReal x1041=(py*x1035);\nIkReal x1042=(py*x1036);\nevalcond[0]=(x1041+(((-1.0)*x1036*x1037))+((sj2*x1038)));\nevalcond[1]=(((cj2*x1038))+(((-1.0)*x1035*x1037))+(((-1.0)*x1042)));\nevalcond[2]=(((sj2*x1042))+((cj2*x1041))+(((-1.0)*x1037*x1040))+((x1035*x1039)));\nevalcond[3]=(((x1036*x1039))+(((-1.0)*x1038))+(((-1.0)*sj2*x1041))+((py*x1040))+((cj2*px*x1035)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1043=(px*sj1);\nIkReal x1044=((553.0)*cj3);\nIkReal x1045=(py*sj1);\nIkReal x1046=((553.0)*sj3);\nIkReal x1047=(cj1*cj2);\nCheckValue<IkReal> x1048=IKPowWithIntegerCheck(IKsign(((((2000.0)*pp))+(((-2000.0)*(pz*pz))))),-1);\nif(!x1048.valid){\ncontinue;\n}\nCheckValue<IkReal> x1049 = IKatan2WithCheck(IkReal(((((-656.0)*x1045))+(((-1.0)*x1044*x1045))+((px*sj2*x1046))+(((-1.0)*py*x1046*x1047)))),((((-656.0)*x1043))+(((-1.0)*py*sj2*x1046))+(((-1.0)*px*x1046*x1047))+(((-1.0)*x1043*x1044))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1049.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1048.value)))+(x1049.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[6];\nIkReal x1050=IKcos(j0);\nIkReal x1051=IKsin(j0);\nIkReal x1052=((0.2765)*cj3);\nIkReal x1053=((1.0)*px);\nIkReal x1054=(cj1*pz);\nIkReal x1055=((0.2765)*sj3);\nIkReal x1056=(cj1*cj2);\nIkReal x1057=(sj2*x1051);\nIkReal x1058=((1.0)*cj1*py);\nIkReal x1059=(cj2*x1051);\nIkReal x1060=(py*x1050);\nIkReal x1061=((1.0)*pz*sj1);\nIkReal x1062=(py*sj1*x1051);\nIkReal x1063=(px*sj1*x1050);\nevalcond[0]=(x1060+((sj2*x1055))+(((-1.0)*x1051*x1053)));\nevalcond[1]=((0.328)+x1052+x1063+x1062+(((-1.0)*x1054)));\nevalcond[2]=((-0.03113175)+(((0.656)*x1054))+(((-1.0)*pp))+(((-0.656)*x1062))+(((-0.656)*x1063)));\nevalcond[3]=((((-1.0)*py*x1051))+(((-0.328)*sj1))+(((-1.0)*x1055*x1056))+(((-1.0)*sj1*x1052))+(((-1.0)*x1050*x1053)));\nevalcond[4]=((((-1.0)*cj1*sj2*x1050*x1053))+((cj2*x1060))+(((-1.0)*sj2*x1061))+(((-1.0)*x1057*x1058))+(((-1.0)*x1053*x1059)));\nevalcond[5]=((((-1.0)*x1055))+((px*x1057))+(((-1.0)*sj2*x1060))+(((-1.0)*x1050*x1053*x1056))+(((-1.0)*py*x1051*x1056))+(((-1.0)*cj2*x1061)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1064=((82000.0)*sj1);\nIkReal x1065=((125000.0)*pp);\nIkReal x1066=((82000.0)*cj1*pz);\nIkReal x1067=((22673.0)*sj1*sj2*sj3);\nCheckValue<IkReal> x1068 = IKatan2WithCheck(IkReal((((py*x1066))+(((-3891.46875)*py))+(((-1.0)*py*x1065))+((px*x1067)))),((((-1.0)*px*x1065))+(((-3891.46875)*px))+(((-1.0)*py*x1067))+((px*x1066))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1068.valid){\ncontinue;\n}\nCheckValue<IkReal> x1069=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1064*(pz*pz)))+((pp*x1064)))),-1);\nif(!x1069.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1068.value)+(((1.5707963267949)*(x1069.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[6];\nIkReal x1070=IKcos(j0);\nIkReal x1071=IKsin(j0);\nIkReal x1072=((0.2765)*cj3);\nIkReal x1073=((1.0)*px);\nIkReal x1074=(cj1*pz);\nIkReal x1075=((0.2765)*sj3);\nIkReal x1076=(cj1*cj2);\nIkReal x1077=(sj2*x1071);\nIkReal x1078=((1.0)*cj1*py);\nIkReal x1079=(cj2*x1071);\nIkReal x1080=(py*x1070);\nIkReal x1081=((1.0)*pz*sj1);\nIkReal x1082=(py*sj1*x1071);\nIkReal x1083=(px*sj1*x1070);\nevalcond[0]=(x1080+(((-1.0)*x1071*x1073))+((sj2*x1075)));\nevalcond[1]=((0.328)+x1072+x1083+x1082+(((-1.0)*x1074)));\nevalcond[2]=((-0.03113175)+(((-1.0)*pp))+(((0.656)*x1074))+(((-0.656)*x1082))+(((-0.656)*x1083)));\nevalcond[3]=((((-1.0)*x1075*x1076))+(((-0.328)*sj1))+(((-1.0)*py*x1071))+(((-1.0)*x1070*x1073))+(((-1.0)*sj1*x1072)));\nevalcond[4]=((((-1.0)*sj2*x1081))+(((-1.0)*x1077*x1078))+(((-1.0)*x1073*x1079))+(((-1.0)*cj1*sj2*x1070*x1073))+((cj2*x1080)));\nevalcond[5]=((((-1.0)*sj2*x1080))+((px*x1077))+(((-1.0)*x1070*x1073*x1076))+(((-1.0)*x1075))+(((-1.0)*cj2*x1081))+(((-1.0)*py*x1071*x1076)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x1084=((553.0)*py);\nIkReal x1085=((2000.0)*sj1);\nIkReal x1086=((553.0)*px);\nIkReal x1087=((2000.0)*cj1*pz);\nIkReal x1088=(sj1*sj2*sj3);\nCheckValue<IkReal> x1089 = IKatan2WithCheck(IkReal((((py*x1087))+(((-656.0)*py))+((x1086*x1088))+(((-1.0)*cj3*x1084)))),(((px*x1087))+(((-656.0)*px))+(((-1.0)*x1084*x1088))+(((-1.0)*cj3*x1086))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1089.valid){\ncontinue;\n}\nCheckValue<IkReal> x1090=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1085*(pz*pz)))+((pp*x1085)))),-1);\nif(!x1090.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x1089.value)+(((1.5707963267949)*(x1090.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[6];\nIkReal x1091=IKcos(j0);\nIkReal x1092=IKsin(j0);\nIkReal x1093=((0.2765)*cj3);\nIkReal x1094=((1.0)*px);\nIkReal x1095=(cj1*pz);\nIkReal x1096=((0.2765)*sj3);\nIkReal x1097=(cj1*cj2);\nIkReal x1098=(sj2*x1092);\nIkReal x1099=((1.0)*cj1*py);\nIkReal x1100=(cj2*x1092);\nIkReal x1101=(py*x1091);\nIkReal x1102=((1.0)*pz*sj1);\nIkReal x1103=(py*sj1*x1092);\nIkReal x1104=(px*sj1*x1091);\nevalcond[0]=(x1101+(((-1.0)*x1092*x1094))+((sj2*x1096)));\nevalcond[1]=((0.328)+x1104+x1103+x1093+(((-1.0)*x1095)));\nevalcond[2]=((-0.03113175)+(((0.656)*x1095))+(((-1.0)*pp))+(((-0.656)*x1104))+(((-0.656)*x1103)));\nevalcond[3]=((((-1.0)*x1091*x1094))+(((-0.328)*sj1))+(((-1.0)*x1096*x1097))+(((-1.0)*sj1*x1093))+(((-1.0)*py*x1092)));\nevalcond[4]=((((-1.0)*cj1*sj2*x1091*x1094))+(((-1.0)*sj2*x1102))+(((-1.0)*x1094*x1100))+((cj2*x1101))+(((-1.0)*x1098*x1099)));\nevalcond[5]=((((-1.0)*sj2*x1101))+(((-1.0)*x1091*x1094*x1097))+(((-1.0)*x1096))+(((-1.0)*py*x1092*x1097))+(((-1.0)*cj2*x1102))+((px*x1098)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x1107 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);\nif(!x1107.valid){\ncontinue;\n}\nIkReal x1105=((1.0)*(x1107.value));\nif((((px*px)+(py*py))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x1108=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);\nif(!x1108.valid){\ncontinue;\n}\nif( (((0.2765)*sj2*sj3*(x1108.value))) < -1-IKFAST_SINCOS_THRESH || (((0.2765)*sj2*sj3*(x1108.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x1106=IKasin(((0.2765)*sj2*sj3*(x1108.value)));\nj0array[0]=((((-1.0)*x1106))+(((-1.0)*x1105)));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+x1106+(((-1.0)*x1105)));\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n\n{\nIkReal j1eval[3];\nIkReal x1109=(py*sj0);\nIkReal x1110=((2000.0)*pz);\nIkReal x1111=(cj0*px);\nIkReal x1112=((553.0)*cj3);\nIkReal x1113=(cj2*sj3);\nIkReal x1114=((1.0)*cj3);\nj1eval[0]=((((-1.18625678119349)*x1111))+(((-1.18625678119349)*x1109))+(((-1.0)*x1109*x1114))+((pz*x1113))+(((-1.0)*x1111*x1114)));\nj1eval[1]=IKsign(((((-656.0)*x1111))+(((-656.0)*x1109))+(((-1.0)*x1109*x1112))+(((553.0)*pz*x1113))+(((-1.0)*x1111*x1112))));\nj1eval[2]=((IKabs(((215.168)+(((152.9045)*(cj3*cj3)))+(((-1.0)*pz*x1110))+(((362.768)*cj3)))))+(IKabs(((((-1.0)*x1109*x1110))+(((152.9045)*cj3*x1113))+(((181.384)*x1113))+(((-1.0)*x1110*x1111))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[3];\nIkReal x1115=cj2*cj2;\nIkReal x1116=cj3*cj3;\nIkReal x1117=(py*sj0);\nIkReal x1118=((1106000.0)*cj3);\nIkReal x1119=(cj0*px);\nIkReal x1120=((305809.0)*x1116);\nIkReal x1121=((1106000.0)*cj2*sj3);\nj1eval[0]=((1.40720515092754)+x1115+x1116+(((2.37251356238698)*cj3))+(((-1.0)*x1115*x1116)));\nj1eval[1]=IKsign(((430336.0)+x1120+(((725536.0)*cj3))+(((305809.0)*x1115))+(((-1.0)*x1115*x1120))));\nj1eval[2]=((IKabs(((((-1.0)*pz*x1121))+(((-1312000.0)*x1119))+(((-1312000.0)*x1117))+(((-1.0)*x1118*x1119))+(((-1.0)*x1117*x1118)))))+(IKabs(((((-1.0)*x1117*x1121))+((pz*x1118))+(((-1.0)*x1119*x1121))+(((1312000.0)*pz))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nIkReal x1122=(cj0*px);\nIkReal x1123=(cj3*pz);\nIkReal x1124=(py*sj0);\nIkReal x1125=(cj2*sj3);\nIkReal x1126=((553.0)*x1125);\nj1eval[0]=(x1123+(((1.18625678119349)*pz))+((x1124*x1125))+((x1122*x1125)));\nj1eval[1]=IKsign(((((553.0)*x1123))+((x1124*x1126))+(((656.0)*pz))+((x1122*x1126))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1127=((0.2765)*sj3);\nIkReal x1128=(cj0*py);\nIkReal x1129=(px*sj0);\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j2), 6.28318530717959))))));\nevalcond[1]=((0.18403625)+(((0.181384)*cj3))+(((-1.0)*pp)));\nevalcond[2]=(x1128+x1127+(((-1.0)*x1129)));\nevalcond[3]=(x1129+(((-1.0)*x1128))+(((-1.0)*x1127)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x1130=((-1.0)*py);\npz=0;\nj2=1.5707963267949;\nsj2=1.0;\ncj2=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1130);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1130);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1130);\nrxp2_1=(px*r22);\nj1eval[0]=((-1.18625678119349)+(((-1.0)*cj3)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[1];\nIkReal x1131=((-1.0)*py);\npz=0;\nj2=1.5707963267949;\nsj2=1.0;\ncj2=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1131);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1131);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1131);\nrxp2_1=(px*r22);\nj1eval[0]=(((cj0*px))+((py*sj0)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1133 = ((px*px)+(py*py));\nif(IKabs(x1133)==0){\ncontinue;\n}\nIkReal x1132=pow(x1133,-0.5);\nCheckValue<IkReal> x1134 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1134.valid){\ncontinue;\n}\nIkReal gconst0=((-1.0)*(x1134.value));\nIkReal gconst1=((-1.0)*px*x1132);\nIkReal gconst2=(py*x1132);\nIkReal x1135=((0.2765)*sj3);\nIkReal x1136=(gconst2*py);\nIkReal x1137=(gconst1*px);\nCheckValue<IkReal> x1138 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1138.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1138.value)+j0)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((-1.0)*(px*px)))+(((0.181384)*cj3))+(((-1.0)*(py*py))));\nevalcond[2]=(x1136+x1135+(((-1.0)*x1137)));\nevalcond[3]=(x1137+(((-1.0)*x1135))+(((-1.0)*x1136)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x1139=((-1.0)*py);\nCheckValue<IkReal> x1143 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1143.valid){\ncontinue;\n}\nIkReal x1140=((-1.0)*(x1143.value));\nIkReal x1141=((px*px)+(py*py));\nIkReal x1142=x1132;\npz=0;\nj2=1.5707963267949;\nsj2=1.0;\ncj2=0;\npp=x1141;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1139);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1139);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1139);\nrxp2_1=(px*r22);\nsj0=gconst1;\ncj0=gconst2;\nj0=x1140;\nIkReal gconst0=x1140;\nIkReal gconst1=((-1.0)*px*x1142);\nIkReal gconst2=(py*x1142);\nj1eval[0]=((-1.18625678119349)+(((-1.0)*cj3)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[1];\nIkReal x1144=((-1.0)*py);\nCheckValue<IkReal> x1148 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1148.valid){\ncontinue;\n}\nIkReal x1145=((-1.0)*(x1148.value));\nIkReal x1146=((px*px)+(py*py));\nIkReal x1147=x1132;\npz=0;\nj2=1.5707963267949;\nsj2=1.0;\ncj2=0;\npp=x1146;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1144);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1144);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1144);\nrxp2_1=(px*r22);\nsj0=gconst1;\ncj0=gconst2;\nj0=x1145;\nIkReal gconst0=x1145;\nIkReal gconst1=((-1.0)*px*x1147);\nIkReal gconst2=(py*x1147);\nj1eval[0]=0;\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x1150=IKPowWithIntegerCheck((((gconst2*px))+((gconst1*py))),-1);\nif(!x1150.valid){\ncontinue;\n}\nIkReal x1149=x1150.value;\nsj1array[0]=((((-0.328)*x1149))+(((-0.2765)*cj3*x1149)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x1151=IKcos(j1);\nIkReal x1152=IKsin(j1);\nIkReal x1153=px*px;\nIkReal x1154=py*py;\nIkReal x1155=(gconst1*py);\nIkReal x1156=((1.0)*gconst2*px);\nIkReal x1157=((1.52439024390244)*x1151);\nIkReal x1158=((0.656)*x1152);\nevalcond[0]=((((-1.0)*x1151*x1156))+(((-1.0)*x1151*x1155)));\nevalcond[1]=((((-1.0)*x1156))+(((-0.2765)*cj3*x1152))+(((-0.328)*x1152))+(((-1.0)*x1155)));\nevalcond[2]=(((x1153*x1157))+(((0.0474569359756098)*x1151))+((x1154*x1157)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x1155*x1158))+(((-1.0)*x1153))+(((-1.0)*x1154))+(((-1.0)*gconst2*px*x1158)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x1160=IKPowWithIntegerCheck(((-0.328)+(((-0.2765)*cj3))),-1);\nif(!x1160.valid){\ncontinue;\n}\nIkReal x1159=x1160.value;\nsj1array[0]=(((gconst1*py*x1159))+((gconst2*px*x1159)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x1161=IKcos(j1);\nIkReal x1162=IKsin(j1);\nIkReal x1163=px*px;\nIkReal x1164=py*py;\nIkReal x1165=(gconst2*px);\nIkReal x1166=((1.0)*x1161);\nIkReal x1167=((1.52439024390244)*x1161);\nIkReal x1168=(gconst1*py*x1162);\nevalcond[0]=((((-1.0)*gconst1*py*x1166))+(((-1.0)*x1165*x1166)));\nevalcond[1]=((0.328)+x1168+((x1162*x1165))+(((0.2765)*cj3)));\nevalcond[2]=(((x1164*x1167))+(((0.0474569359756098)*x1161))+((x1163*x1167)));\nevalcond[3]=((-0.03113175)+(((-0.656)*x1168))+(((-0.656)*x1162*x1165))+(((-1.0)*x1163))+(((-1.0)*x1164)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1170 = ((px*px)+(py*py));\nif(IKabs(x1170)==0){\ncontinue;\n}\nIkReal x1169=pow(x1170,-0.5);\nCheckValue<IkReal> x1171 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1171.valid){\ncontinue;\n}\nIkReal gconst3=((3.14159265358979)+(((-1.0)*(x1171.value))));\nIkReal gconst4=((1.0)*px*x1169);\nIkReal gconst5=((-1.0)*py*x1169);\nIkReal x1172=((0.2765)*sj3);\nIkReal x1173=(gconst4*px);\nIkReal x1174=(gconst5*py);\nCheckValue<IkReal> x1175 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1175.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1175.value)+j0)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((-1.0)*(px*px)))+(((0.181384)*cj3))+(((-1.0)*(py*py))));\nevalcond[2]=(x1174+x1172+(((-1.0)*x1173)));\nevalcond[3]=(x1173+(((-1.0)*x1172))+(((-1.0)*x1174)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nCheckValue<IkReal> x1180 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1180.valid){\ncontinue;\n}\nIkReal x1176=((1.0)*(x1180.value));\nIkReal x1177=((-1.0)*py);\nIkReal x1178=((px*px)+(py*py));\nIkReal x1179=x1169;\npz=0;\nj2=1.5707963267949;\nsj2=1.0;\ncj2=0;\npp=x1178;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1177);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1177);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1177);\nrxp2_1=(px*r22);\nsj0=gconst4;\ncj0=gconst5;\nj0=((3.14159265)+(((-1.0)*x1176)));\nIkReal gconst3=((3.14159265358979)+(((-1.0)*x1176)));\nIkReal gconst4=((1.0)*px*x1179);\nIkReal gconst5=(x1177*x1179);\nj1eval[0]=((-1.18625678119349)+(((-1.0)*cj3)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[1];\nCheckValue<IkReal> x1185 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1185.valid){\ncontinue;\n}\nIkReal x1181=((1.0)*(x1185.value));\nIkReal x1182=((-1.0)*py);\nIkReal x1183=((px*px)+(py*py));\nIkReal x1184=x1169;\npz=0;\nj2=1.5707963267949;\nsj2=1.0;\ncj2=0;\npp=x1183;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1182);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1182);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1182);\nrxp2_1=(px*r22);\nsj0=gconst4;\ncj0=gconst5;\nj0=((3.14159265)+(((-1.0)*x1181)));\nIkReal gconst3=((3.14159265358979)+(((-1.0)*x1181)));\nIkReal gconst4=((1.0)*px*x1184);\nIkReal gconst5=(x1182*x1184);\nj1eval[0]=0;\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x1187=IKPowWithIntegerCheck((((gconst5*px))+((gconst4*py))),-1);\nif(!x1187.valid){\ncontinue;\n}\nIkReal x1186=x1187.value;\nsj1array[0]=((((-0.328)*x1186))+(((-0.2765)*cj3*x1186)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x1188=IKcos(j1);\nIkReal x1189=IKsin(j1);\nIkReal x1190=px*px;\nIkReal x1191=py*py;\nIkReal x1192=(gconst4*py);\nIkReal x1193=(gconst5*px);\nIkReal x1194=((0.656)*x1189);\nIkReal x1195=((1.52439024390244)*x1188);\nIkReal x1196=((1.0)*x1188);\nevalcond[0]=((((-1.0)*x1193*x1196))+(((-1.0)*x1192*x1196)));\nevalcond[1]=((((-0.328)*x1189))+(((-0.2765)*cj3*x1189))+(((-1.0)*x1193))+(((-1.0)*x1192)));\nevalcond[2]=((((0.0474569359756098)*x1188))+((x1191*x1195))+((x1190*x1195)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x1193*x1194))+(((-1.0)*x1192*x1194))+(((-1.0)*x1191))+(((-1.0)*x1190)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x1198=IKPowWithIntegerCheck(((-0.328)+(((-0.2765)*cj3))),-1);\nif(!x1198.valid){\ncontinue;\n}\nIkReal x1197=x1198.value;\nsj1array[0]=(((gconst4*py*x1197))+((gconst5*px*x1197)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x1199=IKcos(j1);\nIkReal x1200=IKsin(j1);\nIkReal x1201=px*px;\nIkReal x1202=py*py;\nIkReal x1203=(gconst5*px);\nIkReal x1204=((1.52439024390244)*x1199);\nIkReal x1205=((1.0)*x1199);\nIkReal x1206=(gconst4*py*x1200);\nevalcond[0]=((((-1.0)*x1203*x1205))+(((-1.0)*gconst4*py*x1205)));\nevalcond[1]=((0.328)+x1206+(((0.2765)*cj3))+((x1200*x1203)));\nevalcond[2]=(((x1202*x1204))+(((0.0474569359756098)*x1199))+((x1201*x1204)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x1202))+(((-1.0)*x1201))+(((-0.656)*x1200*x1203))+(((-0.656)*x1206)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x1208=IKPowWithIntegerCheck((((cj0*px))+((py*sj0))),-1);\nif(!x1208.valid){\ncontinue;\n}\nIkReal x1207=x1208.value;\nsj1array[0]=((((-0.2765)*cj3*x1207))+(((-0.328)*x1207)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x1209=IKcos(j1);\nIkReal x1210=IKsin(j1);\nIkReal x1211=px*px;\nIkReal x1212=py*py;\nIkReal x1213=(cj0*px);\nIkReal x1214=(py*sj0);\nIkReal x1215=((0.656)*x1210);\nIkReal x1216=((1.52439024390244)*x1209);\nIkReal x1217=((1.0)*x1209);\nevalcond[0]=((((-1.0)*x1214*x1217))+(((-1.0)*x1213*x1217)));\nevalcond[1]=((((-0.328)*x1210))+(((-0.2765)*cj3*x1210))+(((-1.0)*x1214))+(((-1.0)*x1213)));\nevalcond[2]=(((x1212*x1216))+(((0.0474569359756098)*x1209))+((x1211*x1216)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x1214*x1215))+(((-1.0)*x1213*x1215))+(((-1.0)*x1212))+(((-1.0)*x1211)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x1219=IKPowWithIntegerCheck(((-0.328)+(((-0.2765)*cj3))),-1);\nif(!x1219.valid){\ncontinue;\n}\nIkReal x1218=x1219.value;\nsj1array[0]=(((cj0*px*x1218))+((py*sj0*x1218)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x1220=IKcos(j1);\nIkReal x1221=IKsin(j1);\nIkReal x1222=px*px;\nIkReal x1223=py*py;\nIkReal x1224=(py*sj0);\nIkReal x1225=(cj0*px);\nIkReal x1226=((1.0)*x1220);\nIkReal x1227=((0.656)*x1221);\nIkReal x1228=((1.52439024390244)*x1220);\nevalcond[0]=((((-1.0)*x1224*x1226))+(((-1.0)*x1225*x1226)));\nevalcond[1]=((0.328)+(((0.2765)*cj3))+((x1221*x1225))+((x1221*x1224)));\nevalcond[2]=((((0.0474569359756098)*x1220))+((x1223*x1228))+((x1222*x1228)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x1224*x1227))+(((-1.0)*x1222))+(((-1.0)*x1223))+(((-1.0)*x1225*x1227)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1229=((((-0.2765)*sj3))+(((-1.0)*px*sj0))+((cj0*py)));\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j2), 6.28318530717959))))));\nevalcond[1]=((0.18403625)+(((0.181384)*cj3))+(((-1.0)*pp)));\nevalcond[2]=x1229;\nevalcond[3]=x1229;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x1230=((-1.0)*py);\npz=0;\nj2=-1.5707963267949;\nsj2=-1.0;\ncj2=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1230);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1230);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1230);\nrxp2_1=(px*r22);\nj1eval[0]=((-1.18625678119349)+(((-1.0)*cj3)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[1];\nIkReal x1231=((-1.0)*py);\npz=0;\nj2=-1.5707963267949;\nsj2=-1.0;\ncj2=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1231);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1231);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1231);\nrxp2_1=(px*r22);\nj1eval[0]=(((cj0*px))+((py*sj0)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1233 = ((px*px)+(py*py));\nif(IKabs(x1233)==0){\ncontinue;\n}\nIkReal x1232=pow(x1233,-0.5);\nCheckValue<IkReal> x1234 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1234.valid){\ncontinue;\n}\nIkReal gconst6=((-1.0)*(x1234.value));\nIkReal gconst7=((-1.0)*px*x1232);\nIkReal gconst8=(py*x1232);\nIkReal x1235=((((-0.2765)*sj3))+((gconst8*py))+(((-1.0)*gconst7*px)));\nCheckValue<IkReal> x1236 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1236.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1236.value)+j0)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((-1.0)*(px*px)))+(((0.181384)*cj3))+(((-1.0)*(py*py))));\nevalcond[2]=x1235;\nevalcond[3]=x1235;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nIkReal x1237=((-1.0)*py);\nCheckValue<IkReal> x1241 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1241.valid){\ncontinue;\n}\nIkReal x1238=((-1.0)*(x1241.value));\nIkReal x1239=((px*px)+(py*py));\nIkReal x1240=x1232;\npz=0;\nj2=-1.5707963267949;\nsj2=-1.0;\ncj2=0;\npp=x1239;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1237);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1237);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1237);\nrxp2_1=(px*r22);\nsj0=gconst7;\ncj0=gconst8;\nj0=x1238;\nIkReal gconst6=x1238;\nIkReal gconst7=((-1.0)*px*x1240);\nIkReal gconst8=(py*x1240);\nj1eval[0]=((-1.18625678119349)+(((-1.0)*cj3)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[1];\nIkReal x1242=((-1.0)*py);\nCheckValue<IkReal> x1246 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1246.valid){\ncontinue;\n}\nIkReal x1243=((-1.0)*(x1246.value));\nIkReal x1244=((px*px)+(py*py));\nIkReal x1245=x1232;\npz=0;\nj2=-1.5707963267949;\nsj2=-1.0;\ncj2=0;\npp=x1244;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1242);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1242);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1242);\nrxp2_1=(px*r22);\nsj0=gconst7;\ncj0=gconst8;\nj0=x1243;\nIkReal gconst6=x1243;\nIkReal gconst7=((-1.0)*px*x1245);\nIkReal gconst8=(py*x1245);\nj1eval[0]=0;\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x1248=IKPowWithIntegerCheck((((gconst8*px))+((gconst7*py))),-1);\nif(!x1248.valid){\ncontinue;\n}\nIkReal x1247=x1248.value;\nsj1array[0]=((((-0.2765)*cj3*x1247))+(((-0.328)*x1247)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x1249=IKcos(j1);\nIkReal x1250=IKsin(j1);\nIkReal x1251=px*px;\nIkReal x1252=py*py;\nIkReal x1253=(gconst8*px);\nIkReal x1254=(gconst7*py);\nIkReal x1255=((0.656)*x1250);\nIkReal x1256=((1.52439024390244)*x1249);\nevalcond[0]=(((x1249*x1253))+((x1249*x1254)));\nevalcond[1]=((((-0.328)*x1250))+(((-0.2765)*cj3*x1250))+(((-1.0)*x1253))+(((-1.0)*x1254)));\nevalcond[2]=(((x1252*x1256))+((x1251*x1256))+(((0.0474569359756098)*x1249)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x1253*x1255))+(((-1.0)*x1254*x1255))+(((-1.0)*x1251))+(((-1.0)*x1252)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x1258=IKPowWithIntegerCheck(((-0.328)+(((-0.2765)*cj3))),-1);\nif(!x1258.valid){\ncontinue;\n}\nIkReal x1257=x1258.value;\nsj1array[0]=(((gconst7*py*x1257))+((gconst8*px*x1257)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x1259=IKcos(j1);\nIkReal x1260=IKsin(j1);\nIkReal x1261=px*px;\nIkReal x1262=py*py;\nIkReal x1263=(gconst8*px);\nIkReal x1264=((1.52439024390244)*x1259);\nIkReal x1265=(gconst7*py*x1260);\nevalcond[0]=(((gconst7*py*x1259))+((x1259*x1263)));\nevalcond[1]=((0.328)+x1265+(((0.2765)*cj3))+((x1260*x1263)));\nevalcond[2]=(((x1261*x1264))+(((0.0474569359756098)*x1259))+((x1262*x1264)));\nevalcond[3]=((-0.03113175)+(((-0.656)*x1265))+(((-1.0)*x1261))+(((-1.0)*x1262))+(((-0.656)*x1260*x1263)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1267 = ((px*px)+(py*py));\nif(IKabs(x1267)==0){\ncontinue;\n}\nIkReal x1266=pow(x1267,-0.5);\nCheckValue<IkReal> x1268 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1268.valid){\ncontinue;\n}\nIkReal gconst9=((3.14159265358979)+(((-1.0)*(x1268.value))));\nIkReal gconst10=((1.0)*px*x1266);\nIkReal gconst11=((-1.0)*py*x1266);\nIkReal x1269=((((-0.2765)*sj3))+(((-1.0)*gconst10*px))+((gconst11*py)));\nCheckValue<IkReal> x1270 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1270.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1270.value)+j0)))), 6.28318530717959)));\nevalcond[1]=((0.18403625)+(((-1.0)*(px*px)))+(((0.181384)*cj3))+(((-1.0)*(py*py))));\nevalcond[2]=x1269;\nevalcond[3]=x1269;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1eval[1];\nCheckValue<IkReal> x1275 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1275.valid){\ncontinue;\n}\nIkReal x1271=((1.0)*(x1275.value));\nIkReal x1272=((-1.0)*py);\nIkReal x1273=((px*px)+(py*py));\nIkReal x1274=x1266;\npz=0;\nj2=-1.5707963267949;\nsj2=-1.0;\ncj2=0;\npp=x1273;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1272);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1272);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1272);\nrxp2_1=(px*r22);\nsj0=gconst10;\ncj0=gconst11;\nj0=((3.14159265)+(((-1.0)*x1271)));\nIkReal gconst9=((3.14159265358979)+(((-1.0)*x1271)));\nIkReal gconst10=((1.0)*px*x1274);\nIkReal gconst11=(x1272*x1274);\nj1eval[0]=((-1.18625678119349)+(((-1.0)*cj3)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[1];\nCheckValue<IkReal> x1280 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x1280.valid){\ncontinue;\n}\nIkReal x1276=((1.0)*(x1280.value));\nIkReal x1277=((-1.0)*py);\nIkReal x1278=((px*px)+(py*py));\nIkReal x1279=x1266;\npz=0;\nj2=-1.5707963267949;\nsj2=-1.0;\ncj2=0;\npp=x1278;\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x1277);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x1277);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x1277);\nrxp2_1=(px*r22);\nsj0=gconst10;\ncj0=gconst11;\nj0=((3.14159265)+(((-1.0)*x1276)));\nIkReal gconst9=((3.14159265358979)+(((-1.0)*x1276)));\nIkReal gconst10=((1.0)*px*x1279);\nIkReal gconst11=(x1277*x1279);\nj1eval[0]=0;\nif( IKabs(j1eval[0]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x1282=IKPowWithIntegerCheck((((gconst10*py))+((gconst11*px))),-1);\nif(!x1282.valid){\ncontinue;\n}\nIkReal x1281=x1282.value;\nsj1array[0]=((((-0.328)*x1281))+(((-0.2765)*cj3*x1281)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x1283=IKcos(j1);\nIkReal x1284=IKsin(j1);\nIkReal x1285=px*px;\nIkReal x1286=py*py;\nIkReal x1287=(gconst10*py);\nIkReal x1288=(gconst11*px);\nIkReal x1289=((1.52439024390244)*x1283);\nIkReal x1290=((0.656)*x1284);\nevalcond[0]=(((x1283*x1288))+((x1283*x1287)));\nevalcond[1]=((((-1.0)*x1288))+(((-1.0)*x1287))+(((-0.328)*x1284))+(((-0.2765)*cj3*x1284)));\nevalcond[2]=(((x1285*x1289))+(((0.0474569359756098)*x1283))+((x1286*x1289)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x1286))+(((-1.0)*x1285))+(((-1.0)*x1287*x1290))+(((-1.0)*x1288*x1290)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x1292=IKPowWithIntegerCheck(((-0.328)+(((-0.2765)*cj3))),-1);\nif(!x1292.valid){\ncontinue;\n}\nIkReal x1291=x1292.value;\nsj1array[0]=(((gconst11*px*x1291))+((gconst10*py*x1291)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x1293=IKcos(j1);\nIkReal x1294=IKsin(j1);\nIkReal x1295=px*px;\nIkReal x1296=py*py;\nIkReal x1297=(gconst10*py);\nIkReal x1298=(gconst11*px);\nIkReal x1299=((1.52439024390244)*x1293);\nIkReal x1300=((0.656)*x1294);\nevalcond[0]=(((x1293*x1298))+((x1293*x1297)));\nevalcond[1]=((0.328)+(((0.2765)*cj3))+((x1294*x1297))+((x1294*x1298)));\nevalcond[2]=(((x1296*x1299))+((x1295*x1299))+(((0.0474569359756098)*x1293)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x1297*x1300))+(((-1.0)*x1296))+(((-1.0)*x1295))+(((-1.0)*x1298*x1300)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x1302=IKPowWithIntegerCheck((((cj0*px))+((py*sj0))),-1);\nif(!x1302.valid){\ncontinue;\n}\nIkReal x1301=x1302.value;\nsj1array[0]=((((-0.2765)*cj3*x1301))+(((-0.328)*x1301)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x1303=IKcos(j1);\nIkReal x1304=IKsin(j1);\nIkReal x1305=px*px;\nIkReal x1306=py*py;\nIkReal x1307=(cj0*px);\nIkReal x1308=(py*sj0);\nIkReal x1309=((0.656)*x1304);\nIkReal x1310=((1.52439024390244)*x1303);\nevalcond[0]=(((x1303*x1308))+((x1303*x1307)));\nevalcond[1]=((((-0.2765)*cj3*x1304))+(((-1.0)*x1308))+(((-1.0)*x1307))+(((-0.328)*x1304)));\nevalcond[2]=(((x1305*x1310))+((x1306*x1310))+(((0.0474569359756098)*x1303)));\nevalcond[3]=((-0.03113175)+(((-1.0)*x1307*x1309))+(((-1.0)*x1305))+(((-1.0)*x1306))+(((-1.0)*x1308*x1309)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nCheckValue<IkReal> x1312=IKPowWithIntegerCheck(((-0.328)+(((-0.2765)*cj3))),-1);\nif(!x1312.valid){\ncontinue;\n}\nIkReal x1311=x1312.value;\nsj1array[0]=(((cj0*px*x1311))+((py*sj0*x1311)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[4];\nIkReal x1313=IKcos(j1);\nIkReal x1314=IKsin(j1);\nIkReal x1315=px*px;\nIkReal x1316=py*py;\nIkReal x1317=((1.52439024390244)*x1313);\nIkReal x1318=(py*sj0*x1314);\nIkReal x1319=(cj0*px*x1314);\nevalcond[0]=(((cj0*px*x1313))+((py*sj0*x1313)));\nevalcond[1]=((0.328)+x1319+x1318+(((0.2765)*cj3)));\nevalcond[2]=(((x1316*x1317))+((x1315*x1317))+(((0.0474569359756098)*x1313)));\nevalcond[3]=((-0.03113175)+(((-0.656)*x1318))+(((-0.656)*x1319))+(((-1.0)*x1316))+(((-1.0)*x1315)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));\nevalcond[1]=((0.36542025)+(((-1.0)*pp)));\nevalcond[2]=((((-1.0)*px*sj0))+((cj0*py)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nsj1array[0]=((((-1.65425971877585)*py*sj0))+(((-1.65425971877585)*cj0*px)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x1320=IKsin(j1);\nIkReal x1321=IKcos(j1);\nCheckValue<IkReal> x1328=IKPowWithIntegerCheck(cj0,-1);\nif(!x1328.valid){\ncontinue;\n}\nIkReal x1322=x1328.value;\nIkReal x1323=sj0*sj0;\nIkReal x1324=(x1322*x1323);\nIkReal x1325=(py*sj0*x1320);\nIkReal x1326=((1.0)*px*x1321);\nIkReal x1327=(cj0*px*x1320);\nevalcond[0]=((0.6045)*x1321);\nevalcond[1]=((0.6045)+x1327+x1325);\nevalcond[2]=((-0.396552)+(((-0.656)*x1325))+(((-0.656)*x1327)));\nevalcond[3]=((((-1.0)*sj2*x1324*x1326))+(((-1.0)*cj0*sj2*x1326)));\nevalcond[4]=((((-1.0)*cj0*cj2*x1326))+(((-1.0)*cj2*x1324*x1326)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j3, 6.28318530717959)))))+(IKabs(pz)));\nevalcond[1]=((0.00265225)+(((-1.0)*pp)));\nevalcond[2]=((((-1.0)*px*sj0))+((cj0*py)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nsj1array[0]=((((-19.4174757281553)*py*sj0))+(((-19.4174757281553)*cj0*px)));\nif( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j1valid[0] = j1valid[1] = true;\n    j1array[0] = IKasin(sj1array[0]);\n    cj1array[0] = IKcos(j1array[0]);\n    sj1array[1] = sj1array[0];\n    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);\n    cj1array[1] = -cj1array[0];\n}\nelse if( isnan(sj1array[0]) )\n{\n    // probably any value will work\n    j1valid[0] = true;\n    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;\n}\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x1329=IKsin(j1);\nIkReal x1330=IKcos(j1);\nCheckValue<IkReal> x1337=IKPowWithIntegerCheck(cj0,-1);\nif(!x1337.valid){\ncontinue;\n}\nIkReal x1331=x1337.value;\nIkReal x1332=sj0*sj0;\nIkReal x1333=(cj0*px);\nIkReal x1334=((1.0)*x1330);\nIkReal x1335=(py*sj0*x1329);\nIkReal x1336=(px*x1331*x1332*x1334);\nevalcond[0]=((0.0515)*x1330);\nevalcond[1]=((0.0515)+x1335+((x1329*x1333)));\nevalcond[2]=((-0.033784)+(((-0.656)*x1329*x1333))+(((-0.656)*x1335)));\nevalcond[3]=((((-1.0)*sj2*x1336))+(((-1.0)*sj2*x1333*x1334)));\nevalcond[4]=((((-1.0)*cj2*x1336))+(((-1.0)*cj2*x1333*x1334)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j1]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x1338=py*py;\nIkReal x1339=cj0*cj0;\nIkReal x1340=(cj0*px);\nIkReal x1341=(py*sj0);\nIkReal x1342=((2000.0)*pz);\nIkReal x1343=(cj2*sj3);\nIkReal x1344=((2000.0)*x1338);\nCheckValue<IkReal> x1345=IKPowWithIntegerCheck(IKsign(((((553.0)*x1341*x1343))+(((656.0)*pz))+(((553.0)*x1340*x1343))+(((553.0)*cj3*pz)))),-1);\nif(!x1345.valid){\ncontinue;\n}\nCheckValue<IkReal> x1346 = IKatan2WithCheck(IkReal(((((-1.0)*x1340*x1342))+(((-1.0)*x1341*x1342))+(((-181.384)*x1343))+(((-152.9045)*cj3*x1343)))),((215.168)+((x1339*x1344))+(((-1.0)*x1344))+(((152.9045)*(cj3*cj3)))+(((-4000.0)*x1340*x1341))+(((-2000.0)*x1339*(px*px)))+(((362.768)*cj3))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1346.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1345.value)))+(x1346.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x1347=IKcos(j1);\nIkReal x1348=IKsin(j1);\nIkReal x1349=((0.2765)*cj3);\nIkReal x1350=(cj0*px);\nIkReal x1351=((1.0)*sj0);\nIkReal x1352=(py*sj0);\nIkReal x1353=((1.0)*pz);\nIkReal x1354=((0.2765)*sj3);\nIkReal x1355=(cj0*py);\nIkReal x1356=((0.656)*x1348);\nIkReal x1357=((1.0)*x1347);\nIkReal x1358=(py*x1347);\nIkReal x1359=(cj2*x1348);\nevalcond[0]=((((-1.0)*x1353))+(((-1.0)*x1354*x1359))+(((0.328)*x1347))+((x1347*x1349)));\nevalcond[1]=((0.328)+x1349+(((-1.0)*x1347*x1353))+((x1348*x1352))+((x1348*x1350)));\nevalcond[2]=((-0.03113175)+(((-1.0)*x1352*x1356))+(((-1.0)*x1350*x1356))+(((-1.0)*pp))+(((0.656)*pz*x1347)));\nevalcond[3]=((((-1.0)*x1350))+(((-1.0)*x1348*x1349))+(((-0.328)*x1348))+(((-1.0)*cj2*x1347*x1354))+(((-1.0)*py*x1351)));\nevalcond[4]=((((-1.0)*sj2*x1351*x1358))+(((-1.0)*cj2*px*x1351))+(((-1.0)*sj2*x1348*x1353))+((cj2*x1355))+(((-1.0)*sj2*x1350*x1357)));\nevalcond[5]=((((-1.0)*x1354))+(((-1.0)*cj2*x1351*x1358))+(((-1.0)*cj2*x1350*x1357))+(((-1.0)*sj2*x1355))+((px*sj0*sj2))+(((-1.0)*x1353*x1359)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x1360=cj2*cj2;\nIkReal x1361=cj3*cj3;\nIkReal x1362=(py*sj0);\nIkReal x1363=((1106000.0)*cj3);\nIkReal x1364=(cj0*px);\nIkReal x1365=((305809.0)*x1361);\nIkReal x1366=((1106000.0)*cj2*sj3);\nCheckValue<IkReal> x1367=IKPowWithIntegerCheck(IKsign(((430336.0)+x1365+(((305809.0)*x1360))+(((725536.0)*cj3))+(((-1.0)*x1360*x1365)))),-1);\nif(!x1367.valid){\ncontinue;\n}\nCheckValue<IkReal> x1368 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x1366))+(((-1312000.0)*x1364))+(((-1312000.0)*x1362))+(((-1.0)*x1362*x1363))+(((-1.0)*x1363*x1364)))),((((-1.0)*x1364*x1366))+(((-1.0)*x1362*x1366))+((pz*x1363))+(((1312000.0)*pz))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1368.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1367.value)))+(x1368.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x1369=IKcos(j1);\nIkReal x1370=IKsin(j1);\nIkReal x1371=((0.2765)*cj3);\nIkReal x1372=(cj0*px);\nIkReal x1373=((1.0)*sj0);\nIkReal x1374=(py*sj0);\nIkReal x1375=((1.0)*pz);\nIkReal x1376=((0.2765)*sj3);\nIkReal x1377=(cj0*py);\nIkReal x1378=((0.656)*x1370);\nIkReal x1379=((1.0)*x1369);\nIkReal x1380=(py*x1369);\nIkReal x1381=(cj2*x1370);\nevalcond[0]=((((-1.0)*x1376*x1381))+(((-1.0)*x1375))+(((0.328)*x1369))+((x1369*x1371)));\nevalcond[1]=((0.328)+x1371+((x1370*x1372))+((x1370*x1374))+(((-1.0)*x1369*x1375)));\nevalcond[2]=((-0.03113175)+(((-1.0)*x1372*x1378))+(((-1.0)*x1374*x1378))+(((-1.0)*pp))+(((0.656)*pz*x1369)));\nevalcond[3]=((((-1.0)*x1370*x1371))+(((-1.0)*x1372))+(((-1.0)*cj2*x1369*x1376))+(((-0.328)*x1370))+(((-1.0)*py*x1373)));\nevalcond[4]=((((-1.0)*sj2*x1372*x1379))+(((-1.0)*sj2*x1373*x1380))+(((-1.0)*sj2*x1370*x1375))+((cj2*x1377))+(((-1.0)*cj2*px*x1373)));\nevalcond[5]=((((-1.0)*sj2*x1377))+(((-1.0)*x1375*x1381))+(((-1.0)*cj2*x1372*x1379))+((px*sj0*sj2))+(((-1.0)*x1376))+(((-1.0)*cj2*x1373*x1380)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x1382=(cj0*px);\nIkReal x1383=((553.0)*cj3);\nIkReal x1384=(cj2*sj3);\nIkReal x1385=(py*sj0);\nIkReal x1386=((2000.0)*pz);\nCheckValue<IkReal> x1387 = IKatan2WithCheck(IkReal(((215.168)+(((152.9045)*(cj3*cj3)))+(((-1.0)*pz*x1386))+(((362.768)*cj3)))),((((152.9045)*cj3*x1384))+(((-1.0)*x1382*x1386))+(((181.384)*x1384))+(((-1.0)*x1385*x1386))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1387.valid){\ncontinue;\n}\nCheckValue<IkReal> x1388=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1383*x1385))+(((-1.0)*x1382*x1383))+(((-656.0)*x1385))+(((-656.0)*x1382))+(((553.0)*pz*x1384)))),-1);\nif(!x1388.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x1387.value)+(((1.5707963267949)*(x1388.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[6];\nIkReal x1389=IKcos(j1);\nIkReal x1390=IKsin(j1);\nIkReal x1391=((0.2765)*cj3);\nIkReal x1392=(cj0*px);\nIkReal x1393=((1.0)*sj0);\nIkReal x1394=(py*sj0);\nIkReal x1395=((1.0)*pz);\nIkReal x1396=((0.2765)*sj3);\nIkReal x1397=(cj0*py);\nIkReal x1398=((0.656)*x1390);\nIkReal x1399=((1.0)*x1389);\nIkReal x1400=(py*x1389);\nIkReal x1401=(cj2*x1390);\nevalcond[0]=((((0.328)*x1389))+((x1389*x1391))+(((-1.0)*x1396*x1401))+(((-1.0)*x1395)));\nevalcond[1]=((0.328)+x1391+(((-1.0)*x1389*x1395))+((x1390*x1392))+((x1390*x1394)));\nevalcond[2]=((-0.03113175)+(((-1.0)*x1392*x1398))+(((-1.0)*x1394*x1398))+(((-1.0)*pp))+(((0.656)*pz*x1389)));\nevalcond[3]=((((-0.328)*x1390))+(((-1.0)*cj2*x1389*x1396))+(((-1.0)*x1390*x1391))+(((-1.0)*x1392))+(((-1.0)*py*x1393)));\nevalcond[4]=((((-1.0)*sj2*x1393*x1400))+(((-1.0)*cj2*px*x1393))+((cj2*x1397))+(((-1.0)*sj2*x1390*x1395))+(((-1.0)*sj2*x1392*x1399)));\nevalcond[5]=((((-1.0)*cj2*x1393*x1400))+(((-1.0)*sj2*x1397))+((px*sj0*sj2))+(((-1.0)*cj2*x1392*x1399))+(((-1.0)*x1395*x1401))+(((-1.0)*x1396)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\nreturn solutions.GetNumSolutions()>0;\n}\ninline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {\nfor(int rotationiter = 0; rotationiter < 1; ++rotationiter) {\nIkReal x147=((1.0)*sj2);\nIkReal x148=(cj3*sj0);\nIkReal x149=(cj2*cj3);\nIkReal x150=(cj0*sj2);\nIkReal x151=(cj1*sj3);\nIkReal x152=((1.0)*cj2);\nIkReal x153=((1.0)*sj1*sj3);\nIkReal x154=((((-1.0)*x153))+((cj1*x149)));\nIkReal x155=(((sj1*x149))+x151);\nIkReal x156=(((cj0*cj2))+(((-1.0)*cj1*sj0*x147)));\nIkReal x157=(((cj1*cj3))+(((-1.0)*sj1*sj3*x152)));\nIkReal x158=(cj0*x154);\nIkReal x159=((((-1.0)*sj0*x152))+(((-1.0)*cj0*cj1*x147)));\nIkReal x160=((((-1.0)*x151*x152))+(((-1.0)*cj3*sj1)));\nIkReal x161=(((cj3*x150))+((sj0*x154)));\nIkReal x162=((((-1.0)*sj2*x148))+x158);\nIkReal x163=(((cj0*x160))+((sj0*sj2*sj3)));\nIkReal x164=(((sj0*x160))+(((-1.0)*sj3*x150)));\nnew_r00=(((r00*((x158+(((-1.0)*x147*x148))))))+((r20*x155))+((r10*x161)));\nnew_r01=(((r01*x162))+((r21*x155))+((r11*x161)));\nnew_r02=(((r12*x161))+((r22*x155))+((r02*x162)));\nnew_r10=(((r00*x159))+((r10*x156))+(((-1.0)*r20*sj1*x147)));\nnew_r11=(((r01*x159))+(((-1.0)*r21*sj1*x147))+((r11*x156)));\nnew_r12=((((-1.0)*r22*sj1*x147))+((r02*x159))+((r12*x156)));\nnew_r20=(((r00*x163))+((r20*x157))+((r10*x164)));\nnew_r21=(((r01*x163))+((r21*x157))+((r11*x164)));\nnew_r22=(((r12*x164))+((r22*x157))+((r02*x163)));\n{\nIkReal j5array[2], cj5array[2], sj5array[2];\nbool j5valid[2]={false};\n_nj5 = 2;\ncj5array[0]=new_r22;\nif( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j5valid[0] = j5valid[1] = true;\n    j5array[0] = IKacos(cj5array[0]);\n    sj5array[0] = IKsin(j5array[0]);\n    cj5array[1] = cj5array[0];\n    j5array[1] = -j5array[0];\n    sj5array[1] = -sj5array[0];\n}\nelse if( isnan(cj5array[0]) )\n{\n    // probably any value will work\n    j5valid[0] = true;\n    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;\n}\nfor(int ij5 = 0; ij5 < 2; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 2; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n\n{\nIkReal j6eval[2];\nIkReal x165=((1.0)*sj2);\nIkReal x166=(cj3*sj0);\nIkReal x167=(cj2*cj3);\nIkReal x168=(cj0*sj2);\nIkReal x169=(cj1*sj3);\nIkReal x170=((1.0)*cj2);\nIkReal x171=((1.0)*sj1*sj3);\nIkReal x172=((((-1.0)*x171))+((cj1*x167)));\nIkReal x173=(((sj1*x167))+x169);\nIkReal x174=x156;\nIkReal x175=x157;\nIkReal x176=(cj0*x172);\nIkReal x177=x159;\nIkReal x178=x160;\nIkReal x179=(((sj0*x172))+((cj3*x168)));\nIkReal x180=((((-1.0)*sj2*x166))+x176);\nIkReal x181=(((cj0*x178))+((sj0*sj2*sj3)));\nIkReal x182=((((-1.0)*sj3*x168))+((sj0*x178)));\nnew_r00=(((r20*x173))+((r00*((x176+(((-1.0)*x165*x166))))))+((r10*x179)));\nnew_r01=(((r01*x180))+((r21*x173))+((r11*x179)));\nnew_r02=(((r22*x173))+((r02*x180))+((r12*x179)));\nnew_r10=(((r00*x177))+(((-1.0)*r20*sj1*x165))+((r10*x174)));\nnew_r11=(((r01*x177))+(((-1.0)*r21*sj1*x165))+((r11*x174)));\nnew_r12=((((-1.0)*r22*sj1*x165))+((r12*x174))+((r02*x177)));\nnew_r20=(((r00*x181))+((r20*x175))+((r10*x182)));\nnew_r21=(((r01*x181))+((r21*x175))+((r11*x182)));\nnew_r22=(((r22*x175))+((r12*x182))+((r02*x181)));\nj6eval[0]=sj5;\nj6eval[1]=IKsign(sj5);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j4eval[1];\nIkReal x183=((1.0)*sj2);\nIkReal x184=(cj3*sj0);\nIkReal x185=(cj2*cj3);\nIkReal x186=(cj0*sj2);\nIkReal x187=(cj1*sj3);\nIkReal x188=((1.0)*cj2);\nIkReal x189=((1.0)*sj1*sj3);\nIkReal x190=((((-1.0)*x189))+((cj1*x185)));\nIkReal x191=(((sj1*x185))+x187);\nIkReal x192=x156;\nIkReal x193=x157;\nIkReal x194=(cj0*x190);\nIkReal x195=x159;\nIkReal x196=x160;\nIkReal x197=(((sj0*x190))+((cj3*x186)));\nIkReal x198=((((-1.0)*sj2*x184))+x194);\nIkReal x199=(((cj0*x196))+((sj0*sj2*sj3)));\nIkReal x200=(((sj0*x196))+(((-1.0)*sj3*x186)));\nnew_r00=(((r00*((x194+(((-1.0)*x183*x184))))))+((r20*x191))+((r10*x197)));\nnew_r01=(((r01*x198))+((r21*x191))+((r11*x197)));\nnew_r02=(((r12*x197))+((r22*x191))+((r02*x198)));\nnew_r10=(((r00*x195))+((r10*x192))+(((-1.0)*r20*sj1*x183)));\nnew_r11=(((r01*x195))+((r11*x192))+(((-1.0)*r21*sj1*x183)));\nnew_r12=((((-1.0)*r22*sj1*x183))+((r12*x192))+((r02*x195)));\nnew_r20=(((r00*x199))+((r20*x193))+((r10*x200)));\nnew_r21=(((r11*x200))+((r01*x199))+((r21*x193)));\nnew_r22=(((r22*x193))+((r02*x199))+((r12*x200)));\nj4eval[0]=sj5;\nif( IKabs(j4eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r12;\nevalcond[4]=new_r21;\nevalcond[5]=new_r20;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j4array[2], cj4array[2], sj4array[2];\nbool j4valid[2]={false};\n_nj4 = 2;\nCheckValue<IkReal> x202 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x202.valid){\ncontinue;\n}\nIkReal x201=x202.value;\nj4array[0]=((-1.0)*x201);\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nj4array[1]=((3.14159265358979)+(((-1.0)*x201)));\nsj4array[1]=IKsin(j4array[1]);\ncj4array[1]=IKcos(j4array[1]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nif( j4array[1] > IKPI )\n{\n    j4array[1]-=IK2PI;\n}\nelse if( j4array[1] < -IKPI )\n{    j4array[1]+=IK2PI;\n}\nj4valid[1] = true;\nfor(int ij4 = 0; ij4 < 2; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 2; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[1];\nevalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x203=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj4*x203))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x203)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x203))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x203))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((((-1.0)*cj4*x203))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x203))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x204=IKsin(j6);\nIkReal x205=IKcos(j6);\nIkReal x206=((1.0)*cj4);\nIkReal x207=(sj4*x204);\nIkReal x208=((1.0)*x205);\nIkReal x209=(x205*x206);\nevalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x204);\nevalcond[1]=(((new_r00*sj4))+x204+(((-1.0)*new_r10*x206)));\nevalcond[2]=(((new_r01*sj4))+x205+(((-1.0)*new_r11*x206)));\nevalcond[3]=(((cj4*x204))+((sj4*x205))+new_r01);\nevalcond[4]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x208)));\nevalcond[5]=((((-1.0)*x209))+x207+new_r00);\nevalcond[6]=((((-1.0)*x209))+x207+new_r11);\nevalcond[7]=((((-1.0)*x204*x206))+new_r10+(((-1.0)*sj4*x208)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r12;\nevalcond[4]=new_r21;\nevalcond[5]=new_r20;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j4array[2], cj4array[2], sj4array[2];\nbool j4valid[2]={false};\n_nj4 = 2;\nCheckValue<IkReal> x211 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x211.valid){\ncontinue;\n}\nIkReal x210=x211.value;\nj4array[0]=((-1.0)*x210);\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nj4array[1]=((3.14159265358979)+(((-1.0)*x210)));\nsj4array[1]=IKsin(j4array[1]);\ncj4array[1]=IKcos(j4array[1]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nif( j4array[1] > IKPI )\n{\n    j4array[1]-=IK2PI;\n}\nelse if( j4array[1] < -IKPI )\n{    j4array[1]+=IK2PI;\n}\nj4valid[1] = true;\nfor(int ij4 = 0; ij4 < 2; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 2; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[1];\nevalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x212=((1.0)*new_r00);\nif( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x212)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x212)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x212))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x212))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x212))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x212))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x213=IKcos(j6);\nIkReal x214=IKsin(j6);\nIkReal x215=((1.0)*cj4);\nIkReal x216=(sj4*x213);\nIkReal x217=((1.0)*x214);\nIkReal x218=(x214*x215);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x213);\nevalcond[1]=(((new_r00*sj4))+(((-1.0)*new_r10*x215))+x214);\nevalcond[2]=((((-1.0)*new_r11*x215))+((new_r01*sj4))+x213);\nevalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x217)));\nevalcond[4]=(((cj4*x213))+new_r00+((sj4*x214)));\nevalcond[5]=(x216+new_r01+(((-1.0)*x218)));\nevalcond[6]=(x216+new_r10+(((-1.0)*x218)));\nevalcond[7]=((((-1.0)*sj4*x217))+(((-1.0)*x213*x215))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j4, j6]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j4array[1], cj4array[1], sj4array[1];\nbool j4valid[1]={false};\n_nj4 = 1;\nCheckValue<IkReal> x220=IKPowWithIntegerCheck(sj5,-1);\nif(!x220.valid){\ncontinue;\n}\nIkReal x219=x220.value;\nCheckValue<IkReal> x221=IKPowWithIntegerCheck(new_r12,-1);\nif(!x221.valid){\ncontinue;\n}\nif( IKabs((x219*(x221.value)*(((-1.0)+(new_r02*new_r02)+(cj5*cj5))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r02*x219)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x219*(x221.value)*(((-1.0)+(new_r02*new_r02)+(cj5*cj5)))))+IKsqr(((-1.0)*new_r02*x219))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj4array[0]=IKatan2((x219*(x221.value)*(((-1.0)+(new_r02*new_r02)+(cj5*cj5)))), ((-1.0)*new_r02*x219));\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nfor(int ij4 = 0; ij4 < 1; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 1; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[8];\nIkReal x222=IKcos(j4);\nIkReal x223=IKsin(j4);\nIkReal x224=((1.0)*sj5);\nIkReal x225=(new_r12*x223);\nIkReal x226=(new_r02*x222);\nIkReal x227=(sj5*x222);\nevalcond[0]=(x227+new_r02);\nevalcond[1]=(((sj5*x223))+new_r12);\nevalcond[2]=(((new_r12*x222))+(((-1.0)*new_r02*x223)));\nevalcond[3]=(sj5+x225+x226);\nevalcond[4]=(((new_r22*sj5))+((cj5*x225))+((cj5*x226)));\nevalcond[5]=(((cj5*new_r20))+(((-1.0)*new_r10*x223*x224))+(((-1.0)*new_r00*x222*x224)));\nevalcond[6]=((((-1.0)*new_r01*x222*x224))+((cj5*new_r21))+(((-1.0)*new_r11*x223*x224)));\nevalcond[7]=((-1.0)+(((-1.0)*x224*x226))+(((-1.0)*x224*x225))+((cj5*new_r22)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j6eval[2];\nIkReal x228=((1.0)*sj2);\nIkReal x229=(cj3*sj0);\nIkReal x230=(cj2*cj3);\nIkReal x231=(cj0*sj2);\nIkReal x232=(cj1*sj3);\nIkReal x233=((1.0)*cj2);\nIkReal x234=((1.0)*sj1*sj3);\nIkReal x235=(((cj1*x230))+(((-1.0)*x234)));\nIkReal x236=(((sj1*x230))+x232);\nIkReal x237=x156;\nIkReal x238=x157;\nIkReal x239=(cj0*x235);\nIkReal x240=x159;\nIkReal x241=x160;\nIkReal x242=(((cj3*x231))+((sj0*x235)));\nIkReal x243=((((-1.0)*sj2*x229))+x239);\nIkReal x244=(((cj0*x241))+((sj0*sj2*sj3)));\nIkReal x245=((((-1.0)*sj3*x231))+((sj0*x241)));\nnew_r00=(((r00*(((((-1.0)*x228*x229))+x239))))+((r20*x236))+((r10*x242)));\nnew_r01=(((r01*x243))+((r11*x242))+((r21*x236)));\nnew_r02=(((r02*x243))+((r12*x242))+((r22*x236)));\nnew_r10=((((-1.0)*r20*sj1*x228))+((r10*x237))+((r00*x240)));\nnew_r11=(((r11*x237))+(((-1.0)*r21*sj1*x228))+((r01*x240)));\nnew_r12=((((-1.0)*r22*sj1*x228))+((r02*x240))+((r12*x237)));\nnew_r20=(((r20*x238))+((r00*x244))+((r10*x245)));\nnew_r21=(((r01*x244))+((r11*x245))+((r21*x238)));\nnew_r22=(((r02*x244))+((r12*x245))+((r22*x238)));\nj6eval[0]=sj5;\nj6eval[1]=IKsign(sj5);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[2];\nIkReal x246=((1.0)*sj2);\nIkReal x247=(cj3*sj0);\nIkReal x248=(cj2*cj3);\nIkReal x249=(cj0*sj2);\nIkReal x250=(cj1*sj3);\nIkReal x251=((1.0)*cj2);\nIkReal x252=((1.0)*sj1*sj3);\nIkReal x253=(((cj1*x248))+(((-1.0)*x252)));\nIkReal x254=(x250+((sj1*x248)));\nIkReal x255=x156;\nIkReal x256=x157;\nIkReal x257=(cj0*x253);\nIkReal x258=x159;\nIkReal x259=x160;\nIkReal x260=(((sj0*x253))+((cj3*x249)));\nIkReal x261=((((-1.0)*sj2*x247))+x257);\nIkReal x262=(((cj0*x259))+((sj0*sj2*sj3)));\nIkReal x263=((((-1.0)*sj3*x249))+((sj0*x259)));\nnew_r00=(((r20*x254))+((r10*x260))+((r00*((x257+(((-1.0)*x246*x247)))))));\nnew_r01=(((r21*x254))+((r11*x260))+((r01*x261)));\nnew_r02=(((r02*x261))+((r12*x260))+((r22*x254)));\nnew_r10=(((r00*x258))+((r10*x255))+(((-1.0)*r20*sj1*x246)));\nnew_r11=((((-1.0)*r21*sj1*x246))+((r11*x255))+((r01*x258)));\nnew_r12=((((-1.0)*r22*sj1*x246))+((r12*x255))+((r02*x258)));\nnew_r20=(((r20*x256))+((r00*x262))+((r10*x263)));\nnew_r21=(((r21*x256))+((r11*x263))+((r01*x262)));\nnew_r22=(((r02*x262))+((r12*x263))+((r22*x256)));\nj6eval[0]=sj5;\nj6eval[1]=sj4;\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[2];\nIkReal x264=((1.0)*sj2);\nIkReal x265=(cj3*sj0);\nIkReal x266=(cj2*cj3);\nIkReal x267=(cj0*sj2);\nIkReal x268=(cj1*sj3);\nIkReal x269=((1.0)*cj2);\nIkReal x270=((1.0)*sj1*sj3);\nIkReal x271=(((cj1*x266))+(((-1.0)*x270)));\nIkReal x272=(x268+((sj1*x266)));\nIkReal x273=x156;\nIkReal x274=x157;\nIkReal x275=(cj0*x271);\nIkReal x276=x159;\nIkReal x277=x160;\nIkReal x278=(((cj3*x267))+((sj0*x271)));\nIkReal x279=((((-1.0)*sj2*x265))+x275);\nIkReal x280=(((sj0*sj2*sj3))+((cj0*x277)));\nIkReal x281=((((-1.0)*sj3*x267))+((sj0*x277)));\nnew_r00=(((r00*((x275+(((-1.0)*x264*x265))))))+((r10*x278))+((r20*x272)));\nnew_r01=(((r21*x272))+((r01*x279))+((r11*x278)));\nnew_r02=(((r02*x279))+((r22*x272))+((r12*x278)));\nnew_r10=((((-1.0)*r20*sj1*x264))+((r00*x276))+((r10*x273)));\nnew_r11=((((-1.0)*r21*sj1*x264))+((r01*x276))+((r11*x273)));\nnew_r12=((((-1.0)*r22*sj1*x264))+((r02*x276))+((r12*x273)));\nnew_r20=(((r00*x280))+((r10*x281))+((r20*x274)));\nnew_r21=(((r01*x280))+((r11*x281))+((r21*x274)));\nnew_r22=(((r22*x274))+((r02*x280))+((r12*x281)));\nj6eval[0]=sj5;\nj6eval[1]=cj4;\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[10];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x282=(new_r02*sj4);\nIkReal x283=(cj4*new_r12);\nIkReal x284=(((new_r12*sj4))+((cj4*new_r02)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r12;\nevalcond[4]=new_r21;\nevalcond[5]=new_r20;\nevalcond[6]=(x283+(((-1.0)*x282)));\nevalcond[7]=(x282+(((-1.0)*x283)));\nevalcond[8]=x284;\nevalcond[9]=x284;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x285=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj4*x285))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x285)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x285))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x285))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((((-1.0)*cj4*x285))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x285))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x286=IKsin(j6);\nIkReal x287=IKcos(j6);\nIkReal x288=((1.0)*cj4);\nIkReal x289=(sj4*x286);\nIkReal x290=((1.0)*x287);\nIkReal x291=(x287*x288);\nevalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x286);\nevalcond[1]=(((new_r00*sj4))+x286+(((-1.0)*new_r10*x288)));\nevalcond[2]=(((new_r01*sj4))+x287+(((-1.0)*new_r11*x288)));\nevalcond[3]=(new_r01+((cj4*x286))+((sj4*x287)));\nevalcond[4]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x290)));\nevalcond[5]=((((-1.0)*x291))+x289+new_r00);\nevalcond[6]=((((-1.0)*x291))+x289+new_r11);\nevalcond[7]=(new_r10+(((-1.0)*sj4*x290))+(((-1.0)*x286*x288)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x292=(cj4*new_r02);\nIkReal x293=((1.0)*new_r12);\nIkReal x294=(new_r02*sj4);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r12;\nevalcond[4]=new_r21;\nevalcond[5]=new_r20;\nevalcond[6]=((((-1.0)*x294))+((cj4*new_r12)));\nevalcond[7]=((((-1.0)*cj4*x293))+x294);\nevalcond[8]=(((new_r12*sj4))+x292);\nevalcond[9]=((((-1.0)*x292))+(((-1.0)*sj4*x293)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x295=((1.0)*new_r00);\nif( IKabs((((cj4*new_r01))+(((-1.0)*sj4*x295)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x295)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*new_r01))+(((-1.0)*sj4*x295))))+IKsqr(((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x295))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2((((cj4*new_r01))+(((-1.0)*sj4*x295))), ((((-1.0)*new_r01*sj4))+(((-1.0)*cj4*x295))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x296=IKcos(j6);\nIkReal x297=IKsin(j6);\nIkReal x298=((1.0)*cj4);\nIkReal x299=(sj4*x296);\nIkReal x300=((1.0)*x297);\nIkReal x301=(x297*x298);\nevalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x296);\nevalcond[1]=((((-1.0)*new_r10*x298))+((new_r00*sj4))+x297);\nevalcond[2]=((((-1.0)*new_r11*x298))+((new_r01*sj4))+x296);\nevalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x300)));\nevalcond[4]=(((cj4*x296))+((sj4*x297))+new_r00);\nevalcond[5]=(x299+new_r01+(((-1.0)*x301)));\nevalcond[6]=(x299+new_r10+(((-1.0)*x301)));\nevalcond[7]=((((-1.0)*sj4*x300))+(((-1.0)*x296*x298))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x302=(new_r22+(((-1.0)*cj5)));\nIkReal x303=(sj5+new_r12);\nIkReal x304=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));\nevalcond[1]=x302;\nevalcond[2]=x302;\nevalcond[3]=new_r02;\nevalcond[4]=x303;\nevalcond[5]=x303;\nevalcond[6]=(((cj5*new_r12))+((new_r22*sj5)));\nevalcond[7]=(((cj5*new_r20))+(((-1.0)*new_r10*x304)));\nevalcond[8]=(((cj5*new_r21))+(((-1.0)*new_r11*x304)));\nevalcond[9]=((-1.0)+((cj5*new_r22))+(((-1.0)*new_r12*x304)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x305=IKcos(j6);\nIkReal x306=IKsin(j6);\nIkReal x307=((1.0)*new_r12);\nIkReal x308=((1.0)*x305);\nevalcond[0]=(x306+new_r00);\nevalcond[1]=(x305+new_r01);\nevalcond[2]=(((new_r12*x305))+new_r20);\nevalcond[3]=(((new_r22*x306))+new_r11);\nevalcond[4]=((((-1.0)*x306*x307))+new_r21);\nevalcond[5]=((((-1.0)*new_r22*x308))+new_r10);\nevalcond[6]=((((-1.0)*new_r21*x307))+x306+((new_r11*new_r22)));\nevalcond[7]=((((-1.0)*new_r20*x307))+((new_r10*new_r22))+(((-1.0)*x308)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x309=(new_r22+(((-1.0)*cj5)));\nIkReal x310=((1.0)*cj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));\nevalcond[1]=x309;\nevalcond[2]=x309;\nevalcond[3]=new_r02;\nevalcond[4]=((((-1.0)*sj5))+new_r12);\nevalcond[5]=(sj5+(((-1.0)*new_r12)));\nevalcond[6]=((((-1.0)*new_r12*x310))+((new_r22*sj5)));\nevalcond[7]=(((new_r10*sj5))+((cj5*new_r20)));\nevalcond[8]=(((new_r11*sj5))+((cj5*new_r21)));\nevalcond[9]=((-1.0)+((new_r12*sj5))+((cj5*new_r22)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r00, new_r01);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x311=IKsin(j6);\nIkReal x312=IKcos(j6);\nIkReal x313=((1.0)*new_r22);\nIkReal x314=((1.0)*x312);\nevalcond[0]=(((new_r12*x311))+new_r21);\nevalcond[1]=(x311+(((-1.0)*new_r00)));\nevalcond[2]=(x312+(((-1.0)*new_r01)));\nevalcond[3]=((((-1.0)*new_r12*x314))+new_r20);\nevalcond[4]=((((-1.0)*new_r11))+((new_r22*x311)));\nevalcond[5]=((((-1.0)*x312*x313))+(((-1.0)*new_r10)));\nevalcond[6]=((((-1.0)*new_r11*x313))+x311+((new_r12*new_r21)));\nevalcond[7]=(((new_r12*new_r20))+(((-1.0)*new_r10*x313))+(((-1.0)*x314)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x315=(new_r22+(((-1.0)*cj5)));\nIkReal x316=(sj5+new_r02);\nIkReal x317=((1.0)*sj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));\nevalcond[1]=x315;\nevalcond[2]=x315;\nevalcond[3]=x316;\nevalcond[4]=new_r12;\nevalcond[5]=x316;\nevalcond[6]=(((cj5*new_r02))+((new_r22*sj5)));\nevalcond[7]=((((-1.0)*new_r00*x317))+((cj5*new_r20)));\nevalcond[8]=(((cj5*new_r21))+(((-1.0)*new_r01*x317)));\nevalcond[9]=((-1.0)+(((-1.0)*new_r02*x317))+((cj5*new_r22)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(new_r10, new_r11);\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x318=IKcos(j6);\nIkReal x319=IKsin(j6);\nIkReal x320=((1.0)*new_r02);\nIkReal x321=((1.0)*x318);\nevalcond[0]=(((new_r02*x318))+new_r20);\nevalcond[1]=(x319+(((-1.0)*new_r10)));\nevalcond[2]=(x318+(((-1.0)*new_r11)));\nevalcond[3]=(new_r01+((new_r22*x319)));\nevalcond[4]=((((-1.0)*x319*x320))+new_r21);\nevalcond[5]=((((-1.0)*new_r22*x321))+new_r00);\nevalcond[6]=(((new_r01*new_r22))+x319+(((-1.0)*new_r21*x320)));\nevalcond[7]=(((new_r00*new_r22))+(((-1.0)*x321))+(((-1.0)*new_r20*x320)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x322=(new_r22+(((-1.0)*cj5)));\nIkReal x323=((1.0)*cj5);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));\nevalcond[1]=x322;\nevalcond[2]=x322;\nevalcond[3]=((((-1.0)*sj5))+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=(sj5+(((-1.0)*new_r02)));\nevalcond[6]=((((-1.0)*new_r02*x323))+((new_r22*sj5)));\nevalcond[7]=(((new_r00*sj5))+((cj5*new_r20)));\nevalcond[8]=(((new_r01*sj5))+((cj5*new_r21)));\nevalcond[9]=((-1.0)+((new_r02*sj5))+((cj5*new_r22)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nif( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[8];\nIkReal x324=IKsin(j6);\nIkReal x325=IKcos(j6);\nIkReal x326=((1.0)*new_r22);\nIkReal x327=((1.0)*x325);\nevalcond[0]=(x324+new_r10);\nevalcond[1]=(x325+new_r11);\nevalcond[2]=(new_r21+((new_r02*x324)));\nevalcond[3]=((((-1.0)*new_r02*x327))+new_r20);\nevalcond[4]=(((new_r22*x324))+(((-1.0)*new_r01)));\nevalcond[5]=((((-1.0)*x325*x326))+(((-1.0)*new_r00)));\nevalcond[6]=(x324+(((-1.0)*new_r01*x326))+((new_r02*new_r21)));\nevalcond[7]=((((-1.0)*x327))+(((-1.0)*new_r00*x326))+((new_r02*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j6]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x329=IKPowWithIntegerCheck(sj5,-1);\nif(!x329.valid){\ncontinue;\n}\nIkReal x328=x329.value;\nCheckValue<IkReal> x330=IKPowWithIntegerCheck(cj4,-1);\nif(!x330.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r21*x328)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x328*(x330.value)*(((((-1.0)*cj5*new_r21*sj4))+((new_r11*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x328))+IKsqr((x328*(x330.value)*(((((-1.0)*cj5*new_r21*sj4))+((new_r11*sj5))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r21*x328), (x328*(x330.value)*(((((-1.0)*cj5*new_r21*sj4))+((new_r11*sj5))))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x331=IKsin(j6);\nIkReal x332=IKcos(j6);\nIkReal x333=(cj4*new_r01);\nIkReal x334=(new_r10*sj4);\nIkReal x335=(cj4*cj5);\nIkReal x336=((1.0)*cj4);\nIkReal x337=(new_r11*sj4);\nIkReal x338=(cj5*x331);\nIkReal x339=((1.0)*x332);\nevalcond[0]=(((sj5*x331))+new_r21);\nevalcond[1]=((((-1.0)*sj5*x339))+new_r20);\nevalcond[2]=((((-1.0)*new_r10*x336))+((new_r00*sj4))+x331);\nevalcond[3]=((((-1.0)*new_r11*x336))+((new_r01*sj4))+x332);\nevalcond[4]=(x338+x333+x337);\nevalcond[5]=(((x331*x335))+((sj4*x332))+new_r01);\nevalcond[6]=(((cj4*new_r00))+(((-1.0)*cj5*x339))+x334);\nevalcond[7]=(((sj4*x331))+new_r00+(((-1.0)*x335*x339)));\nevalcond[8]=(((sj4*x338))+(((-1.0)*x332*x336))+new_r11);\nevalcond[9]=((((-1.0)*cj5*sj4*x339))+(((-1.0)*x331*x336))+new_r10);\nevalcond[10]=(x331+((cj5*x337))+((cj5*x333))+((new_r21*sj5)));\nevalcond[11]=(((new_r20*sj5))+((new_r00*x335))+(((-1.0)*x339))+((cj5*x334)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x341=IKPowWithIntegerCheck(sj5,-1);\nif(!x341.valid){\ncontinue;\n}\nIkReal x340=x341.value;\nCheckValue<IkReal> x342=IKPowWithIntegerCheck(sj4,-1);\nif(!x342.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r21*x340)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x340*(x342.value)*(((((-1.0)*new_r01*sj5))+((cj4*cj5*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x340))+IKsqr((x340*(x342.value)*(((((-1.0)*new_r01*sj5))+((cj4*cj5*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj6array[0]=IKatan2(((-1.0)*new_r21*x340), (x340*(x342.value)*(((((-1.0)*new_r01*sj5))+((cj4*cj5*new_r21))))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x343=IKsin(j6);\nIkReal x344=IKcos(j6);\nIkReal x345=(cj4*new_r01);\nIkReal x346=(new_r10*sj4);\nIkReal x347=(cj4*cj5);\nIkReal x348=((1.0)*cj4);\nIkReal x349=(new_r11*sj4);\nIkReal x350=(cj5*x343);\nIkReal x351=((1.0)*x344);\nevalcond[0]=(((sj5*x343))+new_r21);\nevalcond[1]=(new_r20+(((-1.0)*sj5*x351)));\nevalcond[2]=((((-1.0)*new_r10*x348))+((new_r00*sj4))+x343);\nevalcond[3]=((((-1.0)*new_r11*x348))+((new_r01*sj4))+x344);\nevalcond[4]=(x350+x345+x349);\nevalcond[5]=(((sj4*x344))+new_r01+((x343*x347)));\nevalcond[6]=(((cj4*new_r00))+x346+(((-1.0)*cj5*x351)));\nevalcond[7]=((((-1.0)*x347*x351))+((sj4*x343))+new_r00);\nevalcond[8]=(((sj4*x350))+(((-1.0)*x344*x348))+new_r11);\nevalcond[9]=((((-1.0)*x343*x348))+new_r10+(((-1.0)*cj5*sj4*x351)));\nevalcond[10]=(x343+((cj5*x349))+((cj5*x345))+((new_r21*sj5)));\nevalcond[11]=(((new_r20*sj5))+(((-1.0)*x351))+((new_r00*x347))+((cj5*x346)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x352 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x352.valid){\ncontinue;\n}\nCheckValue<IkReal> x353=IKPowWithIntegerCheck(IKsign(sj5),-1);\nif(!x353.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x352.value)+(((1.5707963267949)*(x353.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[12];\nIkReal x354=IKsin(j6);\nIkReal x355=IKcos(j6);\nIkReal x356=(cj4*new_r01);\nIkReal x357=(new_r10*sj4);\nIkReal x358=(cj4*cj5);\nIkReal x359=((1.0)*cj4);\nIkReal x360=(new_r11*sj4);\nIkReal x361=(cj5*x354);\nIkReal x362=((1.0)*x355);\nevalcond[0]=(((sj5*x354))+new_r21);\nevalcond[1]=((((-1.0)*sj5*x362))+new_r20);\nevalcond[2]=(((new_r00*sj4))+x354+(((-1.0)*new_r10*x359)));\nevalcond[3]=(((new_r01*sj4))+x355+(((-1.0)*new_r11*x359)));\nevalcond[4]=(x356+x360+x361);\nevalcond[5]=(((sj4*x355))+((x354*x358))+new_r01);\nevalcond[6]=(((cj4*new_r00))+(((-1.0)*cj5*x362))+x357);\nevalcond[7]=(((sj4*x354))+(((-1.0)*x358*x362))+new_r00);\nevalcond[8]=(((sj4*x361))+new_r11+(((-1.0)*x355*x359)));\nevalcond[9]=(new_r10+(((-1.0)*x354*x359))+(((-1.0)*cj5*sj4*x362)));\nevalcond[10]=(x354+((cj5*x360))+((cj5*x356))+((new_r21*sj5)));\nevalcond[11]=(((new_r20*sj5))+(((-1.0)*x362))+((cj5*x357))+((new_r00*x358)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nCheckValue<IkReal> x363 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x363.valid){\ncontinue;\n}\nCheckValue<IkReal> x364=IKPowWithIntegerCheck(IKsign(sj5),-1);\nif(!x364.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x363.value)+(((1.5707963267949)*(x364.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[2];\nevalcond[0]=(((sj5*(IKsin(j6))))+new_r21);\nevalcond[1]=((((-1.0)*sj5*(IKcos(j6))))+new_r20);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[2];\nIkReal x365=((1.0)*sj2);\nIkReal x366=(cj3*sj0);\nIkReal x367=(cj2*cj3);\nIkReal x368=(cj0*sj2);\nIkReal x369=(cj1*sj3);\nIkReal x370=((1.0)*cj2);\nIkReal x371=((1.0)*sj1*sj3);\nIkReal x372=((((-1.0)*x371))+((cj1*x367)));\nIkReal x373=(((sj1*x367))+x369);\nIkReal x374=x156;\nIkReal x375=x157;\nIkReal x376=(cj0*x372);\nIkReal x377=x159;\nIkReal x378=x160;\nIkReal x379=(((sj0*x372))+((cj3*x368)));\nIkReal x380=((((-1.0)*sj2*x366))+x376);\nIkReal x381=(((sj0*sj2*sj3))+((cj0*x378)));\nIkReal x382=((((-1.0)*sj3*x368))+((sj0*x378)));\nnew_r00=(((r20*x373))+((r00*((x376+(((-1.0)*x365*x366))))))+((r10*x379)));\nnew_r01=(((r11*x379))+((r21*x373))+((r01*x380)));\nnew_r02=(((r02*x380))+((r12*x379))+((r22*x373)));\nnew_r10=((((-1.0)*r20*sj1*x365))+((r00*x377))+((r10*x374)));\nnew_r11=(((r01*x377))+((r11*x374))+(((-1.0)*r21*sj1*x365)));\nnew_r12=(((r02*x377))+(((-1.0)*r22*sj1*x365))+((r12*x374)));\nnew_r20=(((r20*x375))+((r10*x382))+((r00*x381)));\nnew_r21=(((r11*x382))+((r21*x375))+((r01*x381)));\nnew_r22=(((r12*x382))+((r02*x381))+((r22*x375)));\nj4eval[0]=sj5;\nj4eval[1]=IKsign(sj5);\nif( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j4eval[1];\nIkReal x383=((1.0)*sj2);\nIkReal x384=(cj3*sj0);\nIkReal x385=(cj2*cj3);\nIkReal x386=(cj0*sj2);\nIkReal x387=(cj1*sj3);\nIkReal x388=((1.0)*cj2);\nIkReal x389=((1.0)*sj1*sj3);\nIkReal x390=(((cj1*x385))+(((-1.0)*x389)));\nIkReal x391=(x387+((sj1*x385)));\nIkReal x392=x156;\nIkReal x393=x157;\nIkReal x394=(cj0*x390);\nIkReal x395=x159;\nIkReal x396=x160;\nIkReal x397=(((cj3*x386))+((sj0*x390)));\nIkReal x398=((((-1.0)*sj2*x384))+x394);\nIkReal x399=(((cj0*x396))+((sj0*sj2*sj3)));\nIkReal x400=(((sj0*x396))+(((-1.0)*sj3*x386)));\nnew_r00=(((r20*x391))+((r10*x397))+((r00*((x394+(((-1.0)*x383*x384)))))));\nnew_r01=(((r01*x398))+((r11*x397))+((r21*x391)));\nnew_r02=(((r22*x391))+((r12*x397))+((r02*x398)));\nnew_r10=(((r10*x392))+((r00*x395))+(((-1.0)*r20*sj1*x383)));\nnew_r11=(((r01*x395))+(((-1.0)*r21*sj1*x383))+((r11*x392)));\nnew_r12=((((-1.0)*r22*sj1*x383))+((r12*x392))+((r02*x395)));\nnew_r20=(((r20*x393))+((r00*x399))+((r10*x400)));\nnew_r21=(((r11*x400))+((r01*x399))+((r21*x393)));\nnew_r22=(((r12*x400))+((r22*x393))+((r02*x399)));\nj4eval[0]=sj5;\nif( IKabs(j4eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r12;\nevalcond[4]=new_r21;\nevalcond[5]=new_r20;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j4array[1], cj4array[1], sj4array[1];\nbool j4valid[1]={false};\n_nj4 = 1;\nCheckValue<IkReal> x401=IKPowWithIntegerCheck(IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)))),-1);\nif(!x401.valid){\ncontinue;\n}\nCheckValue<IkReal> x402 = IKatan2WithCheck(IkReal((new_r02*sj6)),((-1.0)*new_r12*sj6),IKFAST_ATAN2_MAGTHRESH);\nif(!x402.valid){\ncontinue;\n}\nj4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x401.value)))+(x402.value));\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nfor(int ij4 = 0; ij4 < 1; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 1; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[10];\nIkReal x403=IKcos(j4);\nIkReal x404=IKsin(j4);\nIkReal x405=(sj6*x404);\nIkReal x406=((1.0)*x403);\nIkReal x407=(cj6*x404);\nIkReal x408=(cj6*x406);\nevalcond[0]=(((new_r12*x404))+((new_r02*x403)));\nevalcond[1]=((((-1.0)*new_r02*x404))+((new_r12*x403)));\nevalcond[2]=(sj6+((new_r11*x404))+((new_r01*x403)));\nevalcond[3]=(((sj6*x403))+x407+new_r01);\nevalcond[4]=(sj6+(((-1.0)*new_r10*x406))+((new_r00*x404)));\nevalcond[5]=(cj6+((new_r01*x404))+(((-1.0)*new_r11*x406)));\nevalcond[6]=(x405+new_r00+(((-1.0)*x408)));\nevalcond[7]=(x405+new_r11+(((-1.0)*x408)));\nevalcond[8]=(((new_r10*x404))+((new_r00*x403))+(((-1.0)*cj6)));\nevalcond[9]=(new_r10+(((-1.0)*x407))+(((-1.0)*sj6*x406)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r02;\nevalcond[3]=new_r12;\nevalcond[4]=new_r21;\nevalcond[5]=new_r20;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j4array[1], cj4array[1], sj4array[1];\nbool j4valid[1]={false};\n_nj4 = 1;\nCheckValue<IkReal> x409=IKPowWithIntegerCheck(IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)))),-1);\nif(!x409.valid){\ncontinue;\n}\nCheckValue<IkReal> x410 = IKatan2WithCheck(IkReal((cj6*new_r02)),((-1.0)*cj6*new_r12),IKFAST_ATAN2_MAGTHRESH);\nif(!x410.valid){\ncontinue;\n}\nj4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x409.value)))+(x410.value));\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nfor(int ij4 = 0; ij4 < 1; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 1; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[10];\nIkReal x411=IKcos(j4);\nIkReal x412=IKsin(j4);\nIkReal x413=((1.0)*sj6);\nIkReal x414=(cj6*x412);\nIkReal x415=((1.0)*x411);\nIkReal x416=(x411*x413);\nevalcond[0]=(((new_r12*x412))+((new_r02*x411)));\nevalcond[1]=((((-1.0)*new_r02*x412))+((new_r12*x411)));\nevalcond[2]=(cj6+((new_r10*x412))+((new_r00*x411)));\nevalcond[3]=(((cj6*x411))+((sj6*x412))+new_r00);\nevalcond[4]=(sj6+((new_r00*x412))+(((-1.0)*new_r10*x415)));\nevalcond[5]=(cj6+(((-1.0)*new_r11*x415))+((new_r01*x412)));\nevalcond[6]=(x414+new_r01+(((-1.0)*x416)));\nevalcond[7]=(x414+new_r10+(((-1.0)*x416)));\nevalcond[8]=(((new_r11*x412))+(((-1.0)*x413))+((new_r01*x411)));\nevalcond[9]=((((-1.0)*x412*x413))+(((-1.0)*cj6*x415))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j4]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j4array[1], cj4array[1], sj4array[1];\nbool j4valid[1]={false};\n_nj4 = 1;\nCheckValue<IkReal> x418=IKPowWithIntegerCheck(sj5,-1);\nif(!x418.valid){\ncontinue;\n}\nIkReal x417=x418.value;\nCheckValue<IkReal> x419=IKPowWithIntegerCheck(new_r12,-1);\nif(!x419.valid){\ncontinue;\n}\nif( IKabs((x417*(x419.value)*(((-1.0)+(new_r02*new_r02)+(cj5*cj5))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r02*x417)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x417*(x419.value)*(((-1.0)+(new_r02*new_r02)+(cj5*cj5)))))+IKsqr(((-1.0)*new_r02*x417))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj4array[0]=IKatan2((x417*(x419.value)*(((-1.0)+(new_r02*new_r02)+(cj5*cj5)))), ((-1.0)*new_r02*x417));\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nfor(int ij4 = 0; ij4 < 1; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 1; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[18];\nIkReal x420=IKcos(j4);\nIkReal x421=IKsin(j4);\nIkReal x422=((1.0)*cj6);\nIkReal x423=((1.0)*new_r10);\nIkReal x424=((1.0)*new_r02);\nIkReal x425=((1.0)*sj5);\nIkReal x426=(sj6*x420);\nIkReal x427=(cj5*x421);\nIkReal x428=(sj5*x420);\nIkReal x429=(new_r11*x421);\nIkReal x430=(cj5*x420);\nIkReal x431=(new_r12*x421);\nIkReal x432=(sj5*x421);\nevalcond[0]=(x428+new_r02);\nevalcond[1]=(x432+new_r12);\nevalcond[2]=((((-1.0)*x421*x424))+((new_r12*x420)));\nevalcond[3]=(sj5+x431+((new_r02*x420)));\nevalcond[4]=((((-1.0)*x420*x423))+sj6+((new_r00*x421)));\nevalcond[5]=(cj6+(((-1.0)*new_r11*x420))+((new_r01*x421)));\nevalcond[6]=(((cj5*x426))+((cj6*x421))+new_r01);\nevalcond[7]=(((cj5*sj6))+x429+((new_r01*x420)));\nevalcond[8]=(((sj6*x421))+new_r00+(((-1.0)*x422*x430)));\nevalcond[9]=((((-1.0)*x420*x422))+((sj6*x427))+new_r11);\nevalcond[10]=(((new_r10*x421))+(((-1.0)*cj5*x422))+((new_r00*x420)));\nevalcond[11]=((((-1.0)*x422*x427))+(((-1.0)*x426))+new_r10);\nevalcond[12]=(((new_r22*sj5))+((new_r12*x427))+((new_r02*x430)));\nevalcond[13]=(((new_r01*x430))+sj6+((new_r11*x427))+((new_r21*sj5)));\nevalcond[14]=(((cj5*new_r20))+(((-1.0)*new_r00*x420*x425))+(((-1.0)*x423*x432)));\nevalcond[15]=((((-1.0)*new_r01*x420*x425))+((cj5*new_r21))+(((-1.0)*x425*x429)));\nevalcond[16]=((-1.0)+((cj5*new_r22))+(((-1.0)*x424*x428))+(((-1.0)*x425*x431)));\nevalcond[17]=(((new_r00*x430))+((new_r20*sj5))+(((-1.0)*x422))+((new_r10*x427)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j4array[1], cj4array[1], sj4array[1];\nbool j4valid[1]={false};\n_nj4 = 1;\nCheckValue<IkReal> x433=IKPowWithIntegerCheck(IKsign(sj5),-1);\nif(!x433.valid){\ncontinue;\n}\nCheckValue<IkReal> x434 = IKatan2WithCheck(IkReal(((-1.0)*new_r12)),((-1.0)*new_r02),IKFAST_ATAN2_MAGTHRESH);\nif(!x434.valid){\ncontinue;\n}\nj4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x433.value)))+(x434.value));\nsj4array[0]=IKsin(j4array[0]);\ncj4array[0]=IKcos(j4array[0]);\nif( j4array[0] > IKPI )\n{\n    j4array[0]-=IK2PI;\n}\nelse if( j4array[0] < -IKPI )\n{    j4array[0]+=IK2PI;\n}\nj4valid[0] = true;\nfor(int ij4 = 0; ij4 < 1; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 1; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n{\nIkReal evalcond[18];\nIkReal x435=IKcos(j4);\nIkReal x436=IKsin(j4);\nIkReal x437=((1.0)*cj6);\nIkReal x438=((1.0)*new_r10);\nIkReal x439=((1.0)*new_r02);\nIkReal x440=((1.0)*sj5);\nIkReal x441=(sj6*x435);\nIkReal x442=(cj5*x436);\nIkReal x443=(sj5*x435);\nIkReal x444=(new_r11*x436);\nIkReal x445=(cj5*x435);\nIkReal x446=(new_r12*x436);\nIkReal x447=(sj5*x436);\nevalcond[0]=(x443+new_r02);\nevalcond[1]=(x447+new_r12);\nevalcond[2]=((((-1.0)*x436*x439))+((new_r12*x435)));\nevalcond[3]=(sj5+x446+((new_r02*x435)));\nevalcond[4]=(((new_r00*x436))+sj6+(((-1.0)*x435*x438)));\nevalcond[5]=(((new_r01*x436))+cj6+(((-1.0)*new_r11*x435)));\nevalcond[6]=(((cj5*x441))+((cj6*x436))+new_r01);\nevalcond[7]=(((new_r01*x435))+((cj5*sj6))+x444);\nevalcond[8]=((((-1.0)*x437*x445))+((sj6*x436))+new_r00);\nevalcond[9]=((((-1.0)*x435*x437))+((sj6*x442))+new_r11);\nevalcond[10]=(((new_r00*x435))+(((-1.0)*cj5*x437))+((new_r10*x436)));\nevalcond[11]=((((-1.0)*x437*x442))+(((-1.0)*x441))+new_r10);\nevalcond[12]=(((new_r12*x442))+((new_r22*sj5))+((new_r02*x445)));\nevalcond[13]=(((new_r01*x445))+sj6+((new_r11*x442))+((new_r21*sj5)));\nevalcond[14]=((((-1.0)*x438*x447))+((cj5*new_r20))+(((-1.0)*new_r00*x435*x440)));\nevalcond[15]=(((cj5*new_r21))+(((-1.0)*x440*x444))+(((-1.0)*new_r01*x435*x440)));\nevalcond[16]=((-1.0)+(((-1.0)*x439*x443))+((cj5*new_r22))+(((-1.0)*x440*x446)));\nevalcond[17]=(((new_r00*x445))+(((-1.0)*x437))+((new_r20*sj5))+((new_r10*x442)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j6;\nvinfos[6].indices[0] = _ij6[0];\nvinfos[6].indices[1] = _ij6[1];\nvinfos[6].maxsolutions = _nj6;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\n}};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"f1b4ece80cdeeec66467d9998ec73679\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\nchar* ComputeFkWrapper(const IkReal* j) {\n    IkReal eetrans[3];\n    IkReal eerot[9];\n    IkReal res[3 + 9];\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n\nstd::vector<IkReal> TrueComputeIk(int argc, char** argv)\n{\n    std::vector<IkReal> solvalues(GetNumJoints());\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return solvalues;\n}\n"]}