{"version":3,"file":"./solvers/pr2_rightarm.html","sources":["./solvers/pr2_rightarm.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAvMA;AAAA;AAAA;;;;;;;;AAFA;AAAA;AAAA;;;;;AA6MA;;;;;;;;;;;;;;;AAgpRA;AACA;AACA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-05-22 19:30:49.293566\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56;\nx0=IKcos(j[0]);\nx1=IKcos(j[1]);\nx2=IKsin(j[3]);\nx3=IKcos(j[3]);\nx4=IKsin(j[1]);\nx5=IKsin(j[2]);\nx6=IKcos(j[2]);\nx7=IKsin(j[0]);\nx8=IKcos(j[4]);\nx9=IKsin(j[4]);\nx10=IKsin(j[5]);\nx11=IKcos(j[5]);\nx12=IKcos(j[6]);\nx13=IKsin(j[6]);\nx14=((1.0)*x10);\nx15=((1.0)*x9);\nx16=((0.321)*x6);\nx17=((1.0)*x7);\nx18=((1.0)*x11);\nx19=((1.0)*x6);\nx20=((0.4)*x1);\nx21=(x1*x2);\nx22=(x0*x6);\nx23=(x2*x4);\nx24=(x0*x5);\nx25=((-1.0)*x0);\nx26=(x3*x4);\nx27=((-1.0)*x3);\nx28=(x4*x7);\nx29=((-1.0)*x2);\nx30=(x1*x3);\nx31=(x30*x7);\nx32=(x1*x5*x8);\nx33=((1.0)*x0*x21);\nx34=(x17*x21);\nx35=(x19*x30);\nx36=((((-1.0)*x17*x6))+((x24*x4)));\nx37=((((-1.0)*x17*x4*x6))+x24);\nx38=(x22+((x28*x5)));\nx39=((((-1.0)*x23))+x35);\nx40=((1.0)*x37);\nx41=((((-1.0)*x17*x5))+(((-1.0)*x0*x19*x4)));\nx42=(x36*x9);\nx43=(x38*x9);\nx44=(x3*x37);\nx45=(((x19*x21))+(((1.0)*x26)));\nx46=(x36*x8);\nx47=(x2*x37);\nx48=(x38*x8);\nx49=(x3*x41);\nx50=((-1.0)*x41);\nx51=(((x1*x5*x9))+((x8*(((((-1.0)*x35))+x23)))));\nx52=(((x27*x41))+x33);\nx53=(x52*x9);\nx54=(x43+((x8*(((((-1.0)*x21*x7))+x44)))));\nx55=((((-1.0)*x18*x51))+(((-1.0)*x14*x45)));\nx56=((((-1.0)*x18*(((((1.0)*x8*(((((-1.0)*x33))+x49))))+(((1.0)*x42))))))+((x14*(((((-1.0)*x25*x30))+(((-1.0)*x29*x41)))))));\neerot[0]=(((x11*((((x2*x41))+((x0*x30))))))+((x10*((((x8*((((x21*x25))+x49))))+x42)))));\neerot[1]=(((x13*x56))+((x12*((x46+x53)))));\neerot[2]=(((x12*x56))+((x13*(((((-1.0)*x46))+(((-1.0)*x53)))))));\neetrans[0]=(((x0*x20))+(((0.1)*x0))+(((0.321)*x0*x30))+((x2*(((((-0.321)*x5*x7))+(((-1.0)*x0*x16*x4)))))));\neerot[3]=(((x11*((x31+x47))))+((x10*((((x8*(((((-1.0)*x34))+x44))))+x43)))));\neerot[4]=((((-1.0)*x13*((((x14*(((((-1.0)*x17*x30))+(((-1.0)*x2*x40))))))+((x18*x54))))))+((x12*((((x9*((((x27*x37))+x34))))+x48)))));\neerot[5]=(((x12*(((((-1.0)*x11*x54))+(((-1.0)*x10*((((x29*x37))+((x1*x27*x7))))))))))+(((-1.0)*x13*((((x15*(((((-1.0)*x3*x40))+x34))))+(((1.0)*x48)))))));\neetrans[1]=((-0.188)+(((0.1)*x7))+(((0.321)*x31))+((x2*(((((-1.0)*x16*x28))+(((0.321)*x24))))))+((x20*x7)));\neerot[6]=(((x10*x51))+(((-1.0)*x11*x45)));\neerot[7]=(((x13*x55))+((x12*((x32+((x39*x9)))))));\neerot[8]=(((x12*x55))+((x13*(((((-1.0)*x32))+(((-1.0)*x15*x39)))))));\neetrans[2]=((((-1.0)*x16*x21))+(((-0.4)*x4))+(((-0.321)*x26)));\n}\n\nIKFAST_API int GetNumFreeParameters() { return 1; }\nIKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }\nIKFAST_API int GetNumJoints() { return 7; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j27,cj27,sj27,htj27,j27mul,j28,cj28,sj28,htj28,j28mul,j30,cj30,sj30,htj30,j30mul,j31,cj31,sj31,htj31,j31mul,j32,cj32,sj32,htj32,j32mul,j33,cj33,sj33,htj33,j33mul,j29,cj29,sj29,htj29,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij27[2], _nj27,_ij28[2], _nj28,_ij30[2], _nj30,_ij31[2], _nj31,_ij32[2], _nj32,_ij33[2], _nj33,_ij29[2], _nj29;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj27=numeric_limits<IkReal>::quiet_NaN(); _ij27[0] = -1; _ij27[1] = -1; _nj27 = -1; j28=numeric_limits<IkReal>::quiet_NaN(); _ij28[0] = -1; _ij28[1] = -1; _nj28 = -1; j30=numeric_limits<IkReal>::quiet_NaN(); _ij30[0] = -1; _ij30[1] = -1; _nj30 = -1; j31=numeric_limits<IkReal>::quiet_NaN(); _ij31[0] = -1; _ij31[1] = -1; _nj31 = -1; j32=numeric_limits<IkReal>::quiet_NaN(); _ij32[0] = -1; _ij32[1] = -1; _nj32 = -1; j33=numeric_limits<IkReal>::quiet_NaN(); _ij33[0] = -1; _ij33[1] = -1; _nj33 = -1;  _ij29[0] = -1; _ij29[1] = -1; _nj29 = 0; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nj29=pfree[0]; cj29=cos(pfree[0]); sj29=sin(pfree[0]), htj29=tan(pfree[0]*0.5);\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=((-1.0)*r02);\nnew_r01=r01;\nnew_r02=r00;\nnew_px=px;\nnew_r10=((-1.0)*r12);\nnew_r11=r11;\nnew_r12=r10;\nnew_py=((0.188)+py);\nnew_r20=((-1.0)*r22);\nnew_r21=r21;\nnew_r22=r20;\nnew_pz=pz;\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x57=((1.0)*px);\nIkReal x58=((1.0)*pz);\nIkReal x59=((1.0)*py);\npp=((px*px)+(py*py)+(pz*pz));\nnpx=(((px*r00))+((py*r10))+((pz*r20)));\nnpy=(((px*r01))+((py*r11))+((pz*r21)));\nnpz=(((px*r02))+((py*r12))+((pz*r22)));\nrxp0_0=((((-1.0)*r20*x59))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x58)));\nrxp0_2=((((-1.0)*r10*x57))+((py*r00)));\nrxp1_0=((((-1.0)*r21*x59))+((pz*r11)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x58)));\nrxp1_2=((((-1.0)*r11*x57))+((py*r01)));\nrxp2_0=(((pz*r12))+(((-1.0)*r22*x59)));\nrxp2_1=(((px*r22))+(((-1.0)*r02*x58)));\nrxp2_2=((((-1.0)*r12*x57))+((py*r02)));\nIkReal op[8+1], zeror[8];\nint numroots;\nIkReal x60=((0.2)*px);\nIkReal x61=((1.0)*pp);\nIkReal x62=((0.509841)+x60+(((-1.0)*x61)));\nIkReal x63=((-0.003759)+x60+(((-1.0)*x61)));\nIkReal x64=(x60+x61);\nIkReal x65=((0.509841)+(((-1.0)*x64)));\nIkReal x66=((-0.003759)+(((-1.0)*x64)));\nIkReal gconst0=x62;\nIkReal gconst1=x63;\nIkReal gconst2=x62;\nIkReal gconst3=x63;\nIkReal gconst4=x65;\nIkReal gconst5=x66;\nIkReal gconst6=x65;\nIkReal gconst7=x66;\nIkReal x67=py*py;\nIkReal x68=sj29*sj29;\nIkReal x69=px*px;\nIkReal x70=((1.0)*gconst4);\nIkReal x71=(gconst5*gconst7);\nIkReal x72=(gconst0*gconst3);\nIkReal x73=(gconst1*gconst2);\nIkReal x74=((2.0)*gconst5);\nIkReal x75=((1.0)*gconst0);\nIkReal x76=(gconst1*gconst7);\nIkReal x77=(gconst0*gconst6);\nIkReal x78=(gconst1*gconst3);\nIkReal x79=(gconst4*gconst7);\nIkReal x80=((2.0)*gconst0);\nIkReal x81=(gconst1*gconst6);\nIkReal x82=(gconst0*gconst7);\nIkReal x83=((2.0)*gconst4);\nIkReal x84=(gconst3*gconst5);\nIkReal x85=(gconst2*gconst5);\nIkReal x86=(gconst3*gconst4);\nIkReal x87=(gconst2*gconst4);\nIkReal x88=(gconst4*gconst6);\nIkReal x89=(gconst5*gconst6);\nIkReal x90=(gconst0*gconst2);\nIkReal x91=((1.05513984)*px*py);\nIkReal x92=(gconst6*x67);\nIkReal x93=((4.0)*px*py);\nIkReal x94=((4.0)*x69);\nIkReal x95=(gconst2*x67);\nIkReal x96=(py*x68);\nIkReal x97=((2.0)*x67);\nIkReal x98=((1.0)*x67);\nIkReal x99=((0.824328)*x68);\nIkReal x100=((0.412164)*x68);\nIkReal x101=(x67*x79);\nIkReal x102=(x67*x89);\nIkReal x103=(x67*x85);\nIkReal x104=(x67*x86);\nIkReal x105=(x67*x82);\nIkReal x106=(x67*x81);\nIkReal x107=((0.0834355125792)*x96);\nIkReal x108=(x67*x73);\nIkReal x109=(x67*x72);\nIkReal x110=(x68*x85);\nIkReal x111=(x67*x68);\nIkReal x112=(x71*x98);\nIkReal x113=(x70*x92);\nIkReal x114=(x100*x89);\nIkReal x115=(x87*x93);\nIkReal x116=(x76*x93);\nIkReal x117=(x84*x93);\nIkReal x118=(x77*x93);\nIkReal x119=(x86*x93);\nIkReal x120=(x82*x93);\nIkReal x121=(x85*x93);\nIkReal x122=(x81*x93);\nIkReal x123=(x100*x85);\nIkReal x124=((0.06594624)*x111);\nIkReal x125=(x76*x98);\nIkReal x126=(x70*x95);\nIkReal x127=(x75*x92);\nIkReal x128=(x100*x81);\nIkReal x129=(x84*x98);\nIkReal x130=((0.3297312)*pp*x96);\nIkReal x131=((0.06594624)*px*x96);\nIkReal x132=(x75*x95);\nIkReal x133=(x100*x73);\nIkReal x134=(x78*x98);\nIkReal x135=(x108+x109);\nIkReal x136=(x101+x102);\nIkReal x137=(x134+x133+x132);\nIkReal x138=(x113+x112+x114);\nIkReal x139=(x104+x105+x106+x103);\nIkReal x140=(x122+x120+x121+x119);\nIkReal x141=(x117+x116+x115+x118);\nIkReal x142=(x126+x127+x124+x125+x123+x128+x129);\nop[0]=(x136+(((-1.0)*x138)));\nop[1]=((((-1.0)*x107))+x131+x130+(((-1.0)*x91)));\nop[2]=((((-1.0)*x142))+((x71*x97))+(((-1.0)*x71*x94))+((x79*x94))+((x89*x94))+x139+(((-1.0)*x74*x92))+(((-1.0)*x79*x97))+((x83*x92))+(((-1.0)*x88*x94))+(((-1.0)*x89*x99)));\nop[3]=((((-1.0)*x141))+((x71*x93))+(((-0.3297312)*gconst5*x96))+x140+(((-1.0)*x79*x93))+((x88*x93))+(((-0.1648656)*gconst2*x96))+(((-0.3297312)*gconst6*x96))+(((-0.1648656)*gconst1*x96))+(((-1.0)*x89*x93)));\nop[4]=(((x82*x94))+((x81*x94))+(((-1.0)*x77*x94))+(((-0.13189248)*x111))+((x86*x94))+((x85*x94))+x135+x136+((gconst3*x67*x74))+(((-1.0)*x87*x94))+(((-1.0)*x137))+(((-1.0)*x138))+(((-1.0)*x74*x95))+((x76*x97))+(((-1.0)*x76*x94))+(((-1.0)*x84*x94))+(((-1.0)*gconst3*x67*x83))+((x83*x95))+(((-1.0)*x81*x97))+(((-1.0)*x81*x99))+((x77*x97))+(((-1.0)*gconst7*x67*x80))+(((-1.0)*x85*x99)));\nop[5]=((((-1.0)*x140))+(((-0.1648656)*gconst5*x96))+(((-1.0)*x90*x93))+((x72*x93))+((x73*x93))+x141+(((-1.0)*x78*x93))+(((-0.1648656)*gconst6*x96))+(((-0.3297312)*gconst1*x96))+(((-0.3297312)*gconst2*x96)));\nop[6]=((((-1.0)*x142))+(((-1.0)*x73*x99))+(((-1.0)*x73*x97))+(((-1.0)*x72*x97))+(((-1.0)*x90*x94))+((x78*x97))+((x72*x94))+((x73*x94))+x139+(((-1.0)*x78*x94))+((x80*x95)));\nop[7]=((((-1.0)*x107))+x130+(((-1.0)*x131))+x91);\nop[8]=(x135+(((-1.0)*x137)));\npolyroots8(op,zeror,numroots);\nIkReal j27array[8], cj27array[8], sj27array[8], tempj27array[1];\nint numsolutions = 0;\nfor(int ij27 = 0; ij27 < numroots; ++ij27)\n{\nIkReal htj27 = zeror[ij27];\ntempj27array[0]=((2.0)*(atan(htj27)));\nfor(int kj27 = 0; kj27 < 1; ++kj27)\n{\nj27array[numsolutions] = tempj27array[kj27];\nif( j27array[numsolutions] > IKPI )\n{\n    j27array[numsolutions]-=IK2PI;\n}\nelse if( j27array[numsolutions] < -IKPI )\n{\n    j27array[numsolutions]+=IK2PI;\n}\nsj27array[numsolutions] = IKsin(j27array[numsolutions]);\ncj27array[numsolutions] = IKcos(j27array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j27valid[8]={true,true,true,true,true,true,true,true};\n_nj27 = 8;\nfor(int ij27 = 0; ij27 < numsolutions; ++ij27)\n    {\nif( !j27valid[ij27] )\n{\n    continue;\n}\n    j27 = j27array[ij27]; cj27 = cj27array[ij27]; sj27 = sj27array[ij27];\nhtj27 = IKtan(j27/2);\n\n_ij27[0] = ij27; _ij27[1] = -1;\nfor(int iij27 = ij27+1; iij27 < numsolutions; ++iij27)\n{\nif( j27valid[iij27] && IKabs(cj27array[ij27]-cj27array[iij27]) < IKFAST_SOLUTION_THRESH && IKabs(sj27array[ij27]-sj27array[iij27]) < IKFAST_SOLUTION_THRESH )\n{\n    j27valid[iij27]=false; _ij27[1] = iij27; break; \n}\n}\n{\nIkReal j28eval[2];\nIkReal x143=cj27*cj27;\nIkReal x144=py*py;\nIkReal x145=px*px;\nIkReal x146=pz*pz;\nIkReal x147=((100.0)*sj29);\nIkReal x148=(py*sj27);\nIkReal x149=((4.0)*sj29);\nIkReal x150=(cj27*px*sj29);\nIkReal x151=(x143*x145);\nIkReal x152=(x144*x149);\nj28eval[0]=((((20.0)*x150))+((x143*x144*x147))+(((-200.0)*x148*x150))+(((-1.0)*x144*x147))+(((-1.0)*sj29))+(((-1.0)*x147*x151))+(((-1.0)*x146*x147))+(((20.0)*sj29*x148)));\nj28eval[1]=IKsign(((((-1.0)*x152))+(((0.8)*sj29*x148))+(((-0.04)*sj29))+(((-1.0)*x146*x149))+(((0.8)*x150))+(((-1.0)*x149*x151))+(((-8.0)*x148*x150))+((x143*x152))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[1];\nj30eval[0]=sj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x153=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));\nevalcond[1]=x153;\nevalcond[2]=x153;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[2], cj30array[2], sj30array[2];\nbool j30valid[2]={false};\n_nj30 = 2;\ncj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));\nif( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j30valid[0] = j30valid[1] = true;\n    j30array[0] = IKacos(cj30array[0]);\n    sj30array[0] = IKsin(j30array[0]);\n    cj30array[1] = cj30array[0];\n    j30array[1] = -j30array[0];\n    sj30array[1] = -sj30array[0];\n}\nelse if( isnan(cj30array[0]) )\n{\n    // probably any value will work\n    j30valid[0] = true;\n    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;\n}\nfor(int ij30 = 0; ij30 < 2; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 2; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n\n{\nIkReal j28eval[3];\nsj29=0;\ncj29=1.0;\nj29=0;\nIkReal x154=((321000.0)*cj30);\nIkReal x155=(py*sj27);\nIkReal x156=((321000.0)*sj30);\nIkReal x157=(cj27*px);\nj28eval[0]=((1.02430295950156)+cj30);\nj28eval[1]=((IKabs(((((-1.0)*pz*x154))+(((32100.0)*sj30))+(((-400000.0)*pz))+(((-1.0)*x156*x157))+(((-1.0)*x155*x156)))))+(IKabs(((-40000.0)+(((-1.0)*pz*x156))+(((400000.0)*x155))+(((400000.0)*x157))+(((-32100.0)*cj30))+((x154*x157))+((x154*x155))))));\nj28eval[2]=IKsign(((263041.0)+(((256800.0)*cj30))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[3];\nsj29=0;\ncj29=1.0;\nj29=0;\nIkReal x158=(pz*sj30);\nIkReal x159=(cj27*px);\nIkReal x160=(py*sj27);\nIkReal x161=((10.0)*cj30);\nIkReal x162=((321.0)*cj30);\nIkReal x163=((1000.0)*pz);\nj28eval[0]=((1.24610591900312)+(((-1.0)*x159*x161))+(((-1.0)*x160*x161))+cj30+(((-10.0)*x158))+(((-12.4610591900312)*x160))+(((-12.4610591900312)*x159)));\nj28eval[1]=((IKabs(((((-100.0)*pz))+(((128.4)*sj30))+((x159*x163))+((x160*x163))+(((103.041)*cj30*sj30)))))+(IKabs(((-160.0)+((pz*x163))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))))));\nj28eval[2]=IKsign(((40.0)+(((-400.0)*x160))+(((-1.0)*x159*x162))+(((-1.0)*x160*x162))+(((-400.0)*x159))+(((32.1)*cj30))+(((-321.0)*x158))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[3];\nsj29=0;\ncj29=1.0;\nj29=0;\nIkReal x164=cj27*cj27;\nIkReal x165=py*py;\nIkReal x166=pz*pz;\nIkReal x167=px*px;\nIkReal x168=(cj27*px);\nIkReal x169=((321.0)*sj30);\nIkReal x170=(py*sj27);\nIkReal x171=((321.0)*cj30);\nIkReal x172=((321.0)*x170);\nIkReal x173=((200.0)*x170);\nIkReal x174=(x164*x165);\nIkReal x175=(x164*x167);\nj28eval[0]=((-1.0)+(((-100.0)*x166))+(((-100.0)*x165))+(((-100.0)*x175))+(((20.0)*x170))+(((20.0)*x168))+(((-1.0)*x168*x173))+(((100.0)*x174)));\nj28eval[1]=((IKabs((((pz*x171))+((x168*x169))+((x169*x170))+(((400.0)*pz))+(((-32.1)*sj30)))))+(IKabs(((40.0)+((pz*x169))+(((-400.0)*x168))+(((-400.0)*x170))+(((-1.0)*x170*x171))+(((-1.0)*x168*x171))+(((32.1)*cj30))))));\nj28eval[2]=IKsign(((-10.0)+x173+(((-2000.0)*x168*x170))+(((-1000.0)*x166))+(((-1000.0)*x165))+(((-1000.0)*x175))+(((200.0)*x168))+(((1000.0)*x174))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j28]\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x176=py*py;\nIkReal x177=cj27*cj27;\nIkReal x178=(cj27*px);\nIkReal x179=(py*sj27);\nIkReal x180=((321.0)*cj30);\nIkReal x181=((321.0)*sj30);\nIkReal x182=((1000.0)*x177);\nCheckValue<IkReal> x183=IKPowWithIntegerCheck(IKsign(((-10.0)+((x176*x182))+(((-1.0)*x182*(px*px)))+(((-1000.0)*(pz*pz)))+(((-2000.0)*x178*x179))+(((-1000.0)*x176))+(((200.0)*x179))+(((200.0)*x178)))),-1);\nif(!x183.valid){\ncontinue;\n}\nCheckValue<IkReal> x184 = IKatan2WithCheck(IkReal((((pz*x180))+((x178*x181))+((x179*x181))+(((400.0)*pz))+(((-32.1)*sj30)))),((40.0)+((pz*x181))+(((-1.0)*x178*x180))+(((-400.0)*x178))+(((-400.0)*x179))+(((-1.0)*x179*x180))+(((32.1)*cj30))),IKFAST_ATAN2_MAGTHRESH);\nif(!x184.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x183.value)))+(x184.value));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x185=IKsin(j28);\nIkReal x186=IKcos(j28);\nIkReal x187=((0.321)*cj30);\nIkReal x188=((0.321)*sj30);\nIkReal x189=(cj27*px);\nIkReal x190=(py*sj27);\nIkReal x191=((1.0)*x190);\nIkReal x192=(pz*x185);\nIkReal x193=((0.8)*x186);\nevalcond[0]=(((x186*x188))+(((0.4)*x185))+((x185*x187))+pz);\nevalcond[1]=(((pz*x186))+((x185*x189))+x188+((x185*x190))+(((-0.1)*x185)));\nevalcond[2]=((0.1)+((x186*x187))+(((0.4)*x186))+(((-1.0)*x191))+(((-1.0)*x189))+(((-1.0)*x185*x188)));\nevalcond[3]=((0.4)+(((0.1)*x186))+(((-1.0)*x186*x191))+x192+x187+(((-1.0)*x186*x189)));\nevalcond[4]=((-0.066959)+(((0.2)*x189))+(((0.2)*x190))+((x189*x193))+(((-1.0)*pp))+((x190*x193))+(((-0.08)*x186))+(((-0.8)*x192)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x645=((321.0)*cj30);\nIkReal x646=(py*sj27);\nIkReal x647=(cj27*px);\nIkReal x648=((1000.0)*pz);\nCheckValue<IkReal> x649=IKPowWithIntegerCheck(IKsign(((40.0)+(((-321.0)*pz*sj30))+(((-400.0)*x646))+(((-400.0)*x647))+(((-1.0)*x645*x646))+(((-1.0)*x645*x647))+(((32.1)*cj30)))),-1);\nif(!x649.valid){\ncontinue;\n}\nCheckValue<IkReal> x650 = IKatan2WithCheck(IkReal(((((-100.0)*pz))+(((128.4)*sj30))+((x646*x648))+(((103.041)*cj30*sj30))+((x647*x648)))),((-160.0)+((pz*x648))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))),IKFAST_ATAN2_MAGTHRESH);\nif(!x650.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x649.value)))+(x650.value));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x651=IKsin(j28);\nIkReal x652=IKcos(j28);\nIkReal x653=((0.321)*cj30);\nIkReal x654=((0.321)*sj30);\nIkReal x655=(cj27*px);\nIkReal x656=(py*sj27);\nIkReal x657=((1.0)*x656);\nIkReal x658=(pz*x651);\nIkReal x659=((0.8)*x652);\nevalcond[0]=(((x652*x654))+((x651*x653))+(((0.4)*x651))+pz);\nevalcond[1]=((((-0.1)*x651))+((pz*x652))+((x651*x656))+((x651*x655))+x654);\nevalcond[2]=((0.1)+(((-1.0)*x651*x654))+(((-1.0)*x655))+((x652*x653))+(((-1.0)*x657))+(((0.4)*x652)));\nevalcond[3]=((0.4)+x653+x658+(((0.1)*x652))+(((-1.0)*x652*x657))+(((-1.0)*x652*x655)));\nevalcond[4]=((-0.066959)+(((-0.8)*x658))+(((-1.0)*pp))+((x656*x659))+((x655*x659))+(((-0.08)*x652))+(((0.2)*x656))+(((0.2)*x655)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x660=((321000.0)*cj30);\nIkReal x661=(py*sj27);\nIkReal x662=(cj27*px);\nIkReal x663=((321000.0)*sj30);\nCheckValue<IkReal> x664=IKPowWithIntegerCheck(IKsign(((263041.0)+(((256800.0)*cj30)))),-1);\nif(!x664.valid){\ncontinue;\n}\nCheckValue<IkReal> x665 = IKatan2WithCheck(IkReal(((((-1.0)*x662*x663))+(((32100.0)*sj30))+(((-1.0)*x661*x663))+(((-400000.0)*pz))+(((-1.0)*pz*x660)))),((-40000.0)+(((-32100.0)*cj30))+(((400000.0)*x661))+(((400000.0)*x662))+((x660*x661))+((x660*x662))+(((-1.0)*pz*x663))),IKFAST_ATAN2_MAGTHRESH);\nif(!x665.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x664.value)))+(x665.value));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x666=IKsin(j28);\nIkReal x667=IKcos(j28);\nIkReal x668=((0.321)*cj30);\nIkReal x669=((0.321)*sj30);\nIkReal x670=(cj27*px);\nIkReal x671=(py*sj27);\nIkReal x672=((1.0)*x671);\nIkReal x673=(pz*x666);\nIkReal x674=((0.8)*x667);\nevalcond[0]=(((x666*x668))+((x667*x669))+(((0.4)*x666))+pz);\nevalcond[1]=(((x666*x671))+((x666*x670))+((pz*x667))+x669+(((-0.1)*x666)));\nevalcond[2]=((0.1)+((x667*x668))+(((0.4)*x667))+(((-1.0)*x670))+(((-1.0)*x666*x669))+(((-1.0)*x672)));\nevalcond[3]=((0.4)+(((-1.0)*x667*x670))+(((0.1)*x667))+(((-1.0)*x667*x672))+x668+x673);\nevalcond[4]=((-0.066959)+(((-0.08)*x667))+((x671*x674))+(((0.2)*x671))+(((0.2)*x670))+((x670*x674))+(((-1.0)*pp))+(((-0.8)*x673)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x675=(px*sj27);\nIkReal x676=(cj27*py);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));\nevalcond[1]=(x675+(((-1.0)*x676)));\nevalcond[2]=(x676+(((-1.0)*x675)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[2], cj30array[2], sj30array[2];\nbool j30valid[2]={false};\n_nj30 = 2;\ncj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));\nif( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j30valid[0] = j30valid[1] = true;\n    j30array[0] = IKacos(cj30array[0]);\n    sj30array[0] = IKsin(j30array[0]);\n    cj30array[1] = cj30array[0];\n    j30array[1] = -j30array[0];\n    sj30array[1] = -sj30array[0];\n}\nelse if( isnan(cj30array[0]) )\n{\n    // probably any value will work\n    j30valid[0] = true;\n    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;\n}\nfor(int ij30 = 0; ij30 < 2; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 2; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n\n{\nIkReal j28eval[3];\nsj29=0;\ncj29=-1.0;\nj29=3.14159265358979;\nIkReal x677=((321000.0)*cj30);\nIkReal x678=(py*sj27);\nIkReal x679=((321000.0)*sj30);\nIkReal x680=(cj27*px);\nj28eval[0]=((-1.02430295950156)+(((-1.0)*cj30)));\nj28eval[1]=IKsign(((-263041.0)+(((-256800.0)*cj30))));\nj28eval[2]=((IKabs((((pz*x677))+(((-1.0)*x678*x679))+(((32100.0)*sj30))+(((400000.0)*pz))+(((-1.0)*x679*x680)))))+(IKabs(((40000.0)+(((-400000.0)*x680))+(((-400000.0)*x678))+(((-1.0)*pz*x679))+(((32100.0)*cj30))+(((-1.0)*x677*x680))+(((-1.0)*x677*x678))))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[3];\nsj29=0;\ncj29=-1.0;\nj29=3.14159265358979;\nIkReal x681=(pz*sj30);\nIkReal x682=(cj27*px);\nIkReal x683=(py*sj27);\nIkReal x684=((10.0)*cj30);\nIkReal x685=((1000.0)*pz);\nIkReal x686=((321.0)*cj30);\nj28eval[0]=((-1.24610591900312)+((x682*x684))+((x683*x684))+(((-1.0)*cj30))+(((-10.0)*x681))+(((12.4610591900312)*x683))+(((12.4610591900312)*x682)));\nj28eval[1]=((IKabs(((((100.0)*pz))+(((128.4)*sj30))+(((-1.0)*x682*x685))+(((-1.0)*x683*x685))+(((103.041)*cj30*sj30)))))+(IKabs(((160.0)+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))+(((-1.0)*pz*x685))))));\nj28eval[2]=IKsign(((-40.0)+((x682*x686))+((x683*x686))+(((400.0)*x682))+(((400.0)*x683))+(((-321.0)*x681))+(((-32.1)*cj30))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[3];\nsj29=0;\ncj29=-1.0;\nj29=3.14159265358979;\nIkReal x687=cj27*cj27;\nIkReal x688=py*py;\nIkReal x689=pz*pz;\nIkReal x690=px*px;\nIkReal x691=(cj27*px);\nIkReal x692=((321.0)*sj30);\nIkReal x693=(py*sj27);\nIkReal x694=((321.0)*cj30);\nIkReal x695=((321.0)*x693);\nIkReal x696=((200.0)*x693);\nIkReal x697=(x687*x688);\nIkReal x698=(x687*x690);\nj28eval[0]=((-1.0)+(((20.0)*x691))+(((20.0)*x693))+(((-100.0)*x689))+(((-100.0)*x688))+(((-100.0)*x698))+(((100.0)*x697))+(((-1.0)*x691*x696)));\nj28eval[1]=((IKabs(((40.0)+(((-1.0)*x693*x694))+(((-400.0)*x693))+(((-400.0)*x691))+(((-1.0)*pz*x692))+(((-1.0)*x691*x694))+(((32.1)*cj30)))))+(IKabs((((pz*x694))+(((400.0)*pz))+(((-1.0)*x692*x693))+(((32.1)*sj30))+(((-1.0)*x691*x692))))));\nj28eval[2]=IKsign(((-10.0)+(((-2000.0)*x691*x693))+(((-1000.0)*x698))+(((-1000.0)*x689))+(((-1000.0)*x688))+(((200.0)*x691))+x696+(((1000.0)*x697))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j28]\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x699=py*py;\nIkReal x700=cj27*cj27;\nIkReal x701=(cj27*px);\nIkReal x702=(py*sj27);\nIkReal x703=((321.0)*cj30);\nIkReal x704=((321.0)*sj30);\nIkReal x705=((1000.0)*x700);\nCheckValue<IkReal> x706=IKPowWithIntegerCheck(IKsign(((-10.0)+(((-1000.0)*x699))+(((-2000.0)*x701*x702))+(((-1000.0)*(pz*pz)))+(((-1.0)*x705*(px*px)))+(((200.0)*x701))+(((200.0)*x702))+((x699*x705)))),-1);\nif(!x706.valid){\ncontinue;\n}\nCheckValue<IkReal> x707 = IKatan2WithCheck(IkReal(((((-1.0)*x702*x704))+(((400.0)*pz))+(((32.1)*sj30))+(((-1.0)*x701*x704))+((pz*x703)))),((40.0)+(((-1.0)*pz*x704))+(((-1.0)*x702*x703))+(((-400.0)*x702))+(((-400.0)*x701))+(((32.1)*cj30))+(((-1.0)*x701*x703))),IKFAST_ATAN2_MAGTHRESH);\nif(!x707.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x706.value)))+(x707.value));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x708=IKsin(j28);\nIkReal x709=IKcos(j28);\nIkReal x710=((0.321)*cj30);\nIkReal x711=((0.321)*sj30);\nIkReal x712=(py*sj27);\nIkReal x713=(cj27*px);\nIkReal x714=((1.0)*x712);\nIkReal x715=(pz*x708);\nIkReal x716=((1.0)*x709);\nIkReal x717=((0.8)*x709);\nevalcond[0]=((((0.4)*x708))+(((-1.0)*x709*x711))+pz+((x708*x710)));\nevalcond[1]=((0.1)+(((0.4)*x709))+(((-1.0)*x713))+((x709*x710))+(((-1.0)*x714))+((x708*x711)));\nevalcond[2]=((0.4)+(((-1.0)*x709*x714))+(((0.1)*x709))+x710+x715+(((-1.0)*x713*x716)));\nevalcond[3]=((((-1.0)*pz*x716))+(((-1.0)*x708*x713))+(((0.1)*x708))+(((-1.0)*x708*x714))+x711);\nevalcond[4]=((-0.066959)+(((-1.0)*pp))+(((-0.8)*x715))+(((0.2)*x712))+(((0.2)*x713))+((x712*x717))+((x713*x717))+(((-0.08)*x709)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x718=((321.0)*cj30);\nIkReal x719=(py*sj27);\nIkReal x720=(cj27*px);\nIkReal x721=((1000.0)*pz);\nCheckValue<IkReal> x722 = IKatan2WithCheck(IkReal(((((100.0)*pz))+(((128.4)*sj30))+(((-1.0)*x720*x721))+(((-1.0)*x719*x721))+(((103.041)*cj30*sj30)))),((160.0)+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))+(((-1.0)*pz*x721))),IKFAST_ATAN2_MAGTHRESH);\nif(!x722.valid){\ncontinue;\n}\nCheckValue<IkReal> x723=IKPowWithIntegerCheck(IKsign(((-40.0)+(((400.0)*x720))+(((400.0)*x719))+(((-321.0)*pz*sj30))+((x718*x720))+((x718*x719))+(((-32.1)*cj30)))),-1);\nif(!x723.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(x722.value)+(((1.5707963267949)*(x723.value))));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x724=IKsin(j28);\nIkReal x725=IKcos(j28);\nIkReal x726=((0.321)*cj30);\nIkReal x727=((0.321)*sj30);\nIkReal x728=(py*sj27);\nIkReal x729=(cj27*px);\nIkReal x730=((1.0)*x728);\nIkReal x731=(pz*x724);\nIkReal x732=((1.0)*x725);\nIkReal x733=((0.8)*x725);\nevalcond[0]=((((-1.0)*x725*x727))+pz+((x724*x726))+(((0.4)*x724)));\nevalcond[1]=((0.1)+(((-1.0)*x729))+(((-1.0)*x730))+((x725*x726))+((x724*x727))+(((0.4)*x725)));\nevalcond[2]=((0.4)+(((-1.0)*x725*x730))+(((0.1)*x725))+x731+x726+(((-1.0)*x729*x732)));\nevalcond[3]=((((-1.0)*x724*x730))+(((-1.0)*x724*x729))+(((0.1)*x724))+x727+(((-1.0)*pz*x732)));\nevalcond[4]=((-0.066959)+(((-0.08)*x725))+((x728*x733))+((x729*x733))+(((-1.0)*pp))+(((-0.8)*x731))+(((0.2)*x729))+(((0.2)*x728)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x734=(cj27*px);\nIkReal x735=((321000.0)*cj30);\nIkReal x736=((321000.0)*sj30);\nIkReal x737=((321000.0)*py*sj27);\nCheckValue<IkReal> x738 = IKatan2WithCheck(IkReal(((((32100.0)*sj30))+(((-1.0)*py*sj27*x736))+(((-1.0)*x734*x736))+(((400000.0)*pz))+((pz*x735)))),((40000.0)+(((-400000.0)*py*sj27))+(((-1.0)*py*sj27*x735))+(((-1.0)*x734*x735))+(((-400000.0)*x734))+(((32100.0)*cj30))+(((-1.0)*pz*x736))),IKFAST_ATAN2_MAGTHRESH);\nif(!x738.valid){\ncontinue;\n}\nCheckValue<IkReal> x739=IKPowWithIntegerCheck(IKsign(((-263041.0)+(((-256800.0)*cj30)))),-1);\nif(!x739.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(x738.value)+(((1.5707963267949)*(x739.value))));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x740=IKsin(j28);\nIkReal x741=IKcos(j28);\nIkReal x742=((0.321)*cj30);\nIkReal x743=((0.321)*sj30);\nIkReal x744=(py*sj27);\nIkReal x745=(cj27*px);\nIkReal x746=((1.0)*x744);\nIkReal x747=(pz*x740);\nIkReal x748=((1.0)*x741);\nIkReal x749=((0.8)*x741);\nevalcond[0]=(((x740*x742))+pz+(((0.4)*x740))+(((-1.0)*x741*x743)));\nevalcond[1]=((0.1)+((x740*x743))+((x741*x742))+(((-1.0)*x745))+(((0.4)*x741))+(((-1.0)*x746)));\nevalcond[2]=((0.4)+(((-1.0)*x745*x748))+(((0.1)*x741))+(((-1.0)*x741*x746))+x747+x742);\nevalcond[3]=((((0.1)*x740))+(((-1.0)*pz*x748))+(((-1.0)*x740*x746))+x743+(((-1.0)*x740*x745)));\nevalcond[4]=((-0.066959)+((x745*x749))+((x744*x749))+(((-0.08)*x741))+(((-1.0)*pp))+(((0.2)*x744))+(((0.2)*x745))+(((-0.8)*x747)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j28, j30]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x750=IKPowWithIntegerCheck(sj29,-1);\nif(!x750.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x750.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x750.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x750.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[2];\nevalcond[0]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*sj29*(IKsin(j30)))));\nevalcond[1]=((0.253041)+(((0.2568)*(IKcos(j30))))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j28eval[3];\nIkReal x751=(py*sj27);\nIkReal x752=(cj29*sj30);\nIkReal x753=(cj27*px);\nIkReal x754=((10.0)*cj30);\nIkReal x755=((1000.0)*pz);\nIkReal x756=((321.0)*cj30);\nj28eval[0]=((-1.24610591900312)+((x751*x754))+(((10.0)*pz*x752))+(((-1.0)*cj30))+(((12.4610591900312)*x753))+(((12.4610591900312)*x751))+((x753*x754)));\nj28eval[1]=IKsign(((-40.0)+((x751*x756))+(((400.0)*x753))+(((400.0)*x751))+(((321.0)*pz*x752))+((x753*x756))+(((-32.1)*cj30))));\nj28eval[2]=((IKabs(((160.0)+(((-1.0)*pz*x755))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30)))))+(IKabs(((((100.0)*pz))+(((-1.0)*x753*x755))+(((-1.0)*x751*x755))+(((-128.4)*x752))+(((-103.041)*cj30*x752))))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[3];\nIkReal x757=cj29*cj29;\nIkReal x758=cj30*cj30;\nIkReal x759=(cj27*px);\nIkReal x760=((321000.0)*cj30);\nIkReal x761=(py*sj27);\nIkReal x762=((321000.0)*cj29*sj30);\nIkReal x763=((103041.0)*x758);\nj28eval[0]=((1.5527799613746)+(((-1.0)*x757*x758))+x757+x758+(((2.49221183800623)*cj30)));\nj28eval[1]=IKsign(((160000.0)+(((256800.0)*cj30))+(((-1.0)*x757*x763))+(((103041.0)*x757))+x763));\nj28eval[2]=((IKabs(((-40000.0)+(((-32100.0)*cj30))+((x760*x761))+((x759*x760))+(((400000.0)*x761))+(((400000.0)*x759))+(((-1.0)*pz*x762)))))+(IKabs(((((32100.0)*cj29*sj30))+(((-400000.0)*pz))+(((-1.0)*x761*x762))+(((-1.0)*x759*x762))+(((-1.0)*pz*x760))))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[2];\nIkReal x764=(cj29*sj30);\nIkReal x765=(py*sj27);\nIkReal x766=(cj30*pz);\nIkReal x767=(cj27*px);\nj28eval[0]=((((-10.0)*x764*x765))+(((-10.0)*x764*x767))+x764+(((10.0)*x766))+(((12.4610591900312)*pz)));\nj28eval[1]=IKsign(((((400.0)*pz))+(((321.0)*x766))+(((-321.0)*x764*x765))+(((-321.0)*x764*x767))+(((32.1)*x764))));\nif( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x768=((((0.321)*sj30))+(((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j29), 6.28318530717959))))));\nevalcond[1]=x768;\nevalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nevalcond[3]=x768;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28eval[1];\nIkReal x769=((-1.0)*py);\npz=0;\nj29=1.5707963267949;\nsj29=1.0;\ncj29=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x769);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x769);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x769);\nrxp2_1=(px*r22);\nj28eval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));\nif( IKabs(j28eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[1];\nIkReal x770=((-1.0)*py);\npz=0;\nj29=1.5707963267949;\nsj29=1.0;\ncj29=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x770);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x770);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x770);\nrxp2_1=(px*r22);\nj28eval[0]=((1.24610591900312)+cj30);\nif( IKabs(j28eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x771=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nif((x771) < -0.00001)\ncontinue;\nIkReal x772=IKabs(IKsqrt(x771));\nIkReal x778 = x771;\nif(IKabs(x778)==0){\ncontinue;\n}\nIkReal x773=pow(x778,-0.5);\nCheckValue<IkReal> x779=IKPowWithIntegerCheck(x772,-1);\nif(!x779.valid){\ncontinue;\n}\nIkReal x774=x779.value;\nIkReal x775=((10.0)*px*x773);\nIkReal x776=((10.0)*py*x773);\nif((((1.0)+(((-1.0)*(x774*x774))))) < -0.00001)\ncontinue;\nIkReal x777=IKsqrt(((1.0)+(((-1.0)*(x774*x774)))));\nif( (x774) < -1-IKFAST_SINCOS_THRESH || (x774) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x780 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x780.valid){\ncontinue;\n}\nIkReal gconst24=((((-1.0)*(IKasin(x774))))+(((-1.0)*(x780.value))));\nIkReal gconst25=(((x774*x776))+((x775*x777)));\nIkReal gconst26=(((x774*x775))+(((-1.0)*x776*x777)));\nIkReal x781=px*px;\nIkReal x782=py*py;\nIkReal x783=(((gconst25*px))+(((0.321)*sj30))+(((-1.0)*gconst26*py)));\nCheckValue<IkReal> x784 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x784.valid){\ncontinue;\n}\nif((((((100.0)*x782))+(((100.0)*x781)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x785=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x782))+(((100.0)*x781))))),-1);\nif(!x785.valid){\ncontinue;\n}\nif( (x785.value) < -1-IKFAST_SINCOS_THRESH || (x785.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j27+(x784.value)+(IKasin(x785.value)))))), 6.28318530717959)));\nevalcond[1]=x783;\nevalcond[2]=((0.253041)+(((0.2568)*cj30))+(((0.2)*gconst25*py))+(((0.2)*gconst26*px))+(((-1.0)*x781))+(((-1.0)*x782)));\nevalcond[3]=x783;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x787=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst25*py))+(((-1.0)*gconst26*px))),-1);\nif(!x787.valid){\ncontinue;\n}\nIkReal x786=x787.value;\ncj28array[0]=((((-0.321)*cj30*x786))+(((-0.4)*x786)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x788=IKsin(j28);\nIkReal x789=IKcos(j28);\nIkReal x790=(gconst25*py);\nIkReal x791=(gconst26*px);\nIkReal x792=((0.321)*cj30);\nIkReal x793=((1.0)*x788);\nIkReal x794=((0.8)*x789);\nevalcond[0]=(((x788*x792))+(((0.4)*x788)));\nevalcond[1]=((((-1.0)*x791*x793))+(((0.1)*x788))+(((-1.0)*x790*x793)));\nevalcond[2]=((0.1)+(((-1.0)*x791))+(((-1.0)*x790))+(((0.4)*x789))+((x789*x792)));\nevalcond[3]=((-0.32)+((x790*x794))+(((-0.08)*x789))+(((-0.2568)*cj30))+((x791*x794)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x795=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nIkReal x802 = x795;\nif(IKabs(x802)==0){\ncontinue;\n}\nIkReal x796=pow(x802,-0.5);\nif((x795) < -0.00001)\ncontinue;\nIkReal x797=IKabs(IKsqrt(x795));\nCheckValue<IkReal> x803=IKPowWithIntegerCheck(x797,-1);\nif(!x803.valid){\ncontinue;\n}\nIkReal x798=x803.value;\nIkReal x799=((10.0)*px*x796);\nIkReal x800=((10.0)*py*x796);\nif((((1.0)+(((-1.0)*(x798*x798))))) < -0.00001)\ncontinue;\nIkReal x801=IKsqrt(((1.0)+(((-1.0)*(x798*x798)))));\nCheckValue<IkReal> x804 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x804.valid){\ncontinue;\n}\nif( (x798) < -1-IKFAST_SINCOS_THRESH || (x798) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal gconst27=((3.14159265358979)+(((-1.0)*(x804.value)))+(IKasin(x798)));\nIkReal gconst28=((((-1.0)*x799*x801))+((x798*x800)));\nIkReal gconst29=(((x800*x801))+((x798*x799)));\nIkReal x805=px*px;\nIkReal x806=py*py;\nIkReal x807=((((0.321)*sj30))+(((-1.0)*gconst29*py))+((gconst28*px)));\nCheckValue<IkReal> x808 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x808.valid){\ncontinue;\n}\nif((((((100.0)*x806))+(((100.0)*x805)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x809=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x806))+(((100.0)*x805))))),-1);\nif(!x809.valid){\ncontinue;\n}\nif( (x809.value) < -1-IKFAST_SINCOS_THRESH || (x809.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j27+(x808.value)+(((-1.0)*(IKasin(x809.value)))))))), 6.28318530717959)));\nevalcond[1]=x807;\nevalcond[2]=((0.253041)+(((-1.0)*x805))+(((-1.0)*x806))+(((0.2568)*cj30))+(((0.2)*gconst29*px))+(((0.2)*gconst28*py)));\nevalcond[3]=x807;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x811=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst29*px))+(((-1.0)*gconst28*py))),-1);\nif(!x811.valid){\ncontinue;\n}\nIkReal x810=x811.value;\ncj28array[0]=((((-0.4)*x810))+(((-0.321)*cj30*x810)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x812=IKsin(j28);\nIkReal x813=IKcos(j28);\nIkReal x814=(gconst28*py);\nIkReal x815=((0.321)*cj30);\nIkReal x816=((0.8)*x813);\nIkReal x817=((1.0)*gconst29*px);\nevalcond[0]=(((x812*x815))+(((0.4)*x812)));\nevalcond[1]=((((-1.0)*x812*x817))+(((-1.0)*x812*x814))+(((0.1)*x812)));\nevalcond[2]=((0.1)+(((-1.0)*x817))+((x813*x815))+(((0.4)*x813))+(((-1.0)*x814)));\nevalcond[3]=((-0.32)+((x814*x816))+((gconst29*px*x816))+(((-0.2568)*cj30))+(((-0.08)*x813)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j28]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x819=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj30))),-1);\nif(!x819.valid){\ncontinue;\n}\nIkReal x818=x819.value;\ncj28array[0]=(((py*sj27*x818))+((cj27*px*x818))+(((-0.1)*x818)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x820=IKsin(j28);\nIkReal x821=IKcos(j28);\nIkReal x822=((0.321)*cj30);\nIkReal x823=(cj27*px);\nIkReal x824=((1.0)*x820);\nIkReal x825=(py*sj27*x821);\nevalcond[0]=(((x820*x822))+(((0.4)*x820)));\nevalcond[1]=((((0.1)*x820))+(((-1.0)*x823*x824))+(((-1.0)*py*sj27*x824)));\nevalcond[2]=((0.4)+(((0.1)*x821))+(((-1.0)*x825))+(((-1.0)*x821*x823))+x822);\nevalcond[3]=((-0.32)+(((0.8)*x825))+(((-0.08)*x821))+(((0.8)*x821*x823))+(((-0.2568)*cj30)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x827=IKPowWithIntegerCheck(((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))),-1);\nif(!x827.valid){\ncontinue;\n}\nIkReal x826=x827.value;\ncj28array[0]=((((-0.4)*x826))+(((-0.321)*cj30*x826)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x828=IKsin(j28);\nIkReal x829=IKcos(j28);\nIkReal x830=(py*sj27);\nIkReal x831=(cj27*px);\nIkReal x832=((0.321)*cj30);\nIkReal x833=((0.8)*x829);\nIkReal x834=((1.0)*x828);\nevalcond[0]=((((0.4)*x828))+((x828*x832)));\nevalcond[1]=((((0.1)*x828))+(((-1.0)*x830*x834))+(((-1.0)*x831*x834)));\nevalcond[2]=((0.1)+(((0.4)*x829))+((x829*x832))+(((-1.0)*x831))+(((-1.0)*x830)));\nevalcond[3]=((-0.32)+((x831*x833))+(((-0.08)*x829))+(((-0.2568)*cj30))+((x830*x833)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x835=((0.321)*sj30);\nIkReal x836=(cj27*py);\nIkReal x837=(px*sj27);\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j29), 6.28318530717959))))));\nevalcond[1]=((((-1.0)*x835))+(((-1.0)*x836))+x837);\nevalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nevalcond[3]=((((-1.0)*x837))+x835+x836);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28eval[1];\nIkReal x838=((-1.0)*py);\npz=0;\nj29=-1.5707963267949;\nsj29=-1.0;\ncj29=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x838);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x838);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x838);\nrxp2_1=(px*r22);\nj28eval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));\nif( IKabs(j28eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j28eval[1];\nIkReal x839=((-1.0)*py);\npz=0;\nj29=-1.5707963267949;\nsj29=-1.0;\ncj29=0;\npp=((px*px)+(py*py));\nnpx=(((px*r00))+((py*r10)));\nnpy=(((px*r01))+((py*r11)));\nnpz=(((px*r02))+((py*r12)));\nrxp0_0=(r20*x839);\nrxp0_1=(px*r20);\nrxp1_0=(r21*x839);\nrxp1_1=(px*r21);\nrxp2_0=(r22*x839);\nrxp2_1=(px*r22);\nj28eval[0]=((1.24610591900312)+cj30);\nif( IKabs(j28eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x840=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nif((x840) < -0.00001)\ncontinue;\nIkReal x841=IKabs(IKsqrt(x840));\nIkReal x847 = x840;\nif(IKabs(x847)==0){\ncontinue;\n}\nIkReal x842=pow(x847,-0.5);\nCheckValue<IkReal> x848=IKPowWithIntegerCheck(x841,-1);\nif(!x848.valid){\ncontinue;\n}\nIkReal x843=x848.value;\nIkReal x844=((10.0)*px*x842);\nIkReal x845=((10.0)*py*x842);\nif((((1.0)+(((-1.0)*(x843*x843))))) < -0.00001)\ncontinue;\nIkReal x846=IKsqrt(((1.0)+(((-1.0)*(x843*x843)))));\nCheckValue<IkReal> x849 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x849.valid){\ncontinue;\n}\nif( (x843) < -1-IKFAST_SINCOS_THRESH || (x843) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal gconst30=((((-1.0)*(x849.value)))+(((-1.0)*(IKasin(x843)))));\nIkReal gconst31=(((x843*x845))+((x844*x846)));\nIkReal gconst32=(((x843*x844))+(((-1.0)*x845*x846)));\nIkReal x850=px*px;\nIkReal x851=py*py;\nIkReal x852=((0.321)*sj30);\nIkReal x853=(gconst32*py);\nIkReal x854=(gconst31*px);\nif((((((100.0)*x851))+(((100.0)*x850)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x855=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x851))+(((100.0)*x850))))),-1);\nif(!x855.valid){\ncontinue;\n}\nif( (x855.value) < -1-IKFAST_SINCOS_THRESH || (x855.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x856 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x856.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x855.value))+j27+(x856.value))))), 6.28318530717959)));\nevalcond[1]=((((-1.0)*x852))+(((-1.0)*x853))+x854);\nevalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*x851))+(((-1.0)*x850))+(((0.2)*gconst32*px))+(((0.2)*gconst31*py)));\nevalcond[3]=((((-1.0)*x854))+x852+x853);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x858=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst32*px))+(((-1.0)*gconst31*py))),-1);\nif(!x858.valid){\ncontinue;\n}\nIkReal x857=x858.value;\ncj28array[0]=((((-0.4)*x857))+(((-0.321)*cj30*x857)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x859=IKsin(j28);\nIkReal x860=IKcos(j28);\nIkReal x861=(gconst31*py);\nIkReal x862=(gconst32*px);\nIkReal x863=((0.321)*cj30);\nIkReal x864=((0.8)*x860);\nevalcond[0]=(((x859*x863))+(((0.4)*x859)));\nevalcond[1]=((((-0.1)*x859))+((x859*x862))+((x859*x861)));\nevalcond[2]=((0.1)+(((-1.0)*x862))+(((-1.0)*x861))+(((0.4)*x860))+((x860*x863)));\nevalcond[3]=((-0.32)+(((-0.2568)*cj30))+((x862*x864))+((x861*x864))+(((-0.08)*x860)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x865=((((100.0)*(px*px)))+(((100.0)*(py*py))));\nIkReal x872 = x865;\nif(IKabs(x872)==0){\ncontinue;\n}\nIkReal x866=pow(x872,-0.5);\nif((x865) < -0.00001)\ncontinue;\nIkReal x867=IKabs(IKsqrt(x865));\nCheckValue<IkReal> x873=IKPowWithIntegerCheck(x867,-1);\nif(!x873.valid){\ncontinue;\n}\nIkReal x868=x873.value;\nIkReal x869=((10.0)*px*x866);\nIkReal x870=((10.0)*py*x866);\nif((((1.0)+(((-1.0)*(x868*x868))))) < -0.00001)\ncontinue;\nIkReal x871=IKsqrt(((1.0)+(((-1.0)*(x868*x868)))));\nif( (x868) < -1-IKFAST_SINCOS_THRESH || (x868) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x874 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x874.valid){\ncontinue;\n}\nIkReal gconst33=((3.14159265358979)+(IKasin(x868))+(((-1.0)*(x874.value))));\nIkReal gconst34=(((x868*x870))+(((-1.0)*x869*x871)));\nIkReal gconst35=(((x868*x869))+((x870*x871)));\nIkReal x875=px*px;\nIkReal x876=py*py;\nIkReal x877=((0.321)*sj30);\nIkReal x878=(gconst35*py);\nIkReal x879=(gconst34*px);\nif((((((100.0)*x875))+(((100.0)*x876)))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x880=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x875))+(((100.0)*x876))))),-1);\nif(!x880.valid){\ncontinue;\n}\nif( (x880.value) < -1-IKFAST_SINCOS_THRESH || (x880.value) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nCheckValue<IkReal> x881 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);\nif(!x881.valid){\ncontinue;\n}\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j27+(((-1.0)*(IKasin(x880.value))))+(x881.value))))), 6.28318530717959)));\nevalcond[1]=((((-1.0)*x878))+x879+(((-1.0)*x877)));\nevalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*x876))+(((-1.0)*x875))+(((0.2)*gconst35*px))+(((0.2)*gconst34*py)));\nevalcond[3]=((((-1.0)*x879))+x878+x877);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x883=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst34*py))+(((-1.0)*gconst35*px))),-1);\nif(!x883.valid){\ncontinue;\n}\nIkReal x882=x883.value;\ncj28array[0]=((((-0.4)*x882))+(((-0.321)*cj30*x882)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x884=IKsin(j28);\nIkReal x885=IKcos(j28);\nIkReal x886=(gconst34*py);\nIkReal x887=(gconst35*px);\nIkReal x888=((0.321)*cj30);\nIkReal x889=((0.8)*x885);\nevalcond[0]=((((0.4)*x884))+((x884*x888)));\nevalcond[1]=((((-0.1)*x884))+((x884*x887))+((x884*x886)));\nevalcond[2]=((0.1)+(((-1.0)*x887))+(((-1.0)*x886))+(((0.4)*x885))+((x885*x888)));\nevalcond[3]=((-0.32)+((x887*x889))+((x886*x889))+(((-0.2568)*cj30))+(((-0.08)*x885)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j28]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x891=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj30))),-1);\nif(!x891.valid){\ncontinue;\n}\nIkReal x890=x891.value;\ncj28array[0]=((((-0.1)*x890))+((cj27*px*x890))+((py*sj27*x890)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x892=IKsin(j28);\nIkReal x893=IKcos(j28);\nIkReal x894=((0.321)*cj30);\nIkReal x895=(py*sj27*x893);\nIkReal x896=(cj27*px*x893);\nevalcond[0]=((((0.4)*x892))+((x892*x894)));\nevalcond[1]=((((-0.1)*x892))+((cj27*px*x892))+((py*sj27*x892)));\nevalcond[2]=((0.4)+(((-1.0)*x895))+(((-1.0)*x896))+x894+(((0.1)*x893)));\nevalcond[3]=((-0.32)+(((0.8)*x896))+(((0.8)*x895))+(((-0.2568)*cj30))+(((-0.08)*x893)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\nCheckValue<IkReal> x898=IKPowWithIntegerCheck(((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))),-1);\nif(!x898.valid){\ncontinue;\n}\nIkReal x897=x898.value;\ncj28array[0]=((((-0.4)*x897))+(((-0.321)*cj30*x897)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[4];\nIkReal x899=IKsin(j28);\nIkReal x900=IKcos(j28);\nIkReal x901=(py*sj27);\nIkReal x902=(cj27*px);\nIkReal x903=((0.321)*cj30);\nIkReal x904=((0.8)*x900);\nevalcond[0]=((((0.4)*x899))+((x899*x903)));\nevalcond[1]=((((-0.1)*x899))+((x899*x901))+((x899*x902)));\nevalcond[2]=((0.1)+((x900*x903))+(((0.4)*x900))+(((-1.0)*x902))+(((-1.0)*x901)));\nevalcond[3]=((-0.32)+((x901*x904))+((x902*x904))+(((-0.08)*x900))+(((-0.2568)*cj30)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));\nevalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[2]=((0.509841)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\ncj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27))+(((1.3869625520111)*cj27*px)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x905=IKcos(j28);\nIkReal x906=px*px;\nCheckValue<IkReal> x915=IKPowWithIntegerCheck(py,-1);\nif(!x915.valid){\ncontinue;\n}\nIkReal x907=x915.value;\nIkReal x908=IKsin(j28);\nIkReal x909=(py*sj27);\nIkReal x910=(x906*x907);\nIkReal x911=((1.0)*x905);\nIkReal x912=(sj29*x908);\nIkReal x913=(cj29*x908);\nIkReal x914=((0.8)*sj27*x905);\nevalcond[0]=((0.721)*x908);\nevalcond[1]=((0.721)+(((-1.0)*cj27*px*x911))+(((0.1)*x905))+(((-1.0)*x909*x911)));\nevalcond[2]=((-0.5768)+((x910*x914))+(((-0.08)*x905))+(((0.8)*x905*x909)));\nevalcond[3]=(((x909*x913))+(((-0.1)*x913))+((sj27*x910*x913)));\nevalcond[4]=((((-1.0)*x909*x912))+(((0.1)*x912))+(((-1.0)*sj27*x910*x912)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));\nevalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[2]=((-0.003759)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j28array[2], cj28array[2], sj28array[2];\nbool j28valid[2]={false};\n_nj28 = 2;\ncj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27))+(((12.6582278481013)*cj27*px)));\nif( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j28valid[0] = j28valid[1] = true;\n    j28array[0] = IKacos(cj28array[0]);\n    sj28array[0] = IKsin(j28array[0]);\n    cj28array[1] = cj28array[0];\n    j28array[1] = -j28array[0];\n    sj28array[1] = -sj28array[0];\n}\nelse if( isnan(cj28array[0]) )\n{\n    // probably any value will work\n    j28valid[0] = true;\n    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;\n}\nfor(int ij28 = 0; ij28 < 2; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 2; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[5];\nIkReal x916=IKcos(j28);\nIkReal x917=px*px;\nCheckValue<IkReal> x926=IKPowWithIntegerCheck(py,-1);\nif(!x926.valid){\ncontinue;\n}\nIkReal x918=x926.value;\nIkReal x919=IKsin(j28);\nIkReal x920=(py*sj27);\nIkReal x921=(x917*x918);\nIkReal x922=((1.0)*x916);\nIkReal x923=(sj29*x919);\nIkReal x924=(cj29*x919);\nIkReal x925=((0.8)*sj27*x916);\nevalcond[0]=((0.079)*x919);\nevalcond[1]=((0.079)+(((-1.0)*x920*x922))+(((0.1)*x916))+(((-1.0)*cj27*px*x922)));\nevalcond[2]=((-0.0632)+(((-0.08)*x916))+((x921*x925))+(((0.8)*x916*x920)));\nevalcond[3]=((((-0.1)*x924))+((x920*x924))+((sj27*x921*x924)));\nevalcond[4]=((((0.1)*x923))+(((-1.0)*x920*x923))+(((-1.0)*sj27*x921*x923)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j28]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x927=cj27*cj27;\nIkReal x928=py*py;\nIkReal x929=(cj27*px);\nIkReal x930=(cj29*sj30);\nIkReal x931=(py*sj27);\nIkReal x932=((1000.0)*pz);\nIkReal x933=((1000.0)*x927);\nCheckValue<IkReal> x934=IKPowWithIntegerCheck(IKsign(((((32.1)*x930))+(((321.0)*cj30*pz))+(((-321.0)*x929*x930))+(((400.0)*pz))+(((-321.0)*x930*x931)))),-1);\nif(!x934.valid){\ncontinue;\n}\nCheckValue<IkReal> x935 = IKatan2WithCheck(IkReal(((-150.0)+(((-200.0)*x931))+(((-200.0)*x929))+(((-1.0)*x928*x933))+((x933*(px*px)))+(((1000.0)*x928))+(((2000.0)*x929*x931))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30)))),((((-100.0)*pz))+(((-103.041)*cj30*x930))+(((-128.4)*x930))+((x931*x932))+((x929*x932))),IKFAST_ATAN2_MAGTHRESH);\nif(!x935.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x934.value)))+(x935.value));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[6];\nIkReal x936=IKsin(j28);\nIkReal x937=IKcos(j28);\nIkReal x938=((0.321)*cj30);\nIkReal x939=(py*sj27);\nIkReal x940=((0.321)*sj30);\nIkReal x941=((1.0)*sj29);\nIkReal x942=(px*sj27);\nIkReal x943=(cj27*px);\nIkReal x944=(cj27*py);\nIkReal x945=((1.0)*x939);\nIkReal x946=(pz*x936);\nIkReal x947=(cj29*x936);\nIkReal x948=(pz*x937);\nIkReal x949=((0.8)*x937);\nIkReal x950=(sj29*x936);\nevalcond[0]=(((x936*x938))+((cj29*x937*x940))+pz+(((0.4)*x936)));\nevalcond[1]=((0.1)+(((-1.0)*x945))+((x937*x938))+(((-1.0)*x943))+(((0.4)*x937))+(((-1.0)*x940*x947)));\nevalcond[2]=((0.4)+(((0.1)*x937))+(((-1.0)*x937*x943))+(((-1.0)*x937*x945))+x938+x946);\nevalcond[3]=((-0.066959)+(((-0.08)*x937))+(((-0.8)*x946))+(((0.2)*x939))+((x939*x949))+(((0.2)*x943))+((x943*x949))+(((-1.0)*pp)));\nevalcond[4]=((((-1.0)*x936*x941*x943))+(((0.1)*x950))+(((-1.0)*cj29*x944))+(((-1.0)*x941*x948))+((cj29*x942))+(((-1.0)*x936*x939*x941)));\nevalcond[5]=(((sj29*x942))+((x939*x947))+((x943*x947))+(((-1.0)*x941*x944))+((cj29*x948))+(((-0.1)*x947))+x940);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x951=cj29*cj29;\nIkReal x952=cj30*cj30;\nIkReal x953=(cj27*px);\nIkReal x954=((321000.0)*cj30);\nIkReal x955=(py*sj27);\nIkReal x956=((321000.0)*cj29*sj30);\nIkReal x957=((103041.0)*x951);\nCheckValue<IkReal> x958 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x954))+(((32100.0)*cj29*sj30))+(((-400000.0)*pz))+(((-1.0)*x953*x956))+(((-1.0)*x955*x956)))),((-40000.0)+(((-1.0)*pz*x956))+(((-32100.0)*cj30))+(((400000.0)*x953))+(((400000.0)*x955))+((x953*x954))+((x954*x955))),IKFAST_ATAN2_MAGTHRESH);\nif(!x958.valid){\ncontinue;\n}\nCheckValue<IkReal> x959=IKPowWithIntegerCheck(IKsign(((160000.0)+(((256800.0)*cj30))+(((-1.0)*x952*x957))+(((103041.0)*x952))+x957)),-1);\nif(!x959.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(x958.value)+(((1.5707963267949)*(x959.value))));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[6];\nIkReal x960=IKsin(j28);\nIkReal x961=IKcos(j28);\nIkReal x962=((0.321)*cj30);\nIkReal x963=(py*sj27);\nIkReal x964=((0.321)*sj30);\nIkReal x965=((1.0)*sj29);\nIkReal x966=(px*sj27);\nIkReal x967=(cj27*px);\nIkReal x968=(cj27*py);\nIkReal x969=((1.0)*x963);\nIkReal x970=(pz*x960);\nIkReal x971=(cj29*x960);\nIkReal x972=(pz*x961);\nIkReal x973=((0.8)*x961);\nIkReal x974=(sj29*x960);\nevalcond[0]=(((x960*x962))+((cj29*x961*x964))+pz+(((0.4)*x960)));\nevalcond[1]=((0.1)+((x961*x962))+(((-1.0)*x967))+(((-1.0)*x964*x971))+(((-1.0)*x969))+(((0.4)*x961)));\nevalcond[2]=((0.4)+(((-1.0)*x961*x969))+(((-1.0)*x961*x967))+(((0.1)*x961))+x970+x962);\nevalcond[3]=((-0.066959)+(((-0.8)*x970))+((x963*x973))+(((-1.0)*pp))+(((0.2)*x967))+(((0.2)*x963))+((x967*x973))+(((-0.08)*x961)));\nevalcond[4]=((((-1.0)*x965*x972))+(((0.1)*x974))+(((-1.0)*x960*x965*x967))+(((-1.0)*cj29*x968))+(((-1.0)*x960*x963*x965))+((cj29*x966)));\nevalcond[5]=(((sj29*x966))+(((-0.1)*x971))+(((-1.0)*x965*x968))+((x963*x971))+((cj29*x972))+((x967*x971))+x964);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x975=(py*sj27);\nIkReal x976=(cj29*sj30);\nIkReal x977=((321.0)*cj30);\nIkReal x978=(cj27*px);\nIkReal x979=((1000.0)*pz);\nCheckValue<IkReal> x980 = IKatan2WithCheck(IkReal(((((100.0)*pz))+(((-1.0)*x978*x979))+(((-128.4)*x976))+(((-1.0)*x975*x979))+(((-103.041)*cj30*x976)))),((160.0)+(((-1.0)*pz*x979))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))),IKFAST_ATAN2_MAGTHRESH);\nif(!x980.valid){\ncontinue;\n}\nCheckValue<IkReal> x981=IKPowWithIntegerCheck(IKsign(((-40.0)+((x975*x977))+(((321.0)*pz*x976))+((x977*x978))+(((400.0)*x975))+(((400.0)*x978))+(((-32.1)*cj30)))),-1);\nif(!x981.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(x980.value)+(((1.5707963267949)*(x981.value))));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[6];\nIkReal x982=IKsin(j28);\nIkReal x983=IKcos(j28);\nIkReal x984=((0.321)*cj30);\nIkReal x985=(py*sj27);\nIkReal x986=((0.321)*sj30);\nIkReal x987=((1.0)*sj29);\nIkReal x988=(px*sj27);\nIkReal x989=(cj27*px);\nIkReal x990=(cj27*py);\nIkReal x991=((1.0)*x985);\nIkReal x992=(pz*x982);\nIkReal x993=(cj29*x982);\nIkReal x994=(pz*x983);\nIkReal x995=((0.8)*x983);\nIkReal x996=(sj29*x982);\nevalcond[0]=((((0.4)*x982))+((x982*x984))+pz+((cj29*x983*x986)));\nevalcond[1]=((0.1)+((x983*x984))+(((0.4)*x983))+(((-1.0)*x989))+(((-1.0)*x991))+(((-1.0)*x986*x993)));\nevalcond[2]=((0.4)+(((0.1)*x983))+(((-1.0)*x983*x989))+(((-1.0)*x983*x991))+x992+x984);\nevalcond[3]=((-0.066959)+(((-0.8)*x992))+((x989*x995))+(((-1.0)*pp))+(((0.2)*x985))+(((0.2)*x989))+(((-0.08)*x983))+((x985*x995)));\nevalcond[4]=((((-1.0)*x982*x987*x989))+(((-1.0)*x982*x985*x987))+(((0.1)*x996))+((cj29*x988))+(((-1.0)*x987*x994))+(((-1.0)*cj29*x990)));\nevalcond[5]=(((x989*x993))+((cj29*x994))+((sj29*x988))+(((-0.1)*x993))+x986+((x985*x993))+(((-1.0)*x987*x990)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j28array[1], cj28array[1], sj28array[1];\nbool j28valid[1]={false};\n_nj28 = 1;\nIkReal x997=cj27*cj27;\nIkReal x998=px*px;\nIkReal x999=py*py;\nIkReal x1000=((1.0)*pz);\nIkReal x1001=(cj27*px);\nIkReal x1002=((5.0)*pp);\nIkReal x1003=(cj29*py);\nIkReal x1004=((4.0)*cj27);\nIkReal x1005=(pz*sj29);\nIkReal x1006=(cj29*sj27);\nIkReal x1007=(py*sj27*sj29);\nIkReal x1008=((4.0)*cj29*px);\nIkReal x1009=(sj29*x997);\nIkReal x1010=((4.0)*x999);\nCheckValue<IkReal> x1011 = IKatan2WithCheck(IkReal(((((-1.0)*sj29*x1000*x1001))+(((8.0)*px*x1003*x997))+(((-0.4)*cj27*x1003))+(((-1.0)*x1004*x1006*x998))+((x1004*x1006*x999))+((x1002*x1005))+(((-1.0)*x1000*x1007))+(((-4.0)*px*x1003))+(((0.334795)*x1005))+(((0.4)*px*x1006)))),((((-1.0)*x1009*x999))+(((0.5)*pp*sj29))+((pz*x1003*x1004))+(((2.0)*x1001*x1007))+(((-4.0)*px*pz*x1006))+((x1009*x998))+(((0.0334795)*sj29))+((sj29*x999))+(((-1.0)*sj29*x1001*x1002))+(((-1.0)*x1002*x1007))+(((-0.434795)*x1007))+(((-0.434795)*sj29*x1001))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1011.valid){\ncontinue;\n}\nCheckValue<IkReal> x1012=IKPowWithIntegerCheck(IKsign(((((0.8)*sj29*x1001))+((x1009*x1010))+(((-4.0)*x1009*x998))+(((-0.04)*sj29))+(((-8.0)*x1001*x1007))+(((-1.0)*sj29*x1010))+(((0.8)*x1007))+(((-4.0)*pz*x1005)))),-1);\nif(!x1012.valid){\ncontinue;\n}\nj28array[0]=((-1.5707963267949)+(x1011.value)+(((1.5707963267949)*(x1012.value))));\nsj28array[0]=IKsin(j28array[0]);\ncj28array[0]=IKcos(j28array[0]);\nif( j28array[0] > IKPI )\n{\n    j28array[0]-=IK2PI;\n}\nelse if( j28array[0] < -IKPI )\n{    j28array[0]+=IK2PI;\n}\nj28valid[0] = true;\nfor(int ij28 = 0; ij28 < 1; ++ij28)\n{\nif( !j28valid[ij28] )\n{\n    continue;\n}\n_ij28[0] = ij28; _ij28[1] = -1;\nfor(int iij28 = ij28+1; iij28 < 1; ++iij28)\n{\nif( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )\n{\n    j28valid[iij28]=false; _ij28[1] = iij28; break; \n}\n}\nj28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];\n{\nIkReal evalcond[2];\nIkReal x1013=IKcos(j28);\nIkReal x1014=IKsin(j28);\nIkReal x1015=(py*sj27);\nIkReal x1016=((1.0)*cj27);\nIkReal x1017=(cj27*px);\nIkReal x1018=((0.8)*x1013);\nIkReal x1019=(sj29*x1014);\nevalcond[0]=((-0.066959)+(((-0.8)*pz*x1014))+((x1017*x1018))+(((-0.08)*x1013))+(((-1.0)*pp))+((x1015*x1018))+(((0.2)*x1017))+(((0.2)*x1015)));\nevalcond[1]=(((cj29*px*sj27))+(((-1.0)*pz*sj29*x1013))+(((-1.0)*cj29*py*x1016))+(((-1.0)*x1015*x1019))+(((-1.0)*px*x1016*x1019))+(((0.1)*x1019)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j30eval[1];\nj30eval[0]=sj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[2];\nj30eval[0]=cj28;\nj30eval[1]=cj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  || IKabs(j30eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[2];\nj30eval[0]=sj29;\nj30eval[1]=sj28;\nif( IKabs(j30eval[0]) < 0.0000010000000000  || IKabs(j30eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1020=(cj27*px);\nIkReal x1021=((0.8)*cj28);\nIkReal x1022=(py*sj27);\nIkReal x1023=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));\nevalcond[1]=x1023;\nevalcond[2]=((-0.066959)+(((-0.08)*cj28))+(((-1.0)*pp))+((x1021*x1022))+((x1020*x1021))+(((0.2)*x1022))+(((0.2)*x1020))+(((-0.8)*pz*sj28)));\nevalcond[3]=x1023;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nIkReal x1024=((3.11526479750779)*cj28);\nIkReal x1025=(py*sj27);\nIkReal x1026=((3.11526479750779)*sj28);\nIkReal x1027=(cj27*px);\nif( IKabs(((((-1.0)*pz*x1024))+(((-1.0)*x1026*x1027))+(((-1.0)*x1025*x1026))+(((0.311526479750779)*sj28)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1026))+((x1024*x1027))+((x1024*x1025)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*pz*x1024))+(((-1.0)*x1026*x1027))+(((-1.0)*x1025*x1026))+(((0.311526479750779)*sj28))))+IKsqr(((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1026))+((x1024*x1027))+((x1024*x1025))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((-1.0)*pz*x1024))+(((-1.0)*x1026*x1027))+(((-1.0)*x1025*x1026))+(((0.311526479750779)*sj28))), ((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1026))+((x1024*x1027))+((x1024*x1025))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1028=IKcos(j30);\nIkReal x1029=IKsin(j30);\nIkReal x1030=(py*sj27);\nIkReal x1031=(cj27*px);\nIkReal x1032=((0.321)*x1028);\nIkReal x1033=((0.321)*x1029);\nevalcond[0]=((((0.4)*sj28))+((cj28*x1033))+pz+((sj28*x1032)));\nevalcond[1]=((0.253041)+(((0.2568)*x1028))+(((-1.0)*pp))+(((0.2)*x1030))+(((0.2)*x1031)));\nevalcond[2]=(x1033+((cj28*pz))+((sj28*x1030))+((sj28*x1031))+(((-0.1)*sj28)));\nCheckValue<IkReal> x1034=IKPowWithIntegerCheck(py,-1);\nif(!x1034.valid){\ncontinue;\n}\nevalcond[3]=((0.31630125)+x1032+(((-1.25)*pp))+(((0.25)*x1030))+(((0.25)*sj27*(px*px)*(x1034.value))));\nevalcond[4]=((0.1)+((cj28*x1032))+(((-1.0)*x1030))+(((-1.0)*x1031))+(((0.4)*cj28))+(((-1.0)*sj28*x1033)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1035=(cj27*px);\nIkReal x1036=((0.8)*cj28);\nIkReal x1037=(cj27*py);\nIkReal x1038=(px*sj27);\nIkReal x1039=(py*sj27);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));\nevalcond[1]=(x1038+(((-1.0)*x1037)));\nevalcond[2]=((-0.066959)+((x1036*x1039))+(((-0.08)*cj28))+(((-1.0)*pp))+((x1035*x1036))+(((-0.8)*pz*sj28))+(((0.2)*x1039))+(((0.2)*x1035)));\nevalcond[3]=(x1037+(((-1.0)*x1038)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nIkReal x1040=((3.11526479750779)*cj28);\nIkReal x1041=(py*sj27);\nIkReal x1042=((3.11526479750779)*sj28);\nIkReal x1043=(cj27*px);\nif( IKabs((((x1042*x1043))+((x1041*x1042))+((pz*x1040))+(((-0.311526479750779)*sj28)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-0.311526479750779)*cj28))+((x1040*x1043))+((x1040*x1041))+(((-1.0)*pz*x1042)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1042*x1043))+((x1041*x1042))+((pz*x1040))+(((-0.311526479750779)*sj28))))+IKsqr(((-1.24610591900312)+(((-0.311526479750779)*cj28))+((x1040*x1043))+((x1040*x1041))+(((-1.0)*pz*x1042))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2((((x1042*x1043))+((x1041*x1042))+((pz*x1040))+(((-0.311526479750779)*sj28))), ((-1.24610591900312)+(((-0.311526479750779)*cj28))+((x1040*x1043))+((x1040*x1041))+(((-1.0)*pz*x1042))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1044=IKcos(j30);\nIkReal x1045=IKsin(j30);\nIkReal x1046=(cj27*px);\nIkReal x1047=((1.0)*sj28);\nIkReal x1048=((0.25)*sj27);\nIkReal x1049=(py*sj27);\nIkReal x1050=((0.321)*x1044);\nIkReal x1051=((0.321)*x1045);\nevalcond[0]=((((0.4)*sj28))+pz+(((-1.0)*cj28*x1051))+((sj28*x1050)));\nevalcond[1]=((0.253041)+(((0.2)*x1046))+(((0.2)*x1049))+(((-1.0)*pp))+(((0.2568)*x1044)));\nCheckValue<IkReal> x1052=IKPowWithIntegerCheck(py,-1);\nif(!x1052.valid){\ncontinue;\n}\nevalcond[2]=((0.31630125)+x1050+(((-1.25)*pp))+((py*x1048))+((x1048*(px*px)*(x1052.value))));\nevalcond[3]=((((-1.0)*x1046*x1047))+x1051+(((0.1)*sj28))+(((-1.0)*cj28*pz))+(((-1.0)*x1047*x1049)));\nevalcond[4]=((0.1)+(((0.4)*cj28))+(((-1.0)*x1049))+(((-1.0)*x1046))+((cj28*x1050))+((sj28*x1051)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j28))), 6.28318530717959)));\nevalcond[1]=((-0.146959)+((cj27*px))+(((-1.0)*pp))+((py*sj27)));\nevalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+(((-1.0)*pz*sj29)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30eval[1];\nsj28=0;\ncj28=1.0;\nj28=0;\nj30eval[0]=cj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[1];\nsj28=0;\ncj28=1.0;\nj28=0;\nj30eval[0]=sj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1053=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));\nevalcond[1]=x1053;\nevalcond[2]=((-0.146959)+((cj27*px))+(((-1.0)*pp))+((py*sj27)));\nevalcond[3]=x1053;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.09981619937695)+(((3.11526479750779)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1054=IKcos(j30);\nevalcond[0]=(pz+(((0.321)*(IKsin(j30)))));\nevalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1054)));\nevalcond[2]=((0.353041)+(((0.321)*x1054))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1055=(cj27*py);\nIkReal x1056=(px*sj27);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));\nevalcond[1]=(x1056+(((-1.0)*x1055)));\nevalcond[2]=((-0.146959)+((cj27*px))+(((-1.0)*pp))+((py*sj27)));\nevalcond[3]=(x1055+(((-1.0)*x1056)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.09981619937695)+(((3.11526479750779)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1057=IKcos(j30);\nevalcond[0]=((((-0.321)*(IKsin(j30))))+pz);\nevalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1057)));\nevalcond[2]=((0.353041)+(((0.321)*x1057))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((-0.146959)+((cj27*px))+(((-1.0)*pp))+((py*sj27)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.09981619937695)+(((3.11526479750779)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1058=IKcos(j30);\nevalcond[0]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1058)));\nevalcond[1]=((0.353041)+(((0.321)*x1058))+(((-1.0)*pp)));\nevalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((-0.146959)+((cj27*px))+(((-1.0)*pp))+((py*sj27)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.09981619937695)+(((3.11526479750779)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1059=IKcos(j30);\nevalcond[0]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1059)));\nevalcond[1]=((0.353041)+(((0.321)*x1059))+(((-1.0)*pp)));\nevalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j30]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1060=IKPowWithIntegerCheck(sj29,-1);\nif(!x1060.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1060.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1060.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1060.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.09981619937695)+(((3.11526479750779)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1061=IKcos(j30);\nIkReal x1062=IKsin(j30);\nIkReal x1063=(px*sj27);\nIkReal x1064=((1.0)*cj27*py);\nIkReal x1065=((0.321)*x1062);\nevalcond[0]=(pz+((cj29*x1065)));\nevalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1061)));\nevalcond[2]=((0.353041)+(((0.321)*x1061))+(((-1.0)*pp)));\nevalcond[3]=(x1063+(((-1.0)*x1064))+((sj29*x1065)));\nevalcond[4]=(x1065+(((-1.0)*sj29*x1064))+((cj29*pz))+((sj29*x1063)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1066=IKPowWithIntegerCheck(cj29,-1);\nif(!x1066.valid){\ncontinue;\n}\nif( IKabs(((-3.11526479750779)*pz*(x1066.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz*(x1066.value)))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((-3.11526479750779)*pz*(x1066.value)), ((-1.09981619937695)+(((3.11526479750779)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1067=IKcos(j30);\nIkReal x1068=IKsin(j30);\nIkReal x1069=(px*sj27);\nIkReal x1070=((1.0)*cj27*py);\nIkReal x1071=((0.321)*x1068);\nevalcond[0]=(pz+((cj29*x1071)));\nevalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1067)));\nevalcond[2]=((0.353041)+(((0.321)*x1067))+(((-1.0)*pp)));\nevalcond[3]=(x1069+((sj29*x1071))+(((-1.0)*x1070)));\nevalcond[4]=((((-1.0)*sj29*x1070))+x1071+((cj29*pz))+((sj29*x1069)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j28)))), 6.28318530717959)));\nevalcond[1]=((0.013041)+(((-0.6)*cj27*px))+(((-1.0)*pp))+(((-0.6)*py*sj27)));\nevalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+((pz*sj29)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30eval[1];\nsj28=0;\ncj28=-1.0;\nj28=3.14159265358979;\nj30eval[0]=cj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[1];\nsj28=0;\ncj28=-1.0;\nj28=3.14159265358979;\nj30eval[0]=sj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1072=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));\nevalcond[1]=x1072;\nevalcond[2]=((0.013041)+(((-0.6)*cj27*px))+(((-1.0)*pp))+(((-0.6)*py*sj27)));\nevalcond[3]=x1072;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.00228971962617)+(((5.19210799584631)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1073=IKcos(j30);\nevalcond[0]=((((-0.321)*(IKsin(j30))))+pz);\nevalcond[1]=((0.257388)+(((0.2568)*x1073))+(((-1.33333333333333)*pp)));\nevalcond[2]=((0.321735)+(((0.321)*x1073))+(((-1.66666666666667)*pp)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1074=(cj27*py);\nIkReal x1075=(px*sj27);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));\nevalcond[1]=(x1075+(((-1.0)*x1074)));\nevalcond[2]=((0.013041)+(((-0.6)*cj27*px))+(((-1.0)*pp))+(((-0.6)*py*sj27)));\nevalcond[3]=(x1074+(((-1.0)*x1075)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.00228971962617)+(((5.19210799584631)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1076=IKcos(j30);\nevalcond[0]=(pz+(((0.321)*(IKsin(j30)))));\nevalcond[1]=((0.257388)+(((0.2568)*x1076))+(((-1.33333333333333)*pp)));\nevalcond[2]=((0.321735)+(((0.321)*x1076))+(((-1.66666666666667)*pp)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((0.013041)+(((-0.6)*cj27*px))+(((-1.0)*pp))+(((-0.6)*py*sj27)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.00228971962617)+(((5.19210799584631)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1077=IKcos(j30);\nevalcond[0]=((0.257388)+(((0.2568)*x1077))+(((-1.33333333333333)*pp)));\nevalcond[1]=((0.321735)+(((0.321)*x1077))+(((-1.66666666666667)*pp)));\nevalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=pz;\nevalcond[2]=((0.013041)+(((-0.6)*cj27*px))+(((-1.0)*pp))+(((-0.6)*py*sj27)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.00228971962617)+(((5.19210799584631)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1078=IKcos(j30);\nevalcond[0]=((0.257388)+(((0.2568)*x1078))+(((-1.33333333333333)*pp)));\nevalcond[1]=((0.321735)+(((0.321)*x1078))+(((-1.66666666666667)*pp)));\nevalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j30]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1079=IKPowWithIntegerCheck(sj29,-1);\nif(!x1079.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1079.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1079.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1079.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.00228971962617)+(((5.19210799584631)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1080=IKcos(j30);\nIkReal x1081=IKsin(j30);\nIkReal x1082=(px*sj27);\nIkReal x1083=((1.0)*cj27*py);\nIkReal x1084=((0.321)*x1081);\nevalcond[0]=(pz+(((-1.0)*cj29*x1084)));\nevalcond[1]=((0.257388)+(((0.2568)*x1080))+(((-1.33333333333333)*pp)));\nevalcond[2]=((0.321735)+(((0.321)*x1080))+(((-1.66666666666667)*pp)));\nevalcond[3]=(x1082+((sj29*x1084))+(((-1.0)*x1083)));\nevalcond[4]=(x1084+((sj29*x1082))+(((-1.0)*cj29*pz))+(((-1.0)*sj29*x1083)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1085=IKPowWithIntegerCheck(cj29,-1);\nif(!x1085.valid){\ncontinue;\n}\nif( IKabs(((3.11526479750779)*pz*(x1085.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz*(x1085.value)))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((3.11526479750779)*pz*(x1085.value)), ((-1.00228971962617)+(((5.19210799584631)*pp))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1086=IKcos(j30);\nIkReal x1087=IKsin(j30);\nIkReal x1088=(px*sj27);\nIkReal x1089=((1.0)*cj27*py);\nIkReal x1090=((0.321)*x1087);\nevalcond[0]=(pz+(((-1.0)*cj29*x1090)));\nevalcond[1]=((0.257388)+(((0.2568)*x1086))+(((-1.33333333333333)*pp)));\nevalcond[2]=((0.321735)+(((0.321)*x1086))+(((-1.66666666666667)*pp)));\nevalcond[3]=(x1088+((sj29*x1090))+(((-1.0)*x1089)));\nevalcond[4]=(x1090+((sj29*x1088))+(((-1.0)*cj29*pz))+(((-1.0)*sj29*x1089)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1091=(cj27*px);\nIkReal x1092=((1.0)*py);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j28)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+(((-0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*x1091)));\nevalcond[2]=(((cj29*px*sj27))+(((-1.0)*sj29*x1091))+(((0.1)*sj29))+(((-1.0)*cj27*cj29*x1092))+(((-1.0)*sj27*sj29*x1092)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30eval[1];\nsj28=1.0;\ncj28=0;\nj28=1.5707963267949;\nj30eval[0]=sj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[1];\nsj28=1.0;\ncj28=0;\nj28=1.5707963267949;\nj30eval[0]=cj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1093=(py*sj27);\nIkReal x1094=(cj27*px);\nIkReal x1095=((0.1)+(((-1.0)*x1093))+(((-1.0)*x1094)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=x1095;\nevalcond[2]=((-0.066959)+(((-0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1094))+(((0.2)*x1093)));\nevalcond[3]=x1095;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1096=IKcos(j30);\nevalcond[0]=((0.4)+pz+(((0.321)*x1096)));\nevalcond[1]=((0.32)+(((0.2568)*x1096))+(((0.8)*pz)));\nevalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1097=(py*sj27);\nIkReal x1098=(cj27*px);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=((0.1)+(((-1.0)*x1098))+(((-1.0)*x1097)));\nevalcond[2]=((-0.066959)+(((-0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1097))+(((0.2)*x1098)));\nevalcond[3]=((-0.1)+x1097+x1098);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1099=IKcos(j30);\nevalcond[0]=((0.4)+pz+(((0.321)*x1099)));\nevalcond[1]=((0.32)+(((0.2568)*x1099))+(((0.8)*pz)));\nevalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1100=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));\nevalcond[1]=x1100;\nevalcond[2]=((-0.066959)+(((-0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nevalcond[3]=x1100;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1101=IKcos(j30);\nevalcond[0]=((0.4)+(((0.321)*x1101))+pz);\nevalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1101)));\nevalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1102=(cj27*py);\nIkReal x1103=(px*sj27);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));\nevalcond[1]=(x1103+(((-1.0)*x1102)));\nevalcond[2]=((-0.066959)+(((-0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nevalcond[3]=(x1102+(((-1.0)*x1103)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1104=IKcos(j30);\nevalcond[0]=((0.4)+(((0.321)*x1104))+pz);\nevalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1104)));\nevalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j30]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1105=IKPowWithIntegerCheck(cj29,-1);\nif(!x1105.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1105.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1105.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1105.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1106=IKcos(j30);\nIkReal x1107=IKsin(j30);\nIkReal x1108=((1.0)*py);\nIkReal x1109=(cj27*px);\nIkReal x1110=(px*sj27);\nIkReal x1111=((0.321)*x1107);\nevalcond[0]=((0.4)+(((0.321)*x1106))+pz);\nevalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1106)));\nevalcond[2]=(x1110+(((-1.0)*cj27*x1108))+((sj29*x1111)));\nevalcond[3]=((0.1)+(((-1.0)*sj27*x1108))+(((-1.0)*x1109))+(((-1.0)*cj29*x1111)));\nevalcond[4]=(((cj29*x1109))+((cj29*py*sj27))+x1111+(((-1.0)*cj27*sj29*x1108))+((sj29*x1110))+(((-0.1)*cj29)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1112=IKPowWithIntegerCheck(sj29,-1);\nif(!x1112.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1112.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1112.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1112.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1113=IKcos(j30);\nIkReal x1114=IKsin(j30);\nIkReal x1115=((1.0)*py);\nIkReal x1116=(cj27*px);\nIkReal x1117=(px*sj27);\nIkReal x1118=((0.321)*x1114);\nevalcond[0]=((0.4)+(((0.321)*x1113))+pz);\nevalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1113)));\nevalcond[2]=(x1117+(((-1.0)*cj27*x1115))+((sj29*x1118)));\nevalcond[3]=((0.1)+(((-1.0)*sj27*x1115))+(((-1.0)*x1116))+(((-1.0)*cj29*x1118)));\nevalcond[4]=(((cj29*py*sj27))+x1118+(((-1.0)*cj27*sj29*x1115))+((sj29*x1117))+(((-0.1)*cj29))+((cj29*x1116)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1119=(py*sj27);\nIkReal x1120=(cj27*px);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j28)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1120))+(((0.2)*x1119)));\nevalcond[2]=(((sj29*x1120))+((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+((sj29*x1119))+(((-0.1)*sj29)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30eval[1];\nsj28=-1.0;\ncj28=0;\nj28=-1.5707963267949;\nj30eval[0]=sj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j30eval[1];\nsj28=-1.0;\ncj28=0;\nj28=-1.5707963267949;\nj30eval[0]=cj29;\nif( IKabs(j30eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[4];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1121=(py*sj27);\nIkReal x1122=(cj27*px);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=((0.1)+(((-1.0)*x1121))+(((-1.0)*x1122)));\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1121))+(((0.2)*x1122)));\nevalcond[3]=((-0.1)+x1121+x1122);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1123=IKcos(j30);\nevalcond[0]=((-0.4)+(((-0.321)*x1123))+pz);\nevalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1123)));\nevalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1124=(py*sj27);\nIkReal x1125=(cj27*px);\nIkReal x1126=((0.1)+(((-1.0)*x1124))+(((-1.0)*x1125)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=x1126;\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1125))+(((0.2)*x1124)));\nevalcond[3]=x1126;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1127=IKcos(j30);\nevalcond[0]=((-0.4)+(((-0.321)*x1127))+pz);\nevalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1127)));\nevalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1128=((((-1.0)*cj27*py))+((px*sj27)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));\nevalcond[1]=x1128;\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nevalcond[3]=x1128;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1129=IKcos(j30);\nevalcond[0]=((-0.4)+(((-0.321)*x1129))+pz);\nevalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1129)));\nevalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1130=(cj27*py);\nIkReal x1131=(px*sj27);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));\nevalcond[1]=(x1131+(((-1.0)*x1130)));\nevalcond[2]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));\nevalcond[3]=(x1130+(((-1.0)*x1131)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[3];\nIkReal x1132=IKcos(j30);\nevalcond[0]=((-0.4)+(((-0.321)*x1132))+pz);\nevalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1132)));\nevalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j30]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1133=IKPowWithIntegerCheck(cj29,-1);\nif(!x1133.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1133.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1133.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1133.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1134=IKcos(j30);\nIkReal x1135=IKsin(j30);\nIkReal x1136=((1.0)*py);\nIkReal x1137=(px*sj27);\nIkReal x1138=((1.0)*cj27*px);\nIkReal x1139=((0.321)*x1135);\nevalcond[0]=((-0.4)+(((-0.321)*x1134))+pz);\nevalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1134)));\nevalcond[2]=(x1137+((sj29*x1139))+(((-1.0)*cj27*x1136)));\nevalcond[3]=((0.1)+(((-1.0)*x1138))+(((-1.0)*sj27*x1136))+((cj29*x1139)));\nevalcond[4]=(x1139+((sj29*x1137))+(((0.1)*cj29))+(((-1.0)*cj29*sj27*x1136))+(((-1.0)*cj27*sj29*x1136))+(((-1.0)*cj29*x1138)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1140=IKPowWithIntegerCheck(sj29,-1);\nif(!x1140.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1140.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1140.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1140.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1141=IKcos(j30);\nIkReal x1142=IKsin(j30);\nIkReal x1143=((1.0)*py);\nIkReal x1144=(px*sj27);\nIkReal x1145=((1.0)*cj27*px);\nIkReal x1146=((0.321)*x1142);\nevalcond[0]=((-0.4)+pz+(((-0.321)*x1141)));\nevalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1141)));\nevalcond[2]=(x1144+(((-1.0)*cj27*x1143))+((sj29*x1146)));\nevalcond[3]=((0.1)+(((-1.0)*x1145))+((cj29*x1146))+(((-1.0)*sj27*x1143)));\nevalcond[4]=((((-1.0)*cj29*sj27*x1143))+x1146+(((-1.0)*cj27*sj29*x1143))+((sj29*x1144))+(((-1.0)*cj29*x1145))+(((0.1)*cj29)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1147=(cj27*px);\nIkReal x1148=((0.8)*cj28);\nIkReal x1149=(py*sj27);\nIkReal x1150=((1.0)*sj28);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+(((-0.08)*cj28))+(((-1.0)*pp))+((x1147*x1148))+((x1148*x1149))+(((0.2)*x1147))+(((0.2)*x1149))+(((-0.8)*pz*sj28)));\nevalcond[2]=((((-1.0)*x1149*x1150))+(((-1.0)*x1147*x1150))+(((0.1)*sj28))+(((-1.0)*cj28*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1151=IKcos(j30);\nIkReal x1152=((1.0)*py);\nIkReal x1153=(cj27*px);\nIkReal x1154=((0.321)*x1151);\nevalcond[0]=((((0.4)*sj28))+((sj28*x1154))+pz);\nevalcond[1]=((((-1.0)*cj27*x1152))+((px*sj27))+(((0.321)*(IKsin(j30)))));\nevalcond[2]=((0.253041)+(((0.2)*x1153))+(((0.2568)*x1151))+(((-1.0)*pp))+(((0.2)*py*sj27)));\nevalcond[3]=((0.1)+(((-1.0)*sj27*x1152))+(((0.4)*cj28))+((cj28*x1154))+(((-1.0)*x1153)));\nevalcond[4]=((0.4)+x1154+(((-1.0)*cj28*sj27*x1152))+(((-1.0)*cj28*x1153))+(((0.1)*cj28))+((pz*sj28)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x1155=(cj27*px);\nIkReal x1156=((0.8)*cj28);\nIkReal x1157=(py*sj27);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));\nevalcond[1]=((-0.066959)+(((0.2)*x1155))+(((0.2)*x1157))+(((-0.08)*cj28))+(((-1.0)*pp))+((x1156*x1157))+(((-0.8)*pz*sj28))+((x1155*x1156)));\nevalcond[2]=(((sj28*x1155))+((sj28*x1157))+((cj28*pz))+(((-0.1)*sj28)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nif( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[5];\nIkReal x1158=IKcos(j30);\nIkReal x1159=((1.0)*py);\nIkReal x1160=(cj27*px);\nIkReal x1161=((0.321)*x1158);\nevalcond[0]=((((0.4)*sj28))+pz+((sj28*x1161)));\nevalcond[1]=((((-1.0)*cj27*x1159))+(((-0.321)*(IKsin(j30))))+((px*sj27)));\nevalcond[2]=((0.253041)+(((0.2568)*x1158))+(((-1.0)*pp))+(((0.2)*x1160))+(((0.2)*py*sj27)));\nevalcond[3]=((0.1)+(((-1.0)*sj27*x1159))+(((0.4)*cj28))+(((-1.0)*x1160))+((cj28*x1161)));\nevalcond[4]=((0.4)+x1161+(((-1.0)*cj28*sj27*x1159))+(((-1.0)*cj28*x1160))+(((0.1)*cj28))+((pz*sj28)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j30]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1167=IKPowWithIntegerCheck(sj29,-1);\nif(!x1167.valid){\ncontinue;\n}\nIkReal x1162=x1167.value;\nIkReal x1163=((0.00311526479750779)*x1162);\nIkReal x1164=(cj28*cj29);\nIkReal x1165=((1000.0)*cj27*py);\nIkReal x1166=((1000.0)*px*sj27);\nCheckValue<IkReal> x1168=IKPowWithIntegerCheck(sj28,-1);\nif(!x1168.valid){\ncontinue;\n}\nif( IKabs((x1163*((x1165+(((-1.0)*x1166)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1163*(x1168.value)*((((x1164*x1166))+(((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+(((-1.0)*x1164*x1165)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1163*((x1165+(((-1.0)*x1166))))))+IKsqr((x1163*(x1168.value)*((((x1164*x1166))+(((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+(((-1.0)*x1164*x1165))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2((x1163*((x1165+(((-1.0)*x1166))))), (x1163*(x1168.value)*((((x1164*x1166))+(((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+(((-1.0)*x1164*x1165))))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[6];\nIkReal x1169=IKsin(j30);\nIkReal x1170=IKcos(j30);\nIkReal x1171=((1.0)*py);\nIkReal x1172=(cj29*sj28);\nIkReal x1173=(cj27*px);\nIkReal x1174=(cj28*cj29);\nIkReal x1175=(py*sj27);\nIkReal x1176=(px*sj27);\nIkReal x1177=((0.321)*x1169);\nIkReal x1178=((0.321)*x1170);\nevalcond[0]=(x1176+(((-1.0)*cj27*x1171))+((sj29*x1177)));\nevalcond[1]=((0.253041)+(((0.2568)*x1170))+(((0.2)*x1175))+(((0.2)*x1173))+(((-1.0)*pp)));\nevalcond[2]=((((0.4)*sj28))+((x1174*x1177))+pz+((sj28*x1178)));\nevalcond[3]=((0.4)+x1178+(((-1.0)*cj28*sj27*x1171))+(((0.1)*cj28))+(((-1.0)*cj28*x1173))+((pz*sj28)));\nevalcond[4]=((0.1)+((cj28*x1178))+(((0.4)*cj28))+(((-1.0)*x1172*x1177))+(((-1.0)*sj27*x1171))+(((-1.0)*x1173)));\nevalcond[5]=((((-1.0)*cj27*sj29*x1171))+x1177+((x1172*x1175))+((x1172*x1173))+((pz*x1174))+(((-0.1)*x1172))+((sj29*x1176)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nIkReal x1179=((250.0)*sj28);\nIkReal x1180=(py*sj27);\nIkReal x1181=(cj27*px);\nCheckValue<IkReal> x1182=IKPowWithIntegerCheck(cj28,-1);\nif(!x1182.valid){\ncontinue;\n}\nCheckValue<IkReal> x1183=IKPowWithIntegerCheck(cj29,-1);\nif(!x1183.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1182.value)*(x1183.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x1179*x1181))+((x1179*x1180))+(((-1250.0)*pp*sj28)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1180))+(((-0.778816199376947)*x1181)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1182.value)*(x1183.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x1179*x1181))+((x1179*x1180))+(((-1250.0)*pp*sj28))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1180))+(((-0.778816199376947)*x1181))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1182.value)*(x1183.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x1179*x1181))+((x1179*x1180))+(((-1250.0)*pp*sj28))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1180))+(((-0.778816199376947)*x1181))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[6];\nIkReal x1184=IKsin(j30);\nIkReal x1185=IKcos(j30);\nIkReal x1186=((1.0)*py);\nIkReal x1187=(cj29*sj28);\nIkReal x1188=(cj27*px);\nIkReal x1189=(cj28*cj29);\nIkReal x1190=(py*sj27);\nIkReal x1191=(px*sj27);\nIkReal x1192=((0.321)*x1184);\nIkReal x1193=((0.321)*x1185);\nevalcond[0]=(((sj29*x1192))+x1191+(((-1.0)*cj27*x1186)));\nevalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1190))+(((0.2)*x1188))+(((0.2568)*x1185)));\nevalcond[2]=((((0.4)*sj28))+((sj28*x1193))+((x1189*x1192))+pz);\nevalcond[3]=((0.4)+x1193+(((0.1)*cj28))+(((-1.0)*cj28*x1188))+(((-1.0)*cj28*sj27*x1186))+((pz*sj28)));\nevalcond[4]=((0.1)+(((0.4)*cj28))+(((-1.0)*x1187*x1192))+((cj28*x1193))+(((-1.0)*sj27*x1186))+(((-1.0)*x1188)));\nevalcond[5]=(((sj29*x1191))+((x1187*x1188))+x1192+((x1187*x1190))+((pz*x1189))+(((-0.1)*x1187))+(((-1.0)*cj27*sj29*x1186)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j30array[1], cj30array[1], sj30array[1];\nbool j30valid[1]={false};\n_nj30 = 1;\nCheckValue<IkReal> x1194=IKPowWithIntegerCheck(sj29,-1);\nif(!x1194.valid){\ncontinue;\n}\nif( IKabs(((0.00311526479750779)*(x1194.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1194.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj30array[0]=IKatan2(((0.00311526479750779)*(x1194.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));\nsj30array[0]=IKsin(j30array[0]);\ncj30array[0]=IKcos(j30array[0]);\nif( j30array[0] > IKPI )\n{\n    j30array[0]-=IK2PI;\n}\nelse if( j30array[0] < -IKPI )\n{    j30array[0]+=IK2PI;\n}\nj30valid[0] = true;\nfor(int ij30 = 0; ij30 < 1; ++ij30)\n{\nif( !j30valid[ij30] )\n{\n    continue;\n}\n_ij30[0] = ij30; _ij30[1] = -1;\nfor(int iij30 = ij30+1; iij30 < 1; ++iij30)\n{\nif( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )\n{\n    j30valid[iij30]=false; _ij30[1] = iij30; break; \n}\n}\nj30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];\n{\nIkReal evalcond[6];\nIkReal x1195=IKsin(j30);\nIkReal x1196=IKcos(j30);\nIkReal x1197=((1.0)*py);\nIkReal x1198=(cj29*sj28);\nIkReal x1199=(cj27*px);\nIkReal x1200=(cj28*cj29);\nIkReal x1201=(py*sj27);\nIkReal x1202=(px*sj27);\nIkReal x1203=((0.321)*x1195);\nIkReal x1204=((0.321)*x1196);\nevalcond[0]=(x1202+((sj29*x1203))+(((-1.0)*cj27*x1197)));\nevalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1199))+(((0.2568)*x1196))+(((0.2)*x1201)));\nevalcond[2]=((((0.4)*sj28))+((sj28*x1204))+((x1200*x1203))+pz);\nevalcond[3]=((0.4)+x1204+(((0.1)*cj28))+(((-1.0)*cj28*x1199))+(((-1.0)*cj28*sj27*x1197))+((pz*sj28)));\nevalcond[4]=((0.1)+(((0.4)*cj28))+((cj28*x1204))+(((-1.0)*sj27*x1197))+(((-1.0)*x1199))+(((-1.0)*x1198*x1203)));\nevalcond[5]=(x1203+(((-0.1)*x1198))+((x1198*x1199))+((sj29*x1202))+(((-1.0)*cj27*sj29*x1197))+((pz*x1200))+((x1198*x1201)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n    }\n}\nreturn solutions.GetNumSolutions()>0;\n}\ninline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {\nfor(int rotationiter = 0; rotationiter < 1; ++rotationiter) {\nIkReal x194=(sj27*sj29);\nIkReal x195=(cj27*sj29);\nIkReal x196=(cj28*sj29);\nIkReal x197=(cj28*cj30);\nIkReal x198=((1.0)*sj30);\nIkReal x199=((1.0)*cj29);\nIkReal x200=(cj29*x198);\nIkReal x201=((1.0)*cj30*sj28);\nIkReal x202=((((-1.0)*x197*x199))+((sj28*sj30)));\nIkReal x203=((((-1.0)*sj27*x199))+((sj28*x195)));\nIkReal x204=(((sj28*x194))+((cj27*cj29)));\nIkReal x205=(x197+(((-1.0)*sj28*x200)));\nIkReal x206=(cj27*x205);\nIkReal x207=((((-1.0)*cj30*sj28*x199))+(((-1.0)*cj28*x198)));\nIkReal x208=((((-1.0)*x201))+(((-1.0)*cj28*x200)));\nIkReal x209=(cj27*x207);\nIkReal x210=(((sj30*x195))+((sj27*x205)));\nIkReal x211=((((-1.0)*sj30*x194))+x206);\nIkReal x212=(((cj30*x195))+((sj27*x207)));\nIkReal x213=((((-1.0)*cj30*x194))+x209);\nnew_r00=(((r20*x202))+((r00*(((((-1.0)*cj30*x194))+x209))))+((r10*x212)));\nnew_r01=(((r11*x212))+((r21*x202))+((r01*x213)));\nnew_r02=(((r22*x202))+((r12*x212))+((r02*x213)));\nnew_r10=(((r20*x196))+((r00*x203))+((r10*x204)));\nnew_r11=(((r11*x204))+((r01*x203))+((r21*x196)));\nnew_r12=(((r22*x196))+((r12*x204))+((r02*x203)));\nnew_r20=(((r20*x208))+((r00*x211))+((r10*x210)));\nnew_r21=(((r11*x210))+((r21*x208))+((r01*x211)));\nnew_r22=(((r22*x208))+((r02*(((((-1.0)*x194*x198))+x206))))+((r12*x210)));\n{\nIkReal j32array[2], cj32array[2], sj32array[2];\nbool j32valid[2]={false};\n_nj32 = 2;\ncj32array[0]=new_r22;\nif( cj32array[0] >= -1-IKFAST_SINCOS_THRESH && cj32array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j32valid[0] = j32valid[1] = true;\n    j32array[0] = IKacos(cj32array[0]);\n    sj32array[0] = IKsin(j32array[0]);\n    cj32array[1] = cj32array[0];\n    j32array[1] = -j32array[0];\n    sj32array[1] = -sj32array[0];\n}\nelse if( isnan(cj32array[0]) )\n{\n    // probably any value will work\n    j32valid[0] = true;\n    cj32array[0] = 1; sj32array[0] = 0; j32array[0] = 0;\n}\nfor(int ij32 = 0; ij32 < 2; ++ij32)\n{\nif( !j32valid[ij32] )\n{\n    continue;\n}\n_ij32[0] = ij32; _ij32[1] = -1;\nfor(int iij32 = ij32+1; iij32 < 2; ++iij32)\n{\nif( j32valid[iij32] && IKabs(cj32array[ij32]-cj32array[iij32]) < IKFAST_SOLUTION_THRESH && IKabs(sj32array[ij32]-sj32array[iij32]) < IKFAST_SOLUTION_THRESH )\n{\n    j32valid[iij32]=false; _ij32[1] = iij32; break; \n}\n}\nj32 = j32array[ij32]; cj32 = cj32array[ij32]; sj32 = sj32array[ij32];\n\n{\nIkReal j31eval[2];\nIkReal x214=(sj27*sj29);\nIkReal x215=(cj27*sj29);\nIkReal x216=(cj28*sj29);\nIkReal x217=(cj28*cj30);\nIkReal x218=((1.0)*sj30);\nIkReal x219=((1.0)*cj29);\nIkReal x220=(cj29*x218);\nIkReal x221=((1.0)*cj30*sj28);\nIkReal x222=x202;\nIkReal x223=x203;\nIkReal x224=x204;\nIkReal x225=((((-1.0)*sj28*x220))+x217);\nIkReal x226=(cj27*x225);\nIkReal x227=x207;\nIkReal x228=((((-1.0)*cj28*x220))+(((-1.0)*x221)));\nIkReal x229=(cj27*x227);\nIkReal x230=(((sj30*x215))+((sj27*x225)));\nIkReal x231=(x226+(((-1.0)*sj30*x214)));\nIkReal x232=(((cj30*x215))+((sj27*x227)));\nIkReal x233=(x229+(((-1.0)*cj30*x214)));\nnew_r00=(((r20*x222))+((r10*x232))+((r00*((x229+(((-1.0)*cj30*x214)))))));\nnew_r01=(((r11*x232))+((r01*x233))+((r21*x222)));\nnew_r02=(((r02*x233))+((r22*x222))+((r12*x232)));\nnew_r10=(((r00*x223))+((r10*x224))+((r20*x216)));\nnew_r11=(((r21*x216))+((r01*x223))+((r11*x224)));\nnew_r12=(((r12*x224))+((r22*x216))+((r02*x223)));\nnew_r20=(((r20*x228))+((r10*x230))+((r00*x231)));\nnew_r21=(((r11*x230))+((r01*x231))+((r21*x228)));\nnew_r22=(((r22*x228))+((r02*((x226+(((-1.0)*x214*x218))))))+((r12*x230)));\nj31eval[0]=sj32;\nj31eval[1]=IKsign(sj32);\nif( IKabs(j31eval[0]) < 0.0000010000000000  || IKabs(j31eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j31eval[1];\nIkReal x234=(sj27*sj29);\nIkReal x235=(cj27*sj29);\nIkReal x236=(cj28*sj29);\nIkReal x237=(cj28*cj30);\nIkReal x238=((1.0)*sj30);\nIkReal x239=((1.0)*cj29);\nIkReal x240=(cj29*x238);\nIkReal x241=((1.0)*cj30*sj28);\nIkReal x242=x202;\nIkReal x243=x203;\nIkReal x244=x204;\nIkReal x245=(x237+(((-1.0)*sj28*x240)));\nIkReal x246=(cj27*x245);\nIkReal x247=x207;\nIkReal x248=((((-1.0)*x241))+(((-1.0)*cj28*x240)));\nIkReal x249=(cj27*x247);\nIkReal x250=(((sj27*x245))+((sj30*x235)));\nIkReal x251=(x246+(((-1.0)*sj30*x234)));\nIkReal x252=(((sj27*x247))+((cj30*x235)));\nIkReal x253=(x249+(((-1.0)*cj30*x234)));\nnew_r00=(((r00*((x249+(((-1.0)*cj30*x234))))))+((r10*x252))+((r20*x242)));\nnew_r01=(((r11*x252))+((r01*x253))+((r21*x242)));\nnew_r02=(((r22*x242))+((r12*x252))+((r02*x253)));\nnew_r10=(((r20*x236))+((r00*x243))+((r10*x244)));\nnew_r11=(((r01*x243))+((r11*x244))+((r21*x236)));\nnew_r12=(((r02*x243))+((r12*x244))+((r22*x236)));\nnew_r20=(((r00*x251))+((r10*x250))+((r20*x248)));\nnew_r21=(((r11*x250))+((r01*x251))+((r21*x248)));\nnew_r22=(((r22*x248))+((r12*x250))+((r02*((x246+(((-1.0)*x234*x238)))))));\nj31eval[0]=sj32;\nif( IKabs(j31eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j31array[2], cj31array[2], sj31array[2];\nbool j31valid[2]={false};\n_nj31 = 2;\nCheckValue<IkReal> x255 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x255.valid){\ncontinue;\n}\nIkReal x254=x255.value;\nj31array[0]=((-1.0)*x254);\nsj31array[0]=IKsin(j31array[0]);\ncj31array[0]=IKcos(j31array[0]);\nj31array[1]=((3.14159265358979)+(((-1.0)*x254)));\nsj31array[1]=IKsin(j31array[1]);\ncj31array[1]=IKcos(j31array[1]);\nif( j31array[0] > IKPI )\n{\n    j31array[0]-=IK2PI;\n}\nelse if( j31array[0] < -IKPI )\n{    j31array[0]+=IK2PI;\n}\nj31valid[0] = true;\nif( j31array[1] > IKPI )\n{\n    j31array[1]-=IK2PI;\n}\nelse if( j31array[1] < -IKPI )\n{    j31array[1]+=IK2PI;\n}\nj31valid[1] = true;\nfor(int ij31 = 0; ij31 < 2; ++ij31)\n{\nif( !j31valid[ij31] )\n{\n    continue;\n}\n_ij31[0] = ij31; _ij31[1] = -1;\nfor(int iij31 = ij31+1; iij31 < 2; ++iij31)\n{\nif( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )\n{\n    j31valid[iij31]=false; _ij31[1] = iij31; break; \n}\n}\nj31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];\n{\nIkReal evalcond[1];\nevalcond[0]=(((new_r12*(IKcos(j31))))+(((-1.0)*new_r02*(IKsin(j31)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nIkReal x256=((1.0)*sj31);\nif( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x256)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x256))+((cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x256))))+IKsqr(((((-1.0)*new_r01*x256))+((cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x256))), ((((-1.0)*new_r01*x256))+((cj31*new_r00))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x257=IKsin(j33);\nIkReal x258=IKcos(j33);\nIkReal x259=((1.0)*sj31);\nIkReal x260=((1.0)*x258);\nIkReal x261=(sj31*x257);\nIkReal x262=((1.0)*x257);\nIkReal x263=(cj31*x260);\nevalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x257);\nevalcond[1]=(((cj31*x257))+((sj31*x258))+new_r01);\nevalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x260)));\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*x262))+(((-1.0)*new_r00*x259)));\nevalcond[4]=((((-1.0)*new_r01*x259))+((cj31*new_r11))+(((-1.0)*x260)));\nevalcond[5]=(x261+new_r00+(((-1.0)*x263)));\nevalcond[6]=(x261+new_r11+(((-1.0)*x263)));\nevalcond[7]=((((-1.0)*cj31*x262))+new_r10+(((-1.0)*x258*x259)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j31array[2], cj31array[2], sj31array[2];\nbool j31valid[2]={false};\n_nj31 = 2;\nCheckValue<IkReal> x265 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x265.valid){\ncontinue;\n}\nIkReal x264=x265.value;\nj31array[0]=((-1.0)*x264);\nsj31array[0]=IKsin(j31array[0]);\ncj31array[0]=IKcos(j31array[0]);\nj31array[1]=((3.14159265358979)+(((-1.0)*x264)));\nsj31array[1]=IKsin(j31array[1]);\ncj31array[1]=IKcos(j31array[1]);\nif( j31array[0] > IKPI )\n{\n    j31array[0]-=IK2PI;\n}\nelse if( j31array[0] < -IKPI )\n{    j31array[0]+=IK2PI;\n}\nj31valid[0] = true;\nif( j31array[1] > IKPI )\n{\n    j31array[1]-=IK2PI;\n}\nelse if( j31array[1] < -IKPI )\n{    j31array[1]+=IK2PI;\n}\nj31valid[1] = true;\nfor(int ij31 = 0; ij31 < 2; ++ij31)\n{\nif( !j31valid[ij31] )\n{\n    continue;\n}\n_ij31[0] = ij31; _ij31[1] = -1;\nfor(int iij31 = ij31+1; iij31 < 2; ++iij31)\n{\nif( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )\n{\n    j31valid[iij31]=false; _ij31[1] = iij31; break; \n}\n}\nj31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];\n{\nIkReal evalcond[1];\nevalcond[0]=(((new_r12*(IKcos(j31))))+(((-1.0)*new_r02*(IKsin(j31)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nIkReal x266=((1.0)*sj31);\nif( IKabs(((((-1.0)*new_r00*x266))+((cj31*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x266))+(((-1.0)*cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x266))+((cj31*new_r01))))+IKsqr(((((-1.0)*new_r01*x266))+(((-1.0)*cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((((-1.0)*new_r00*x266))+((cj31*new_r01))), ((((-1.0)*new_r01*x266))+(((-1.0)*cj31*new_r00))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x267=IKsin(j33);\nIkReal x268=IKcos(j33);\nIkReal x269=((1.0)*sj31);\nIkReal x270=((1.0)*x267);\nIkReal x271=(sj31*x268);\nIkReal x272=((1.0)*x268);\nIkReal x273=(cj31*x270);\nevalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x268);\nevalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x270)));\nevalcond[2]=(((sj31*x267))+((cj31*x268))+new_r00);\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x269))+(((-1.0)*x270)));\nevalcond[4]=((((-1.0)*new_r01*x269))+((cj31*new_r11))+(((-1.0)*x272)));\nevalcond[5]=(x271+(((-1.0)*x273))+new_r01);\nevalcond[6]=(x271+(((-1.0)*x273))+new_r10);\nevalcond[7]=((((-1.0)*cj31*x272))+(((-1.0)*x267*x269))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j31, j33]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j31array[1], cj31array[1], sj31array[1];\nbool j31valid[1]={false};\n_nj31 = 1;\nCheckValue<IkReal> x275=IKPowWithIntegerCheck(sj32,-1);\nif(!x275.valid){\ncontinue;\n}\nIkReal x274=x275.value;\nCheckValue<IkReal> x276=IKPowWithIntegerCheck(new_r12,-1);\nif(!x276.valid){\ncontinue;\n}\nif( IKabs((x274*(x276.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x274)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x274*(x276.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32)))))))+IKsqr((new_r02*x274))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj31array[0]=IKatan2((x274*(x276.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32)))))), (new_r02*x274));\nsj31array[0]=IKsin(j31array[0]);\ncj31array[0]=IKcos(j31array[0]);\nif( j31array[0] > IKPI )\n{\n    j31array[0]-=IK2PI;\n}\nelse if( j31array[0] < -IKPI )\n{    j31array[0]+=IK2PI;\n}\nj31valid[0] = true;\nfor(int ij31 = 0; ij31 < 1; ++ij31)\n{\nif( !j31valid[ij31] )\n{\n    continue;\n}\n_ij31[0] = ij31; _ij31[1] = -1;\nfor(int iij31 = ij31+1; iij31 < 1; ++iij31)\n{\nif( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )\n{\n    j31valid[iij31]=false; _ij31[1] = iij31; break; \n}\n}\nj31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];\n{\nIkReal evalcond[8];\nIkReal x277=IKcos(j31);\nIkReal x278=IKsin(j31);\nIkReal x279=((1.0)*sj32);\nIkReal x280=(new_r02*x277);\nIkReal x281=(new_r12*x278);\nIkReal x282=(sj32*x277);\nIkReal x283=(sj32*x278);\nevalcond[0]=((((-1.0)*x277*x279))+new_r02);\nevalcond[1]=((((-1.0)*x278*x279))+new_r12);\nevalcond[2]=((((-1.0)*new_r02*x278))+((new_r12*x277)));\nevalcond[3]=(x281+x280+(((-1.0)*x279)));\nevalcond[4]=(((cj32*new_r20))+((new_r00*x282))+((new_r10*x283)));\nevalcond[5]=(((cj32*new_r21))+((new_r11*x283))+((new_r01*x282)));\nevalcond[6]=((-1.0)+((cj32*new_r22))+((sj32*x281))+((sj32*x280)));\nevalcond[7]=((((-1.0)*new_r22*x279))+((cj32*x281))+((cj32*x280)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j33eval[2];\nIkReal x284=(sj27*sj29);\nIkReal x285=(cj27*sj29);\nIkReal x286=(cj28*sj29);\nIkReal x287=(cj28*cj30);\nIkReal x288=((1.0)*sj30);\nIkReal x289=((1.0)*cj29);\nIkReal x290=(cj29*x288);\nIkReal x291=((1.0)*cj30*sj28);\nIkReal x292=x202;\nIkReal x293=x203;\nIkReal x294=x204;\nIkReal x295=((((-1.0)*sj28*x290))+x287);\nIkReal x296=(cj27*x295);\nIkReal x297=x207;\nIkReal x298=((((-1.0)*x291))+(((-1.0)*cj28*x290)));\nIkReal x299=(cj27*x297);\nIkReal x300=(((sj30*x285))+((sj27*x295)));\nIkReal x301=(x296+(((-1.0)*sj30*x284)));\nIkReal x302=(((cj30*x285))+((sj27*x297)));\nIkReal x303=((((-1.0)*cj30*x284))+x299);\nnew_r00=(((r00*(((((-1.0)*cj30*x284))+x299))))+((r20*x292))+((r10*x302)));\nnew_r01=(((r11*x302))+((r01*x303))+((r21*x292)));\nnew_r02=(((r02*x303))+((r22*x292))+((r12*x302)));\nnew_r10=(((r00*x293))+((r10*x294))+((r20*x286)));\nnew_r11=(((r21*x286))+((r01*x293))+((r11*x294)));\nnew_r12=(((r12*x294))+((r22*x286))+((r02*x293)));\nnew_r20=(((r20*x298))+((r10*x300))+((r00*x301)));\nnew_r21=(((r11*x300))+((r01*x301))+((r21*x298)));\nnew_r22=(((r02*((x296+(((-1.0)*x284*x288))))))+((r22*x298))+((r12*x300)));\nj33eval[0]=sj32;\nj33eval[1]=IKsign(sj32);\nif( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j33eval[2];\nIkReal x304=(sj27*sj29);\nIkReal x305=(cj27*sj29);\nIkReal x306=(cj28*sj29);\nIkReal x307=(cj28*cj30);\nIkReal x308=((1.0)*sj30);\nIkReal x309=((1.0)*cj29);\nIkReal x310=(cj29*x308);\nIkReal x311=((1.0)*cj30*sj28);\nIkReal x312=x202;\nIkReal x313=x203;\nIkReal x314=x204;\nIkReal x315=(x307+(((-1.0)*sj28*x310)));\nIkReal x316=(cj27*x315);\nIkReal x317=x207;\nIkReal x318=((((-1.0)*cj28*x310))+(((-1.0)*x311)));\nIkReal x319=(cj27*x317);\nIkReal x320=(((sj27*x315))+((sj30*x305)));\nIkReal x321=(x316+(((-1.0)*sj30*x304)));\nIkReal x322=(((cj30*x305))+((sj27*x317)));\nIkReal x323=((((-1.0)*cj30*x304))+x319);\nnew_r00=(((r20*x312))+((r00*(((((-1.0)*cj30*x304))+x319))))+((r10*x322)));\nnew_r01=(((r11*x322))+((r01*x323))+((r21*x312)));\nnew_r02=(((r02*x323))+((r12*x322))+((r22*x312)));\nnew_r10=(((r20*x306))+((r00*x313))+((r10*x314)));\nnew_r11=(((r11*x314))+((r21*x306))+((r01*x313)));\nnew_r12=(((r22*x306))+((r02*x313))+((r12*x314)));\nnew_r20=(((r00*x321))+((r20*x318))+((r10*x320)));\nnew_r21=(((r11*x320))+((r01*x321))+((r21*x318)));\nnew_r22=(((r12*x320))+((r02*((x316+(((-1.0)*x304*x308))))))+((r22*x318)));\nj33eval[0]=sj31;\nj33eval[1]=sj32;\nif( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j33eval[3];\nIkReal x324=(sj27*sj29);\nIkReal x325=(cj27*sj29);\nIkReal x326=(cj28*sj29);\nIkReal x327=(cj28*cj30);\nIkReal x328=((1.0)*sj30);\nIkReal x329=((1.0)*cj29);\nIkReal x330=(cj29*x328);\nIkReal x331=((1.0)*cj30*sj28);\nIkReal x332=x202;\nIkReal x333=x203;\nIkReal x334=x204;\nIkReal x335=((((-1.0)*sj28*x330))+x327);\nIkReal x336=(cj27*x335);\nIkReal x337=x207;\nIkReal x338=((((-1.0)*cj28*x330))+(((-1.0)*x331)));\nIkReal x339=(cj27*x337);\nIkReal x340=(((sj30*x325))+((sj27*x335)));\nIkReal x341=((((-1.0)*sj30*x324))+x336);\nIkReal x342=(((sj27*x337))+((cj30*x325)));\nIkReal x343=(x339+(((-1.0)*cj30*x324)));\nnew_r00=(((r00*((x339+(((-1.0)*cj30*x324))))))+((r20*x332))+((r10*x342)));\nnew_r01=(((r01*x343))+((r21*x332))+((r11*x342)));\nnew_r02=(((r22*x332))+((r02*x343))+((r12*x342)));\nnew_r10=(((r00*x333))+((r20*x326))+((r10*x334)));\nnew_r11=(((r01*x333))+((r11*x334))+((r21*x326)));\nnew_r12=(((r12*x334))+((r02*x333))+((r22*x326)));\nnew_r20=(((r00*x341))+((r20*x338))+((r10*x340)));\nnew_r21=(((r01*x341))+((r21*x338))+((r11*x340)));\nnew_r22=(((r22*x338))+((r02*((x336+(((-1.0)*x324*x328))))))+((r12*x340)));\nj33eval[0]=cj31;\nj33eval[1]=cj32;\nj33eval[2]=sj32;\nif( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x344=((((-1.0)*cj32))+new_r22);\nIkReal x345=((((-1.0)*sj32))+new_r12);\nIkReal x346=((1.0)*sj32);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j31)))), 6.28318530717959)));\nevalcond[1]=x344;\nevalcond[2]=x344;\nevalcond[3]=new_r02;\nevalcond[4]=x345;\nevalcond[5]=x345;\nevalcond[6]=(((new_r10*sj32))+((cj32*new_r20)));\nevalcond[7]=(((new_r11*sj32))+((cj32*new_r21)));\nevalcond[8]=((-1.0)+((new_r12*sj32))+((cj32*new_r22)));\nevalcond[9]=(((cj32*new_r12))+(((-1.0)*new_r22*x346)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x347 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x347.valid){\ncontinue;\n}\nCheckValue<IkReal> x348=IKPowWithIntegerCheck(IKsign(new_r12),-1);\nif(!x348.valid){\ncontinue;\n}\nj33array[0]=((-1.5707963267949)+(x347.value)+(((1.5707963267949)*(x348.value))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x349=IKsin(j33);\nIkReal x350=IKcos(j33);\nIkReal x351=((1.0)*new_r12);\nIkReal x352=((1.0)*x350);\nIkReal x353=((1.0)*x349);\nevalcond[0]=(new_r20+((new_r12*x350)));\nevalcond[1]=(((new_r22*x349))+new_r11);\nevalcond[2]=((((-1.0)*x349*x351))+new_r21);\nevalcond[3]=((((-1.0)*new_r22*x352))+new_r10);\nevalcond[4]=((((-1.0)*x353))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*x352))+(((-1.0)*new_r01)));\nevalcond[6]=(x349+((new_r11*new_r22))+(((-1.0)*new_r21*x351)));\nevalcond[7]=((((-1.0)*x352))+((new_r10*new_r22))+(((-1.0)*new_r20*x351)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x354=((((-1.0)*cj32))+new_r22);\nIkReal x355=((1.0)*sj32);\nIkReal x356=((1.0)*new_r12);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j31)))), 6.28318530717959)));\nevalcond[1]=x354;\nevalcond[2]=x354;\nevalcond[3]=new_r02;\nevalcond[4]=(sj32+new_r12);\nevalcond[5]=((((-1.0)*x356))+(((-1.0)*x355)));\nevalcond[6]=(((cj32*new_r20))+(((-1.0)*new_r10*x355)));\nevalcond[7]=((((-1.0)*new_r11*x355))+((cj32*new_r21)));\nevalcond[8]=((-1.0)+(((-1.0)*new_r12*x355))+((cj32*new_r22)));\nevalcond[9]=((((-1.0)*new_r22*x355))+(((-1.0)*cj32*x356)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(new_r00, new_r01);\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x357=IKsin(j33);\nIkReal x358=IKcos(j33);\nIkReal x359=((1.0)*new_r10);\nIkReal x360=((1.0)*new_r11);\nIkReal x361=((1.0)*x358);\nevalcond[0]=(new_r21+((new_r12*x357)));\nevalcond[1]=((((-1.0)*x357))+new_r00);\nevalcond[2]=((((-1.0)*x361))+new_r01);\nevalcond[3]=((((-1.0)*new_r12*x361))+new_r20);\nevalcond[4]=(((new_r22*x357))+(((-1.0)*x360)));\nevalcond[5]=((((-1.0)*x359))+(((-1.0)*new_r22*x361)));\nevalcond[6]=((((-1.0)*new_r22*x360))+x357+((new_r12*new_r21)));\nevalcond[7]=((((-1.0)*new_r22*x359))+(((-1.0)*x361))+((new_r12*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x362=((1.0)*sj31);\nIkReal x363=(((cj31*new_r12))+(((-1.0)*new_r02*x362)));\nIkReal x364=(((cj31*new_r00))+((new_r10*sj31)));\nIkReal x365=(((cj31*new_r01))+((new_r11*sj31)));\nIkReal x366=((-1.0)+((cj31*new_r02))+((new_r12*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*cj31))+new_r02);\nevalcond[3]=((((-1.0)*x362))+new_r12);\nevalcond[4]=x363;\nevalcond[5]=x363;\nevalcond[6]=x366;\nevalcond[7]=x365;\nevalcond[8]=x364;\nevalcond[9]=x364;\nevalcond[10]=x365;\nevalcond[11]=x366;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x367=IKcos(j33);\nIkReal x368=IKsin(j33);\nIkReal x369=((1.0)*new_r12);\nIkReal x370=((1.0)*x368);\nIkReal x371=((1.0)*x367);\nevalcond[0]=(x367+new_r20);\nevalcond[1]=((((-1.0)*x370))+new_r21);\nevalcond[2]=(new_r01+((new_r12*x367)));\nevalcond[3]=(new_r00+((new_r12*x368)));\nevalcond[4]=(new_r11+(((-1.0)*new_r02*x371)));\nevalcond[5]=(new_r10+(((-1.0)*new_r02*x370)));\nevalcond[6]=((((-1.0)*new_r00*x369))+(((-1.0)*x370))+((new_r02*new_r10)));\nevalcond[7]=((((-1.0)*x371))+((new_r02*new_r11))+(((-1.0)*new_r01*x369)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x372=(new_r10*sj31);\nIkReal x373=(cj31*new_r00);\nIkReal x374=(cj31*new_r02);\nIkReal x375=(new_r11*sj31);\nIkReal x376=(new_r12*sj31);\nIkReal x377=(cj31*new_r01);\nIkReal x378=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(cj31+new_r02);\nevalcond[3]=(sj31+new_r12);\nevalcond[4]=x378;\nevalcond[5]=x378;\nevalcond[6]=((1.0)+x376+x374);\nevalcond[7]=(x377+x375);\nevalcond[8]=(x373+x372);\nevalcond[9]=((((-1.0)*x373))+(((-1.0)*x372)));\nevalcond[10]=((((-1.0)*x377))+(((-1.0)*x375)));\nevalcond[11]=((-1.0)+(((-1.0)*x374))+(((-1.0)*x376)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((-1.0)*new_r21), new_r20);\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x379=IKcos(j33);\nIkReal x380=IKsin(j33);\nIkReal x381=((1.0)*new_r02);\nIkReal x382=((1.0)*x379);\nIkReal x383=((1.0)*x380);\nevalcond[0]=(x380+new_r21);\nevalcond[1]=((((-1.0)*x382))+new_r20);\nevalcond[2]=(new_r11+((new_r02*x379)));\nevalcond[3]=(((new_r02*x380))+new_r10);\nevalcond[4]=((((-1.0)*new_r12*x382))+new_r01);\nevalcond[5]=((((-1.0)*new_r12*x383))+new_r00);\nevalcond[6]=((((-1.0)*new_r10*x381))+((new_r00*new_r12))+(((-1.0)*x383)));\nevalcond[7]=((((-1.0)*new_r11*x381))+((new_r01*new_r12))+(((-1.0)*x382)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x384=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));\nIkReal x385=(((cj31*new_r02))+((new_r12*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x384;\nevalcond[7]=x384;\nevalcond[8]=x385;\nevalcond[9]=x385;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nIkReal x386=((1.0)*sj31);\nif( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x386)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj31*new_r00))+(((-1.0)*new_r01*x386)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x386))))+IKsqr((((cj31*new_r00))+(((-1.0)*new_r01*x386))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x386))), (((cj31*new_r00))+(((-1.0)*new_r01*x386))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x387=IKsin(j33);\nIkReal x388=IKcos(j33);\nIkReal x389=((1.0)*sj31);\nIkReal x390=((1.0)*x388);\nIkReal x391=(sj31*x387);\nIkReal x392=((1.0)*x387);\nIkReal x393=(cj31*x390);\nevalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x387);\nevalcond[1]=(((sj31*x388))+((cj31*x387))+new_r01);\nevalcond[2]=((((-1.0)*x390))+((cj31*new_r00))+((new_r10*sj31)));\nevalcond[3]=((((-1.0)*x392))+((cj31*new_r10))+(((-1.0)*new_r00*x389)));\nevalcond[4]=((((-1.0)*x390))+((cj31*new_r11))+(((-1.0)*new_r01*x389)));\nevalcond[5]=((((-1.0)*x393))+x391+new_r00);\nevalcond[6]=((((-1.0)*x393))+x391+new_r11);\nevalcond[7]=((((-1.0)*cj31*x392))+new_r10+(((-1.0)*x388*x389)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x394=(cj31*new_r02);\nIkReal x395=(new_r12*sj31);\nIkReal x396=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x396;\nevalcond[7]=x396;\nevalcond[8]=(x395+x394);\nevalcond[9]=((((-1.0)*x395))+(((-1.0)*x394)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nIkReal x397=((1.0)*sj31);\nif( IKabs((((cj31*new_r01))+(((-1.0)*new_r00*x397)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x397))+(((-1.0)*cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj31*new_r01))+(((-1.0)*new_r00*x397))))+IKsqr(((((-1.0)*new_r01*x397))+(((-1.0)*cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2((((cj31*new_r01))+(((-1.0)*new_r00*x397))), ((((-1.0)*new_r01*x397))+(((-1.0)*cj31*new_r00))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x398=IKsin(j33);\nIkReal x399=IKcos(j33);\nIkReal x400=((1.0)*sj31);\nIkReal x401=((1.0)*x398);\nIkReal x402=(sj31*x399);\nIkReal x403=((1.0)*x399);\nIkReal x404=(cj31*x401);\nevalcond[0]=(((cj31*new_r00))+x399+((new_r10*sj31)));\nevalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x401)));\nevalcond[2]=(((cj31*x399))+((sj31*x398))+new_r00);\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x400))+(((-1.0)*x401)));\nevalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x400))+(((-1.0)*x403)));\nevalcond[5]=(x402+new_r01+(((-1.0)*x404)));\nevalcond[6]=(x402+new_r10+(((-1.0)*x404)));\nevalcond[7]=((((-1.0)*cj31*x403))+(((-1.0)*x398*x400))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x405=((((-1.0)*cj32))+new_r22);\nIkReal x406=((((-1.0)*sj32))+new_r02);\nIkReal x407=((1.0)*sj32);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));\nevalcond[1]=x405;\nevalcond[2]=x405;\nevalcond[3]=x406;\nevalcond[4]=new_r12;\nevalcond[5]=x406;\nevalcond[6]=(((new_r00*sj32))+((cj32*new_r20)));\nevalcond[7]=(((new_r01*sj32))+((cj32*new_r21)));\nevalcond[8]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));\nevalcond[9]=(((cj32*new_r02))+(((-1.0)*new_r22*x407)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(new_r10, new_r11);\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x408=IKcos(j33);\nIkReal x409=IKsin(j33);\nIkReal x410=((1.0)*new_r02);\nIkReal x411=((1.0)*x408);\nevalcond[0]=(new_r20+((new_r02*x408)));\nevalcond[1]=(new_r10+(((-1.0)*x409)));\nevalcond[2]=(new_r11+(((-1.0)*x411)));\nevalcond[3]=(((new_r22*x409))+new_r01);\nevalcond[4]=(new_r21+(((-1.0)*x409*x410)));\nevalcond[5]=(new_r00+(((-1.0)*new_r22*x411)));\nevalcond[6]=(((new_r01*new_r22))+x409+(((-1.0)*new_r21*x410)));\nevalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x410))+(((-1.0)*x411)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x412=((((-1.0)*cj32))+new_r22);\nIkReal x413=((1.0)*sj32);\nIkReal x414=((1.0)*new_r02);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));\nevalcond[1]=x412;\nevalcond[2]=x412;\nevalcond[3]=(sj32+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x414))+(((-1.0)*x413)));\nevalcond[6]=(((cj32*new_r20))+(((-1.0)*new_r00*x413)));\nevalcond[7]=(((cj32*new_r21))+(((-1.0)*new_r01*x413)));\nevalcond[8]=((-1.0)+((cj32*new_r22))+(((-1.0)*new_r02*x413)));\nevalcond[9]=((((-1.0)*cj32*x414))+(((-1.0)*new_r22*x413)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x415 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x415.valid){\ncontinue;\n}\nCheckValue<IkReal> x416=IKPowWithIntegerCheck(IKsign(new_r02),-1);\nif(!x416.valid){\ncontinue;\n}\nj33array[0]=((-1.5707963267949)+(x415.value)+(((1.5707963267949)*(x416.value))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x417=IKsin(j33);\nIkReal x418=IKcos(j33);\nIkReal x419=((1.0)*new_r22);\nIkReal x420=((1.0)*x418);\nevalcond[0]=(new_r21+((new_r02*x417)));\nevalcond[1]=((((-1.0)*new_r02*x420))+new_r20);\nevalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x417)));\nevalcond[3]=((((-1.0)*x420))+(((-1.0)*new_r11)));\nevalcond[4]=(((new_r22*x417))+(((-1.0)*new_r01)));\nevalcond[5]=((((-1.0)*x418*x419))+(((-1.0)*new_r00)));\nevalcond[6]=(x417+((new_r02*new_r21))+(((-1.0)*new_r01*x419)));\nevalcond[7]=((((-1.0)*x420))+((new_r02*new_r20))+(((-1.0)*new_r00*x419)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j33]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x422=IKPowWithIntegerCheck(sj32,-1);\nif(!x422.valid){\ncontinue;\n}\nIkReal x421=x422.value;\nCheckValue<IkReal> x423=IKPowWithIntegerCheck(cj31,-1);\nif(!x423.valid){\ncontinue;\n}\nCheckValue<IkReal> x424=IKPowWithIntegerCheck(cj32,-1);\nif(!x424.valid){\ncontinue;\n}\nif( IKabs((x421*(x423.value)*(x424.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x421)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x421*(x423.value)*(x424.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))))+IKsqr(((-1.0)*new_r20*x421))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2((x421*(x423.value)*(x424.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))), ((-1.0)*new_r20*x421));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[12];\nIkReal x425=IKsin(j33);\nIkReal x426=IKcos(j33);\nIkReal x427=(cj31*cj32);\nIkReal x428=((1.0)*sj31);\nIkReal x429=(new_r11*sj31);\nIkReal x430=(new_r10*sj31);\nIkReal x431=((1.0)*sj32);\nIkReal x432=((1.0)*x426);\nIkReal x433=((1.0)*x425);\nIkReal x434=(sj31*x425);\nevalcond[0]=(new_r20+((sj32*x426)));\nevalcond[1]=((((-1.0)*x425*x431))+new_r21);\nevalcond[2]=(((cj31*new_r01))+x429+((cj32*x425)));\nevalcond[3]=((((-1.0)*x433))+((cj31*new_r10))+(((-1.0)*new_r00*x428)));\nevalcond[4]=((((-1.0)*x432))+((cj31*new_r11))+(((-1.0)*new_r01*x428)));\nevalcond[5]=(((x425*x427))+((sj31*x426))+new_r01);\nevalcond[6]=(((cj31*new_r00))+x430+(((-1.0)*cj32*x432)));\nevalcond[7]=((((-1.0)*x427*x432))+x434+new_r00);\nevalcond[8]=(((cj32*x434))+(((-1.0)*cj31*x432))+new_r11);\nevalcond[9]=((((-1.0)*cj32*x426*x428))+(((-1.0)*cj31*x433))+new_r10);\nevalcond[10]=(x425+((cj32*x429))+((new_r01*x427))+(((-1.0)*new_r21*x431)));\nevalcond[11]=((((-1.0)*x432))+((cj32*x430))+(((-1.0)*new_r20*x431))+((new_r00*x427)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x436=IKPowWithIntegerCheck(sj32,-1);\nif(!x436.valid){\ncontinue;\n}\nIkReal x435=x436.value;\nCheckValue<IkReal> x437=IKPowWithIntegerCheck(sj31,-1);\nif(!x437.valid){\ncontinue;\n}\nif( IKabs((x435*(x437.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x435)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x435*(x437.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))))+IKsqr(((-1.0)*new_r20*x435))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2((x435*(x437.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))), ((-1.0)*new_r20*x435));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[12];\nIkReal x438=IKsin(j33);\nIkReal x439=IKcos(j33);\nIkReal x440=(cj31*cj32);\nIkReal x441=((1.0)*sj31);\nIkReal x442=(new_r11*sj31);\nIkReal x443=(new_r10*sj31);\nIkReal x444=((1.0)*sj32);\nIkReal x445=((1.0)*x439);\nIkReal x446=((1.0)*x438);\nIkReal x447=(sj31*x438);\nevalcond[0]=(((sj32*x439))+new_r20);\nevalcond[1]=((((-1.0)*x438*x444))+new_r21);\nevalcond[2]=(((cj31*new_r01))+((cj32*x438))+x442);\nevalcond[3]=((((-1.0)*x446))+(((-1.0)*new_r00*x441))+((cj31*new_r10)));\nevalcond[4]=((((-1.0)*x445))+((cj31*new_r11))+(((-1.0)*new_r01*x441)));\nevalcond[5]=(((sj31*x439))+((x438*x440))+new_r01);\nevalcond[6]=(((cj31*new_r00))+x443+(((-1.0)*cj32*x445)));\nevalcond[7]=(x447+new_r00+(((-1.0)*x440*x445)));\nevalcond[8]=(((cj32*x447))+(((-1.0)*cj31*x445))+new_r11);\nevalcond[9]=((((-1.0)*cj31*x446))+new_r10+(((-1.0)*cj32*x439*x441)));\nevalcond[10]=(((new_r01*x440))+((cj32*x442))+x438+(((-1.0)*new_r21*x444)));\nevalcond[11]=(((new_r00*x440))+(((-1.0)*x445))+((cj32*x443))+(((-1.0)*new_r20*x444)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x448=IKPowWithIntegerCheck(IKsign(sj32),-1);\nif(!x448.valid){\ncontinue;\n}\nCheckValue<IkReal> x449 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x449.valid){\ncontinue;\n}\nj33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x448.value)))+(x449.value));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[12];\nIkReal x450=IKsin(j33);\nIkReal x451=IKcos(j33);\nIkReal x452=(cj31*cj32);\nIkReal x453=((1.0)*sj31);\nIkReal x454=(new_r11*sj31);\nIkReal x455=(new_r10*sj31);\nIkReal x456=((1.0)*sj32);\nIkReal x457=((1.0)*x451);\nIkReal x458=((1.0)*x450);\nIkReal x459=(sj31*x450);\nevalcond[0]=(((sj32*x451))+new_r20);\nevalcond[1]=((((-1.0)*x450*x456))+new_r21);\nevalcond[2]=(((cj31*new_r01))+x454+((cj32*x450)));\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x453))+(((-1.0)*x458)));\nevalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x453))+(((-1.0)*x457)));\nevalcond[5]=(((x450*x452))+new_r01+((sj31*x451)));\nevalcond[6]=((((-1.0)*cj32*x457))+((cj31*new_r00))+x455);\nevalcond[7]=(x459+(((-1.0)*x452*x457))+new_r00);\nevalcond[8]=(new_r11+((cj32*x459))+(((-1.0)*cj31*x457)));\nevalcond[9]=((((-1.0)*cj32*x451*x453))+new_r10+(((-1.0)*cj31*x458)));\nevalcond[10]=((((-1.0)*new_r21*x456))+((new_r01*x452))+x450+((cj32*x454)));\nevalcond[11]=((((-1.0)*new_r20*x456))+((new_r00*x452))+(((-1.0)*x457))+((cj32*x455)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j31array[1], cj31array[1], sj31array[1];\nbool j31valid[1]={false};\n_nj31 = 1;\nCheckValue<IkReal> x460=IKPowWithIntegerCheck(IKsign(sj32),-1);\nif(!x460.valid){\ncontinue;\n}\nCheckValue<IkReal> x461 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);\nif(!x461.valid){\ncontinue;\n}\nj31array[0]=((-1.5707963267949)+(((1.5707963267949)*(x460.value)))+(x461.value));\nsj31array[0]=IKsin(j31array[0]);\ncj31array[0]=IKcos(j31array[0]);\nif( j31array[0] > IKPI )\n{\n    j31array[0]-=IK2PI;\n}\nelse if( j31array[0] < -IKPI )\n{    j31array[0]+=IK2PI;\n}\nj31valid[0] = true;\nfor(int ij31 = 0; ij31 < 1; ++ij31)\n{\nif( !j31valid[ij31] )\n{\n    continue;\n}\n_ij31[0] = ij31; _ij31[1] = -1;\nfor(int iij31 = ij31+1; iij31 < 1; ++iij31)\n{\nif( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )\n{\n    j31valid[iij31]=false; _ij31[1] = iij31; break; \n}\n}\nj31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];\n{\nIkReal evalcond[8];\nIkReal x462=IKcos(j31);\nIkReal x463=IKsin(j31);\nIkReal x464=((1.0)*sj32);\nIkReal x465=(new_r02*x462);\nIkReal x466=(new_r12*x463);\nIkReal x467=(sj32*x462);\nIkReal x468=(sj32*x463);\nevalcond[0]=((((-1.0)*x462*x464))+new_r02);\nevalcond[1]=((((-1.0)*x463*x464))+new_r12);\nevalcond[2]=(((new_r12*x462))+(((-1.0)*new_r02*x463)));\nevalcond[3]=((((-1.0)*x464))+x466+x465);\nevalcond[4]=(((new_r10*x468))+((new_r00*x467))+((cj32*new_r20)));\nevalcond[5]=(((new_r11*x468))+((new_r01*x467))+((cj32*new_r21)));\nevalcond[6]=((-1.0)+((sj32*x466))+((sj32*x465))+((cj32*new_r22)));\nevalcond[7]=((((-1.0)*new_r22*x464))+((cj32*x465))+((cj32*x466)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j33eval[2];\nIkReal x469=(sj27*sj29);\nIkReal x470=(cj27*sj29);\nIkReal x471=(cj28*sj29);\nIkReal x472=(cj28*cj30);\nIkReal x473=((1.0)*sj30);\nIkReal x474=((1.0)*cj29);\nIkReal x475=(cj29*x473);\nIkReal x476=((1.0)*cj30*sj28);\nIkReal x477=x202;\nIkReal x478=x203;\nIkReal x479=x204;\nIkReal x480=((((-1.0)*sj28*x475))+x472);\nIkReal x481=(cj27*x480);\nIkReal x482=x207;\nIkReal x483=((((-1.0)*cj28*x475))+(((-1.0)*x476)));\nIkReal x484=(cj27*x482);\nIkReal x485=(((sj27*x480))+((sj30*x470)));\nIkReal x486=((((-1.0)*sj30*x469))+x481);\nIkReal x487=(((sj27*x482))+((cj30*x470)));\nIkReal x488=(x484+(((-1.0)*cj30*x469)));\nnew_r00=(((r20*x477))+((r10*x487))+((r00*((x484+(((-1.0)*cj30*x469)))))));\nnew_r01=(((r21*x477))+((r11*x487))+((r01*x488)));\nnew_r02=(((r02*x488))+((r12*x487))+((r22*x477)));\nnew_r10=(((r10*x479))+((r20*x471))+((r00*x478)));\nnew_r11=(((r21*x471))+((r11*x479))+((r01*x478)));\nnew_r12=(((r02*x478))+((r12*x479))+((r22*x471)));\nnew_r20=(((r20*x483))+((r10*x485))+((r00*x486)));\nnew_r21=(((r11*x485))+((r21*x483))+((r01*x486)));\nnew_r22=(((r12*x485))+((r22*x483))+((r02*(((((-1.0)*x469*x473))+x481)))));\nj33eval[0]=sj32;\nj33eval[1]=IKsign(sj32);\nif( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j33eval[2];\nIkReal x489=(sj27*sj29);\nIkReal x490=(cj27*sj29);\nIkReal x491=(cj28*sj29);\nIkReal x492=(cj28*cj30);\nIkReal x493=((1.0)*sj30);\nIkReal x494=((1.0)*cj29);\nIkReal x495=(cj29*x493);\nIkReal x496=((1.0)*cj30*sj28);\nIkReal x497=x202;\nIkReal x498=x203;\nIkReal x499=x204;\nIkReal x500=(x492+(((-1.0)*sj28*x495)));\nIkReal x501=(cj27*x500);\nIkReal x502=x207;\nIkReal x503=((((-1.0)*x496))+(((-1.0)*cj28*x495)));\nIkReal x504=(cj27*x502);\nIkReal x505=(((sj27*x500))+((sj30*x490)));\nIkReal x506=((((-1.0)*sj30*x489))+x501);\nIkReal x507=(((sj27*x502))+((cj30*x490)));\nIkReal x508=((((-1.0)*cj30*x489))+x504);\nnew_r00=(((r10*x507))+((r00*(((((-1.0)*cj30*x489))+x504))))+((r20*x497)));\nnew_r01=(((r01*x508))+((r11*x507))+((r21*x497)));\nnew_r02=(((r22*x497))+((r12*x507))+((r02*x508)));\nnew_r10=(((r10*x499))+((r00*x498))+((r20*x491)));\nnew_r11=(((r11*x499))+((r21*x491))+((r01*x498)));\nnew_r12=(((r02*x498))+((r22*x491))+((r12*x499)));\nnew_r20=(((r20*x503))+((r10*x505))+((r00*x506)));\nnew_r21=(((r21*x503))+((r01*x506))+((r11*x505)));\nnew_r22=(((r02*(((((-1.0)*x489*x493))+x501))))+((r22*x503))+((r12*x505)));\nj33eval[0]=sj31;\nj33eval[1]=sj32;\nif( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j33eval[3];\nIkReal x509=(sj27*sj29);\nIkReal x510=(cj27*sj29);\nIkReal x511=(cj28*sj29);\nIkReal x512=(cj28*cj30);\nIkReal x513=((1.0)*sj30);\nIkReal x514=((1.0)*cj29);\nIkReal x515=(cj29*x513);\nIkReal x516=((1.0)*cj30*sj28);\nIkReal x517=x202;\nIkReal x518=x203;\nIkReal x519=x204;\nIkReal x520=(x512+(((-1.0)*sj28*x515)));\nIkReal x521=(cj27*x520);\nIkReal x522=x207;\nIkReal x523=((((-1.0)*cj28*x515))+(((-1.0)*x516)));\nIkReal x524=(cj27*x522);\nIkReal x525=(((sj27*x520))+((sj30*x510)));\nIkReal x526=(x521+(((-1.0)*sj30*x509)));\nIkReal x527=(((cj30*x510))+((sj27*x522)));\nIkReal x528=(x524+(((-1.0)*cj30*x509)));\nnew_r00=(((r20*x517))+((r10*x527))+((r00*((x524+(((-1.0)*cj30*x509)))))));\nnew_r01=(((r11*x527))+((r21*x517))+((r01*x528)));\nnew_r02=(((r02*x528))+((r12*x527))+((r22*x517)));\nnew_r10=(((r20*x511))+((r10*x519))+((r00*x518)));\nnew_r11=(((r01*x518))+((r11*x519))+((r21*x511)));\nnew_r12=(((r02*x518))+((r22*x511))+((r12*x519)));\nnew_r20=(((r20*x523))+((r10*x525))+((r00*x526)));\nnew_r21=(((r21*x523))+((r11*x525))+((r01*x526)));\nnew_r22=(((r12*x525))+((r22*x523))+((r02*((x521+(((-1.0)*x509*x513)))))));\nj33eval[0]=cj31;\nj33eval[1]=cj32;\nj33eval[2]=sj32;\nif( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[12];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x529=((((-1.0)*cj32))+new_r22);\nIkReal x530=((((-1.0)*sj32))+new_r12);\nIkReal x531=((1.0)*sj32);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j31)))), 6.28318530717959)));\nevalcond[1]=x529;\nevalcond[2]=x529;\nevalcond[3]=new_r02;\nevalcond[4]=x530;\nevalcond[5]=x530;\nevalcond[6]=(((new_r10*sj32))+((cj32*new_r20)));\nevalcond[7]=(((new_r11*sj32))+((cj32*new_r21)));\nevalcond[8]=((-1.0)+((new_r12*sj32))+((cj32*new_r22)));\nevalcond[9]=((((-1.0)*new_r22*x531))+((cj32*new_r12)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x532 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x532.valid){\ncontinue;\n}\nCheckValue<IkReal> x533=IKPowWithIntegerCheck(IKsign(new_r12),-1);\nif(!x533.valid){\ncontinue;\n}\nj33array[0]=((-1.5707963267949)+(x532.value)+(((1.5707963267949)*(x533.value))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x534=IKsin(j33);\nIkReal x535=IKcos(j33);\nIkReal x536=((1.0)*new_r12);\nIkReal x537=((1.0)*x535);\nIkReal x538=((1.0)*x534);\nevalcond[0]=(((new_r12*x535))+new_r20);\nevalcond[1]=(((new_r22*x534))+new_r11);\nevalcond[2]=((((-1.0)*x534*x536))+new_r21);\nevalcond[3]=((((-1.0)*new_r22*x537))+new_r10);\nevalcond[4]=((((-1.0)*x538))+(((-1.0)*new_r00)));\nevalcond[5]=((((-1.0)*x537))+(((-1.0)*new_r01)));\nevalcond[6]=((((-1.0)*new_r21*x536))+x534+((new_r11*new_r22)));\nevalcond[7]=((((-1.0)*x537))+(((-1.0)*new_r20*x536))+((new_r10*new_r22)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x539=((((-1.0)*cj32))+new_r22);\nIkReal x540=((1.0)*sj32);\nIkReal x541=((1.0)*new_r12);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j31)))), 6.28318530717959)));\nevalcond[1]=x539;\nevalcond[2]=x539;\nevalcond[3]=new_r02;\nevalcond[4]=(sj32+new_r12);\nevalcond[5]=((((-1.0)*x541))+(((-1.0)*x540)));\nevalcond[6]=((((-1.0)*new_r10*x540))+((cj32*new_r20)));\nevalcond[7]=((((-1.0)*new_r11*x540))+((cj32*new_r21)));\nevalcond[8]=((-1.0)+(((-1.0)*new_r12*x540))+((cj32*new_r22)));\nevalcond[9]=((((-1.0)*cj32*x541))+(((-1.0)*new_r22*x540)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(new_r00, new_r01);\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x542=IKsin(j33);\nIkReal x543=IKcos(j33);\nIkReal x544=((1.0)*new_r10);\nIkReal x545=((1.0)*new_r11);\nIkReal x546=((1.0)*x543);\nevalcond[0]=(((new_r12*x542))+new_r21);\nevalcond[1]=((((-1.0)*x542))+new_r00);\nevalcond[2]=((((-1.0)*x546))+new_r01);\nevalcond[3]=((((-1.0)*new_r12*x546))+new_r20);\nevalcond[4]=((((-1.0)*x545))+((new_r22*x542)));\nevalcond[5]=((((-1.0)*new_r22*x546))+(((-1.0)*x544)));\nevalcond[6]=((((-1.0)*new_r22*x545))+((new_r12*new_r21))+x542);\nevalcond[7]=((((-1.0)*new_r22*x544))+(((-1.0)*x546))+((new_r12*new_r20)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x547=((1.0)*sj31);\nIkReal x548=(((cj31*new_r12))+(((-1.0)*new_r02*x547)));\nIkReal x549=(((cj31*new_r00))+((new_r10*sj31)));\nIkReal x550=(((cj31*new_r01))+((new_r11*sj31)));\nIkReal x551=((-1.0)+((cj31*new_r02))+((new_r12*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=((((-1.0)*cj31))+new_r02);\nevalcond[3]=((((-1.0)*x547))+new_r12);\nevalcond[4]=x548;\nevalcond[5]=x548;\nevalcond[6]=x551;\nevalcond[7]=x550;\nevalcond[8]=x549;\nevalcond[9]=x549;\nevalcond[10]=x550;\nevalcond[11]=x551;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x552=IKcos(j33);\nIkReal x553=IKsin(j33);\nIkReal x554=((1.0)*new_r12);\nIkReal x555=((1.0)*x553);\nIkReal x556=((1.0)*x552);\nevalcond[0]=(x552+new_r20);\nevalcond[1]=((((-1.0)*x555))+new_r21);\nevalcond[2]=(((new_r12*x552))+new_r01);\nevalcond[3]=(((new_r12*x553))+new_r00);\nevalcond[4]=(new_r11+(((-1.0)*new_r02*x556)));\nevalcond[5]=(new_r10+(((-1.0)*new_r02*x555)));\nevalcond[6]=((((-1.0)*new_r00*x554))+(((-1.0)*x555))+((new_r02*new_r10)));\nevalcond[7]=((((-1.0)*new_r01*x554))+(((-1.0)*x556))+((new_r02*new_r11)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x557=(new_r10*sj31);\nIkReal x558=(cj31*new_r00);\nIkReal x559=(cj31*new_r02);\nIkReal x560=(new_r11*sj31);\nIkReal x561=(new_r12*sj31);\nIkReal x562=(cj31*new_r01);\nIkReal x563=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));\nevalcond[1]=new_r22;\nevalcond[2]=(cj31+new_r02);\nevalcond[3]=(sj31+new_r12);\nevalcond[4]=x563;\nevalcond[5]=x563;\nevalcond[6]=((1.0)+x559+x561);\nevalcond[7]=(x562+x560);\nevalcond[8]=(x558+x557);\nevalcond[9]=((((-1.0)*x557))+(((-1.0)*x558)));\nevalcond[10]=((((-1.0)*x560))+(((-1.0)*x562)));\nevalcond[11]=((-1.0)+(((-1.0)*x559))+(((-1.0)*x561)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((-1.0)*new_r21), new_r20);\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x564=IKcos(j33);\nIkReal x565=IKsin(j33);\nIkReal x566=((1.0)*new_r02);\nIkReal x567=((1.0)*x564);\nIkReal x568=((1.0)*x565);\nevalcond[0]=(x565+new_r21);\nevalcond[1]=(new_r20+(((-1.0)*x567)));\nevalcond[2]=(((new_r02*x564))+new_r11);\nevalcond[3]=(((new_r02*x565))+new_r10);\nevalcond[4]=((((-1.0)*new_r12*x567))+new_r01);\nevalcond[5]=((((-1.0)*new_r12*x568))+new_r00);\nevalcond[6]=(((new_r00*new_r12))+(((-1.0)*new_r10*x566))+(((-1.0)*x568)));\nevalcond[7]=(((new_r01*new_r12))+(((-1.0)*new_r11*x566))+(((-1.0)*x567)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x569=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));\nIkReal x570=(((cj31*new_r02))+((new_r12*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x569;\nevalcond[7]=x569;\nevalcond[8]=x570;\nevalcond[9]=x570;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nIkReal x571=((1.0)*sj31);\nif( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x571)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj31*new_r00))+(((-1.0)*new_r01*x571)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x571))))+IKsqr((((cj31*new_r00))+(((-1.0)*new_r01*x571))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x571))), (((cj31*new_r00))+(((-1.0)*new_r01*x571))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x572=IKsin(j33);\nIkReal x573=IKcos(j33);\nIkReal x574=((1.0)*sj31);\nIkReal x575=((1.0)*x573);\nIkReal x576=(sj31*x572);\nIkReal x577=((1.0)*x572);\nIkReal x578=(cj31*x575);\nevalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x572);\nevalcond[1]=(((cj31*x572))+new_r01+((sj31*x573)));\nevalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x575)));\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*x577))+(((-1.0)*new_r00*x574)));\nevalcond[4]=(((cj31*new_r11))+(((-1.0)*x575))+(((-1.0)*new_r01*x574)));\nevalcond[5]=((((-1.0)*x578))+x576+new_r00);\nevalcond[6]=((((-1.0)*x578))+x576+new_r11);\nevalcond[7]=((((-1.0)*x573*x574))+new_r10+(((-1.0)*cj31*x577)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x579=(cj31*new_r02);\nIkReal x580=(new_r12*sj31);\nIkReal x581=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r20;\nevalcond[3]=new_r02;\nevalcond[4]=new_r12;\nevalcond[5]=new_r21;\nevalcond[6]=x581;\nevalcond[7]=x581;\nevalcond[8]=(x579+x580);\nevalcond[9]=((((-1.0)*x580))+(((-1.0)*x579)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nIkReal x582=((1.0)*sj31);\nif( IKabs((((cj31*new_r01))+(((-1.0)*new_r00*x582)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x582))+(((-1.0)*cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj31*new_r01))+(((-1.0)*new_r00*x582))))+IKsqr(((((-1.0)*new_r01*x582))+(((-1.0)*cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2((((cj31*new_r01))+(((-1.0)*new_r00*x582))), ((((-1.0)*new_r01*x582))+(((-1.0)*cj31*new_r00))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x583=IKsin(j33);\nIkReal x584=IKcos(j33);\nIkReal x585=((1.0)*sj31);\nIkReal x586=((1.0)*x583);\nIkReal x587=(sj31*x584);\nIkReal x588=((1.0)*x584);\nIkReal x589=(cj31*x586);\nevalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x584);\nevalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x586)));\nevalcond[2]=(((cj31*x584))+((sj31*x583))+new_r00);\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*x586))+(((-1.0)*new_r00*x585)));\nevalcond[4]=((((-1.0)*new_r01*x585))+((cj31*new_r11))+(((-1.0)*x588)));\nevalcond[5]=(x587+new_r01+(((-1.0)*x589)));\nevalcond[6]=(x587+new_r10+(((-1.0)*x589)));\nevalcond[7]=((((-1.0)*cj31*x588))+(((-1.0)*x583*x585))+new_r11);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x590=((((-1.0)*cj32))+new_r22);\nIkReal x591=((((-1.0)*sj32))+new_r02);\nIkReal x592=((1.0)*sj32);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));\nevalcond[1]=x590;\nevalcond[2]=x590;\nevalcond[3]=x591;\nevalcond[4]=new_r12;\nevalcond[5]=x591;\nevalcond[6]=(((new_r00*sj32))+((cj32*new_r20)));\nevalcond[7]=(((new_r01*sj32))+((cj32*new_r21)));\nevalcond[8]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));\nevalcond[9]=(((cj32*new_r02))+(((-1.0)*new_r22*x592)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nif( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2(new_r10, new_r11);\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x593=IKcos(j33);\nIkReal x594=IKsin(j33);\nIkReal x595=((1.0)*new_r02);\nIkReal x596=((1.0)*x593);\nevalcond[0]=(((new_r02*x593))+new_r20);\nevalcond[1]=((((-1.0)*x594))+new_r10);\nevalcond[2]=((((-1.0)*x596))+new_r11);\nevalcond[3]=(new_r01+((new_r22*x594)));\nevalcond[4]=((((-1.0)*x594*x595))+new_r21);\nevalcond[5]=((((-1.0)*new_r22*x596))+new_r00);\nevalcond[6]=((((-1.0)*new_r21*x595))+((new_r01*new_r22))+x594);\nevalcond[7]=((((-1.0)*new_r20*x595))+((new_r00*new_r22))+(((-1.0)*x596)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x597=((((-1.0)*cj32))+new_r22);\nIkReal x598=((1.0)*sj32);\nIkReal x599=((1.0)*new_r02);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));\nevalcond[1]=x597;\nevalcond[2]=x597;\nevalcond[3]=(sj32+new_r02);\nevalcond[4]=new_r12;\nevalcond[5]=((((-1.0)*x598))+(((-1.0)*x599)));\nevalcond[6]=((((-1.0)*new_r00*x598))+((cj32*new_r20)));\nevalcond[7]=((((-1.0)*new_r01*x598))+((cj32*new_r21)));\nevalcond[8]=((-1.0)+(((-1.0)*new_r02*x598))+((cj32*new_r22)));\nevalcond[9]=((((-1.0)*cj32*x599))+(((-1.0)*new_r22*x598)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x600 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x600.valid){\ncontinue;\n}\nCheckValue<IkReal> x601=IKPowWithIntegerCheck(IKsign(new_r02),-1);\nif(!x601.valid){\ncontinue;\n}\nj33array[0]=((-1.5707963267949)+(x600.value)+(((1.5707963267949)*(x601.value))));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[8];\nIkReal x602=IKsin(j33);\nIkReal x603=IKcos(j33);\nIkReal x604=((1.0)*new_r22);\nIkReal x605=((1.0)*x603);\nevalcond[0]=(((new_r02*x602))+new_r21);\nevalcond[1]=((((-1.0)*new_r02*x605))+new_r20);\nevalcond[2]=((((-1.0)*x602))+(((-1.0)*new_r10)));\nevalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x605)));\nevalcond[4]=(((new_r22*x602))+(((-1.0)*new_r01)));\nevalcond[5]=((((-1.0)*x603*x604))+(((-1.0)*new_r00)));\nevalcond[6]=(x602+(((-1.0)*new_r01*x604))+((new_r02*new_r21)));\nevalcond[7]=((((-1.0)*x605))+((new_r02*new_r20))+(((-1.0)*new_r00*x604)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j33]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x607=IKPowWithIntegerCheck(sj32,-1);\nif(!x607.valid){\ncontinue;\n}\nIkReal x606=x607.value;\nCheckValue<IkReal> x608=IKPowWithIntegerCheck(cj31,-1);\nif(!x608.valid){\ncontinue;\n}\nCheckValue<IkReal> x609=IKPowWithIntegerCheck(cj32,-1);\nif(!x609.valid){\ncontinue;\n}\nif( IKabs((x606*(x608.value)*(x609.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x606)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x606*(x608.value)*(x609.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))))+IKsqr(((-1.0)*new_r20*x606))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2((x606*(x608.value)*(x609.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))), ((-1.0)*new_r20*x606));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[12];\nIkReal x610=IKsin(j33);\nIkReal x611=IKcos(j33);\nIkReal x612=(cj31*cj32);\nIkReal x613=((1.0)*sj31);\nIkReal x614=(new_r11*sj31);\nIkReal x615=(new_r10*sj31);\nIkReal x616=((1.0)*sj32);\nIkReal x617=((1.0)*x611);\nIkReal x618=((1.0)*x610);\nIkReal x619=(sj31*x610);\nevalcond[0]=(((sj32*x611))+new_r20);\nevalcond[1]=((((-1.0)*x610*x616))+new_r21);\nevalcond[2]=(((cj31*new_r01))+((cj32*x610))+x614);\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*x618))+(((-1.0)*new_r00*x613)));\nevalcond[4]=(((cj31*new_r11))+(((-1.0)*x617))+(((-1.0)*new_r01*x613)));\nevalcond[5]=(((sj31*x611))+new_r01+((x610*x612)));\nevalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x617))+x615);\nevalcond[7]=((((-1.0)*x612*x617))+x619+new_r00);\nevalcond[8]=(((cj32*x619))+new_r11+(((-1.0)*cj31*x617)));\nevalcond[9]=((((-1.0)*cj32*x611*x613))+new_r10+(((-1.0)*cj31*x618)));\nevalcond[10]=((((-1.0)*new_r21*x616))+((cj32*x614))+x610+((new_r01*x612)));\nevalcond[11]=(((cj32*x615))+(((-1.0)*x617))+(((-1.0)*new_r20*x616))+((new_r00*x612)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x621=IKPowWithIntegerCheck(sj32,-1);\nif(!x621.valid){\ncontinue;\n}\nIkReal x620=x621.value;\nCheckValue<IkReal> x622=IKPowWithIntegerCheck(sj31,-1);\nif(!x622.valid){\ncontinue;\n}\nif( IKabs((x620*(x622.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x620)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x620*(x622.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))))+IKsqr(((-1.0)*new_r20*x620))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj33array[0]=IKatan2((x620*(x622.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))), ((-1.0)*new_r20*x620));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[12];\nIkReal x623=IKsin(j33);\nIkReal x624=IKcos(j33);\nIkReal x625=(cj31*cj32);\nIkReal x626=((1.0)*sj31);\nIkReal x627=(new_r11*sj31);\nIkReal x628=(new_r10*sj31);\nIkReal x629=((1.0)*sj32);\nIkReal x630=((1.0)*x624);\nIkReal x631=((1.0)*x623);\nIkReal x632=(sj31*x623);\nevalcond[0]=(((sj32*x624))+new_r20);\nevalcond[1]=((((-1.0)*x623*x629))+new_r21);\nevalcond[2]=(((cj31*new_r01))+x627+((cj32*x623)));\nevalcond[3]=((((-1.0)*new_r00*x626))+((cj31*new_r10))+(((-1.0)*x631)));\nevalcond[4]=((((-1.0)*new_r01*x626))+((cj31*new_r11))+(((-1.0)*x630)));\nevalcond[5]=(((sj31*x624))+new_r01+((x623*x625)));\nevalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x630))+x628);\nevalcond[7]=(x632+(((-1.0)*x625*x630))+new_r00);\nevalcond[8]=((((-1.0)*cj31*x630))+new_r11+((cj32*x632)));\nevalcond[9]=((((-1.0)*cj32*x624*x626))+(((-1.0)*cj31*x631))+new_r10);\nevalcond[10]=(((new_r01*x625))+(((-1.0)*new_r21*x629))+x623+((cj32*x627)));\nevalcond[11]=((((-1.0)*x630))+((new_r00*x625))+(((-1.0)*new_r20*x629))+((cj32*x628)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j33array[1], cj33array[1], sj33array[1];\nbool j33valid[1]={false};\n_nj33 = 1;\nCheckValue<IkReal> x633=IKPowWithIntegerCheck(IKsign(sj32),-1);\nif(!x633.valid){\ncontinue;\n}\nCheckValue<IkReal> x634 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);\nif(!x634.valid){\ncontinue;\n}\nj33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x633.value)))+(x634.value));\nsj33array[0]=IKsin(j33array[0]);\ncj33array[0]=IKcos(j33array[0]);\nif( j33array[0] > IKPI )\n{\n    j33array[0]-=IK2PI;\n}\nelse if( j33array[0] < -IKPI )\n{    j33array[0]+=IK2PI;\n}\nj33valid[0] = true;\nfor(int ij33 = 0; ij33 < 1; ++ij33)\n{\nif( !j33valid[ij33] )\n{\n    continue;\n}\n_ij33[0] = ij33; _ij33[1] = -1;\nfor(int iij33 = ij33+1; iij33 < 1; ++iij33)\n{\nif( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )\n{\n    j33valid[iij33]=false; _ij33[1] = iij33; break; \n}\n}\nj33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];\n{\nIkReal evalcond[12];\nIkReal x635=IKsin(j33);\nIkReal x636=IKcos(j33);\nIkReal x637=(cj31*cj32);\nIkReal x638=((1.0)*sj31);\nIkReal x639=(new_r11*sj31);\nIkReal x640=(new_r10*sj31);\nIkReal x641=((1.0)*sj32);\nIkReal x642=((1.0)*x636);\nIkReal x643=((1.0)*x635);\nIkReal x644=(sj31*x635);\nevalcond[0]=(((sj32*x636))+new_r20);\nevalcond[1]=((((-1.0)*x635*x641))+new_r21);\nevalcond[2]=(((cj31*new_r01))+x639+((cj32*x635)));\nevalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x638))+(((-1.0)*x643)));\nevalcond[4]=((((-1.0)*new_r01*x638))+((cj31*new_r11))+(((-1.0)*x642)));\nevalcond[5]=(((x635*x637))+((sj31*x636))+new_r01);\nevalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x642))+x640);\nevalcond[7]=(x644+(((-1.0)*x637*x642))+new_r00);\nevalcond[8]=(((cj32*x644))+new_r11+(((-1.0)*cj31*x642)));\nevalcond[9]=(new_r10+(((-1.0)*cj32*x636*x638))+(((-1.0)*cj31*x643)));\nevalcond[10]=(((new_r01*x637))+(((-1.0)*new_r21*x641))+x635+((cj32*x639)));\nevalcond[11]=(((cj32*x640))+((new_r00*x637))+(((-1.0)*x642))+(((-1.0)*new_r20*x641)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j27;\nvinfos[0].indices[0] = _ij27[0];\nvinfos[0].indices[1] = _ij27[1];\nvinfos[0].maxsolutions = _nj27;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j28;\nvinfos[1].indices[0] = _ij28[0];\nvinfos[1].indices[1] = _ij28[1];\nvinfos[1].maxsolutions = _nj28;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j29;\nvinfos[2].indices[0] = _ij29[0];\nvinfos[2].indices[1] = _ij29[1];\nvinfos[2].maxsolutions = _nj29;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j30;\nvinfos[3].indices[0] = _ij30[0];\nvinfos[3].indices[1] = _ij30[1];\nvinfos[3].maxsolutions = _nj30;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j31;\nvinfos[4].indices[0] = _ij31[0];\nvinfos[4].indices[1] = _ij31[1];\nvinfos[4].maxsolutions = _nj31;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j32;\nvinfos[5].indices[0] = _ij32[0];\nvinfos[5].indices[1] = _ij32[1];\nvinfos[5].maxsolutions = _nj32;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j33;\nvinfos[6].indices[0] = _ij33[0];\nvinfos[6].indices[1] = _ij33[1];\nvinfos[6].maxsolutions = _nj33;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\n}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[3];\n    const int maxsteps = 110;\n    for(int i = 0; i < 3; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[3];\n    IkReal err[3];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 3; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 3; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 3; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 3; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[3] = {false};\n    for(int i = 0; i < 3; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 3; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {\n    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];\n    if( det < 0 ) {\n        numroots=0;\n    }\n    else if( det == 0 ) {\n        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];\n        numroots = 1;\n    }\n    else {\n        det = IKsqrt(det);\n        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);\n        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);\n        numroots = 2;\n    }\n}\nstatic inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[5];\n    const int maxsteps = 110;\n    for(int i = 0; i < 5; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[5];\n    IkReal err[5];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 5; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 5; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 5; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 5; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[5] = {false};\n    for(int i = 0; i < 5; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 5; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[4];\n    const int maxsteps = 110;\n    for(int i = 0; i < 4; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[4];\n    IkReal err[4];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 4; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 4; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 4; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 4; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[4] = {false};\n    for(int i = 0; i < 4; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 4; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[7];\n    const int maxsteps = 110;\n    for(int i = 0; i < 7; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[7];\n    IkReal err[7];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 7; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 7; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 7; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 7; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[7] = {false};\n    for(int i = 0; i < 7; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 7; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[6];\n    const int maxsteps = 110;\n    for(int i = 0; i < 6; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[6];\n    IkReal err[6];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 6; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 6; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 6; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 6; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[6] = {false};\n    for(int i = 0; i < 6; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 6; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[8];\n    const int maxsteps = 110;\n    for(int i = 0; i < 8; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[8];\n    IkReal err[8];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 8; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 8; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 8; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 8; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[8] = {false};\n    for(int i = 0; i < 8; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 8; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\n};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"f720334422c04aa0c3fc731126ce5f95\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\nchar* ComputeFkWrapper(const IkReal* j) {\n    IkReal eetrans[3] = {0};\n    IkReal eerot[9] = {0};\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n\nstd::vector<IkReal> TrueComputeIk(int argc, char** argv)\n{\n    std::vector<IkReal> solvalues(GetNumJoints());\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return solvalues;\n}\n"]}