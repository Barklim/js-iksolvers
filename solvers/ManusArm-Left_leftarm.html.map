{"version":3,"file":"./solvers/ManusArm-Left_leftarm.html","sources":["./solvers/ManusArm-Left_leftarm.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAIA;;;;;;;;;;;;;;;AAkrHA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAx3HA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-05-22 07:14:04.317813\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42;\nx0=IKsin(j[0]);\nx1=IKcos(j[0]);\nx2=IKcos(j[3]);\nx3=IKsin(j[3]);\nx4=IKcos(j[1]);\nx5=IKcos(j[2]);\nx6=IKsin(j[1]);\nx7=IKsin(j[2]);\nx8=IKsin(j[4]);\nx9=IKcos(j[4]);\nx10=IKsin(j[5]);\nx11=IKcos(j[5]);\nx12=((0.331)*x5);\nx13=((1.0)*x9);\nx14=((1.0)*x7);\nx15=((1.0)*x0);\nx16=((1.0)*x8);\nx17=((1.0)*x5);\nx18=(x1*x3);\nx19=(x0*x4);\nx20=(x1*x4);\nx21=(x5*x6);\nx22=(x1*x6);\nx23=(x4*x7);\nx24=(x17*x4);\nx25=((0.331)*x6*x7);\nx26=(x0*x14*x6);\nx27=(x17*x20);\nx28=(x21+x23);\nx29=((((-1.0)*x24))+((x6*x7)));\nx30=((((-1.0)*x14*x6))+x24);\nx31=(x2*x29);\nx32=(((x19*x5))+(((-1.0)*x26)));\nx33=(((x22*x7))+(((-1.0)*x27)));\nx34=(x3*x30*x9);\nx35=((((-1.0)*x15*x21))+(((-1.0)*x14*x19)));\nx36=(((x14*x20))+((x17*x22)));\nx37=(x32*x8);\nx38=(x33*x8);\nx39=(x2*x35);\nx40=(((x1*x2))+((x3*x35)));\nx41=(((x0*x2))+((x3*x36)));\nx42=(((x2*x36))+(((-1.0)*x15*x3)));\neerot[0]=(((x11*((x37+((x40*x9))))))+((x10*(((((-1.0)*x18))+x39)))));\neerot[1]=(((x9*((x26+(((-1.0)*x15*x4*x5))))))+((x40*x8)));\neerot[2]=(((x11*(((((-1.0)*x18))+x39))))+((x10*(((((-1.0)*x16*x32))+(((-1.0)*x13*x40)))))));\neetrans[0]=((0.045416)+(((-0.10015)*x1))+((x0*x25))+(((-1.0)*x12*x19))+(((-0.405)*x19)));\neerot[3]=(((x10*x31))+((x11*(((((-1.0)*x16*x28))+(((-1.0)*x13*x3*x30)))))));\neerot[4]=(((x29*x3*x8))+((x28*x9)));\neerot[5]=(((x11*x31))+((x10*((x34+((x28*x8)))))));\neetrans[1]=((0.302408)+(((0.331)*x23))+(((0.405)*x6))+((x12*x6)));\neerot[6]=(((x11*((((x41*x9))+x38))))+((x10*x42)));\neerot[7]=(((x41*x8))+((x9*(((((-1.0)*x14*x22))+x27)))));\neerot[8]=(((x11*x42))+((x10*(((((-1.0)*x16*x33))+(((-1.0)*x13*x41)))))));\neetrans[2]=((0.467052)+(((-0.10015)*x0))+(((-0.331)*x22*x7))+(((0.405)*x20))+((x12*x20)));\n}\n\nIKFAST_API int GetNumFreeParameters() { return 0; }\nIKFAST_API int* GetFreeParameters() { return NULL; }\nIKFAST_API int GetNumJoints() { return 6; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=r00;\nnew_r01=r02;\nnew_r02=((-1.0)*r01);\nnew_px=((-0.045416)+px);\nnew_r10=r20;\nnew_r11=r22;\nnew_r12=((-1.0)*r21);\nnew_py=((-0.467052)+pz);\nnew_r20=((-1.0)*r10);\nnew_r21=((-1.0)*r12);\nnew_r22=r11;\nnew_pz=((0.302408)+(((-1.0)*py)));\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x43=((1.0)*px);\nIkReal x44=((1.0)*pz);\nIkReal x45=((1.0)*py);\npp=((px*px)+(py*py)+(pz*pz));\nnpx=(((px*r00))+((py*r10))+((pz*r20)));\nnpy=(((px*r01))+((py*r11))+((pz*r21)));\nnpz=(((px*r02))+((py*r12))+((pz*r22)));\nrxp0_0=((((-1.0)*r20*x45))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x44)));\nrxp0_2=((((-1.0)*r10*x43))+((py*r00)));\nrxp1_0=((((-1.0)*r21*x45))+((pz*r11)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x44)));\nrxp1_2=((((-1.0)*r11*x43))+((py*r01)));\nrxp2_0=((((-1.0)*r22*x45))+((pz*r12)));\nrxp2_1=((((-1.0)*r02*x44))+((px*r22)));\nrxp2_2=((((-1.0)*r12*x43))+((py*r02)));\n{\nIkReal j2array[2], cj2array[2], sj2array[2];\nbool j2valid[2]={false};\n_nj2 = 2;\ncj2array[0]=((-1.05783455484689)+(((3.72981239043676)*pp)));\nif( cj2array[0] >= -1-IKFAST_SINCOS_THRESH && cj2array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j2valid[0] = j2valid[1] = true;\n    j2array[0] = IKacos(cj2array[0]);\n    sj2array[0] = IKsin(j2array[0]);\n    cj2array[1] = cj2array[0];\n    j2array[1] = -j2array[0];\n    sj2array[1] = -sj2array[0];\n}\nelse if( isnan(cj2array[0]) )\n{\n    // probably any value will work\n    j2valid[0] = true;\n    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;\n}\nfor(int ij2 = 0; ij2 < 2; ++ij2)\n{\nif( !j2valid[ij2] )\n{\n    continue;\n}\n_ij2[0] = ij2; _ij2[1] = -1;\nfor(int iij2 = ij2+1; iij2 < 2; ++iij2)\n{\nif( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )\n{\n    j2valid[iij2]=false; _ij2[1] = iij2; break; \n}\n}\nj2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];\n\n{\nIkReal j0eval[2];\nj0eval[0]=((px*px)+(py*py));\nj0eval[1]=((IKabs(px))+(IKabs(py)));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[2];\nj1eval[0]=((1.49711119832787)+(sj2*sj2)+(cj2*cj2)+(((2.44712990936556)*cj2)));\nj1eval[1]=((((3.02114803625378)*(IKabs(((0.405)+(((0.331)*cj2)))))))+(IKabs(sj2)));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0, j1]\n\n} else\n{\n{\nIkReal j1array[2], cj1array[2], sj1array[2];\nbool j1valid[2]={false};\n_nj1 = 2;\nIkReal x46=((0.405)+(((0.331)*cj2)));\nCheckValue<IkReal> x49 = IKatan2WithCheck(IkReal(((0.331)*sj2)),x46,IKFAST_ATAN2_MAGTHRESH);\nif(!x49.valid){\ncontinue;\n}\nIkReal x47=((1.0)*(x49.value));\nif((((x46*x46)+(((0.109561)*(sj2*sj2))))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x50=IKPowWithIntegerCheck(IKabs(IKsqrt(((x46*x46)+(((0.109561)*(sj2*sj2)))))),-1);\nif(!x50.valid){\ncontinue;\n}\nif( ((pz*(x50.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x50.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x48=IKasin((pz*(x50.value)));\nj1array[0]=((((-1.0)*x48))+(((-1.0)*x47)));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nj1array[1]=((3.14159265358979)+(((-1.0)*x47))+x48);\nsj1array[1]=IKsin(j1array[1]);\ncj1array[1]=IKcos(j1array[1]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nif( j1array[1] > IKPI )\n{\n    j1array[1]-=IK2PI;\n}\nelse if( j1array[1] < -IKPI )\n{    j1array[1]+=IK2PI;\n}\nj1valid[1] = true;\nfor(int ij1 = 0; ij1 < 2; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 2; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n\n{\nIkReal j0eval[3];\nIkReal x51=pz*pz;\nIkReal x52=((6620.0)*sj2);\nIkReal x53=(pp*sj1);\nIkReal x54=((2003.0)*sj1);\nIkReal x55=(sj1*x51);\nIkReal x56=((20000.0)*cj1*pz);\nj0eval[0]=(x53+(((-1.0)*x55)));\nj0eval[1]=((IKabs((((px*x56))+((px*x52))+(((-1.0)*py*x54)))))+(IKabs(((((-1.0)*px*x54))+(((-1.0)*py*x56))+(((-1.0)*py*x52))))));\nj0eval[2]=IKsign(((((20000.0)*x53))+(((-20000.0)*x55))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nIkReal x57=pz*pz;\nIkReal x58=(cj1*pp);\nIkReal x59=((2003.0)*cj1);\nIkReal x60=((6620.0)*cj2);\nIkReal x61=((20000.0)*pz*sj1);\nIkReal x62=(cj1*x57);\nj0eval[0]=(x58+(((-1.0)*x62)));\nj0eval[1]=((IKabs(((((-1.0)*px*x59))+(((8100.0)*py))+((py*x61))+((py*x60)))))+(IKabs(((((-1.0)*px*x61))+(((-1.0)*px*x60))+(((-8100.0)*px))+(((-1.0)*py*x59))))));\nj0eval[2]=IKsign(((((20000.0)*x58))+(((-20000.0)*x62))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nIkReal x63=pz*pz;\nIkReal x64=((2000000.0)*pp);\nIkReal x65=((162243.0)*cj1);\nIkReal x66=(cj1*pp);\nIkReal x67=((1620000.0)*pz*sj1);\nIkReal x68=(cj1*x63);\nj0eval[0]=(x66+(((-1.0)*x68)));\nj0eval[1]=((IKabs(((((-88867.955)*px))+(((-1.0)*px*x67))+(((-1.0)*px*x64))+(((-1.0)*py*x65)))))+(IKabs(((((-1.0)*px*x65))+((py*x67))+((py*x64))+(((88867.955)*py))))));\nj0eval[2]=IKsign(((((1620000.0)*x66))+(((-1620000.0)*x68))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[5];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x69=((1.0)*pp);\nIkReal x70=((0.405)+(((0.331)*cj2))+pz);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));\nevalcond[1]=((0.2836160225)+(((-1.0)*x69))+(((0.26811)*cj2)));\nevalcond[2]=x70;\nevalcond[3]=x70;\nevalcond[4]=((-0.0444339775)+(((-0.81)*pz))+(((-1.0)*x69)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=1.0;\ncj1=0;\nj1=1.5707963267949;\nIkReal x71=pz*pz;\nIkReal x72=((6620.0)*sj2);\nj0eval[0]=(pp+(((-1.0)*x71)));\nj0eval[1]=IKsign(((((-20000.0)*x71))+(((20000.0)*pp))));\nj0eval[2]=((IKabs(((((-1.0)*py*x72))+(((-2003.0)*px)))))+(IKabs((((px*x72))+(((-2003.0)*py))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x73=((6620.0)*sj2);\nCheckValue<IkReal> x74 = IKatan2WithCheck(IkReal((((px*x73))+(((-2003.0)*py)))),((((-1.0)*py*x73))+(((-2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x74.valid){\ncontinue;\n}\nCheckValue<IkReal> x75=IKPowWithIntegerCheck(IKsign(((((-20000.0)*(pz*pz)))+(((20000.0)*pp)))),-1);\nif(!x75.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x74.value)+(((1.5707963267949)*(x75.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x76=IKcos(j0);\nIkReal x77=IKsin(j0);\nevalcond[0]=((0.10015)+((py*x77))+((px*x76)));\nevalcond[1]=(((py*x76))+(((-1.0)*px*x77))+(((0.331)*sj2)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x351=((0.331)*cj2);\nIkReal x352=((1.0)*pp);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));\nevalcond[1]=((0.2836160225)+(((-1.0)*x352))+(((0.26811)*cj2)));\nevalcond[2]=((-0.405)+(((-1.0)*x351))+pz);\nevalcond[3]=((0.405)+x351+(((-1.0)*pz)));\nevalcond[4]=((-0.0444339775)+(((-1.0)*x352))+(((0.81)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=-1.0;\ncj1=0;\nj1=-1.5707963267949;\nIkReal x353=pz*pz;\nIkReal x354=((6620.0)*sj2);\nj0eval[0]=(x353+(((-1.0)*pp)));\nj0eval[1]=IKsign(((((-20000.0)*pp))+(((20000.0)*x353))));\nj0eval[2]=((IKabs((((px*x354))+(((2003.0)*py)))))+(IKabs(((((-1.0)*py*x354))+(((2003.0)*px))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x355=((6620.0)*sj2);\nCheckValue<IkReal> x356 = IKatan2WithCheck(IkReal((((px*x355))+(((2003.0)*py)))),((((-1.0)*py*x355))+(((2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x356.valid){\ncontinue;\n}\nCheckValue<IkReal> x357=IKPowWithIntegerCheck(IKsign(((((-20000.0)*pp))+(((20000.0)*(pz*pz))))),-1);\nif(!x357.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x356.value)+(((1.5707963267949)*(x357.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[2];\nIkReal x358=IKsin(j0);\nIkReal x359=IKcos(j0);\nevalcond[0]=((0.10015)+((px*x359))+((py*x358)));\nevalcond[1]=(((px*x358))+(((-1.0)*py*x359))+(((0.331)*sj2)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x360=(pz+(((0.331)*sj2)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));\nevalcond[1]=((0.2836160225)+(((-1.0)*pp))+(((0.26811)*cj2)));\nevalcond[2]=x360;\nevalcond[3]=x360;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nIkReal x361=pz*pz;\nIkReal x362=((24691.3580246914)*pp);\nj0eval[0]=(x361+(((-1.0)*pp)));\nj0eval[1]=IKsign(((((-20000.0)*pp))+(((20000.0)*x361))));\nj0eval[2]=((IKabs(((((-1097.13524691358)*py))+(((-1.0)*py*x362))+(((2003.0)*px)))))+(IKabs(((((1097.13524691358)*px))+((px*x362))+(((2003.0)*py))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=1.0;\nj1=0;\nIkReal x363=pz*pz;\nIkReal x364=((2000000.0)*pp);\nj0eval[0]=((((-1.0)*x363))+pp);\nj0eval[1]=IKsign(((((-1620000.0)*x363))+(((1620000.0)*pp))));\nj0eval[2]=((IKabs(((((-88867.955)*px))+(((-162243.0)*py))+(((-1.0)*px*x364)))))+(IKabs((((py*x364))+(((-162243.0)*px))+(((88867.955)*py))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x365=((2000000.0)*pp);\nCheckValue<IkReal> x366=IKPowWithIntegerCheck(IKsign(((((-1620000.0)*(pz*pz)))+(((1620000.0)*pp)))),-1);\nif(!x366.valid){\ncontinue;\n}\nCheckValue<IkReal> x367 = IKatan2WithCheck(IkReal(((((-88867.955)*px))+(((-162243.0)*py))+(((-1.0)*px*x365)))),(((py*x365))+(((-162243.0)*px))+(((88867.955)*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x367.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x366.value)))+(x367.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x368=IKsin(j0);\nIkReal x369=IKcos(j0);\nIkReal x370=(px*x368);\nIkReal x371=(py*x369);\nevalcond[0]=((0.10015)+((py*x368))+((px*x369)));\nevalcond[1]=((0.054856762345679)+(((-1.0)*x371))+x370+(((1.23456790123457)*pp)));\nevalcond[2]=((-0.0444339775)+(((-0.81)*x370))+(((-1.0)*pp))+(((0.81)*x371)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x372=((24691.3580246914)*pp);\nCheckValue<IkReal> x373 = IKatan2WithCheck(IkReal(((((1097.13524691358)*px))+((px*x372))+(((2003.0)*py)))),((((-1097.13524691358)*py))+(((-1.0)*py*x372))+(((2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x373.valid){\ncontinue;\n}\nCheckValue<IkReal> x374=IKPowWithIntegerCheck(IKsign(((((-20000.0)*pp))+(((20000.0)*(pz*pz))))),-1);\nif(!x374.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x373.value)+(((1.5707963267949)*(x374.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x375=IKsin(j0);\nIkReal x376=IKcos(j0);\nIkReal x377=(px*x375);\nIkReal x378=(py*x376);\nevalcond[0]=((0.10015)+((px*x376))+((py*x375)));\nevalcond[1]=((0.054856762345679)+(((-1.0)*x378))+x377+(((1.23456790123457)*pp)));\nevalcond[2]=((-0.0444339775)+(((-0.81)*x377))+(((-1.0)*pp))+(((0.81)*x378)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x379=((0.331)*sj2);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));\nevalcond[1]=((0.2836160225)+(((-1.0)*pp))+(((0.26811)*cj2)));\nevalcond[2]=((((-1.0)*x379))+pz);\nevalcond[3]=(x379+(((-1.0)*pz)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nIkReal x380=pz*pz;\nIkReal x381=((24691.3580246914)*pp);\nj0eval[0]=((((-1.0)*x380))+pp);\nj0eval[1]=IKsign(((((-20000.0)*x380))+(((20000.0)*pp))));\nj0eval[2]=((IKabs(((((-1097.13524691358)*py))+(((-1.0)*py*x381))+(((-2003.0)*px)))))+(IKabs((((px*x381))+(((1097.13524691358)*px))+(((-2003.0)*py))))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j0eval[3];\nsj1=0;\ncj1=-1.0;\nj1=3.14159265358979;\nIkReal x382=pz*pz;\nIkReal x383=((2000000.0)*pp);\nj0eval[0]=(x382+(((-1.0)*pp)));\nj0eval[1]=((IKabs(((((162243.0)*px))+((py*x383))+(((88867.955)*py)))))+(IKabs(((((-88867.955)*px))+(((162243.0)*py))+(((-1.0)*px*x383))))));\nj0eval[2]=IKsign(((((-1620000.0)*pp))+(((1620000.0)*x382))));\nif( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j0]\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x384=((2000000.0)*pp);\nCheckValue<IkReal> x385=IKPowWithIntegerCheck(IKsign(((((1620000.0)*(pz*pz)))+(((-1620000.0)*pp)))),-1);\nif(!x385.valid){\ncontinue;\n}\nCheckValue<IkReal> x386 = IKatan2WithCheck(IkReal(((((-88867.955)*px))+(((162243.0)*py))+(((-1.0)*px*x384)))),((((162243.0)*px))+((py*x384))+(((88867.955)*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x386.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x385.value)))+(x386.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x387=IKcos(j0);\nIkReal x388=IKsin(j0);\nIkReal x389=(px*x388);\nIkReal x390=(py*x387);\nevalcond[0]=((0.10015)+((px*x387))+((py*x388)));\nevalcond[1]=((0.054856762345679)+x390+(((-1.0)*x389))+(((1.23456790123457)*pp)));\nevalcond[2]=((-0.0444339775)+(((-0.81)*x390))+(((0.81)*x389))+(((-1.0)*pp)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x391=((24691.3580246914)*pp);\nCheckValue<IkReal> x392=IKPowWithIntegerCheck(IKsign(((((-20000.0)*(pz*pz)))+(((20000.0)*pp)))),-1);\nif(!x392.valid){\ncontinue;\n}\nCheckValue<IkReal> x393 = IKatan2WithCheck(IkReal(((((1097.13524691358)*px))+((px*x391))+(((-2003.0)*py)))),((((-1097.13524691358)*py))+(((-1.0)*py*x391))+(((-2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);\nif(!x393.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x392.value)))+(x393.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[3];\nIkReal x394=IKcos(j0);\nIkReal x395=IKsin(j0);\nIkReal x396=(px*x395);\nIkReal x397=(py*x394);\nevalcond[0]=((0.10015)+((py*x395))+((px*x394)));\nevalcond[1]=((0.054856762345679)+(((-1.0)*x396))+x397+(((1.23456790123457)*pp)));\nevalcond[2]=((-0.0444339775)+(((-0.81)*x397))+(((-1.0)*pp))+(((0.81)*x396)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j0]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x398=((2000000.0)*pp);\nIkReal x399=((1620000.0)*cj1);\nIkReal x400=((162243.0)*cj1);\nIkReal x401=((1620000.0)*pz*sj1);\nCheckValue<IkReal> x402 = IKatan2WithCheck(IkReal(((((-88867.955)*px))+(((-1.0)*px*x401))+(((-1.0)*px*x398))+(((-1.0)*py*x400)))),(((py*x401))+(((-1.0)*px*x400))+((py*x398))+(((88867.955)*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x402.valid){\ncontinue;\n}\nCheckValue<IkReal> x403=IKPowWithIntegerCheck(IKsign(((((-1.0)*x399*(pz*pz)))+((pp*x399)))),-1);\nif(!x403.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x402.value)+(((1.5707963267949)*(x403.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x404=IKcos(j0);\nIkReal x405=IKsin(j0);\nIkReal x406=((0.81)*cj1);\nIkReal x407=((0.331)*sj2);\nIkReal x408=(pz*sj1);\nIkReal x409=((0.331)*cj2);\nIkReal x410=(px*x405);\nIkReal x411=(py*x404);\nIkReal x412=((1.0)*x411);\nevalcond[0]=((0.10015)+((py*x405))+((px*x404)));\nevalcond[1]=((((-1.0)*sj1*x410))+((sj1*x411))+((cj1*pz))+x407);\nevalcond[2]=((0.405)+(((-1.0)*cj1*x412))+x409+x408+((cj1*x410)));\nevalcond[3]=((-0.0444339775)+(((-1.0)*x406*x410))+(((-0.81)*x408))+((x406*x411))+(((-1.0)*pp)));\nevalcond[4]=((((0.405)*cj1))+x410+((cj1*x409))+(((-1.0)*x412))+(((-1.0)*sj1*x407)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x413=((2003.0)*cj1);\nIkReal x414=((6620.0)*cj2);\nIkReal x415=((20000.0)*cj1);\nIkReal x416=((20000.0)*pz*sj1);\nCheckValue<IkReal> x417 = IKatan2WithCheck(IkReal(((((-1.0)*px*x414))+(((-1.0)*px*x416))+(((-8100.0)*px))+(((-1.0)*py*x413)))),(((py*x414))+((py*x416))+(((-1.0)*px*x413))+(((8100.0)*py))),IKFAST_ATAN2_MAGTHRESH);\nif(!x417.valid){\ncontinue;\n}\nCheckValue<IkReal> x418=IKPowWithIntegerCheck(IKsign(((((-1.0)*x415*(pz*pz)))+((pp*x415)))),-1);\nif(!x418.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(x417.value)+(((1.5707963267949)*(x418.value))));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x419=IKcos(j0);\nIkReal x420=IKsin(j0);\nIkReal x421=((0.81)*cj1);\nIkReal x422=((0.331)*sj2);\nIkReal x423=(pz*sj1);\nIkReal x424=((0.331)*cj2);\nIkReal x425=(px*x420);\nIkReal x426=(py*x419);\nIkReal x427=((1.0)*x426);\nevalcond[0]=((0.10015)+((px*x419))+((py*x420)));\nevalcond[1]=(((cj1*pz))+(((-1.0)*sj1*x425))+x422+((sj1*x426)));\nevalcond[2]=((0.405)+(((-1.0)*cj1*x427))+x424+x423+((cj1*x425)));\nevalcond[3]=((-0.0444339775)+(((-1.0)*x421*x425))+(((-1.0)*pp))+((x421*x426))+(((-0.81)*x423)));\nevalcond[4]=((((-1.0)*sj1*x422))+(((0.405)*cj1))+(((-1.0)*x427))+x425+((cj1*x424)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[1], cj0array[1], sj0array[1];\nbool j0valid[1]={false};\n_nj0 = 1;\nIkReal x428=((6620.0)*sj2);\nIkReal x429=((20000.0)*sj1);\nIkReal x430=((2003.0)*sj1);\nIkReal x431=((20000.0)*cj1*pz);\nCheckValue<IkReal> x432=IKPowWithIntegerCheck(IKsign((((pp*x429))+(((-1.0)*x429*(pz*pz))))),-1);\nif(!x432.valid){\ncontinue;\n}\nCheckValue<IkReal> x433 = IKatan2WithCheck(IkReal((((px*x431))+(((-1.0)*py*x430))+((px*x428)))),((((-1.0)*py*x431))+(((-1.0)*py*x428))+(((-1.0)*px*x430))),IKFAST_ATAN2_MAGTHRESH);\nif(!x433.valid){\ncontinue;\n}\nj0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x432.value)))+(x433.value));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nfor(int ij0 = 0; ij0 < 1; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 1; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n{\nIkReal evalcond[5];\nIkReal x434=IKcos(j0);\nIkReal x435=IKsin(j0);\nIkReal x436=((0.81)*cj1);\nIkReal x437=((0.331)*sj2);\nIkReal x438=(pz*sj1);\nIkReal x439=((0.331)*cj2);\nIkReal x440=(px*x435);\nIkReal x441=(py*x434);\nIkReal x442=((1.0)*x441);\nevalcond[0]=((0.10015)+((px*x434))+((py*x435)));\nevalcond[1]=(((sj1*x441))+(((-1.0)*sj1*x440))+((cj1*pz))+x437);\nevalcond[2]=((0.405)+((cj1*x440))+(((-1.0)*cj1*x442))+x438+x439);\nevalcond[3]=((-0.0444339775)+(((-0.81)*x438))+(((-1.0)*x436*x440))+(((-1.0)*pp))+((x436*x441)));\nevalcond[4]=((((-1.0)*x442))+(((-1.0)*sj1*x437))+((cj1*x439))+(((0.405)*cj1))+x440);\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j0array[2], cj0array[2], sj0array[2];\nbool j0valid[2]={false};\n_nj0 = 2;\nCheckValue<IkReal> x445 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);\nif(!x445.valid){\ncontinue;\n}\nIkReal x443=((1.0)*(x445.value));\nif((((px*px)+(py*py))) < -0.00001)\ncontinue;\nCheckValue<IkReal> x446=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);\nif(!x446.valid){\ncontinue;\n}\nif( (((0.10015)*(x446.value))) < -1-IKFAST_SINCOS_THRESH || (((0.10015)*(x446.value))) > 1+IKFAST_SINCOS_THRESH )\n    continue;\nIkReal x444=IKasin(((0.10015)*(x446.value)));\nj0array[0]=((((-1.0)*x443))+(((-1.0)*x444)));\nsj0array[0]=IKsin(j0array[0]);\ncj0array[0]=IKcos(j0array[0]);\nj0array[1]=((3.14159265358979)+(((-1.0)*x443))+x444);\nsj0array[1]=IKsin(j0array[1]);\ncj0array[1]=IKcos(j0array[1]);\nif( j0array[0] > IKPI )\n{\n    j0array[0]-=IK2PI;\n}\nelse if( j0array[0] < -IKPI )\n{    j0array[0]+=IK2PI;\n}\nj0valid[0] = true;\nif( j0array[1] > IKPI )\n{\n    j0array[1]-=IK2PI;\n}\nelse if( j0array[1] < -IKPI )\n{    j0array[1]+=IK2PI;\n}\nj0valid[1] = true;\nfor(int ij0 = 0; ij0 < 2; ++ij0)\n{\nif( !j0valid[ij0] )\n{\n    continue;\n}\n_ij0[0] = ij0; _ij0[1] = -1;\nfor(int iij0 = ij0+1; iij0 < 2; ++iij0)\n{\nif( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )\n{\n    j0valid[iij0]=false; _ij0[1] = iij0; break; \n}\n}\nj0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];\n\n{\nIkReal j1eval[3];\nIkReal x447=((331000.0)*cj2);\nIkReal x448=(px*sj0);\nIkReal x449=(cj0*py);\nIkReal x450=((331000.0)*sj2);\nj1eval[0]=((1.02042445265003)+cj2);\nj1eval[1]=((IKabs((((x447*x449))+(((-405000.0)*x448))+(((405000.0)*x449))+(((-1.0)*pz*x450))+(((-1.0)*x447*x448)))))+(IKabs(((((-405000.0)*pz))+((x448*x450))+(((-1.0)*pz*x447))+(((-1.0)*x449*x450))))));\nj1eval[2]=IKsign(((273586.0)+(((268110.0)*cj2))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[3];\nIkReal x451=(px*sj0);\nIkReal x452=(cj0*py);\nIkReal x453=((1000.0)*pz);\nIkReal x454=(pz*sj2);\nIkReal x455=((331.0)*cj2);\nj1eval[0]=((((-1.0)*cj2*x452))+(((1.22356495468278)*x451))+(((-1.0)*x454))+((cj2*x451))+(((-1.22356495468278)*x452)));\nj1eval[1]=IKsign(((((405.0)*x451))+(((-405.0)*x452))+(((-1.0)*x452*x455))+(((-331.0)*x454))+((x451*x455))));\nj1eval[2]=((IKabs((((x452*x453))+(((134.055)*sj2))+(((-1.0)*x451*x453))+(((109.561)*cj2*sj2)))))+(IKabs(((-164.025)+(((-268.11)*cj2))+((pz*x453))+(((-109.561)*(cj2*cj2)))))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j1eval[3];\nIkReal x456=(px*sj0);\nIkReal x457=(cj0*py);\nIkReal x458=((26811.0)*cj2);\nIkReal x459=((33100.0)*pp);\nIkReal x460=(pz*sj2);\nIkReal x461=((81000.0)*pz);\nj1eval[0]=((((-1.0)*cj2*x456))+(((1.22356495468278)*x457))+((cj2*x457))+x460+(((-1.22356495468278)*x456)));\nj1eval[1]=((IKabs(((1799.57608875)+(((1470.76465525)*cj2))+((cj2*x459))+(((-1.0)*pz*x461))+(((40500.0)*pp)))))+(IKabs((((x456*x461))+(((-1470.76465525)*sj2))+(((-1.0)*sj2*x459))+(((-1.0)*x457*x461))))));\nj1eval[2]=IKsign(((((-32805.0)*x456))+(((-1.0)*x456*x458))+(((32805.0)*x457))+(((26811.0)*x460))+((x457*x458))));\nif( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j1]\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x462=(cj0*py);\nIkReal x463=((81000.0)*pz);\nIkReal x464=((26811.0)*cj2);\nIkReal x465=(px*sj0);\nIkReal x466=((33100.0)*pp);\nCheckValue<IkReal> x467 = IKatan2WithCheck(IkReal(((((-1470.76465525)*sj2))+(((-1.0)*x462*x463))+((x463*x465))+(((-1.0)*sj2*x466)))),((1799.57608875)+(((1470.76465525)*cj2))+((cj2*x466))+(((-1.0)*pz*x463))+(((40500.0)*pp))),IKFAST_ATAN2_MAGTHRESH);\nif(!x467.valid){\ncontinue;\n}\nCheckValue<IkReal> x468=IKPowWithIntegerCheck(IKsign(((((26811.0)*pz*sj2))+(((-32805.0)*x465))+(((-1.0)*x464*x465))+(((32805.0)*x462))+((x462*x464)))),-1);\nif(!x468.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x467.value)+(((1.5707963267949)*(x468.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x469=IKsin(j1);\nIkReal x470=IKcos(j1);\nIkReal x471=((0.331)*sj2);\nIkReal x472=(cj0*py);\nIkReal x473=(px*sj0);\nIkReal x474=((0.331)*cj2);\nIkReal x475=((0.81)*x470);\nIkReal x476=(pz*x469);\nevalcond[0]=(((x469*x474))+((x470*x471))+(((0.405)*x469))+pz);\nevalcond[1]=(((x469*x472))+(((-1.0)*x469*x473))+x471+((pz*x470)));\nevalcond[2]=((0.405)+((x470*x473))+x474+x476+(((-1.0)*x470*x472)));\nevalcond[3]=((-0.0444339775)+((x472*x475))+(((-1.0)*x473*x475))+(((-1.0)*pp))+(((-0.81)*x476)));\nevalcond[4]=(((x470*x474))+(((-1.0)*x469*x471))+(((-1.0)*x472))+x473+(((0.405)*x470)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x477=(cj0*py);\nIkReal x478=((1000.0)*pz);\nIkReal x479=(px*sj0);\nIkReal x480=((331.0)*cj2);\nCheckValue<IkReal> x481 = IKatan2WithCheck(IkReal(((((-1.0)*x478*x479))+(((134.055)*sj2))+((x477*x478))+(((109.561)*cj2*sj2)))),((-164.025)+((pz*x478))+(((-268.11)*cj2))+(((-109.561)*(cj2*cj2)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x481.valid){\ncontinue;\n}\nCheckValue<IkReal> x482=IKPowWithIntegerCheck(IKsign(((((-405.0)*x477))+(((-331.0)*pz*sj2))+(((405.0)*x479))+(((-1.0)*x477*x480))+((x479*x480)))),-1);\nif(!x482.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(x481.value)+(((1.5707963267949)*(x482.value))));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x483=IKsin(j1);\nIkReal x484=IKcos(j1);\nIkReal x485=((0.331)*sj2);\nIkReal x486=(cj0*py);\nIkReal x487=(px*sj0);\nIkReal x488=((0.331)*cj2);\nIkReal x489=((0.81)*x484);\nIkReal x490=(pz*x483);\nevalcond[0]=(((x484*x485))+((x483*x488))+pz+(((0.405)*x483)));\nevalcond[1]=(((pz*x484))+((x483*x486))+x485+(((-1.0)*x483*x487)));\nevalcond[2]=((0.405)+((x484*x487))+(((-1.0)*x484*x486))+x488+x490);\nevalcond[3]=((-0.0444339775)+(((-0.81)*x490))+(((-1.0)*pp))+(((-1.0)*x487*x489))+((x486*x489)));\nevalcond[4]=(((x484*x488))+(((-1.0)*x483*x485))+(((-1.0)*x486))+x487+(((0.405)*x484)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j1array[1], cj1array[1], sj1array[1];\nbool j1valid[1]={false};\n_nj1 = 1;\nIkReal x491=((331000.0)*cj2);\nIkReal x492=(px*sj0);\nIkReal x493=(cj0*py);\nIkReal x494=((331000.0)*sj2);\nCheckValue<IkReal> x495=IKPowWithIntegerCheck(IKsign(((273586.0)+(((268110.0)*cj2)))),-1);\nif(!x495.valid){\ncontinue;\n}\nCheckValue<IkReal> x496 = IKatan2WithCheck(IkReal(((((-1.0)*x493*x494))+(((-405000.0)*pz))+(((-1.0)*pz*x491))+((x492*x494)))),(((x491*x493))+(((-1.0)*x491*x492))+(((405000.0)*x493))+(((-405000.0)*x492))+(((-1.0)*pz*x494))),IKFAST_ATAN2_MAGTHRESH);\nif(!x496.valid){\ncontinue;\n}\nj1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x495.value)))+(x496.value));\nsj1array[0]=IKsin(j1array[0]);\ncj1array[0]=IKcos(j1array[0]);\nif( j1array[0] > IKPI )\n{\n    j1array[0]-=IK2PI;\n}\nelse if( j1array[0] < -IKPI )\n{    j1array[0]+=IK2PI;\n}\nj1valid[0] = true;\nfor(int ij1 = 0; ij1 < 1; ++ij1)\n{\nif( !j1valid[ij1] )\n{\n    continue;\n}\n_ij1[0] = ij1; _ij1[1] = -1;\nfor(int iij1 = ij1+1; iij1 < 1; ++iij1)\n{\nif( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )\n{\n    j1valid[iij1]=false; _ij1[1] = iij1; break; \n}\n}\nj1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];\n{\nIkReal evalcond[5];\nIkReal x497=IKsin(j1);\nIkReal x498=IKcos(j1);\nIkReal x499=((0.331)*sj2);\nIkReal x500=(cj0*py);\nIkReal x501=(px*sj0);\nIkReal x502=((0.331)*cj2);\nIkReal x503=((0.81)*x498);\nIkReal x504=(pz*x497);\nevalcond[0]=((((0.405)*x497))+((x497*x502))+pz+((x498*x499)));\nevalcond[1]=(((pz*x498))+((x497*x500))+x499+(((-1.0)*x497*x501)));\nevalcond[2]=((0.405)+(((-1.0)*x498*x500))+((x498*x501))+x502+x504);\nevalcond[3]=((-0.0444339775)+((x500*x503))+(((-1.0)*x501*x503))+(((-1.0)*pp))+(((-0.81)*x504)));\nevalcond[4]=((((0.405)*x498))+(((-1.0)*x497*x499))+((x498*x502))+x501+(((-1.0)*x500)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\nrotationfunction0(solutions);\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\nreturn solutions.GetNumSolutions()>0;\n}\ninline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {\nfor(int rotationiter = 0; rotationiter < 1; ++rotationiter) {\nIkReal x78=(cj0*r10);\nIkReal x79=((1.0)*sj0);\nIkReal x80=(cj0*r11);\nIkReal x81=((1.0)*cj2);\nIkReal x82=(cj1*sj2);\nIkReal x83=(cj0*r12);\nIkReal x84=(((sj1*sj2))+(((-1.0)*cj1*x81)));\nIkReal x85=(((cj2*sj1))+x82);\nIkReal x86=(cj0*x84);\nIkReal x87=((((-1.0)*sj1*x81))+(((-1.0)*x82)));\nnew_r00=((((-1.0)*r00*x79*x87))+((x78*x87))+((r20*x84)));\nnew_r01=(((r21*x84))+((x80*x87))+(((-1.0)*r01*x79*x87)));\nnew_r02=((((-1.0)*r02*x79*x87))+((x83*x87))+((r22*x84)));\nnew_r10=(((r10*sj0))+((cj0*r00)));\nnew_r11=(((r11*sj0))+((cj0*r01)));\nnew_r12=(((r12*sj0))+((cj0*r02)));\nnew_r20=((((-1.0)*r00*x79*x84))+((x78*x84))+((r20*x85)));\nnew_r21=(((r21*x85))+((x80*x84))+(((-1.0)*r01*x79*x84)));\nnew_r22=((((-1.0)*r02*x79*x84))+((x83*x84))+((r22*x85)));\n{\nIkReal j4array[2], cj4array[2], sj4array[2];\nbool j4valid[2]={false};\n_nj4 = 2;\ncj4array[0]=new_r22;\nif( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )\n{\n    j4valid[0] = j4valid[1] = true;\n    j4array[0] = IKacos(cj4array[0]);\n    sj4array[0] = IKsin(j4array[0]);\n    cj4array[1] = cj4array[0];\n    j4array[1] = -j4array[0];\n    sj4array[1] = -sj4array[0];\n}\nelse if( isnan(cj4array[0]) )\n{\n    // probably any value will work\n    j4valid[0] = true;\n    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;\n}\nfor(int ij4 = 0; ij4 < 2; ++ij4)\n{\nif( !j4valid[ij4] )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < 2; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\nj4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\n\n{\nIkReal j3eval[2];\nIkReal x88=(cj0*r10);\nIkReal x89=((1.0)*sj0);\nIkReal x90=(cj0*r11);\nIkReal x91=((1.0)*cj2);\nIkReal x92=(cj1*sj2);\nIkReal x93=(cj0*r12);\nIkReal x94=x84;\nIkReal x95=(((cj2*sj1))+x92);\nIkReal x96=(cj0*x94);\nIkReal x97=x87;\nnew_r00=(((r20*x94))+((x88*x97))+(((-1.0)*r00*x89*x97)));\nnew_r01=(((r21*x94))+((x90*x97))+(((-1.0)*r01*x89*x97)));\nnew_r02=((((-1.0)*r02*x89*x97))+((x93*x97))+((r22*x94)));\nnew_r10=(((r10*sj0))+((cj0*r00)));\nnew_r11=(((r11*sj0))+((cj0*r01)));\nnew_r12=(((r12*sj0))+((cj0*r02)));\nnew_r20=(((r20*x95))+((x88*x94))+(((-1.0)*r00*x89*x94)));\nnew_r21=(((r21*x95))+((x90*x94))+(((-1.0)*r01*x89*x94)));\nnew_r22=((((-1.0)*r02*x89*x94))+((x93*x94))+((r22*x95)));\nj3eval[0]=sj4;\nj3eval[1]=IKsign(sj4);\nif( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j3eval[1];\nIkReal x98=(cj0*r10);\nIkReal x99=((1.0)*sj0);\nIkReal x100=(cj0*r11);\nIkReal x101=((1.0)*cj2);\nIkReal x102=(cj1*sj2);\nIkReal x103=(cj0*r12);\nIkReal x104=x84;\nIkReal x105=(((cj2*sj1))+x102);\nIkReal x106=(cj0*x104);\nIkReal x107=x87;\nnew_r00=(((x107*x98))+((r20*x104))+(((-1.0)*r00*x107*x99)));\nnew_r01=((((-1.0)*r01*x107*x99))+((r21*x104))+((x100*x107)));\nnew_r02=(((r22*x104))+((x103*x107))+(((-1.0)*r02*x107*x99)));\nnew_r10=(((r10*sj0))+((cj0*r00)));\nnew_r11=(((r11*sj0))+((cj0*r01)));\nnew_r12=(((r12*sj0))+((cj0*r02)));\nnew_r20=((((-1.0)*r00*x104*x99))+((r20*x105))+((x104*x98)));\nnew_r21=((((-1.0)*r01*x104*x99))+((r21*x105))+((x100*x104)));\nnew_r22=(((r22*x105))+(((-1.0)*r02*x104*x99))+((x103*x104)));\nj3eval[0]=sj4;\nif( IKabs(j3eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[6];\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r12;\nevalcond[3]=new_r21;\nevalcond[4]=new_r02;\nevalcond[5]=new_r20;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j3array[2], cj3array[2], sj3array[2];\nbool j3valid[2]={false};\n_nj3 = 2;\nCheckValue<IkReal> x109 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x109.valid){\ncontinue;\n}\nIkReal x108=x109.value;\nj3array[0]=((-1.0)*x108);\nsj3array[0]=IKsin(j3array[0]);\ncj3array[0]=IKcos(j3array[0]);\nj3array[1]=((3.14159265358979)+(((-1.0)*x108)));\nsj3array[1]=IKsin(j3array[1]);\ncj3array[1]=IKcos(j3array[1]);\nif( j3array[0] > IKPI )\n{\n    j3array[0]-=IK2PI;\n}\nelse if( j3array[0] < -IKPI )\n{    j3array[0]+=IK2PI;\n}\nj3valid[0] = true;\nif( j3array[1] > IKPI )\n{\n    j3array[1]-=IK2PI;\n}\nelse if( j3array[1] < -IKPI )\n{    j3array[1]+=IK2PI;\n}\nj3valid[1] = true;\nfor(int ij3 = 0; ij3 < 2; ++ij3)\n{\nif( !j3valid[ij3] )\n{\n    continue;\n}\n_ij3[0] = ij3; _ij3[1] = -1;\nfor(int iij3 = ij3+1; iij3 < 2; ++iij3)\n{\nif( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )\n{\n    j3valid[iij3]=false; _ij3[1] = iij3; break; \n}\n}\nj3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*new_r02*(IKsin(j3))))+((new_r12*(IKcos(j3)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x110=((1.0)*cj3);\nif( IKabs(((((-1.0)*new_r00*x110))+((new_r01*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x110))+(((-1.0)*new_r00*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x110))+((new_r01*sj3))))+IKsqr(((((-1.0)*new_r01*x110))+(((-1.0)*new_r00*sj3))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((((-1.0)*new_r00*x110))+((new_r01*sj3))), ((((-1.0)*new_r01*x110))+(((-1.0)*new_r00*sj3))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[8];\nIkReal x111=IKsin(j5);\nIkReal x112=IKcos(j5);\nIkReal x113=((1.0)*sj3);\nIkReal x114=(cj3*x111);\nIkReal x115=(sj3*x112);\nIkReal x116=((1.0)*x112);\nIkReal x117=(x115+x114);\nevalcond[0]=(((new_r10*sj3))+x111+((cj3*new_r00)));\nevalcond[1]=(((new_r11*sj3))+x112+((cj3*new_r01)));\nevalcond[2]=((((-1.0)*new_r01*x113))+x111+((cj3*new_r11)));\nevalcond[3]=(x117+new_r00);\nevalcond[4]=(x117+new_r11);\nevalcond[5]=((((-1.0)*x111*x113))+((cj3*x112))+new_r01);\nevalcond[6]=(((sj3*x111))+(((-1.0)*cj3*x116))+new_r10);\nevalcond[7]=((((-1.0)*new_r00*x113))+(((-1.0)*x116))+((cj3*new_r10)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r12;\nevalcond[3]=new_r21;\nevalcond[4]=new_r02;\nevalcond[5]=new_r20;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j3array[2], cj3array[2], sj3array[2];\nbool j3valid[2]={false};\n_nj3 = 2;\nCheckValue<IkReal> x119 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);\nif(!x119.valid){\ncontinue;\n}\nIkReal x118=x119.value;\nj3array[0]=((-1.0)*x118);\nsj3array[0]=IKsin(j3array[0]);\ncj3array[0]=IKcos(j3array[0]);\nj3array[1]=((3.14159265358979)+(((-1.0)*x118)));\nsj3array[1]=IKsin(j3array[1]);\ncj3array[1]=IKcos(j3array[1]);\nif( j3array[0] > IKPI )\n{\n    j3array[0]-=IK2PI;\n}\nelse if( j3array[0] < -IKPI )\n{    j3array[0]+=IK2PI;\n}\nj3valid[0] = true;\nif( j3array[1] > IKPI )\n{\n    j3array[1]-=IK2PI;\n}\nelse if( j3array[1] < -IKPI )\n{    j3array[1]+=IK2PI;\n}\nj3valid[1] = true;\nfor(int ij3 = 0; ij3 < 2; ++ij3)\n{\nif( !j3valid[ij3] )\n{\n    continue;\n}\n_ij3[0] = ij3; _ij3[1] = -1;\nfor(int iij3 = ij3+1; iij3 < 2; ++iij3)\n{\nif( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )\n{\n    j3valid[iij3]=false; _ij3[1] = iij3; break; \n}\n}\nj3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];\n{\nIkReal evalcond[1];\nevalcond[0]=((((-1.0)*new_r02*(IKsin(j3))))+((new_r12*(IKcos(j3)))));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x120=((1.0)*new_r01);\nif( IKabs(((((-1.0)*sj3*x120))+(((-1.0)*cj3*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r00*sj3))+(((-1.0)*cj3*x120)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj3*x120))+(((-1.0)*cj3*new_r00))))+IKsqr((((new_r00*sj3))+(((-1.0)*cj3*x120))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((((-1.0)*sj3*x120))+(((-1.0)*cj3*new_r00))), (((new_r00*sj3))+(((-1.0)*cj3*x120))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[8];\nIkReal x121=IKcos(j5);\nIkReal x122=IKsin(j5);\nIkReal x123=((1.0)*sj3);\nIkReal x124=(sj3*x122);\nIkReal x125=(cj3*x121);\nIkReal x126=((1.0)*x122);\nIkReal x127=(x124+x125);\nevalcond[0]=(((new_r10*sj3))+x122+((cj3*new_r00)));\nevalcond[1]=(((new_r11*sj3))+x121+((cj3*new_r01)));\nevalcond[2]=((((-1.0)*new_r00*x123))+x121+((cj3*new_r10)));\nevalcond[3]=(x127+new_r01);\nevalcond[4]=(x127+new_r10);\nevalcond[5]=(((cj3*x122))+(((-1.0)*x121*x123))+new_r00);\nevalcond[6]=(((sj3*x121))+(((-1.0)*cj3*x126))+new_r11);\nevalcond[7]=((((-1.0)*new_r01*x123))+(((-1.0)*x126))+((cj3*new_r11)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j3, j5]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j3array[1], cj3array[1], sj3array[1];\nbool j3valid[1]={false};\n_nj3 = 1;\nCheckValue<IkReal> x129=IKPowWithIntegerCheck(sj4,-1);\nif(!x129.valid){\ncontinue;\n}\nIkReal x128=x129.value;\nCheckValue<IkReal> x130=IKPowWithIntegerCheck(new_r02,-1);\nif(!x130.valid){\ncontinue;\n}\nif( IKabs((x128*(x130.value)*(((1.0)+(((-1.0)*(cj4*cj4)))+(((-1.0)*(new_r12*new_r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x128)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x128*(x130.value)*(((1.0)+(((-1.0)*(cj4*cj4)))+(((-1.0)*(new_r12*new_r12)))))))+IKsqr(((-1.0)*new_r12*x128))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj3array[0]=IKatan2((x128*(x130.value)*(((1.0)+(((-1.0)*(cj4*cj4)))+(((-1.0)*(new_r12*new_r12)))))), ((-1.0)*new_r12*x128));\nsj3array[0]=IKsin(j3array[0]);\ncj3array[0]=IKcos(j3array[0]);\nif( j3array[0] > IKPI )\n{\n    j3array[0]-=IK2PI;\n}\nelse if( j3array[0] < -IKPI )\n{    j3array[0]+=IK2PI;\n}\nj3valid[0] = true;\nfor(int ij3 = 0; ij3 < 1; ++ij3)\n{\nif( !j3valid[ij3] )\n{\n    continue;\n}\n_ij3[0] = ij3; _ij3[1] = -1;\nfor(int iij3 = ij3+1; iij3 < 1; ++iij3)\n{\nif( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )\n{\n    j3valid[iij3]=false; _ij3[1] = iij3; break; \n}\n}\nj3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];\n{\nIkReal evalcond[8];\nIkReal x131=IKsin(j3);\nIkReal x132=IKcos(j3);\nIkReal x133=((1.0)*sj4);\nIkReal x134=(new_r12*x132);\nIkReal x135=(sj4*x131);\nIkReal x136=((1.0)*new_r02*x131);\nevalcond[0]=(((sj4*x132))+new_r12);\nevalcond[1]=(new_r02+(((-1.0)*x131*x133)));\nevalcond[2]=(((new_r12*x131))+((new_r02*x132)));\nevalcond[3]=(sj4+x134+(((-1.0)*x136)));\nevalcond[4]=(((new_r22*sj4))+(((-1.0)*cj4*x136))+((cj4*x134)));\nevalcond[5]=(((cj4*new_r20))+((new_r00*x135))+(((-1.0)*new_r10*x132*x133)));\nevalcond[6]=(((new_r01*x135))+(((-1.0)*new_r11*x132*x133))+((cj4*new_r21)));\nevalcond[7]=((-1.0)+((cj4*new_r22))+(((-1.0)*x133*x134))+((new_r02*x135)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j5eval[2];\nIkReal x137=(cj0*r10);\nIkReal x138=((1.0)*sj0);\nIkReal x139=(cj0*r11);\nIkReal x140=((1.0)*cj2);\nIkReal x141=(cj1*sj2);\nIkReal x142=(cj0*r12);\nIkReal x143=x84;\nIkReal x144=(((cj2*sj1))+x141);\nIkReal x145=(cj0*x143);\nIkReal x146=x87;\nnew_r00=(((r20*x143))+((x137*x146))+(((-1.0)*r00*x138*x146)));\nnew_r01=(((r21*x143))+(((-1.0)*r01*x138*x146))+((x139*x146)));\nnew_r02=(((x142*x146))+((r22*x143))+(((-1.0)*r02*x138*x146)));\nnew_r10=(((r10*sj0))+((cj0*r00)));\nnew_r11=(((r11*sj0))+((cj0*r01)));\nnew_r12=(((r12*sj0))+((cj0*r02)));\nnew_r20=(((r20*x144))+((x137*x143))+(((-1.0)*r00*x138*x143)));\nnew_r21=(((r21*x144))+(((-1.0)*r01*x138*x143))+((x139*x143)));\nnew_r22=(((x142*x143))+((r22*x144))+(((-1.0)*r02*x138*x143)));\nj5eval[0]=sj4;\nj5eval[1]=IKsign(sj4);\nif( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j5eval[1];\nIkReal x147=(cj0*r10);\nIkReal x148=((1.0)*sj0);\nIkReal x149=(cj0*r11);\nIkReal x150=((1.0)*cj2);\nIkReal x151=(cj1*sj2);\nIkReal x152=(cj0*r12);\nIkReal x153=x84;\nIkReal x154=(((cj2*sj1))+x151);\nIkReal x155=(cj0*x153);\nIkReal x156=x87;\nnew_r00=((((-1.0)*r00*x148*x156))+((r20*x153))+((x147*x156)));\nnew_r01=(((x149*x156))+(((-1.0)*r01*x148*x156))+((r21*x153)));\nnew_r02=((((-1.0)*r02*x148*x156))+((x152*x156))+((r22*x153)));\nnew_r10=(((r10*sj0))+((cj0*r00)));\nnew_r11=(((r11*sj0))+((cj0*r01)));\nnew_r12=(((r12*sj0))+((cj0*r02)));\nnew_r20=((((-1.0)*r00*x148*x153))+((r20*x154))+((x147*x153)));\nnew_r21=(((x149*x153))+(((-1.0)*r01*x148*x153))+((r21*x154)));\nnew_r22=((((-1.0)*r02*x148*x153))+((x152*x153))+((r22*x154)));\nj5eval[0]=sj4;\nif( IKabs(j5eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j5eval[2];\nIkReal x157=(cj0*r10);\nIkReal x158=((1.0)*sj0);\nIkReal x159=(cj0*r11);\nIkReal x160=((1.0)*cj2);\nIkReal x161=(cj1*sj2);\nIkReal x162=(cj0*r12);\nIkReal x163=x84;\nIkReal x164=(((cj2*sj1))+x161);\nIkReal x165=(cj0*x163);\nIkReal x166=x87;\nnew_r00=(((x157*x166))+((r20*x163))+(((-1.0)*r00*x158*x166)));\nnew_r01=(((r21*x163))+(((-1.0)*r01*x158*x166))+((x159*x166)));\nnew_r02=(((r22*x163))+((x162*x166))+(((-1.0)*r02*x158*x166)));\nnew_r10=(((r10*sj0))+((cj0*r00)));\nnew_r11=(((r11*sj0))+((cj0*r01)));\nnew_r12=(((r12*sj0))+((cj0*r02)));\nnew_r20=(((x157*x163))+((r20*x164))+(((-1.0)*r00*x158*x163)));\nnew_r21=(((r21*x164))+(((-1.0)*r01*x158*x163))+((x159*x163)));\nnew_r22=(((r22*x164))+((x162*x163))+(((-1.0)*r02*x158*x163)));\nj5eval[0]=sj4;\nj5eval[1]=sj3;\nif( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[10];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x167=(((new_r12*sj3))+((cj3*new_r02)));\nIkReal x168=((((-1.0)*new_r02*sj3))+((cj3*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r12;\nevalcond[3]=new_r21;\nevalcond[4]=new_r02;\nevalcond[5]=new_r20;\nevalcond[6]=x167;\nevalcond[7]=x167;\nevalcond[8]=x168;\nevalcond[9]=x168;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x169=((1.0)*cj3);\nif( IKabs(((((-1.0)*new_r00*x169))+((new_r01*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r00*sj3))+(((-1.0)*new_r01*x169)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x169))+((new_r01*sj3))))+IKsqr(((((-1.0)*new_r00*sj3))+(((-1.0)*new_r01*x169))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((((-1.0)*new_r00*x169))+((new_r01*sj3))), ((((-1.0)*new_r00*sj3))+(((-1.0)*new_r01*x169))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[8];\nIkReal x170=IKsin(j5);\nIkReal x171=IKcos(j5);\nIkReal x172=((1.0)*sj3);\nIkReal x173=(cj3*x170);\nIkReal x174=(sj3*x171);\nIkReal x175=((1.0)*x171);\nIkReal x176=(x173+x174);\nevalcond[0]=(((new_r10*sj3))+x170+((cj3*new_r00)));\nevalcond[1]=(((new_r11*sj3))+x171+((cj3*new_r01)));\nevalcond[2]=(x170+((cj3*new_r11))+(((-1.0)*new_r01*x172)));\nevalcond[3]=(x176+new_r00);\nevalcond[4]=(x176+new_r11);\nevalcond[5]=(((cj3*x171))+(((-1.0)*x170*x172))+new_r01);\nevalcond[6]=((((-1.0)*cj3*x175))+new_r10+((sj3*x170)));\nevalcond[7]=((((-1.0)*x175))+((cj3*new_r10))+(((-1.0)*new_r00*x172)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x177=(cj3*new_r12);\nIkReal x178=(new_r02*sj3);\nIkReal x179=(((new_r12*sj3))+((cj3*new_r02)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r12;\nevalcond[3]=new_r21;\nevalcond[4]=new_r02;\nevalcond[5]=new_r20;\nevalcond[6]=x179;\nevalcond[7]=x179;\nevalcond[8]=((((-1.0)*x178))+x177);\nevalcond[9]=((((-1.0)*x177))+x178);\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x180=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj3*new_r00))+(((-1.0)*sj3*x180)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r00*sj3))+(((-1.0)*cj3*x180)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*new_r00))+(((-1.0)*sj3*x180))))+IKsqr((((new_r00*sj3))+(((-1.0)*cj3*x180))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((((-1.0)*cj3*new_r00))+(((-1.0)*sj3*x180))), (((new_r00*sj3))+(((-1.0)*cj3*x180))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[8];\nIkReal x181=IKcos(j5);\nIkReal x182=IKsin(j5);\nIkReal x183=((1.0)*sj3);\nIkReal x184=(sj3*x182);\nIkReal x185=(cj3*x181);\nIkReal x186=((1.0)*x182);\nIkReal x187=(x184+x185);\nevalcond[0]=(((new_r10*sj3))+x182+((cj3*new_r00)));\nevalcond[1]=(((new_r11*sj3))+x181+((cj3*new_r01)));\nevalcond[2]=(x181+((cj3*new_r10))+(((-1.0)*new_r00*x183)));\nevalcond[3]=(x187+new_r01);\nevalcond[4]=(x187+new_r10);\nevalcond[5]=(((cj3*x182))+new_r00+(((-1.0)*x181*x183)));\nevalcond[6]=(((sj3*x181))+new_r11+(((-1.0)*cj3*x186)));\nevalcond[7]=((((-1.0)*x186))+(((-1.0)*new_r01*x183))+((cj3*new_r11)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x188=(new_r22+(((-1.0)*cj4)));\nIkReal x189=(sj4+new_r12);\nIkReal x190=((1.0)*sj4);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=x188;\nevalcond[2]=x188;\nevalcond[3]=x189;\nevalcond[4]=new_r02;\nevalcond[5]=x189;\nevalcond[6]=(((cj4*new_r12))+((new_r22*sj4)));\nevalcond[7]=(((cj4*new_r20))+(((-1.0)*new_r10*x190)));\nevalcond[8]=(((cj4*new_r21))+(((-1.0)*new_r11*x190)));\nevalcond[9]=((-1.0)+((cj4*new_r22))+(((-1.0)*new_r12*x190)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nif( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[8];\nIkReal x191=IKcos(j5);\nIkReal x192=IKsin(j5);\nIkReal x193=((1.0)*new_r12);\nIkReal x194=((1.0)*x191);\nevalcond[0]=(x192+new_r00);\nevalcond[1]=(x191+new_r01);\nevalcond[2]=(((new_r12*x191))+new_r20);\nevalcond[3]=(((new_r22*x192))+new_r11);\nevalcond[4]=((((-1.0)*x192*x193))+new_r21);\nevalcond[5]=((((-1.0)*new_r22*x194))+new_r10);\nevalcond[6]=((((-1.0)*new_r21*x193))+x192+((new_r11*new_r22)));\nevalcond[7]=((((-1.0)*x194))+(((-1.0)*new_r20*x193))+((new_r10*new_r22)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x195=(new_r22+(((-1.0)*cj4)));\nIkReal x196=((1.0)*cj4);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=x195;\nevalcond[2]=x195;\nevalcond[3]=((((-1.0)*sj4))+new_r12);\nevalcond[4]=new_r02;\nevalcond[5]=(sj4+(((-1.0)*new_r12)));\nevalcond[6]=(((new_r22*sj4))+(((-1.0)*new_r12*x196)));\nevalcond[7]=(((new_r10*sj4))+((cj4*new_r20)));\nevalcond[8]=(((new_r11*sj4))+((cj4*new_r21)));\nevalcond[9]=((-1.0)+((new_r12*sj4))+((cj4*new_r22)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nif( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(new_r00, new_r01);\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[8];\nIkReal x197=IKsin(j5);\nIkReal x198=IKcos(j5);\nIkReal x199=((1.0)*new_r22);\nIkReal x200=((1.0)*x198);\nevalcond[0]=(((new_r12*x197))+new_r21);\nevalcond[1]=(x197+(((-1.0)*new_r00)));\nevalcond[2]=(x198+(((-1.0)*new_r01)));\nevalcond[3]=(((new_r22*x198))+new_r10);\nevalcond[4]=((((-1.0)*new_r12*x200))+new_r20);\nevalcond[5]=((((-1.0)*x197*x199))+new_r11);\nevalcond[6]=(x197+((new_r12*new_r21))+(((-1.0)*new_r11*x199)));\nevalcond[7]=((((-1.0)*x200))+((new_r12*new_r20))+(((-1.0)*new_r10*x199)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j5]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nCheckValue<IkReal> x202=IKPowWithIntegerCheck(sj4,-1);\nif(!x202.valid){\ncontinue;\n}\nIkReal x201=x202.value;\nCheckValue<IkReal> x203=IKPowWithIntegerCheck(sj3,-1);\nif(!x203.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r21*x201)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x201*(x203.value)*((((cj3*cj4*new_r21))+(((-1.0)*new_r11*sj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x201))+IKsqr((x201*(x203.value)*((((cj3*cj4*new_r21))+(((-1.0)*new_r11*sj4))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((-1.0)*new_r21*x201), (x201*(x203.value)*((((cj3*cj4*new_r21))+(((-1.0)*new_r11*sj4))))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[12];\nIkReal x204=IKsin(j5);\nIkReal x205=IKcos(j5);\nIkReal x206=(cj4*sj3);\nIkReal x207=(cj3*new_r10);\nIkReal x208=((1.0)*new_r01);\nIkReal x209=((1.0)*cj4);\nIkReal x210=((1.0)*new_r00);\nIkReal x211=(cj3*new_r11);\nIkReal x212=(cj3*x205);\nIkReal x213=(cj3*x204);\nIkReal x214=((1.0)*x205);\nevalcond[0]=(((sj4*x204))+new_r21);\nevalcond[1]=((((-1.0)*sj4*x214))+new_r20);\nevalcond[2]=(((new_r10*sj3))+x204+((cj3*new_r00)));\nevalcond[3]=(((new_r11*sj3))+x205+((cj3*new_r01)));\nevalcond[4]=(((x205*x206))+x213+new_r00);\nevalcond[5]=(((sj3*x205))+((cj4*x213))+new_r11);\nevalcond[6]=(((cj4*x204))+x211+(((-1.0)*sj3*x208)));\nevalcond[7]=(x212+(((-1.0)*x204*x206))+new_r01);\nevalcond[8]=(((sj3*x204))+new_r10+(((-1.0)*x209*x212)));\nevalcond[9]=((((-1.0)*sj3*x210))+x207+(((-1.0)*x205*x209)));\nevalcond[10]=(((cj4*x211))+(((-1.0)*x206*x208))+x204+((new_r21*sj4)));\nevalcond[11]=(((new_r20*sj4))+(((-1.0)*x206*x210))+((cj4*x207))+(((-1.0)*x214)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nCheckValue<IkReal> x215=IKPowWithIntegerCheck(sj4,-1);\nif(!x215.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r21*(x215.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj3*new_r01))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x215.value)))+IKsqr(((((-1.0)*cj3*new_r01))+(((-1.0)*new_r11*sj3))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((-1.0)*new_r21*(x215.value)), ((((-1.0)*cj3*new_r01))+(((-1.0)*new_r11*sj3))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[12];\nIkReal x216=IKsin(j5);\nIkReal x217=IKcos(j5);\nIkReal x218=(cj4*sj3);\nIkReal x219=(cj3*new_r10);\nIkReal x220=((1.0)*new_r01);\nIkReal x221=((1.0)*cj4);\nIkReal x222=((1.0)*new_r00);\nIkReal x223=(cj3*new_r11);\nIkReal x224=(cj3*x217);\nIkReal x225=(cj3*x216);\nIkReal x226=((1.0)*x217);\nevalcond[0]=(new_r21+((sj4*x216)));\nevalcond[1]=((((-1.0)*sj4*x226))+new_r20);\nevalcond[2]=(((new_r10*sj3))+x216+((cj3*new_r00)));\nevalcond[3]=(((new_r11*sj3))+x217+((cj3*new_r01)));\nevalcond[4]=(x225+new_r00+((x217*x218)));\nevalcond[5]=(((sj3*x217))+((cj4*x225))+new_r11);\nevalcond[6]=(((cj4*x216))+x223+(((-1.0)*sj3*x220)));\nevalcond[7]=((((-1.0)*x216*x218))+x224+new_r01);\nevalcond[8]=(((sj3*x216))+(((-1.0)*x221*x224))+new_r10);\nevalcond[9]=(x219+(((-1.0)*sj3*x222))+(((-1.0)*x217*x221)));\nevalcond[10]=(x216+(((-1.0)*x218*x220))+((cj4*x223))+((new_r21*sj4)));\nevalcond[11]=(((cj4*x219))+((new_r20*sj4))+(((-1.0)*x218*x222))+(((-1.0)*x226)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nCheckValue<IkReal> x227 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x227.valid){\ncontinue;\n}\nCheckValue<IkReal> x228=IKPowWithIntegerCheck(IKsign(sj4),-1);\nif(!x228.valid){\ncontinue;\n}\nj5array[0]=((-1.5707963267949)+(x227.value)+(((1.5707963267949)*(x228.value))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[12];\nIkReal x229=IKsin(j5);\nIkReal x230=IKcos(j5);\nIkReal x231=(cj4*sj3);\nIkReal x232=(cj3*new_r10);\nIkReal x233=((1.0)*new_r01);\nIkReal x234=((1.0)*cj4);\nIkReal x235=((1.0)*new_r00);\nIkReal x236=(cj3*new_r11);\nIkReal x237=(cj3*x230);\nIkReal x238=(cj3*x229);\nIkReal x239=((1.0)*x230);\nevalcond[0]=(((sj4*x229))+new_r21);\nevalcond[1]=((((-1.0)*sj4*x239))+new_r20);\nevalcond[2]=(((new_r10*sj3))+x229+((cj3*new_r00)));\nevalcond[3]=(((new_r11*sj3))+x230+((cj3*new_r01)));\nevalcond[4]=(((x230*x231))+x238+new_r00);\nevalcond[5]=(((cj4*x238))+new_r11+((sj3*x230)));\nevalcond[6]=(x236+((cj4*x229))+(((-1.0)*sj3*x233)));\nevalcond[7]=(x237+(((-1.0)*x229*x231))+new_r01);\nevalcond[8]=(((sj3*x229))+new_r10+(((-1.0)*x234*x237)));\nevalcond[9]=((((-1.0)*x230*x234))+x232+(((-1.0)*sj3*x235)));\nevalcond[10]=(x229+((cj4*x236))+(((-1.0)*x231*x233))+((new_r21*sj4)));\nevalcond[11]=(((new_r20*sj4))+(((-1.0)*x239))+((cj4*x232))+(((-1.0)*x231*x235)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j3array[1], cj3array[1], sj3array[1];\nbool j3valid[1]={false};\n_nj3 = 1;\nCheckValue<IkReal> x240=IKPowWithIntegerCheck(IKsign(sj4),-1);\nif(!x240.valid){\ncontinue;\n}\nCheckValue<IkReal> x241 = IKatan2WithCheck(IkReal(new_r02),((-1.0)*new_r12),IKFAST_ATAN2_MAGTHRESH);\nif(!x241.valid){\ncontinue;\n}\nj3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x240.value)))+(x241.value));\nsj3array[0]=IKsin(j3array[0]);\ncj3array[0]=IKcos(j3array[0]);\nif( j3array[0] > IKPI )\n{\n    j3array[0]-=IK2PI;\n}\nelse if( j3array[0] < -IKPI )\n{    j3array[0]+=IK2PI;\n}\nj3valid[0] = true;\nfor(int ij3 = 0; ij3 < 1; ++ij3)\n{\nif( !j3valid[ij3] )\n{\n    continue;\n}\n_ij3[0] = ij3; _ij3[1] = -1;\nfor(int iij3 = ij3+1; iij3 < 1; ++iij3)\n{\nif( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )\n{\n    j3valid[iij3]=false; _ij3[1] = iij3; break; \n}\n}\nj3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];\n{\nIkReal evalcond[8];\nIkReal x242=IKsin(j3);\nIkReal x243=IKcos(j3);\nIkReal x244=((1.0)*sj4);\nIkReal x245=(new_r12*x243);\nIkReal x246=(sj4*x242);\nIkReal x247=((1.0)*new_r02*x242);\nevalcond[0]=(new_r12+((sj4*x243)));\nevalcond[1]=((((-1.0)*x242*x244))+new_r02);\nevalcond[2]=(((new_r12*x242))+((new_r02*x243)));\nevalcond[3]=(sj4+x245+(((-1.0)*x247)));\nevalcond[4]=((((-1.0)*cj4*x247))+((cj4*x245))+((new_r22*sj4)));\nevalcond[5]=((((-1.0)*new_r10*x243*x244))+((cj4*new_r20))+((new_r00*x246)));\nevalcond[6]=(((cj4*new_r21))+((new_r01*x246))+(((-1.0)*new_r11*x243*x244)));\nevalcond[7]=((-1.0)+((cj4*new_r22))+((new_r02*x246))+(((-1.0)*x244*x245)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j5eval[2];\nIkReal x248=(cj0*r10);\nIkReal x249=((1.0)*sj0);\nIkReal x250=(cj0*r11);\nIkReal x251=((1.0)*cj2);\nIkReal x252=(cj1*sj2);\nIkReal x253=(cj0*r12);\nIkReal x254=x84;\nIkReal x255=(((cj2*sj1))+x252);\nIkReal x256=(cj0*x254);\nIkReal x257=x87;\nnew_r00=(((x248*x257))+(((-1.0)*r00*x249*x257))+((r20*x254)));\nnew_r01=(((r21*x254))+(((-1.0)*r01*x249*x257))+((x250*x257)));\nnew_r02=((((-1.0)*r02*x249*x257))+((x253*x257))+((r22*x254)));\nnew_r10=(((r10*sj0))+((cj0*r00)));\nnew_r11=(((r11*sj0))+((cj0*r01)));\nnew_r12=(((r12*sj0))+((cj0*r02)));\nnew_r20=(((x248*x254))+(((-1.0)*r00*x249*x254))+((r20*x255)));\nnew_r21=(((r21*x255))+(((-1.0)*r01*x249*x254))+((x250*x254)));\nnew_r22=((((-1.0)*r02*x249*x254))+((x253*x254))+((r22*x255)));\nj5eval[0]=sj4;\nj5eval[1]=IKsign(sj4);\nif( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal j5eval[1];\nIkReal x258=(cj0*r10);\nIkReal x259=((1.0)*sj0);\nIkReal x260=(cj0*r11);\nIkReal x261=((1.0)*cj2);\nIkReal x262=(cj1*sj2);\nIkReal x263=(cj0*r12);\nIkReal x264=x84;\nIkReal x265=(((cj2*sj1))+x262);\nIkReal x266=(cj0*x264);\nIkReal x267=x87;\nnew_r00=((((-1.0)*r00*x259*x267))+((x258*x267))+((r20*x264)));\nnew_r01=((((-1.0)*r01*x259*x267))+((x260*x267))+((r21*x264)));\nnew_r02=((((-1.0)*r02*x259*x267))+((r22*x264))+((x263*x267)));\nnew_r10=(((r10*sj0))+((cj0*r00)));\nnew_r11=(((r11*sj0))+((cj0*r01)));\nnew_r12=(((r12*sj0))+((cj0*r02)));\nnew_r20=((((-1.0)*r00*x259*x264))+((x258*x264))+((r20*x265)));\nnew_r21=((((-1.0)*r01*x259*x264))+((x260*x264))+((r21*x265)));\nnew_r22=((((-1.0)*r02*x259*x264))+((r22*x265))+((x263*x264)));\nj5eval[0]=sj4;\nif( IKabs(j5eval[0]) < 0.0000010000000000  )\n{\n{\nIkReal j5eval[2];\nIkReal x268=(cj0*r10);\nIkReal x269=((1.0)*sj0);\nIkReal x270=(cj0*r11);\nIkReal x271=((1.0)*cj2);\nIkReal x272=(cj1*sj2);\nIkReal x273=(cj0*r12);\nIkReal x274=x84;\nIkReal x275=(((cj2*sj1))+x272);\nIkReal x276=(cj0*x274);\nIkReal x277=x87;\nnew_r00=((((-1.0)*r00*x269*x277))+((r20*x274))+((x268*x277)));\nnew_r01=((((-1.0)*r01*x269*x277))+((r21*x274))+((x270*x277)));\nnew_r02=(((x273*x277))+(((-1.0)*r02*x269*x277))+((r22*x274)));\nnew_r10=(((r10*sj0))+((cj0*r00)));\nnew_r11=(((r11*sj0))+((cj0*r01)));\nnew_r12=(((r12*sj0))+((cj0*r02)));\nnew_r20=((((-1.0)*r00*x269*x274))+((r20*x275))+((x268*x274)));\nnew_r21=((((-1.0)*r01*x269*x274))+((r21*x275))+((x270*x274)));\nnew_r22=(((x273*x274))+(((-1.0)*r02*x269*x274))+((r22*x275)));\nj5eval[0]=sj4;\nj5eval[1]=sj3;\nif( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[10];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x278=(((new_r12*sj3))+((cj3*new_r02)));\nIkReal x279=((((-1.0)*new_r02*sj3))+((cj3*new_r12)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));\nevalcond[1]=((-1.0)+new_r22);\nevalcond[2]=new_r12;\nevalcond[3]=new_r21;\nevalcond[4]=new_r02;\nevalcond[5]=new_r20;\nevalcond[6]=x278;\nevalcond[7]=x278;\nevalcond[8]=x279;\nevalcond[9]=x279;\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x280=((1.0)*cj3);\nif( IKabs((((new_r01*sj3))+(((-1.0)*new_r00*x280)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x280))+(((-1.0)*new_r00*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r01*sj3))+(((-1.0)*new_r00*x280))))+IKsqr(((((-1.0)*new_r01*x280))+(((-1.0)*new_r00*sj3))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2((((new_r01*sj3))+(((-1.0)*new_r00*x280))), ((((-1.0)*new_r01*x280))+(((-1.0)*new_r00*sj3))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[8];\nIkReal x281=IKsin(j5);\nIkReal x282=IKcos(j5);\nIkReal x283=((1.0)*sj3);\nIkReal x284=(cj3*x281);\nIkReal x285=(sj3*x282);\nIkReal x286=((1.0)*x282);\nIkReal x287=(x285+x284);\nevalcond[0]=(((new_r10*sj3))+x281+((cj3*new_r00)));\nevalcond[1]=(((new_r11*sj3))+x282+((cj3*new_r01)));\nevalcond[2]=(x281+(((-1.0)*new_r01*x283))+((cj3*new_r11)));\nevalcond[3]=(x287+new_r00);\nevalcond[4]=(x287+new_r11);\nevalcond[5]=((((-1.0)*x281*x283))+((cj3*x282))+new_r01);\nevalcond[6]=((((-1.0)*cj3*x286))+((sj3*x281))+new_r10);\nevalcond[7]=((((-1.0)*new_r00*x283))+((cj3*new_r10))+(((-1.0)*x286)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x288=(cj3*new_r12);\nIkReal x289=(new_r02*sj3);\nIkReal x290=(((new_r12*sj3))+((cj3*new_r02)));\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));\nevalcond[1]=((1.0)+new_r22);\nevalcond[2]=new_r12;\nevalcond[3]=new_r21;\nevalcond[4]=new_r02;\nevalcond[5]=new_r20;\nevalcond[6]=x290;\nevalcond[7]=x290;\nevalcond[8]=(x288+(((-1.0)*x289)));\nevalcond[9]=(x289+(((-1.0)*x288)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x291=((1.0)*new_r01);\nif( IKabs(((((-1.0)*cj3*new_r00))+(((-1.0)*sj3*x291)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r00*sj3))+(((-1.0)*cj3*x291)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*new_r00))+(((-1.0)*sj3*x291))))+IKsqr((((new_r00*sj3))+(((-1.0)*cj3*x291))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((((-1.0)*cj3*new_r00))+(((-1.0)*sj3*x291))), (((new_r00*sj3))+(((-1.0)*cj3*x291))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[8];\nIkReal x292=IKcos(j5);\nIkReal x293=IKsin(j5);\nIkReal x294=((1.0)*sj3);\nIkReal x295=(sj3*x293);\nIkReal x296=(cj3*x292);\nIkReal x297=((1.0)*x293);\nIkReal x298=(x295+x296);\nevalcond[0]=(((new_r10*sj3))+x293+((cj3*new_r00)));\nevalcond[1]=(((new_r11*sj3))+x292+((cj3*new_r01)));\nevalcond[2]=(x292+((cj3*new_r10))+(((-1.0)*new_r00*x294)));\nevalcond[3]=(x298+new_r01);\nevalcond[4]=(x298+new_r10);\nevalcond[5]=(((cj3*x293))+new_r00+(((-1.0)*x292*x294)));\nevalcond[6]=((((-1.0)*cj3*x297))+new_r11+((sj3*x292)));\nevalcond[7]=((((-1.0)*new_r01*x294))+(((-1.0)*x297))+((cj3*new_r11)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x299=(new_r22+(((-1.0)*cj4)));\nIkReal x300=(sj4+new_r12);\nIkReal x301=((1.0)*sj4);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=x299;\nevalcond[2]=x299;\nevalcond[3]=x300;\nevalcond[4]=new_r02;\nevalcond[5]=x300;\nevalcond[6]=(((cj4*new_r12))+((new_r22*sj4)));\nevalcond[7]=(((cj4*new_r20))+(((-1.0)*new_r10*x301)));\nevalcond[8]=(((cj4*new_r21))+(((-1.0)*new_r11*x301)));\nevalcond[9]=((-1.0)+((cj4*new_r22))+(((-1.0)*new_r12*x301)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nif( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[8];\nIkReal x302=IKcos(j5);\nIkReal x303=IKsin(j5);\nIkReal x304=((1.0)*new_r12);\nIkReal x305=((1.0)*x302);\nevalcond[0]=(x303+new_r00);\nevalcond[1]=(x302+new_r01);\nevalcond[2]=(((new_r12*x302))+new_r20);\nevalcond[3]=(((new_r22*x303))+new_r11);\nevalcond[4]=((((-1.0)*x303*x304))+new_r21);\nevalcond[5]=((((-1.0)*new_r22*x305))+new_r10);\nevalcond[6]=((((-1.0)*new_r21*x304))+x303+((new_r11*new_r22)));\nevalcond[7]=((((-1.0)*new_r20*x304))+((new_r10*new_r22))+(((-1.0)*x305)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x306=(new_r22+(((-1.0)*cj4)));\nIkReal x307=((1.0)*cj4);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=x306;\nevalcond[2]=x306;\nevalcond[3]=((((-1.0)*sj4))+new_r12);\nevalcond[4]=new_r02;\nevalcond[5]=(sj4+(((-1.0)*new_r12)));\nevalcond[6]=(((new_r22*sj4))+(((-1.0)*new_r12*x307)));\nevalcond[7]=(((new_r10*sj4))+((cj4*new_r20)));\nevalcond[8]=(((new_r11*sj4))+((cj4*new_r21)));\nevalcond[9]=((-1.0)+((new_r12*sj4))+((cj4*new_r22)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nif( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(new_r00, new_r01);\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[8];\nIkReal x308=IKsin(j5);\nIkReal x309=IKcos(j5);\nIkReal x310=((1.0)*new_r22);\nIkReal x311=((1.0)*x309);\nevalcond[0]=(((new_r12*x308))+new_r21);\nevalcond[1]=(x308+(((-1.0)*new_r00)));\nevalcond[2]=(x309+(((-1.0)*new_r01)));\nevalcond[3]=(((new_r22*x309))+new_r10);\nevalcond[4]=((((-1.0)*new_r12*x311))+new_r20);\nevalcond[5]=((((-1.0)*x308*x310))+new_r11);\nevalcond[6]=((((-1.0)*new_r11*x310))+x308+((new_r12*new_r21)));\nevalcond[7]=(((new_r12*new_r20))+(((-1.0)*new_r10*x310))+(((-1.0)*x311)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j5]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nCheckValue<IkReal> x313=IKPowWithIntegerCheck(sj4,-1);\nif(!x313.valid){\ncontinue;\n}\nIkReal x312=x313.value;\nCheckValue<IkReal> x314=IKPowWithIntegerCheck(sj3,-1);\nif(!x314.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r21*x312)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x312*(x314.value)*((((cj3*cj4*new_r21))+(((-1.0)*new_r11*sj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x312))+IKsqr((x312*(x314.value)*((((cj3*cj4*new_r21))+(((-1.0)*new_r11*sj4))))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((-1.0)*new_r21*x312), (x312*(x314.value)*((((cj3*cj4*new_r21))+(((-1.0)*new_r11*sj4))))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[12];\nIkReal x315=IKsin(j5);\nIkReal x316=IKcos(j5);\nIkReal x317=(cj4*sj3);\nIkReal x318=(cj3*new_r10);\nIkReal x319=((1.0)*new_r01);\nIkReal x320=((1.0)*cj4);\nIkReal x321=((1.0)*new_r00);\nIkReal x322=(cj3*new_r11);\nIkReal x323=(cj3*x316);\nIkReal x324=(cj3*x315);\nIkReal x325=((1.0)*x316);\nevalcond[0]=(((sj4*x315))+new_r21);\nevalcond[1]=(new_r20+(((-1.0)*sj4*x325)));\nevalcond[2]=(((new_r10*sj3))+x315+((cj3*new_r00)));\nevalcond[3]=(((new_r11*sj3))+x316+((cj3*new_r01)));\nevalcond[4]=(x324+new_r00+((x316*x317)));\nevalcond[5]=(((cj4*x324))+new_r11+((sj3*x316)));\nevalcond[6]=(((cj4*x315))+(((-1.0)*sj3*x319))+x322);\nevalcond[7]=(x323+new_r01+(((-1.0)*x315*x317)));\nevalcond[8]=((((-1.0)*x320*x323))+new_r10+((sj3*x315)));\nevalcond[9]=(x318+(((-1.0)*x316*x320))+(((-1.0)*sj3*x321)));\nevalcond[10]=(x315+((cj4*x322))+((new_r21*sj4))+(((-1.0)*x317*x319)));\nevalcond[11]=(((new_r20*sj4))+((cj4*x318))+(((-1.0)*x317*x321))+(((-1.0)*x325)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nCheckValue<IkReal> x326=IKPowWithIntegerCheck(sj4,-1);\nif(!x326.valid){\ncontinue;\n}\nif( IKabs(((-1.0)*new_r21*(x326.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj3*new_r01))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x326.value)))+IKsqr(((((-1.0)*cj3*new_r01))+(((-1.0)*new_r11*sj3))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((-1.0)*new_r21*(x326.value)), ((((-1.0)*cj3*new_r01))+(((-1.0)*new_r11*sj3))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[12];\nIkReal x327=IKsin(j5);\nIkReal x328=IKcos(j5);\nIkReal x329=(cj4*sj3);\nIkReal x330=(cj3*new_r10);\nIkReal x331=((1.0)*new_r01);\nIkReal x332=((1.0)*cj4);\nIkReal x333=((1.0)*new_r00);\nIkReal x334=(cj3*new_r11);\nIkReal x335=(cj3*x328);\nIkReal x336=(cj3*x327);\nIkReal x337=((1.0)*x328);\nevalcond[0]=(((sj4*x327))+new_r21);\nevalcond[1]=((((-1.0)*sj4*x337))+new_r20);\nevalcond[2]=(((new_r10*sj3))+x327+((cj3*new_r00)));\nevalcond[3]=(((new_r11*sj3))+x328+((cj3*new_r01)));\nevalcond[4]=(((x328*x329))+x336+new_r00);\nevalcond[5]=(((sj3*x328))+((cj4*x336))+new_r11);\nevalcond[6]=((((-1.0)*sj3*x331))+x334+((cj4*x327)));\nevalcond[7]=(x335+(((-1.0)*x327*x329))+new_r01);\nevalcond[8]=(((sj3*x327))+(((-1.0)*x332*x335))+new_r10);\nevalcond[9]=((((-1.0)*sj3*x333))+(((-1.0)*x328*x332))+x330);\nevalcond[10]=((((-1.0)*x329*x331))+x327+((cj4*x334))+((new_r21*sj4)));\nevalcond[11]=(((new_r20*sj4))+(((-1.0)*x329*x333))+(((-1.0)*x337))+((cj4*x330)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nCheckValue<IkReal> x338 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);\nif(!x338.valid){\ncontinue;\n}\nCheckValue<IkReal> x339=IKPowWithIntegerCheck(IKsign(sj4),-1);\nif(!x339.valid){\ncontinue;\n}\nj5array[0]=((-1.5707963267949)+(x338.value)+(((1.5707963267949)*(x339.value))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[12];\nIkReal x340=IKsin(j5);\nIkReal x341=IKcos(j5);\nIkReal x342=(cj4*sj3);\nIkReal x343=(cj3*new_r10);\nIkReal x344=((1.0)*new_r01);\nIkReal x345=((1.0)*cj4);\nIkReal x346=((1.0)*new_r00);\nIkReal x347=(cj3*new_r11);\nIkReal x348=(cj3*x341);\nIkReal x349=(cj3*x340);\nIkReal x350=((1.0)*x341);\nevalcond[0]=(((sj4*x340))+new_r21);\nevalcond[1]=(new_r20+(((-1.0)*sj4*x350)));\nevalcond[2]=(((new_r10*sj3))+x340+((cj3*new_r00)));\nevalcond[3]=(((new_r11*sj3))+x341+((cj3*new_r01)));\nevalcond[4]=(x349+((x341*x342))+new_r00);\nevalcond[5]=(((sj3*x341))+((cj4*x349))+new_r11);\nevalcond[6]=(x347+((cj4*x340))+(((-1.0)*sj3*x344)));\nevalcond[7]=(x348+(((-1.0)*x340*x342))+new_r01);\nevalcond[8]=(((sj3*x340))+(((-1.0)*x345*x348))+new_r10);\nevalcond[9]=(x343+(((-1.0)*x341*x345))+(((-1.0)*sj3*x346)));\nevalcond[10]=(x340+((cj4*x347))+((new_r21*sj4))+(((-1.0)*x342*x344)));\nevalcond[11]=(((new_r20*sj4))+(((-1.0)*x350))+((cj4*x343))+(((-1.0)*x342*x346)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j1;\nvinfos[1].indices[0] = _ij1[0];\nvinfos[1].indices[1] = _ij1[1];\nvinfos[1].maxsolutions = _nj1;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j2;\nvinfos[2].indices[0] = _ij2[0];\nvinfos[2].indices[1] = _ij2[1];\nvinfos[2].maxsolutions = _nj2;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j3;\nvinfos[3].indices[0] = _ij3[0];\nvinfos[3].indices[1] = _ij3[1];\nvinfos[3].maxsolutions = _nj3;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j4;\nvinfos[4].indices[0] = _ij4[0];\nvinfos[4].indices[1] = _ij4[1];\nvinfos[4].maxsolutions = _nj4;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j5;\nvinfos[5].indices[0] = _ij5[0];\nvinfos[5].indices[1] = _ij5[1];\nvinfos[5].maxsolutions = _nj5;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n}\n}};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"932c89545e6a1721f49778d9ea6940ca\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\nchar* ComputeFkWrapper(const IkReal* j) {\n    IkReal eetrans[3];\n    IkReal eerot[9];\n    IkReal res[3 + 9];\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n\nstd::vector<IkReal> TrueComputeIk(int argc, char** argv)\n{\n    std::vector<IkReal> solvalues(GetNumJoints());\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return solvalues;\n}\n"]}