/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2015-05-22 19:29:10.531261
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54;
x0=IKcos(j[1]);
x1=IKcos(j[4]);
x2=IKcos(j[2]);
x3=IKsin(j[4]);
x4=IKsin(j[2]);
x5=IKsin(j[3]);
x6=IKcos(j[3]);
x7=IKsin(j[1]);
x8=IKcos(j[5]);
x9=IKsin(j[5]);
x10=IKsin(j[6]);
x11=IKcos(j[6]);
x12=IKsin(j[7]);
x13=IKcos(j[7]);
x14=((1.0)*x1);
x15=((1.0)*x3);
x16=((0.321)*x1);
x17=((1.0)*x6);
x18=((0.321)*x5);
x19=((1.0)*x8);
x20=((1.0)*x9);
x21=((1.0)*x10);
x22=((0.321)*x6);
x23=((1.0)*x11);
x24=(x2*x7);
x25=((-1.0)*x3);
x26=(x2*x5);
x27=((-1.0)*x10);
x28=(x0*x2);
x29=((-1.0)*x1);
x30=(x0*x4);
x31=((-1.0)*x11);
x32=(x2*x6);
x33=(x5*x7);
x34=(x4*x7);
x35=(x15*x28);
x36=(x14*x32);
x37=(((x30*x5))+(((-1.0)*x17*x7)));
x38=(((x0*x5))+(((-1.0)*x17*x34)));
x39=(((x0*x6))+((x33*x4)));
x40=(x36+(((-1.0)*x15*x4)));
x41=((((-1.0)*x33))+(((-1.0)*x17*x30)));
x42=(x37*x9);
x43=(((x14*x4))+((x15*x32)));
x44=(x39*x8);
x45=((1.0)*x41);
x46=(x40*x9);
x47=(x1*x41);
x48=(((x26*x9))+((x8*(((((-1.0)*x36))+((x3*x4)))))));
x49=((((-1.0)*x14*x38))+((x15*x24)));
x50=(x49*x9);
x51=(((x8*((((x1*x38))+((x24*x25))))))+((x39*x9)));
x52=(((x8*((x47+((x25*x28))))))+x42);
x53=((((-1.0)*x21*x43))+(((-1.0)*x23*x48)));
x54=(((x31*x51))+((x27*((((x24*x29))+((x25*x38)))))));
eerot[0]=(((x10*((x42+((x8*(((((-1.0)*x35))+x47))))))))+((x11*((((x1*x28))+((x3*x41)))))));
eerot[1]=((((-1.0)*x12*((((x21*(((((-1.0)*x15*x41))+(((-1.0)*x14*x28))))))+((x23*x52))))))+((x13*((((x9*((((x29*x41))+x35))))+((x37*x8)))))));
eerot[2]=((((-1.0)*x12*((((x19*x37))+((x20*(((((-1.0)*x14*x41))+x35))))))))+((x13*((((x27*((((x28*x29))+((x25*x41))))))+((x31*x52)))))));
eetrans[0]=((-0.05)+(((0.1)*x0))+((x16*x28))+((x3*(((((-1.0)*x18*x7))+(((-1.0)*x22*x30))))))+(((0.4)*x28)));
eerot[3]=(((x10*x51))+((x11*((((x1*x24))+((x3*x38)))))));
eerot[4]=(((x13*((x44+x50))))+((x12*x54)));
eerot[5]=(((x13*x54))+((x12*(((((-1.0)*x20*x49))+(((-1.0)*x19*x39)))))));
eetrans[1]=((0.188)+(((0.1)*x7))+((x16*x24))+(((0.4)*x24))+((x3*((((x0*x18))+(((-1.0)*x22*x34)))))));
eerot[6]=(((x10*x48))+(((-1.0)*x11*x43)));
eerot[7]=(((x12*x53))+((x13*((x46+((x26*x8)))))));
eerot[8]=(((x13*x53))+((x12*(((((-1.0)*x20*x40))+(((-1.0)*x19*x26)))))));
eetrans[2]=((0.739675)+(((-1.0)*x2*x22*x3))+(((-1.0)*x16*x4))+(((-0.4)*x4))+j[0]);
}

IKFAST_API int GetNumFreeParameters() { return 2; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {0, 3}; return freeparams; }
IKFAST_API int GetNumJoints() { return 8; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j15,cj15,sj15,htj15,j15mul,j16,cj16,sj16,htj16,j16mul,j18,cj18,sj18,htj18,j18mul,j19,cj19,sj19,htj19,j19mul,j20,cj20,sj20,htj20,j20mul,j21,cj21,sj21,htj21,j21mul,j12,cj12,sj12,htj12,j17,cj17,sj17,htj17,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij15[2], _nj15,_ij16[2], _nj16,_ij18[2], _nj18,_ij19[2], _nj19,_ij20[2], _nj20,_ij21[2], _nj21,_ij12[2], _nj12,_ij17[2], _nj17;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1; j16=numeric_limits<IkReal>::quiet_NaN(); _ij16[0] = -1; _ij16[1] = -1; _nj16 = -1; j18=numeric_limits<IkReal>::quiet_NaN(); _ij18[0] = -1; _ij18[1] = -1; _nj18 = -1; j19=numeric_limits<IkReal>::quiet_NaN(); _ij19[0] = -1; _ij19[1] = -1; _nj19 = -1; j20=numeric_limits<IkReal>::quiet_NaN(); _ij20[0] = -1; _ij20[1] = -1; _nj20 = -1; j21=numeric_limits<IkReal>::quiet_NaN(); _ij21[0] = -1; _ij21[1] = -1; _nj21 = -1;  _ij12[0] = -1; _ij12[1] = -1; _nj12 = 0;  _ij17[0] = -1; _ij17[1] = -1; _nj17 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j12=pfree[0]; cj12=cos(pfree[0]); sj12=sin(pfree[0]), htj12=tan(pfree[0]*0.5);
j17=pfree[1]; cj17=cos(pfree[1]); sj17=sin(pfree[1]), htj17=tan(pfree[1]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r02);
new_r01=r01;
new_r02=r00;
new_px=((0.05)+px);
new_r10=((-1.0)*r12);
new_r11=r11;
new_r12=r10;
new_py=((-0.188)+py);
new_r20=((-1.0)*r22);
new_r21=r21;
new_r22=r20;
new_pz=((-0.739675)+(((-1.0)*j12))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x55=((1.0)*px);
IkReal x56=((1.0)*pz);
IkReal x57=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x57))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x56)));
rxp0_2=((((-1.0)*r10*x55))+((py*r00)));
rxp1_0=((((-1.0)*r21*x57))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x56)));
rxp1_2=((((-1.0)*r11*x55))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x57)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x56)));
rxp2_2=((((-1.0)*r12*x55))+((py*r02)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x58=((0.2)*px);
IkReal x59=((1.0)*pp);
IkReal x60=((0.509841)+x58+(((-1.0)*x59)));
IkReal x61=((-0.003759)+x58+(((-1.0)*x59)));
IkReal x62=(x59+x58);
IkReal x63=((0.509841)+(((-1.0)*x62)));
IkReal x64=((-0.003759)+(((-1.0)*x62)));
IkReal gconst0=x60;
IkReal gconst1=x61;
IkReal gconst2=x60;
IkReal gconst3=x61;
IkReal gconst4=x63;
IkReal gconst5=x64;
IkReal gconst6=x63;
IkReal gconst7=x64;
IkReal x65=py*py;
IkReal x66=sj17*sj17;
IkReal x67=px*px;
IkReal x68=((1.0)*gconst4);
IkReal x69=(gconst5*py);
IkReal x70=((4.0)*px);
IkReal x71=(gconst0*gconst3);
IkReal x72=(gconst1*gconst2);
IkReal x73=((2.0)*gconst5);
IkReal x74=((1.0)*gconst0);
IkReal x75=(gconst1*gconst7);
IkReal x76=(gconst0*gconst6);
IkReal x77=(gconst1*gconst3);
IkReal x78=(gconst4*gconst7);
IkReal x79=(gconst6*py);
IkReal x80=((2.0)*gconst0);
IkReal x81=(gconst0*gconst7);
IkReal x82=((2.0)*gconst4);
IkReal x83=(gconst3*gconst5);
IkReal x84=(gconst2*gconst5);
IkReal x85=(gconst3*gconst4);
IkReal x86=(gconst5*gconst6);
IkReal x87=(gconst2*gconst4);
IkReal x88=(gconst1*gconst6);
IkReal x89=(px*py);
IkReal x90=(gconst1*py);
IkReal x91=(gconst2*py);
IkReal x92=(gconst5*gconst7);
IkReal x93=((1.05513984)*x89);
IkReal x94=(gconst6*x65);
IkReal x95=((0.3297312)*x66);
IkReal x96=((4.0)*x67);
IkReal x97=(gconst2*x65);
IkReal x98=((2.0)*x65);
IkReal x99=((1.0)*x65);
IkReal x100=((0.824328)*x66);
IkReal x101=((0.412164)*x66);
IkReal x102=((0.1648656)*x66);
IkReal x103=(x65*x78);
IkReal x104=(x65*x86);
IkReal x105=(x65*x84);
IkReal x106=(x65*x85);
IkReal x107=(x65*x81);
IkReal x108=(x65*x88);
IkReal x109=((0.0834355125792)*py*x66);
IkReal x110=(x65*x72);
IkReal x111=(x65*x71);
IkReal x112=(x65*x66);
IkReal x113=(x101*x86);
IkReal x114=(x92*x99);
IkReal x115=(x68*x94);
IkReal x116=(py*x70*x87);
IkReal x117=(py*x70*x75);
IkReal x118=(gconst3*x69*x70);
IkReal x119=(py*x70*x76);
IkReal x120=(py*x70*x85);
IkReal x121=(py*x70*x81);
IkReal x122=(gconst2*x69*x70);
IkReal x123=(gconst1*x70*x79);
IkReal x124=(x75*x99);
IkReal x125=(x68*x97);
IkReal x126=(x101*x88);
IkReal x127=((0.06594624)*x112);
IkReal x128=(x74*x94);
IkReal x129=(x101*x84);
IkReal x130=(x83*x99);
IkReal x131=(pp*py*x95);
IkReal x132=((0.06594624)*x66*x89);
IkReal x133=(x74*x97);
IkReal x134=(x77*x99);
IkReal x135=(x101*x72);
IkReal x136=(x111+x110);
IkReal x137=(x104+x103);
IkReal x138=(x113+x115+x114);
IkReal x139=(x135+x134+x133);
IkReal x140=(x108+x105+x106+x107);
IkReal x141=(x122+x123+x120+x121);
IkReal x142=(x117+x116+x119+x118);
IkReal x143=(x130+x126+x127+x124+x125+x128+x129);
op[0]=(x137+(((-1.0)*x138)));
op[1]=((((-1.0)*x109))+x131+x132+(((-1.0)*x93)));
op[2]=((((-1.0)*x143))+(((-1.0)*gconst4*gconst6*x96))+((x82*x94))+(((-1.0)*x73*x94))+((x78*x96))+((x86*x96))+x140+(((-1.0)*x78*x98))+(((-1.0)*x92*x96))+(((-1.0)*x100*x86))+((gconst7*x65*x73)));
op[3]=((((-1.0)*x142))+(((-1.0)*x102*x91))+(((-1.0)*x102*x90))+(((-1.0)*gconst6*x69*x70))+(((-1.0)*py*x70*x78))+x141+((gconst7*x69*x70))+(((-1.0)*x79*x95))+(((-1.0)*x69*x95))+((gconst4*x70*x79)));
op[4]=(((x82*x97))+((x81*x96))+(((-1.0)*x73*x97))+((gconst3*x65*x73))+(((-1.0)*x83*x96))+(((-0.13189248)*x112))+((x85*x96))+x137+x136+(((-1.0)*x87*x96))+(((-1.0)*x138))+(((-1.0)*x139))+((x75*x98))+((x88*x96))+((x76*x98))+(((-1.0)*x76*x96))+(((-1.0)*x100*x84))+(((-1.0)*x100*x88))+(((-1.0)*x75*x96))+(((-1.0)*gconst3*x65*x82))+(((-1.0)*x88*x98))+(((-1.0)*gconst7*x65*x80))+((x84*x96)));
op[5]=((((-1.0)*x141))+(((-1.0)*x90*x95))+(((-1.0)*gconst0*x70*x91))+(((-1.0)*x91*x95))+(((-1.0)*py*x70*x77))+x142+((py*x70*x72))+((py*x70*x71))+(((-1.0)*x102*x69))+(((-1.0)*x102*x79)));
op[6]=((((-1.0)*x143))+((x71*x96))+(((-1.0)*gconst0*gconst2*x96))+(((-1.0)*x71*x98))+(((-1.0)*x72*x98))+(((-1.0)*x77*x96))+((x72*x96))+x140+(((-1.0)*x100*x72))+((x80*x97))+((x77*x98)));
op[7]=((((-1.0)*x109))+x131+(((-1.0)*x132))+x93);
op[8]=(x136+(((-1.0)*x139)));
polyroots8(op,zeror,numroots);
IkReal j15array[8], cj15array[8], sj15array[8], tempj15array[1];
int numsolutions = 0;
for(int ij15 = 0; ij15 < numroots; ++ij15)
{
IkReal htj15 = zeror[ij15];
tempj15array[0]=((2.0)*(atan(htj15)));
for(int kj15 = 0; kj15 < 1; ++kj15)
{
j15array[numsolutions] = tempj15array[kj15];
if( j15array[numsolutions] > IKPI )
{
    j15array[numsolutions]-=IK2PI;
}
else if( j15array[numsolutions] < -IKPI )
{
    j15array[numsolutions]+=IK2PI;
}
sj15array[numsolutions] = IKsin(j15array[numsolutions]);
cj15array[numsolutions] = IKcos(j15array[numsolutions]);
numsolutions++;
}
}
bool j15valid[8]={true,true,true,true,true,true,true,true};
_nj15 = 8;
for(int ij15 = 0; ij15 < numsolutions; ++ij15)
    {
if( !j15valid[ij15] )
{
    continue;
}
    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
htj15 = IKtan(j15/2);

_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
{
IkReal j16eval[2];
IkReal x144=py*py;
IkReal x145=cj15*cj15;
IkReal x146=px*px;
IkReal x147=pz*pz;
IkReal x148=((4.0)*sj17);
IkReal x149=((20.0)*sj17);
IkReal x150=(py*sj15);
IkReal x151=(cj15*px);
IkReal x152=((100.0)*sj17);
IkReal x153=((0.8)*sj17);
IkReal x154=(x144*x145);
IkReal x155=(x145*x146);
j16eval[0]=(((x149*x150))+((x149*x151))+(((-1.0)*x144*x152))+((x152*x154))+(((-1.0)*x152*x155))+(((-1.0)*sj17))+(((-1.0)*x147*x152))+(((-200.0)*sj17*x150*x151)));
j16eval[1]=IKsign((((x150*x153))+(((-1.0)*x144*x148))+((x151*x153))+(((-1.0)*x147*x148))+(((-1.0)*x148*x155))+(((-8.0)*sj17*x150*x151))+((x148*x154))+(((-0.04)*sj17))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal j18eval[1];
j18eval[0]=sj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
IkReal x156=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=x156;
evalcond[2]=x156;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal j16eval[3];
sj17=0;
cj17=1.0;
j17=0;
IkReal x157=((321000.0)*sj18);
IkReal x158=(py*sj15);
IkReal x159=((321000.0)*cj18);
IkReal x160=(cj15*px);
j16eval[0]=((1.02430295950156)+cj18);
j16eval[1]=IKsign(((263041.0)+(((256800.0)*cj18))));
j16eval[2]=((IKabs(((-40000.0)+(((400000.0)*x160))+(((-1.0)*pz*x157))+(((400000.0)*x158))+(((-32100.0)*cj18))+((x158*x159))+((x159*x160)))))+(IKabs(((((-1.0)*x157*x160))+(((-1.0)*x157*x158))+(((-1.0)*pz*x159))+(((-400000.0)*pz))+(((32100.0)*sj18))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj17=0;
cj17=1.0;
j17=0;
IkReal x161=(cj15*px);
IkReal x162=((1000.0)*pz);
IkReal x163=(py*sj15);
IkReal x164=((10.0)*cj18);
IkReal x165=((321.0)*cj18);
IkReal x166=(pz*sj18);
j16eval[0]=((1.24610591900312)+(((-1.0)*x163*x164))+(((-1.0)*x161*x164))+cj18+(((-10.0)*x166))+(((-12.4610591900312)*x161))+(((-12.4610591900312)*x163)));
j16eval[1]=IKsign(((40.0)+(((-400.0)*x161))+(((-400.0)*x163))+(((-1.0)*x163*x165))+(((32.1)*cj18))+(((-1.0)*x161*x165))+(((-321.0)*x166))));
j16eval[2]=((IKabs(((-160.0)+((pz*x162))+(((-256.8)*cj18))+(((-103.041)*(cj18*cj18))))))+(IKabs((((x161*x162))+(((-100.0)*pz))+(((103.041)*cj18*sj18))+((x162*x163))+(((128.4)*sj18))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj17=0;
cj17=1.0;
j17=0;
IkReal x167=cj15*cj15;
IkReal x168=py*py;
IkReal x169=px*px;
IkReal x170=pz*pz;
IkReal x171=(py*sj15);
IkReal x172=((321.0)*sj18);
IkReal x173=(cj15*px);
IkReal x174=((321.0)*cj18);
IkReal x175=((100.0)*x167);
IkReal x176=((1000.0)*x167);
j16eval[0]=((-1.0)+(((-100.0)*x168))+(((-100.0)*x170))+((x168*x175))+(((20.0)*x171))+(((20.0)*x173))+(((-200.0)*x171*x173))+(((-1.0)*x169*x175)));
j16eval[1]=IKsign(((-10.0)+(((-2000.0)*x171*x173))+((x168*x176))+(((-1000.0)*x168))+(((-1000.0)*x170))+(((-1.0)*x169*x176))+(((200.0)*x173))+(((200.0)*x171))));
j16eval[2]=((IKabs((((pz*x174))+((x172*x173))+(((400.0)*pz))+((x171*x172))+(((-32.1)*sj18)))))+(IKabs(((40.0)+((pz*x172))+(((-400.0)*x173))+(((-400.0)*x171))+(((32.1)*cj18))+(((-1.0)*x171*x174))+(((-1.0)*x173*x174))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j16]

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x177=py*py;
IkReal x178=cj15*cj15;
IkReal x179=(py*sj15);
IkReal x180=((321.0)*sj18);
IkReal x181=(cj15*px);
IkReal x182=((321.0)*cj18);
IkReal x183=((1000.0)*x178);
CheckValue<IkReal> x184=IKPowWithIntegerCheck(IKsign(((-10.0)+((x177*x183))+(((-1.0)*x183*(px*px)))+(((-2000.0)*x179*x181))+(((-1000.0)*(pz*pz)))+(((-1000.0)*x177))+(((200.0)*x181))+(((200.0)*x179)))),-1);
if(!x184.valid){
continue;
}
CheckValue<IkReal> x185 = IKatan2WithCheck(IkReal((((pz*x182))+((x180*x181))+((x179*x180))+(((400.0)*pz))+(((-32.1)*sj18)))),((40.0)+((pz*x180))+(((-400.0)*x181))+(((-400.0)*x179))+(((32.1)*cj18))+(((-1.0)*x179*x182))+(((-1.0)*x181*x182))),IKFAST_ATAN2_MAGTHRESH);
if(!x185.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x184.value)))+(x185.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x186=IKsin(j16);
IkReal x187=IKcos(j16);
IkReal x188=((0.321)*sj18);
IkReal x189=((0.321)*cj18);
IkReal x190=(py*sj15);
IkReal x191=(cj15*px);
IkReal x192=(pz*x186);
IkReal x193=(x187*x191);
evalcond[0]=(((x186*x189))+(((0.4)*x186))+((x187*x188))+pz);
evalcond[1]=(((pz*x187))+((x186*x190))+((x186*x191))+x188+(((-0.1)*x186)));
evalcond[2]=((0.1)+(((0.4)*x187))+(((-1.0)*x186*x188))+((x187*x189))+(((-1.0)*x191))+(((-1.0)*x190)));
evalcond[3]=((0.4)+(((0.1)*x187))+(((-1.0)*x193))+x192+x189+(((-1.0)*x187*x190)));
evalcond[4]=((-0.066959)+(((0.2)*x191))+(((0.2)*x190))+(((-1.0)*pp))+(((0.8)*x187*x190))+(((0.8)*x193))+(((-0.08)*x187))+(((-0.8)*x192)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x619=(cj15*px);
IkReal x620=((1000.0)*pz);
IkReal x621=((321.0)*cj18);
IkReal x622=(py*sj15);
CheckValue<IkReal> x623 = IKatan2WithCheck(IkReal(((((-100.0)*pz))+(((103.041)*cj18*sj18))+((x619*x620))+(((128.4)*sj18))+((x620*x622)))),((-160.0)+((pz*x620))+(((-256.8)*cj18))+(((-103.041)*(cj18*cj18)))),IKFAST_ATAN2_MAGTHRESH);
if(!x623.valid){
continue;
}
CheckValue<IkReal> x624=IKPowWithIntegerCheck(IKsign(((40.0)+(((-1.0)*x621*x622))+(((-400.0)*x622))+(((-321.0)*pz*sj18))+(((32.1)*cj18))+(((-1.0)*x619*x621))+(((-400.0)*x619)))),-1);
if(!x624.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x623.value)+(((1.5707963267949)*(x624.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x625=IKsin(j16);
IkReal x626=IKcos(j16);
IkReal x627=((0.321)*sj18);
IkReal x628=((0.321)*cj18);
IkReal x629=(py*sj15);
IkReal x630=(cj15*px);
IkReal x631=(pz*x625);
IkReal x632=(x626*x630);
evalcond[0]=(((x625*x628))+pz+(((0.4)*x625))+((x626*x627)));
evalcond[1]=(((pz*x626))+(((-0.1)*x625))+((x625*x630))+((x625*x629))+x627);
evalcond[2]=((0.1)+(((-1.0)*x625*x627))+(((-1.0)*x629))+(((-1.0)*x630))+(((0.4)*x626))+((x626*x628)));
evalcond[3]=((0.4)+x628+x631+(((0.1)*x626))+(((-1.0)*x632))+(((-1.0)*x626*x629)));
evalcond[4]=((-0.066959)+(((0.2)*x630))+(((0.2)*x629))+(((-0.08)*x626))+(((-1.0)*pp))+(((0.8)*x632))+(((-0.8)*x631))+(((0.8)*x626*x629)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x633=((321000.0)*sj18);
IkReal x634=(py*sj15);
IkReal x635=((321000.0)*cj18);
IkReal x636=(cj15*px);
CheckValue<IkReal> x637=IKPowWithIntegerCheck(IKsign(((263041.0)+(((256800.0)*cj18)))),-1);
if(!x637.valid){
continue;
}
CheckValue<IkReal> x638 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x635))+(((-1.0)*x633*x634))+(((-1.0)*x633*x636))+(((-400000.0)*pz))+(((32100.0)*sj18)))),((-40000.0)+(((-1.0)*pz*x633))+((x634*x635))+((x635*x636))+(((-32100.0)*cj18))+(((400000.0)*x636))+(((400000.0)*x634))),IKFAST_ATAN2_MAGTHRESH);
if(!x638.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x637.value)))+(x638.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x639=IKsin(j16);
IkReal x640=IKcos(j16);
IkReal x641=((0.321)*sj18);
IkReal x642=((0.321)*cj18);
IkReal x643=(py*sj15);
IkReal x644=(cj15*px);
IkReal x645=(pz*x639);
IkReal x646=(x640*x644);
evalcond[0]=(((x639*x642))+((x640*x641))+pz+(((0.4)*x639)));
evalcond[1]=((((-0.1)*x639))+((x639*x644))+((x639*x643))+((pz*x640))+x641);
evalcond[2]=((0.1)+(((-1.0)*x644))+(((-1.0)*x643))+(((-1.0)*x639*x641))+((x640*x642))+(((0.4)*x640)));
evalcond[3]=((0.4)+(((-1.0)*x646))+(((-1.0)*x640*x643))+(((0.1)*x640))+x645+x642);
evalcond[4]=((-0.066959)+(((-0.8)*x645))+(((-1.0)*pp))+(((-0.08)*x640))+(((0.2)*x643))+(((0.2)*x644))+(((0.8)*x646))+(((0.8)*x640*x643)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x647=(cj15*py);
IkReal x648=(px*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x647))+x648);
evalcond[2]=((((-1.0)*x648))+x647);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal j16eval[3];
sj17=0;
cj17=-1.0;
j17=3.14159265358979;
IkReal x649=((321000.0)*pz);
IkReal x650=((321000.0)*py*sj15);
IkReal x651=((321000.0)*cj15*px);
j16eval[0]=((-1.02430295950156)+(((-1.0)*cj18)));
j16eval[1]=IKsign(((-263041.0)+(((-256800.0)*cj18))));
j16eval[2]=((IKabs(((40000.0)+(((32100.0)*cj18))+(((-1.0)*sj18*x649))+(((-400000.0)*cj15*px))+(((-400000.0)*py*sj15))+(((-1.0)*cj18*x650))+(((-1.0)*cj18*x651)))))+(IKabs((((cj18*x649))+(((-1.0)*sj18*x651))+(((-1.0)*sj18*x650))+(((400000.0)*pz))+(((32100.0)*sj18))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj17=0;
cj17=-1.0;
j17=3.14159265358979;
IkReal x652=(cj15*px);
IkReal x653=((1000.0)*pz);
IkReal x654=(py*sj15);
IkReal x655=((10.0)*cj18);
IkReal x656=((321.0)*cj18);
IkReal x657=(pz*sj18);
j16eval[0]=((-1.24610591900312)+(((-10.0)*x657))+(((12.4610591900312)*x654))+(((12.4610591900312)*x652))+((x652*x655))+((x654*x655))+(((-1.0)*cj18)));
j16eval[1]=((IKabs(((160.0)+(((256.8)*cj18))+(((-1.0)*pz*x653))+(((103.041)*(cj18*cj18))))))+(IKabs(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))+(((-1.0)*x653*x654))+(((-1.0)*x652*x653))))));
j16eval[2]=IKsign(((-40.0)+(((400.0)*x654))+(((400.0)*x652))+(((-321.0)*x657))+((x652*x656))+((x654*x656))+(((-32.1)*cj18))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj17=0;
cj17=-1.0;
j17=3.14159265358979;
IkReal x658=cj15*cj15;
IkReal x659=py*py;
IkReal x660=px*px;
IkReal x661=pz*pz;
IkReal x662=(py*sj15);
IkReal x663=((321.0)*cj18);
IkReal x664=(cj15*px);
IkReal x665=((321.0)*sj18);
IkReal x666=(x658*x660);
IkReal x667=(x658*x659);
j16eval[0]=((-1.0)+(((-200.0)*x662*x664))+(((100.0)*x667))+(((20.0)*x662))+(((20.0)*x664))+(((-100.0)*x659))+(((-100.0)*x666))+(((-100.0)*x661)));
j16eval[1]=IKsign(((-10.0)+(((-1000.0)*x661))+(((-1000.0)*x666))+(((1000.0)*x667))+(((200.0)*x664))+(((200.0)*x662))+(((-1000.0)*x659))+(((-2000.0)*x662*x664))));
j16eval[2]=((IKabs(((((32.1)*sj18))+(((-1.0)*x662*x665))+(((400.0)*pz))+((pz*x663))+(((-1.0)*x664*x665)))))+(IKabs(((40.0)+(((-1.0)*x662*x663))+(((-1.0)*x663*x664))+(((32.1)*cj18))+(((-1.0)*pz*x665))+(((-400.0)*x664))+(((-400.0)*x662))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j16]

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x668=py*py;
IkReal x669=cj15*cj15;
IkReal x670=(py*sj15);
IkReal x671=((321.0)*sj18);
IkReal x672=(cj15*px);
IkReal x673=((321.0)*cj18);
IkReal x674=((1000.0)*x669);
CheckValue<IkReal> x675 = IKatan2WithCheck(IkReal((((pz*x673))+(((32.1)*sj18))+(((400.0)*pz))+(((-1.0)*x670*x671))+(((-1.0)*x671*x672)))),((40.0)+(((32.1)*cj18))+(((-1.0)*pz*x671))+(((-1.0)*x670*x673))+(((-1.0)*x672*x673))+(((-400.0)*x670))+(((-400.0)*x672))),IKFAST_ATAN2_MAGTHRESH);
if(!x675.valid){
continue;
}
CheckValue<IkReal> x676=IKPowWithIntegerCheck(IKsign(((-10.0)+(((-1000.0)*x668))+(((-1000.0)*(pz*pz)))+(((-2000.0)*x670*x672))+(((200.0)*x672))+(((200.0)*x670))+(((-1.0)*x674*(px*px)))+((x668*x674)))),-1);
if(!x676.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x675.value)+(((1.5707963267949)*(x676.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x677=IKsin(j16);
IkReal x678=IKcos(j16);
IkReal x679=((0.321)*sj18);
IkReal x680=((0.321)*cj18);
IkReal x681=(cj15*px);
IkReal x682=(py*sj15);
IkReal x683=(pz*x677);
IkReal x684=((1.0)*x677);
IkReal x685=((1.0)*x678);
IkReal x686=(x678*x681);
evalcond[0]=((((-1.0)*x678*x679))+(((0.4)*x677))+((x677*x680))+pz);
evalcond[1]=((0.1)+((x678*x680))+(((0.4)*x678))+((x677*x679))+(((-1.0)*x681))+(((-1.0)*x682)));
evalcond[2]=((0.4)+(((0.1)*x678))+(((-1.0)*x681*x685))+x683+x680+(((-1.0)*x682*x685)));
evalcond[3]=((((0.1)*x677))+(((-1.0)*x681*x684))+x679+(((-1.0)*x682*x684))+(((-1.0)*pz*x685)));
evalcond[4]=((-0.066959)+(((-0.08)*x678))+(((0.2)*x681))+(((0.2)*x682))+(((-1.0)*pp))+(((0.8)*x686))+(((0.8)*x678*x682))+(((-0.8)*x683)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x687=(cj15*px);
IkReal x688=((1000.0)*pz);
IkReal x689=((321.0)*cj18);
IkReal x690=(py*sj15);
CheckValue<IkReal> x691=IKPowWithIntegerCheck(IKsign(((-40.0)+(((400.0)*x690))+((x687*x689))+(((-321.0)*pz*sj18))+((x689*x690))+(((-32.1)*cj18))+(((400.0)*x687)))),-1);
if(!x691.valid){
continue;
}
CheckValue<IkReal> x692 = IKatan2WithCheck(IkReal(((((-1.0)*x687*x688))+(((100.0)*pz))+(((103.041)*cj18*sj18))+(((-1.0)*x688*x690))+(((128.4)*sj18)))),((160.0)+(((256.8)*cj18))+(((-1.0)*pz*x688))+(((103.041)*(cj18*cj18)))),IKFAST_ATAN2_MAGTHRESH);
if(!x692.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x691.value)))+(x692.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x693=IKsin(j16);
IkReal x694=IKcos(j16);
IkReal x695=((0.321)*sj18);
IkReal x696=((0.321)*cj18);
IkReal x697=(cj15*px);
IkReal x698=(py*sj15);
IkReal x699=(pz*x693);
IkReal x700=((1.0)*x693);
IkReal x701=((1.0)*x694);
IkReal x702=(x694*x697);
evalcond[0]=(((x693*x696))+(((0.4)*x693))+pz+(((-1.0)*x694*x695)));
evalcond[1]=((0.1)+((x694*x696))+((x693*x695))+(((0.4)*x694))+(((-1.0)*x698))+(((-1.0)*x697)));
evalcond[2]=((0.4)+(((0.1)*x694))+x696+x699+(((-1.0)*x698*x701))+(((-1.0)*x697*x701)));
evalcond[3]=((((-1.0)*pz*x701))+(((0.1)*x693))+x695+(((-1.0)*x698*x700))+(((-1.0)*x697*x700)));
evalcond[4]=((-0.066959)+(((0.8)*x694*x698))+(((-1.0)*pp))+(((-0.08)*x694))+(((-0.8)*x699))+(((0.8)*x702))+(((0.2)*x697))+(((0.2)*x698)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x703=((321000.0)*pz);
IkReal x704=((321000.0)*py*sj15);
IkReal x705=((321000.0)*cj15*px);
CheckValue<IkReal> x706=IKPowWithIntegerCheck(IKsign(((-263041.0)+(((-256800.0)*cj18)))),-1);
if(!x706.valid){
continue;
}
CheckValue<IkReal> x707 = IKatan2WithCheck(IkReal(((((-1.0)*sj18*x704))+(((-1.0)*sj18*x705))+((cj18*x703))+(((400000.0)*pz))+(((32100.0)*sj18)))),((40000.0)+(((32100.0)*cj18))+(((-1.0)*sj18*x703))+(((-400000.0)*cj15*px))+(((-400000.0)*py*sj15))+(((-1.0)*cj18*x704))+(((-1.0)*cj18*x705))),IKFAST_ATAN2_MAGTHRESH);
if(!x707.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x706.value)))+(x707.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x708=IKsin(j16);
IkReal x709=IKcos(j16);
IkReal x710=((0.321)*sj18);
IkReal x711=((0.321)*cj18);
IkReal x712=(cj15*px);
IkReal x713=(py*sj15);
IkReal x714=(pz*x708);
IkReal x715=((1.0)*x708);
IkReal x716=((1.0)*x709);
IkReal x717=(x709*x712);
evalcond[0]=((((0.4)*x708))+(((-1.0)*x709*x710))+pz+((x708*x711)));
evalcond[1]=((0.1)+(((0.4)*x709))+(((-1.0)*x713))+(((-1.0)*x712))+((x709*x711))+((x708*x710)));
evalcond[2]=((0.4)+(((0.1)*x709))+(((-1.0)*x712*x716))+x711+x714+(((-1.0)*x713*x716)));
evalcond[3]=((((-1.0)*pz*x716))+(((0.1)*x708))+(((-1.0)*x712*x715))+x710+(((-1.0)*x713*x715)));
evalcond[4]=((-0.066959)+(((0.8)*x709*x713))+(((-1.0)*pp))+(((-0.8)*x714))+(((0.2)*x712))+(((0.2)*x713))+(((0.8)*x717))+(((-0.08)*x709)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16, j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x718=IKPowWithIntegerCheck(sj17,-1);
if(!x718.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x718.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x718.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x718.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[2];
evalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*sj17*(IKsin(j18)))));
evalcond[1]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*(IKcos(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j16eval[3];
IkReal x719=(cj15*px);
IkReal x720=((1000.0)*pz);
IkReal x721=(py*sj15);
IkReal x722=((10.0)*cj18);
IkReal x723=((321.0)*cj18);
IkReal x724=(cj17*sj18);
IkReal x725=(pz*x724);
j16eval[0]=((-1.24610591900312)+((x721*x722))+(((12.4610591900312)*x719))+(((12.4610591900312)*x721))+(((10.0)*x725))+((x719*x722))+(((-1.0)*cj18)));
j16eval[1]=((IKabs(((160.0)+(((256.8)*cj18))+(((-1.0)*pz*x720))+(((103.041)*(cj18*cj18))))))+(IKabs(((((-103.041)*cj18*x724))+(((100.0)*pz))+(((-1.0)*x720*x721))+(((-1.0)*x719*x720))+(((-128.4)*x724))))));
j16eval[2]=IKsign(((-40.0)+((x721*x723))+(((400.0)*x721))+(((321.0)*x725))+(((400.0)*x719))+(((-32.1)*cj18))+((x719*x723))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
IkReal x726=cj17*cj17;
IkReal x727=cj18*cj18;
IkReal x728=(cj15*px);
IkReal x729=(py*sj15);
IkReal x730=((321000.0)*cj18);
IkReal x731=((321000.0)*cj17*sj18);
IkReal x732=((103041.0)*x727);
j16eval[0]=((1.5527799613746)+(((2.49221183800623)*cj18))+x726+x727+(((-1.0)*x726*x727)));
j16eval[1]=((IKabs(((-40000.0)+((x728*x730))+((x729*x730))+(((400000.0)*x729))+(((400000.0)*x728))+(((-32100.0)*cj18))+(((-1.0)*pz*x731)))))+(IKabs(((((32100.0)*cj17*sj18))+(((-400000.0)*pz))+(((-1.0)*pz*x730))+(((-1.0)*x728*x731))+(((-1.0)*x729*x731))))));
j16eval[2]=IKsign(((160000.0)+(((103041.0)*x726))+(((256800.0)*cj18))+x732+(((-1.0)*x726*x732))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[2];
IkReal x733=(cj17*sj18);
IkReal x734=(py*sj15);
IkReal x735=(cj18*pz);
IkReal x736=(cj15*px);
j16eval[0]=((((-10.0)*x733*x736))+(((-10.0)*x733*x734))+(((10.0)*x735))+x733+(((12.4610591900312)*pz)));
j16eval[1]=IKsign(((((321.0)*x735))+(((400.0)*pz))+(((-321.0)*x733*x734))+(((-321.0)*x733*x736))+(((32.1)*x733))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x737=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*sj18)));
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j17), 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=x737;
evalcond[2]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*cj18)));
evalcond[3]=x737;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
IkReal x738=((-1.0)*py);
pz=0;
j17=1.5707963267949;
sj17=1.0;
cj17=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x738);
rxp0_1=(px*r20);
rxp1_0=(r21*x738);
rxp1_1=(px*r21);
rxp2_0=(r22*x738);
rxp2_1=(px*r22);
j16eval[0]=((1.0)+(((-10.0)*cj15*px))+(((-10.0)*py*sj15)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
IkReal x739=((-1.0)*py);
pz=0;
j17=1.5707963267949;
sj17=1.0;
cj17=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x739);
rxp0_1=(px*r20);
rxp1_0=(r21*x739);
rxp1_1=(px*r21);
rxp2_0=(r22*x739);
rxp2_1=(px*r22);
j16eval[0]=((1.24610591900312)+cj18);
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x740=((((100.0)*(px*px)))+(((100.0)*(py*py))));
if((x740) < -0.00001)
continue;
IkReal x741=IKabs(IKsqrt(x740));
IkReal x747 = x740;
if(IKabs(x747)==0){
continue;
}
IkReal x742=pow(x747,-0.5);
CheckValue<IkReal> x748=IKPowWithIntegerCheck(x741,-1);
if(!x748.valid){
continue;
}
IkReal x743=x748.value;
IkReal x744=((10.0)*px*x742);
IkReal x745=((10.0)*py*x742);
if((((1.0)+(((-1.0)*(x743*x743))))) < -0.00001)
continue;
IkReal x746=IKsqrt(((1.0)+(((-1.0)*(x743*x743)))));
CheckValue<IkReal> x749 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x749.valid){
continue;
}
if( (x743) < -1-IKFAST_SINCOS_THRESH || (x743) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst24=((((-1.0)*(x749.value)))+(((-1.0)*(IKasin(x743)))));
IkReal gconst25=(((x744*x746))+((x743*x745)));
IkReal gconst26=((((-1.0)*x745*x746))+((x743*x744)));
IkReal x750=px*px;
IkReal x751=py*py;
IkReal x752=(((gconst25*px))+(((0.321)*sj18))+(((-1.0)*gconst26*py)));
if((((((100.0)*x750))+(((100.0)*x751)))) < -0.00001)
continue;
CheckValue<IkReal> x753=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x750))+(((100.0)*x751))))),-1);
if(!x753.valid){
continue;
}
if( (x753.value) < -1-IKFAST_SINCOS_THRESH || (x753.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x754 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x754.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x753.value))+j15+(x754.value))))), 6.28318530717959)));
evalcond[1]=x752;
evalcond[2]=((0.253041)+(((0.2)*gconst25*py))+(((0.2)*gconst26*px))+(((-1.0)*x751))+(((-1.0)*x750))+(((0.2568)*cj18)));
evalcond[3]=x752;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x756=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst25*py))+(((-1.0)*gconst26*px))),-1);
if(!x756.valid){
continue;
}
IkReal x755=x756.value;
cj16array[0]=((((-0.4)*x755))+(((-0.321)*cj18*x755)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x757=IKsin(j16);
IkReal x758=IKcos(j16);
IkReal x759=(gconst26*px);
IkReal x760=(gconst25*py);
IkReal x761=((0.321)*cj18);
IkReal x762=((0.8)*x758);
IkReal x763=((1.0)*x757);
evalcond[0]=(((x757*x761))+(((0.4)*x757)));
evalcond[1]=((((0.1)*x757))+(((-1.0)*x760*x763))+(((-1.0)*x759*x763)));
evalcond[2]=((0.1)+((x758*x761))+(((-1.0)*x760))+(((-1.0)*x759))+(((0.4)*x758)));
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((-0.08)*x758))+(((0.2)*x760))+((x760*x762))+((x759*x762))+(((0.2)*x759))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x764=((((100.0)*(px*px)))+(((100.0)*(py*py))));
IkReal x771 = x764;
if(IKabs(x771)==0){
continue;
}
IkReal x765=pow(x771,-0.5);
if((x764) < -0.00001)
continue;
IkReal x766=IKabs(IKsqrt(x764));
CheckValue<IkReal> x772=IKPowWithIntegerCheck(x766,-1);
if(!x772.valid){
continue;
}
IkReal x767=x772.value;
IkReal x768=((10.0)*px*x765);
IkReal x769=((10.0)*py*x765);
if((((1.0)+(((-1.0)*(x767*x767))))) < -0.00001)
continue;
IkReal x770=IKsqrt(((1.0)+(((-1.0)*(x767*x767)))));
if( (x767) < -1-IKFAST_SINCOS_THRESH || (x767) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x773 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x773.valid){
continue;
}
IkReal gconst27=((3.14159265358979)+(IKasin(x767))+(((-1.0)*(x773.value))));
IkReal gconst28=((((-1.0)*x768*x770))+((x767*x769)));
IkReal gconst29=(((x769*x770))+((x767*x768)));
IkReal x774=px*px;
IkReal x775=py*py;
IkReal x776=((((-1.0)*gconst29*py))+(((0.321)*sj18))+((gconst28*px)));
if((((((100.0)*x775))+(((100.0)*x774)))) < -0.00001)
continue;
CheckValue<IkReal> x777=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x775))+(((100.0)*x774))))),-1);
if(!x777.valid){
continue;
}
if( (x777.value) < -1-IKFAST_SINCOS_THRESH || (x777.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x778 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x778.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j15+(((-1.0)*(IKasin(x777.value))))+(x778.value))))), 6.28318530717959)));
evalcond[1]=x776;
evalcond[2]=((0.253041)+(((0.2)*gconst29*px))+(((-1.0)*x774))+(((-1.0)*x775))+(((0.2568)*cj18))+(((0.2)*gconst28*py)));
evalcond[3]=x776;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x780=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst29*px))+(((-1.0)*gconst28*py))),-1);
if(!x780.valid){
continue;
}
IkReal x779=x780.value;
cj16array[0]=((((-0.4)*x779))+(((-0.321)*cj18*x779)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x781=IKsin(j16);
IkReal x782=IKcos(j16);
IkReal x783=(gconst29*px);
IkReal x784=((0.321)*cj18);
IkReal x785=(gconst28*py);
IkReal x786=((1.0)*x781);
IkReal x787=((0.8)*x782);
evalcond[0]=(((x781*x784))+(((0.4)*x781)));
evalcond[1]=((((0.1)*x781))+(((-1.0)*x785*x786))+(((-1.0)*x783*x786)));
evalcond[2]=((0.1)+((x782*x784))+(((-1.0)*x783))+(((-1.0)*x785))+(((0.4)*x782)));
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+((x785*x787))+((x783*x787))+(((-0.08)*x782))+(((0.2)*x783))+(((0.2)*x785))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x789=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj18))),-1);
if(!x789.valid){
continue;
}
IkReal x788=x789.value;
cj16array[0]=(((cj15*px*x788))+(((-0.1)*x788))+((py*sj15*x788)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x790=IKsin(j16);
IkReal x791=IKcos(j16);
IkReal x792=(cj15*px);
IkReal x793=((0.321)*cj18);
IkReal x794=(py*sj15);
IkReal x795=((1.0)*x794);
IkReal x796=((0.8)*x791);
evalcond[0]=(((x790*x793))+(((0.4)*x790)));
evalcond[1]=((((-1.0)*x790*x795))+(((0.1)*x790))+(((-1.0)*x790*x792)));
evalcond[2]=((0.4)+(((-1.0)*x791*x795))+(((0.1)*x791))+(((-1.0)*x791*x792))+x793);
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((-0.08)*x791))+(((0.2)*x792))+(((0.2)*x794))+((x792*x796))+((x794*x796))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x798=IKPowWithIntegerCheck(((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15))),-1);
if(!x798.valid){
continue;
}
IkReal x797=x798.value;
cj16array[0]=((((-0.321)*cj18*x797))+(((-0.4)*x797)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x799=IKsin(j16);
IkReal x800=IKcos(j16);
IkReal x801=(py*sj15);
IkReal x802=((0.321)*cj18);
IkReal x803=(cj15*px);
IkReal x804=((1.0)*x799);
IkReal x805=((0.8)*x800);
evalcond[0]=(((x799*x802))+(((0.4)*x799)));
evalcond[1]=((((0.1)*x799))+(((-1.0)*x803*x804))+(((-1.0)*x801*x804)));
evalcond[2]=((0.1)+(((-1.0)*x801))+(((-1.0)*x803))+((x800*x802))+(((0.4)*x800)));
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((0.2)*x801))+(((0.2)*x803))+(((-0.08)*x800))+((x803*x805))+((x801*x805))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x806=((0.321)*sj18);
IkReal x807=(cj15*py);
IkReal x808=(px*sj15);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j17), 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=((((-1.0)*x807))+x808+(((-1.0)*x806)));
evalcond[2]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*cj18)));
evalcond[3]=((((-1.0)*x808))+x807+x806);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
IkReal x809=((-1.0)*py);
pz=0;
j17=-1.5707963267949;
sj17=-1.0;
cj17=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x809);
rxp0_1=(px*r20);
rxp1_0=(r21*x809);
rxp1_1=(px*r21);
rxp2_0=(r22*x809);
rxp2_1=(px*r22);
j16eval[0]=((1.0)+(((-10.0)*cj15*px))+(((-10.0)*py*sj15)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
IkReal x810=((-1.0)*py);
pz=0;
j17=-1.5707963267949;
sj17=-1.0;
cj17=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x810);
rxp0_1=(px*r20);
rxp1_0=(r21*x810);
rxp1_1=(px*r21);
rxp2_0=(r22*x810);
rxp2_1=(px*r22);
j16eval[0]=((1.24610591900312)+cj18);
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x811=((((100.0)*(px*px)))+(((100.0)*(py*py))));
if((x811) < -0.00001)
continue;
IkReal x812=IKabs(IKsqrt(x811));
IkReal x818 = x811;
if(IKabs(x818)==0){
continue;
}
IkReal x813=pow(x818,-0.5);
CheckValue<IkReal> x819=IKPowWithIntegerCheck(x812,-1);
if(!x819.valid){
continue;
}
IkReal x814=x819.value;
IkReal x815=((10.0)*px*x813);
IkReal x816=((10.0)*py*x813);
if((((1.0)+(((-1.0)*(x814*x814))))) < -0.00001)
continue;
IkReal x817=IKsqrt(((1.0)+(((-1.0)*(x814*x814)))));
CheckValue<IkReal> x820 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x820.valid){
continue;
}
if( (x814) < -1-IKFAST_SINCOS_THRESH || (x814) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst30=((((-1.0)*(x820.value)))+(((-1.0)*(IKasin(x814)))));
IkReal gconst31=(((x815*x817))+((x814*x816)));
IkReal gconst32=((((-1.0)*x816*x817))+((x814*x815)));
IkReal x821=px*px;
IkReal x822=py*py;
IkReal x823=((0.321)*sj18);
IkReal x824=(gconst32*py);
IkReal x825=(gconst31*px);
CheckValue<IkReal> x826 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x826.valid){
continue;
}
if((((((100.0)*x822))+(((100.0)*x821)))) < -0.00001)
continue;
CheckValue<IkReal> x827=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x822))+(((100.0)*x821))))),-1);
if(!x827.valid){
continue;
}
if( (x827.value) < -1-IKFAST_SINCOS_THRESH || (x827.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j15+(x826.value)+(IKasin(x827.value)))))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x823))+(((-1.0)*x824))+x825);
evalcond[2]=((0.253041)+(((0.2)*gconst32*px))+(((-1.0)*x821))+(((-1.0)*x822))+(((0.2)*gconst31*py))+(((0.2568)*cj18)));
evalcond[3]=((((-1.0)*x825))+x823+x824);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x829=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst32*px))+(((-1.0)*gconst31*py))),-1);
if(!x829.valid){
continue;
}
IkReal x828=x829.value;
cj16array[0]=((((-0.4)*x828))+(((-0.321)*cj18*x828)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x830=IKsin(j16);
IkReal x831=IKcos(j16);
IkReal x832=(gconst32*px);
IkReal x833=(gconst31*py);
IkReal x834=((0.321)*cj18);
IkReal x835=((0.8)*x831);
evalcond[0]=((((0.4)*x830))+((x830*x834)));
evalcond[1]=(((x830*x832))+((x830*x833))+(((-0.1)*x830)));
evalcond[2]=((0.1)+((x831*x834))+(((0.4)*x831))+(((-1.0)*x832))+(((-1.0)*x833)));
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((-0.08)*x831))+((x832*x835))+((x833*x835))+(((0.2)*x832))+(((0.2)*x833))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x836=((((100.0)*(px*px)))+(((100.0)*(py*py))));
IkReal x843 = x836;
if(IKabs(x843)==0){
continue;
}
IkReal x837=pow(x843,-0.5);
if((x836) < -0.00001)
continue;
IkReal x838=IKabs(IKsqrt(x836));
CheckValue<IkReal> x844=IKPowWithIntegerCheck(x838,-1);
if(!x844.valid){
continue;
}
IkReal x839=x844.value;
IkReal x840=((10.0)*px*x837);
IkReal x841=((10.0)*py*x837);
if((((1.0)+(((-1.0)*(x839*x839))))) < -0.00001)
continue;
IkReal x842=IKsqrt(((1.0)+(((-1.0)*(x839*x839)))));
if( (x839) < -1-IKFAST_SINCOS_THRESH || (x839) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x845 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x845.valid){
continue;
}
IkReal gconst33=((3.14159265358979)+(IKasin(x839))+(((-1.0)*(x845.value))));
IkReal gconst34=(((x839*x841))+(((-1.0)*x840*x842)));
IkReal gconst35=(((x839*x840))+((x841*x842)));
IkReal x846=px*px;
IkReal x847=py*py;
IkReal x848=((0.321)*sj18);
IkReal x849=(gconst35*py);
IkReal x850=(gconst34*px);
CheckValue<IkReal> x851 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x851.valid){
continue;
}
if((((((100.0)*x846))+(((100.0)*x847)))) < -0.00001)
continue;
CheckValue<IkReal> x852=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*x846))+(((100.0)*x847))))),-1);
if(!x852.valid){
continue;
}
if( (x852.value) < -1-IKFAST_SINCOS_THRESH || (x852.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j15+(x851.value)+(((-1.0)*(IKasin(x852.value)))))))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x848))+(((-1.0)*x849))+x850);
evalcond[2]=((0.253041)+(((0.2)*gconst35*px))+(((0.2)*gconst34*py))+(((-1.0)*x846))+(((-1.0)*x847))+(((0.2568)*cj18)));
evalcond[3]=((((-1.0)*x850))+x849+x848);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x854=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst34*py))+(((-1.0)*gconst35*px))),-1);
if(!x854.valid){
continue;
}
IkReal x853=x854.value;
cj16array[0]=((((-0.321)*cj18*x853))+(((-0.4)*x853)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x855=IKsin(j16);
IkReal x856=IKcos(j16);
IkReal x857=(gconst34*py);
IkReal x858=(gconst35*px);
IkReal x859=((0.321)*cj18);
IkReal x860=((0.8)*x856);
evalcond[0]=(((x855*x859))+(((0.4)*x855)));
evalcond[1]=(((x855*x858))+((x855*x857))+(((-0.1)*x855)));
evalcond[2]=((0.1)+(((-1.0)*x858))+(((-1.0)*x857))+((x856*x859))+(((0.4)*x856)));
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+((x858*x860))+(((-0.08)*x856))+(((-1.0)*(py*py)))+((x857*x860))+(((0.2)*x858))+(((0.2)*x857)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x862=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj18))),-1);
if(!x862.valid){
continue;
}
IkReal x861=x862.value;
cj16array[0]=((((-0.1)*x861))+((cj15*px*x861))+((py*sj15*x861)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x863=IKsin(j16);
IkReal x864=IKcos(j16);
IkReal x865=(cj15*px);
IkReal x866=(py*sj15);
IkReal x867=((0.321)*cj18);
IkReal x868=((1.0)*x864);
IkReal x869=((0.8)*x864);
evalcond[0]=(((x863*x867))+(((0.4)*x863)));
evalcond[1]=(((x863*x865))+((x863*x866))+(((-0.1)*x863)));
evalcond[2]=((0.4)+(((-1.0)*x865*x868))+(((-1.0)*x866*x868))+(((0.1)*x864))+x867);
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((0.2)*x866))+(((0.2)*x865))+((x866*x869))+((x865*x869))+(((-1.0)*(py*py)))+(((-0.08)*x864)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x871=IKPowWithIntegerCheck(((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15))),-1);
if(!x871.valid){
continue;
}
IkReal x870=x871.value;
cj16array[0]=((((-0.4)*x870))+(((-0.321)*cj18*x870)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x872=IKsin(j16);
IkReal x873=IKcos(j16);
IkReal x874=(py*sj15);
IkReal x875=((0.321)*cj18);
IkReal x876=(cj15*px);
IkReal x877=((0.8)*x873);
evalcond[0]=(((x872*x875))+(((0.4)*x872)));
evalcond[1]=(((x872*x874))+((x872*x876))+(((-0.1)*x872)));
evalcond[2]=((0.1)+(((-1.0)*x876))+(((-1.0)*x874))+((x873*x875))+(((0.4)*x873)));
evalcond[3]=((-0.066959)+((x876*x877))+(((-1.0)*(px*px)))+(((0.2)*x876))+(((0.2)*x874))+((x874*x877))+(((-0.08)*x873))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j18), 6.28318530717959))))));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[2]=((0.509841)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj15))+(((1.3869625520111)*cj15*px)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x878=IKcos(j16);
IkReal x879=IKsin(j16);
CheckValue<IkReal> x889=IKPowWithIntegerCheck(px,-1);
if(!x889.valid){
continue;
}
IkReal x880=x889.value;
IkReal x881=py*py;
IkReal x882=((1.0)*cj15);
IkReal x883=(cj15*cj17);
IkReal x884=((0.8)*cj15);
IkReal x885=(px*x878);
IkReal x886=(px*x879);
IkReal x887=((0.1)*x879);
IkReal x888=(x879*x880*x881);
evalcond[0]=((0.721)*x879);
evalcond[1]=((0.721)+(((-1.0)*x882*x885))+(((0.1)*x878))+(((-1.0)*py*sj15*x878)));
evalcond[2]=((-0.5768)+((x878*x880*x881*x884))+(((-0.08)*x878))+((x884*x885)));
evalcond[3]=(((x883*x886))+((x883*x888))+(((-1.0)*cj17*x887)));
evalcond[4]=(((sj17*x887))+(((-1.0)*sj17*x882*x888))+(((-1.0)*sj17*x882*x886)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j18, 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[2]=((-0.003759)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-1.26582278481013)+(((12.6582278481013)*cj15*px))+(((12.6582278481013)*py*sj15)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x890=IKcos(j16);
IkReal x891=IKsin(j16);
CheckValue<IkReal> x901=IKPowWithIntegerCheck(px,-1);
if(!x901.valid){
continue;
}
IkReal x892=x901.value;
IkReal x893=py*py;
IkReal x894=((1.0)*cj15);
IkReal x895=(cj15*cj17);
IkReal x896=((0.8)*cj15);
IkReal x897=(px*x890);
IkReal x898=(px*x891);
IkReal x899=((0.1)*x891);
IkReal x900=(x891*x892*x893);
evalcond[0]=((0.079)*x891);
evalcond[1]=((0.079)+(((-1.0)*py*sj15*x890))+(((-1.0)*x894*x897))+(((0.1)*x890)));
evalcond[2]=((-0.0632)+((x896*x897))+((x890*x892*x893*x896))+(((-0.08)*x890)));
evalcond[3]=(((x895*x900))+((x895*x898))+(((-1.0)*cj17*x899)));
evalcond[4]=((((-1.0)*sj17*x894*x898))+(((-1.0)*sj17*x894*x900))+((sj17*x899)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x902=cj15*cj15;
IkReal x903=py*py;
IkReal x904=(py*sj15);
IkReal x905=(cj15*px);
IkReal x906=((1000.0)*pz);
IkReal x907=(cj17*sj18);
IkReal x908=((1000.0)*x902);
CheckValue<IkReal> x909=IKPowWithIntegerCheck(IKsign(((((-321.0)*x904*x907))+(((-321.0)*x905*x907))+(((321.0)*cj18*pz))+(((400.0)*pz))+(((32.1)*x907)))),-1);
if(!x909.valid){
continue;
}
CheckValue<IkReal> x910 = IKatan2WithCheck(IkReal(((-150.0)+(((-1.0)*x903*x908))+((x908*(px*px)))+(((-256.8)*cj18))+(((-200.0)*x904))+(((-200.0)*x905))+(((2000.0)*x904*x905))+(((-103.041)*(cj18*cj18)))+(((1000.0)*x903)))),((((-100.0)*pz))+((x905*x906))+(((-128.4)*x907))+(((-103.041)*cj18*x907))+((x904*x906))),IKFAST_ATAN2_MAGTHRESH);
if(!x910.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x909.value)))+(x910.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x911=IKsin(j16);
IkReal x912=IKcos(j16);
IkReal x913=((0.321)*sj18);
IkReal x914=(cj15*px);
IkReal x915=(py*sj15);
IkReal x916=(px*sj15);
IkReal x917=((1.0)*sj17);
IkReal x918=(cj15*py);
IkReal x919=((0.321)*cj18);
IkReal x920=(pz*x912);
IkReal x921=((1.0)*x914);
IkReal x922=((0.321)*x912);
IkReal x923=(sj17*x911);
IkReal x924=(pz*x911);
IkReal x925=((0.8)*x912);
IkReal x926=(cj17*x911);
evalcond[0]=(((cj17*x912*x913))+((x911*x919))+pz+(((0.4)*x911)));
evalcond[1]=((0.1)+(((-1.0)*x921))+(((0.4)*x912))+(((-1.0)*x915))+(((-1.0)*x913*x926))+((x912*x919)));
evalcond[2]=((0.4)+(((-1.0)*x912*x921))+(((-1.0)*x912*x915))+(((0.1)*x912))+x924+x919);
evalcond[3]=((-0.066959)+(((0.2)*x915))+(((0.2)*x914))+((x915*x925))+(((-0.08)*x912))+(((-0.8)*x924))+(((-1.0)*pp))+((x914*x925)));
evalcond[4]=((((0.1)*x923))+(((-1.0)*x911*x914*x917))+(((-1.0)*cj17*x918))+((cj17*x916))+(((-1.0)*x911*x915*x917))+(((-1.0)*x917*x920)));
evalcond[5]=(((x915*x926))+((cj17*x920))+(((-0.1)*x926))+((sj17*x916))+((x914*x926))+x913+(((-1.0)*x917*x918)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x927=cj17*cj17;
IkReal x928=cj18*cj18;
IkReal x929=(cj15*px);
IkReal x930=(py*sj15);
IkReal x931=((321000.0)*cj18);
IkReal x932=((321000.0)*cj17*sj18);
IkReal x933=((103041.0)*x928);
CheckValue<IkReal> x934 = IKatan2WithCheck(IkReal(((((32100.0)*cj17*sj18))+(((-1.0)*x930*x932))+(((-400000.0)*pz))+(((-1.0)*x929*x932))+(((-1.0)*pz*x931)))),((-40000.0)+((x930*x931))+(((-32100.0)*cj18))+(((-1.0)*pz*x932))+(((400000.0)*x930))+(((400000.0)*x929))+((x929*x931))),IKFAST_ATAN2_MAGTHRESH);
if(!x934.valid){
continue;
}
CheckValue<IkReal> x935=IKPowWithIntegerCheck(IKsign(((160000.0)+(((-1.0)*x927*x933))+(((256800.0)*cj18))+(((103041.0)*x927))+x933)),-1);
if(!x935.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x934.value)+(((1.5707963267949)*(x935.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x936=IKsin(j16);
IkReal x937=IKcos(j16);
IkReal x938=((0.321)*sj18);
IkReal x939=(cj15*px);
IkReal x940=(py*sj15);
IkReal x941=(px*sj15);
IkReal x942=((1.0)*sj17);
IkReal x943=(cj15*py);
IkReal x944=((0.321)*cj18);
IkReal x945=(pz*x937);
IkReal x946=((1.0)*x939);
IkReal x947=((0.321)*x937);
IkReal x948=(sj17*x936);
IkReal x949=(pz*x936);
IkReal x950=((0.8)*x937);
IkReal x951=(cj17*x936);
evalcond[0]=(((x936*x944))+((cj17*x937*x938))+pz+(((0.4)*x936)));
evalcond[1]=((0.1)+(((-1.0)*x946))+(((-1.0)*x938*x951))+((x937*x944))+(((-1.0)*x940))+(((0.4)*x937)));
evalcond[2]=((0.4)+(((0.1)*x937))+(((-1.0)*x937*x940))+(((-1.0)*x937*x946))+x949+x944);
evalcond[3]=((-0.066959)+(((-0.08)*x937))+((x940*x950))+(((-0.8)*x949))+(((0.2)*x939))+(((0.2)*x940))+(((-1.0)*pp))+((x939*x950)));
evalcond[4]=(((cj17*x941))+(((-1.0)*cj17*x943))+(((-1.0)*x942*x945))+(((-1.0)*x936*x940*x942))+(((0.1)*x948))+(((-1.0)*x936*x939*x942)));
evalcond[5]=(((cj17*x945))+((x940*x951))+(((-0.1)*x951))+(((-1.0)*x942*x943))+((sj17*x941))+((x939*x951))+x938);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x952=(cj15*px);
IkReal x953=((1000.0)*pz);
IkReal x954=(cj17*sj18);
IkReal x955=((321.0)*cj18);
IkReal x956=(py*sj15);
CheckValue<IkReal> x957=IKPowWithIntegerCheck(IKsign(((-40.0)+(((321.0)*pz*x954))+((x955*x956))+((x952*x955))+(((400.0)*x956))+(((400.0)*x952))+(((-32.1)*cj18)))),-1);
if(!x957.valid){
continue;
}
CheckValue<IkReal> x958 = IKatan2WithCheck(IkReal(((((100.0)*pz))+(((-128.4)*x954))+(((-103.041)*cj18*x954))+(((-1.0)*x953*x956))+(((-1.0)*x952*x953)))),((160.0)+(((-1.0)*pz*x953))+(((256.8)*cj18))+(((103.041)*(cj18*cj18)))),IKFAST_ATAN2_MAGTHRESH);
if(!x958.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x957.value)))+(x958.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x959=IKsin(j16);
IkReal x960=IKcos(j16);
IkReal x961=((0.321)*sj18);
IkReal x962=(cj15*px);
IkReal x963=(py*sj15);
IkReal x964=(px*sj15);
IkReal x965=((1.0)*sj17);
IkReal x966=(cj15*py);
IkReal x967=((0.321)*cj18);
IkReal x968=(pz*x960);
IkReal x969=((1.0)*x962);
IkReal x970=((0.321)*x960);
IkReal x971=(sj17*x959);
IkReal x972=(pz*x959);
IkReal x973=((0.8)*x960);
IkReal x974=(cj17*x959);
evalcond[0]=(((cj17*x960*x961))+pz+((x959*x967))+(((0.4)*x959)));
evalcond[1]=((0.1)+(((-1.0)*x963))+((x960*x967))+(((-1.0)*x961*x974))+(((-1.0)*x969))+(((0.4)*x960)));
evalcond[2]=((0.4)+(((-1.0)*x960*x969))+(((-1.0)*x960*x963))+(((0.1)*x960))+x972+x967);
evalcond[3]=((-0.066959)+(((-0.8)*x972))+((x963*x973))+((x962*x973))+(((-1.0)*pp))+(((0.2)*x962))+(((0.2)*x963))+(((-0.08)*x960)));
evalcond[4]=((((0.1)*x971))+(((-1.0)*x959*x962*x965))+(((-1.0)*x965*x968))+((cj17*x964))+(((-1.0)*cj17*x966))+(((-1.0)*x959*x963*x965)));
evalcond[5]=((((-0.1)*x974))+((sj17*x964))+(((-1.0)*x965*x966))+((cj17*x968))+((x963*x974))+((x962*x974))+x961);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x975=py*py;
IkReal x976=cj15*cj15;
IkReal x977=px*px;
IkReal x978=((5.0)*pp);
IkReal x979=(py*sj15);
IkReal x980=(pz*sj17);
IkReal x981=(cj17*py);
IkReal x982=(cj15*px*sj17);
IkReal x983=((4.0)*x975);
IkReal x984=(cj15*cj17*sj15);
IkReal x985=(sj17*x976);
IkReal x986=((4.0)*x977);
IkReal x987=((4.0)*x981);
IkReal x988=(cj17*px*sj15);
CheckValue<IkReal> x989 = IKatan2WithCheck(IkReal(((((-1.0)*px*x987))+((x983*x984))+(((0.4)*x988))+(((8.0)*px*x976*x981))+(((-1.0)*cj15*px*x980))+(((-1.0)*x979*x980))+(((-1.0)*x984*x986))+(((-0.4)*cj15*x981))+(((0.334795)*x980))+((x978*x980)))),((((2.0)*x979*x982))+(((-4.0)*pz*x988))+((cj15*pz*x987))+((x977*x985))+(((-1.0)*sj17*x978*x979))+(((0.5)*pp*sj17))+(((-1.0)*x978*x982))+(((-1.0)*x975*x985))+(((-0.434795)*x982))+(((0.0334795)*sj17))+((sj17*x975))+(((-0.434795)*sj17*x979))),IKFAST_ATAN2_MAGTHRESH);
if(!x989.valid){
continue;
}
CheckValue<IkReal> x990=IKPowWithIntegerCheck(IKsign((((x983*x985))+(((-4.0)*pz*x980))+(((0.8)*sj17*x979))+(((-8.0)*x979*x982))+(((-1.0)*x985*x986))+(((0.8)*x982))+(((-0.04)*sj17))+(((-1.0)*sj17*x983)))),-1);
if(!x990.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x989.value)+(((1.5707963267949)*(x990.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[2];
IkReal x991=IKcos(j16);
IkReal x992=IKsin(j16);
IkReal x993=((1.0)*py);
IkReal x994=(cj15*px);
IkReal x995=(py*sj15);
IkReal x996=(sj17*x992);
IkReal x997=((0.8)*x991);
evalcond[0]=((-0.066959)+((x994*x997))+(((-1.0)*pp))+(((-0.08)*x991))+(((-0.8)*pz*x992))+((x995*x997))+(((0.2)*x994))+(((0.2)*x995)));
evalcond[1]=((((-1.0)*cj15*cj17*x993))+(((-1.0)*pz*sj17*x991))+(((0.1)*x996))+((cj17*px*sj15))+(((-1.0)*sj15*x993*x996))+(((-1.0)*x994*x996)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j18eval[1];
j18eval[0]=sj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal j18eval[2];
j18eval[0]=cj16;
j18eval[1]=cj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  )
{
{
IkReal j18eval[2];
j18eval[0]=sj17;
j18eval[1]=sj16;
if( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x998=(py*sj15);
IkReal x999=((0.8)*cj16);
IkReal x1000=(cj15*px);
IkReal x1001=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=x1001;
evalcond[2]=((-0.066959)+(((0.2)*x1000))+((x1000*x999))+((x998*x999))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+(((0.2)*x998)));
evalcond[3]=x1001;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1002=((3.11526479750779)*cj16);
IkReal x1003=(py*sj15);
IkReal x1004=((3.11526479750779)*sj16);
IkReal x1005=(cj15*px);
if( IKabs(((((-1.0)*pz*x1002))+(((0.311526479750779)*sj16))+(((-1.0)*x1004*x1005))+(((-1.0)*x1003*x1004)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-1.0)*pz*x1004))+((x1002*x1005))+((x1002*x1003))+(((-0.311526479750779)*cj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*pz*x1002))+(((0.311526479750779)*sj16))+(((-1.0)*x1004*x1005))+(((-1.0)*x1003*x1004))))+IKsqr(((-1.24610591900312)+(((-1.0)*pz*x1004))+((x1002*x1005))+((x1002*x1003))+(((-0.311526479750779)*cj16))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*pz*x1002))+(((0.311526479750779)*sj16))+(((-1.0)*x1004*x1005))+(((-1.0)*x1003*x1004))), ((-1.24610591900312)+(((-1.0)*pz*x1004))+((x1002*x1005))+((x1002*x1003))+(((-0.311526479750779)*cj16))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1006=IKcos(j18);
IkReal x1007=IKsin(j18);
IkReal x1008=(py*sj15);
IkReal x1009=(cj15*px);
IkReal x1010=((1.0)*cj16);
IkReal x1011=((0.321)*x1006);
IkReal x1012=((0.321)*x1007);
evalcond[0]=((((0.4)*sj16))+pz+((cj16*x1012))+((sj16*x1011)));
evalcond[1]=((0.253041)+(((0.2)*x1008))+(((0.2)*x1009))+(((-1.0)*pp))+(((0.2568)*x1006)));
evalcond[2]=((((-0.1)*sj16))+x1012+((sj16*x1008))+((sj16*x1009))+((cj16*pz)));
evalcond[3]=((0.4)+x1011+(((-1.0)*x1009*x1010))+(((-1.0)*x1008*x1010))+((pz*sj16))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((-1.0)*x1009))+(((-1.0)*x1008))+(((0.4)*cj16))+((cj16*x1011))+(((-1.0)*sj16*x1012)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1013=(py*sj15);
IkReal x1014=(cj15*py);
IkReal x1015=((0.8)*cj16);
IkReal x1016=(cj15*px);
IkReal x1017=(px*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=(x1017+(((-1.0)*x1014)));
evalcond[2]=((-0.066959)+((x1013*x1015))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1015*x1016))+(((0.2)*x1016))+(((0.2)*x1013)));
evalcond[3]=(x1014+(((-1.0)*x1017)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1018=((3.11526479750779)*cj16);
IkReal x1019=((3.11526479750779)*sj16);
IkReal x1020=(py*sj15);
IkReal x1021=(cj15*px);
if( IKabs(((((-0.311526479750779)*sj16))+((x1019*x1021))+((x1019*x1020))+((pz*x1018)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-1.0)*pz*x1019))+((x1018*x1021))+((x1018*x1020))+(((-0.311526479750779)*cj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-0.311526479750779)*sj16))+((x1019*x1021))+((x1019*x1020))+((pz*x1018))))+IKsqr(((-1.24610591900312)+(((-1.0)*pz*x1019))+((x1018*x1021))+((x1018*x1020))+(((-0.311526479750779)*cj16))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-0.311526479750779)*sj16))+((x1019*x1021))+((x1019*x1020))+((pz*x1018))), ((-1.24610591900312)+(((-1.0)*pz*x1019))+((x1018*x1021))+((x1018*x1020))+(((-0.311526479750779)*cj16))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1022=IKcos(j18);
IkReal x1023=IKsin(j18);
IkReal x1024=((1.0)*cj16);
IkReal x1025=(py*sj15);
IkReal x1026=(cj15*px);
IkReal x1027=((0.321)*x1022);
IkReal x1028=((1.0)*x1026);
IkReal x1029=((0.321)*x1023);
evalcond[0]=(((sj16*x1027))+(((0.4)*sj16))+pz+(((-1.0)*cj16*x1029)));
evalcond[1]=((0.253041)+(((0.2568)*x1022))+(((-1.0)*pp))+(((0.2)*x1025))+(((0.2)*x1026)));
evalcond[2]=((0.4)+x1027+((pz*sj16))+(((-1.0)*x1024*x1026))+(((-1.0)*x1024*x1025))+(((0.1)*cj16)));
evalcond[3]=((((-1.0)*pz*x1024))+x1029+(((0.1)*sj16))+(((-1.0)*sj16*x1028))+(((-1.0)*sj16*x1025)));
evalcond[4]=((0.1)+(((-1.0)*x1025))+((sj16*x1029))+(((-1.0)*x1028))+(((0.4)*cj16))+((cj16*x1027)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j16))), 6.28318530717959)));
evalcond[1]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));
evalcond[2]=((((-1.0)*cj15*cj17*py))+(((-1.0)*pz*sj17))+((cj17*px*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18eval[1];
sj16=0;
cj16=1.0;
j16=0;
j18eval[0]=cj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal j18eval[1];
sj16=0;
cj16=1.0;
j16=0;
j18eval[0]=sj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x1030=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=x1030;
evalcond[2]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));
evalcond[3]=x1030;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1031=IKcos(j18);
IkReal x1032=(py*sj15);
IkReal x1033=(cj15*px);
evalcond[0]=(pz+(((0.321)*(IKsin(j18)))));
evalcond[1]=((0.4)+(((0.2568)*x1031))+(((-0.8)*x1032))+(((-0.8)*x1033)));
evalcond[2]=((0.5)+(((0.321)*x1031))+(((-1.0)*x1032))+(((-1.0)*x1033)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1034=(cj15*py);
IkReal x1035=(px*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=(x1035+(((-1.0)*x1034)));
evalcond[2]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));
evalcond[3]=(x1034+(((-1.0)*x1035)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1036=IKcos(j18);
IkReal x1037=(py*sj15);
IkReal x1038=(cj15*px);
evalcond[0]=((((-0.321)*(IKsin(j18))))+pz);
evalcond[1]=((0.4)+(((0.2568)*x1036))+(((-0.8)*x1038))+(((-0.8)*x1037)));
evalcond[2]=((0.5)+(((0.321)*x1036))+(((-1.0)*x1037))+(((-1.0)*x1038)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=pz;
evalcond[2]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1039=((3.11526479750779)*cj15);
IkReal x1040=((3.11526479750779)*sj15);
if( IKabs(((((-1.0)*px*x1040))+((py*x1039)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+((px*x1039))+((py*x1040)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*px*x1040))+((py*x1039))))+IKsqr(((-1.55763239875389)+((px*x1039))+((py*x1040))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*px*x1040))+((py*x1039))), ((-1.55763239875389)+((px*x1039))+((py*x1040))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1041=IKcos(j18);
IkReal x1042=(py*sj15);
IkReal x1043=(cj15*px);
evalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));
evalcond[1]=((0.4)+(((0.2568)*x1041))+(((-0.8)*x1043))+(((-0.8)*x1042)));
evalcond[2]=((0.5)+(((0.321)*x1041))+(((-1.0)*x1043))+(((-1.0)*x1042)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=pz;
evalcond[2]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1044=((3.11526479750779)*cj15);
IkReal x1045=((3.11526479750779)*sj15);
if( IKabs((((px*x1045))+(((-1.0)*py*x1044)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+((px*x1044))+((py*x1045)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((px*x1045))+(((-1.0)*py*x1044))))+IKsqr(((-1.55763239875389)+((px*x1044))+((py*x1045))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2((((px*x1045))+(((-1.0)*py*x1044))), ((-1.55763239875389)+((px*x1044))+((py*x1045))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1046=IKcos(j18);
IkReal x1047=(py*sj15);
IkReal x1048=(cj15*px);
evalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));
evalcond[1]=((0.4)+(((0.2568)*x1046))+(((-0.8)*x1047))+(((-0.8)*x1048)));
evalcond[2]=((0.5)+(((0.321)*x1046))+(((-1.0)*x1048))+(((-1.0)*x1047)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1049=IKPowWithIntegerCheck(sj17,-1);
if(!x1049.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1049.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1049.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1049.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1050=IKsin(j18);
IkReal x1051=IKcos(j18);
IkReal x1052=(py*sj15);
IkReal x1053=(cj15*px);
IkReal x1054=(px*sj15);
IkReal x1055=((0.321)*x1050);
IkReal x1056=((1.0)*cj15*py);
evalcond[0]=(((cj17*x1055))+pz);
evalcond[1]=((((-1.0)*x1056))+x1054+((sj17*x1055)));
evalcond[2]=((0.4)+(((-0.8)*x1052))+(((-0.8)*x1053))+(((0.2568)*x1051)));
evalcond[3]=((0.5)+(((0.321)*x1051))+(((-1.0)*x1052))+(((-1.0)*x1053)));
evalcond[4]=(x1055+(((-1.0)*sj17*x1056))+((cj17*pz))+((sj17*x1054)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1057=IKPowWithIntegerCheck(cj17,-1);
if(!x1057.valid){
continue;
}
if( IKabs(((-3.11526479750779)*pz*(x1057.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz*(x1057.value)))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-3.11526479750779)*pz*(x1057.value)), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1058=IKsin(j18);
IkReal x1059=IKcos(j18);
IkReal x1060=(py*sj15);
IkReal x1061=(cj15*px);
IkReal x1062=(px*sj15);
IkReal x1063=((0.321)*x1058);
IkReal x1064=((1.0)*cj15*py);
evalcond[0]=(((cj17*x1063))+pz);
evalcond[1]=(x1062+(((-1.0)*x1064))+((sj17*x1063)));
evalcond[2]=((0.4)+(((0.2568)*x1059))+(((-0.8)*x1061))+(((-0.8)*x1060)));
evalcond[3]=((0.5)+(((0.321)*x1059))+(((-1.0)*x1060))+(((-1.0)*x1061)));
evalcond[4]=(x1063+(((-1.0)*sj17*x1064))+((cj17*pz))+((sj17*x1062)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j16)))), 6.28318530717959)));
evalcond[1]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));
evalcond[2]=((((-1.0)*cj15*cj17*py))+((pz*sj17))+((cj17*px*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18eval[1];
sj16=0;
cj16=-1.0;
j16=3.14159265358979;
j18eval[0]=cj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal j18eval[1];
sj16=0;
cj16=-1.0;
j16=3.14159265358979;
j18eval[0]=sj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x1065=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=x1065;
evalcond[2]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));
evalcond[3]=x1065;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1066=IKcos(j18);
IkReal x1067=(py*sj15);
IkReal x1068=(cj15*px);
evalcond[0]=((((-0.321)*(IKsin(j18))))+pz);
evalcond[1]=((0.3)+x1068+x1067+(((0.321)*x1066)));
evalcond[2]=((0.24)+(((0.8)*x1067))+(((0.8)*x1068))+(((0.2568)*x1066)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1069=(cj15*py);
IkReal x1070=(px*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=(x1070+(((-1.0)*x1069)));
evalcond[2]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));
evalcond[3]=(x1069+(((-1.0)*x1070)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1071=IKcos(j18);
IkReal x1072=(py*sj15);
IkReal x1073=(cj15*px);
evalcond[0]=(pz+(((0.321)*(IKsin(j18)))));
evalcond[1]=((0.3)+x1072+x1073+(((0.321)*x1071)));
evalcond[2]=((0.24)+(((0.8)*x1073))+(((0.8)*x1072))+(((0.2568)*x1071)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=pz;
evalcond[2]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1074=((3.11526479750779)*cj15);
IkReal x1075=((3.11526479750779)*sj15);
if( IKabs(((((-1.0)*px*x1075))+((py*x1074)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-1.0)*px*x1074))+(((-1.0)*py*x1075)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*px*x1075))+((py*x1074))))+IKsqr(((-0.934579439252336)+(((-1.0)*px*x1074))+(((-1.0)*py*x1075))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*px*x1075))+((py*x1074))), ((-0.934579439252336)+(((-1.0)*px*x1074))+(((-1.0)*py*x1075))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1076=IKcos(j18);
IkReal x1077=(py*sj15);
IkReal x1078=(cj15*px);
evalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));
evalcond[1]=((0.3)+x1078+x1077+(((0.321)*x1076)));
evalcond[2]=((0.24)+(((0.8)*x1078))+(((0.8)*x1077))+(((0.2568)*x1076)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=pz;
evalcond[2]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1079=((3.11526479750779)*cj15);
IkReal x1080=((3.11526479750779)*sj15);
if( IKabs((((px*x1080))+(((-1.0)*py*x1079)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-1.0)*py*x1080))+(((-1.0)*px*x1079)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((px*x1080))+(((-1.0)*py*x1079))))+IKsqr(((-0.934579439252336)+(((-1.0)*py*x1080))+(((-1.0)*px*x1079))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2((((px*x1080))+(((-1.0)*py*x1079))), ((-0.934579439252336)+(((-1.0)*py*x1080))+(((-1.0)*px*x1079))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1081=IKcos(j18);
IkReal x1082=(py*sj15);
IkReal x1083=(cj15*px);
evalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));
evalcond[1]=((0.3)+x1083+x1082+(((0.321)*x1081)));
evalcond[2]=((0.24)+(((0.8)*x1082))+(((0.8)*x1083))+(((0.2568)*x1081)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1084=IKPowWithIntegerCheck(sj17,-1);
if(!x1084.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1084.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1084.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1084.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1085=IKsin(j18);
IkReal x1086=IKcos(j18);
IkReal x1087=(py*sj15);
IkReal x1088=(cj15*px);
IkReal x1089=(px*sj15);
IkReal x1090=((0.321)*x1085);
IkReal x1091=((1.0)*cj15*py);
evalcond[0]=(pz+(((-1.0)*cj17*x1090)));
evalcond[1]=((0.3)+x1087+x1088+(((0.321)*x1086)));
evalcond[2]=(x1089+(((-1.0)*x1091))+((sj17*x1090)));
evalcond[3]=((0.24)+(((0.8)*x1087))+(((0.8)*x1088))+(((0.2568)*x1086)));
evalcond[4]=(((sj17*x1089))+x1090+(((-1.0)*sj17*x1091))+(((-1.0)*cj17*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1092=IKPowWithIntegerCheck(cj17,-1);
if(!x1092.valid){
continue;
}
if( IKabs(((3.11526479750779)*pz*(x1092.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz*(x1092.value)))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((3.11526479750779)*pz*(x1092.value)), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1093=IKsin(j18);
IkReal x1094=IKcos(j18);
IkReal x1095=(py*sj15);
IkReal x1096=(cj15*px);
IkReal x1097=(px*sj15);
IkReal x1098=((0.321)*x1093);
IkReal x1099=((1.0)*cj15*py);
evalcond[0]=(pz+(((-1.0)*cj17*x1098)));
evalcond[1]=((0.3)+x1095+x1096+(((0.321)*x1094)));
evalcond[2]=(x1097+(((-1.0)*x1099))+((sj17*x1098)));
evalcond[3]=((0.24)+(((0.2568)*x1094))+(((0.8)*x1095))+(((0.8)*x1096)));
evalcond[4]=(x1098+((sj17*x1097))+(((-1.0)*sj17*x1099))+(((-1.0)*cj17*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1100=((1.0)*py);
IkReal x1101=(cj15*px);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-0.8)*pz))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2)*x1101)));
evalcond[2]=((((-1.0)*cj15*cj17*x1100))+((cj17*px*sj15))+(((-1.0)*sj17*x1101))+(((0.1)*sj17))+(((-1.0)*sj15*sj17*x1100)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1102=((3.11526479750779)*cj15);
IkReal x1103=((3.11526479750779)*sj15);
if( IKabs(((((-1.0)*cj17*py*x1103))+((py*sj17*x1102))+(((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x1103))+(((-1.0)*cj17*px*x1102)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj17*py*x1103))+((py*sj17*x1102))+(((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x1103))+(((-1.0)*cj17*px*x1102))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*cj17*py*x1103))+((py*sj17*x1102))+(((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x1103))+(((-1.0)*cj17*px*x1102))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1104=IKsin(j18);
IkReal x1105=IKcos(j18);
IkReal x1106=(py*sj15);
IkReal x1107=(px*sj15);
IkReal x1108=(cj15*px);
IkReal x1109=((0.321)*x1104);
IkReal x1110=((1.0)*cj15*py);
evalcond[0]=((0.4)+(((0.321)*x1105))+pz);
evalcond[1]=(x1107+((sj17*x1109))+(((-1.0)*x1110)));
evalcond[2]=((0.1)+(((-1.0)*cj17*x1109))+(((-1.0)*x1108))+(((-1.0)*x1106)));
evalcond[3]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1106))+(((0.2)*x1108))+(((0.2568)*x1105)));
evalcond[4]=(x1109+(((-1.0)*sj17*x1110))+(((-0.1)*cj17))+((sj17*x1107))+((cj17*x1106))+((cj17*x1108)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1111=(cj15*px);
IkReal x1112=(py*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j16)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1111))+(((0.2)*x1112)));
evalcond[2]=((((-1.0)*cj15*cj17*py))+(((-0.1)*sj17))+((cj17*px*sj15))+((sj17*x1112))+((sj17*x1111)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18eval[1];
sj16=-1.0;
cj16=0;
j16=-1.5707963267949;
j18eval[0]=sj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal j18eval[1];
sj16=-1.0;
cj16=0;
j16=-1.5707963267949;
j18eval[0]=cj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x1113=(cj15*px);
IkReal x1114=(py*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*x1113))+(((-1.0)*x1114)));
evalcond[2]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1114))+(((0.2)*x1113)));
evalcond[3]=((-0.1)+x1113+x1114);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1115=IKcos(j18);
evalcond[0]=((-0.4)+(((-0.321)*x1115))+pz);
evalcond[1]=((0.273041)+(((-1.0)*pp))+(((0.2568)*x1115)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1116=(py*sj15);
IkReal x1117=(cj15*px);
IkReal x1118=((0.1)+(((-1.0)*x1117))+(((-1.0)*x1116)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=x1118;
evalcond[2]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1116))+(((0.2)*x1117)));
evalcond[3]=x1118;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1119=IKcos(j18);
evalcond[0]=((-0.4)+(((-0.321)*x1119))+pz);
evalcond[1]=((0.273041)+(((-1.0)*pp))+(((0.2568)*x1119)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1120=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=x1120;
evalcond[2]=((-0.066959)+(((0.8)*pz))+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
evalcond[3]=x1120;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1121=IKcos(j18);
IkReal x1122=(cj15*px);
IkReal x1123=(py*sj15);
evalcond[0]=((-0.4)+(((-0.321)*x1121))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1122))+(((-1.0)*x1123))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1123))+(((0.2)*x1122))+(((0.2568)*x1121)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1124=(cj15*py);
IkReal x1125=(px*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=(x1125+(((-1.0)*x1124)));
evalcond[2]=((-0.066959)+(((0.8)*pz))+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
evalcond[3]=(x1124+(((-1.0)*x1125)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1126=IKcos(j18);
IkReal x1127=(cj15*px);
IkReal x1128=(py*sj15);
evalcond[0]=((-0.4)+(((-0.321)*x1126))+pz);
evalcond[1]=((0.1)+(((-0.321)*(IKsin(j18))))+(((-1.0)*x1128))+(((-1.0)*x1127)));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1127))+(((0.2)*x1128))+(((0.2568)*x1126)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1129=IKPowWithIntegerCheck(cj17,-1);
if(!x1129.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1129.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1129.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1129.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1130=IKsin(j18);
IkReal x1131=IKcos(j18);
IkReal x1132=(py*sj15);
IkReal x1133=((1.0)*cj15);
IkReal x1134=(px*sj15);
IkReal x1135=((0.321)*x1130);
evalcond[0]=((-0.4)+(((-0.321)*x1131))+pz);
evalcond[1]=(x1134+(((-1.0)*py*x1133))+((sj17*x1135)));
evalcond[2]=((0.1)+((cj17*x1135))+(((-1.0)*x1132))+(((-1.0)*px*x1133)));
evalcond[3]=((0.253041)+(((0.2)*cj15*px))+(((-1.0)*pp))+(((0.2)*x1132))+(((0.2568)*x1131)));
evalcond[4]=(x1135+(((-1.0)*cj17*px*x1133))+((sj17*x1134))+(((-1.0)*py*sj17*x1133))+(((-1.0)*cj17*x1132))+(((0.1)*cj17)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1136=IKPowWithIntegerCheck(sj17,-1);
if(!x1136.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1136.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1136.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1136.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1137=IKsin(j18);
IkReal x1138=IKcos(j18);
IkReal x1139=(py*sj15);
IkReal x1140=((1.0)*cj15);
IkReal x1141=(px*sj15);
IkReal x1142=((0.321)*x1137);
evalcond[0]=((-0.4)+(((-0.321)*x1138))+pz);
evalcond[1]=(x1141+((sj17*x1142))+(((-1.0)*py*x1140)));
evalcond[2]=((0.1)+(((-1.0)*px*x1140))+(((-1.0)*x1139))+((cj17*x1142)));
evalcond[3]=((0.253041)+(((0.2)*cj15*px))+(((-1.0)*pp))+(((0.2)*x1139))+(((0.2568)*x1138)));
evalcond[4]=(x1142+((sj17*x1141))+(((-1.0)*cj17*px*x1140))+(((-1.0)*cj17*x1139))+(((0.1)*cj17))+(((-1.0)*py*sj17*x1140)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1143=((1.0)*sj16);
IkReal x1144=(cj15*px);
IkReal x1145=(py*sj15);
IkReal x1146=((0.8)*cj16);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+((x1145*x1146))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1144*x1146))+(((0.2)*x1144))+(((0.2)*x1145)));
evalcond[2]=((((-1.0)*x1143*x1144))+(((-1.0)*x1143*x1145))+(((-1.0)*cj16*pz))+(((0.1)*sj16)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1147=IKcos(j18);
IkReal x1148=(py*sj15);
IkReal x1149=((1.0)*cj16);
IkReal x1150=((1.0)*cj15);
IkReal x1151=(cj15*px);
IkReal x1152=((0.321)*x1147);
evalcond[0]=((((0.4)*sj16))+pz+((sj16*x1152)));
evalcond[1]=(((px*sj15))+(((-1.0)*py*x1150))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2)*x1151))+(((-1.0)*pp))+(((0.2)*x1148))+(((0.2568)*x1147)));
evalcond[3]=((0.1)+(((-1.0)*px*x1150))+(((-1.0)*x1148))+(((0.4)*cj16))+((cj16*x1152)));
evalcond[4]=((0.4)+x1152+(((-1.0)*x1149*x1151))+((pz*sj16))+(((-1.0)*x1148*x1149))+(((0.1)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1153=(cj15*px);
IkReal x1154=((0.8)*cj16);
IkReal x1155=(py*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((0.2)*x1155))+(((0.2)*x1153))+((x1153*x1154))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1154*x1155)));
evalcond[2]=((((-0.1)*sj16))+((cj16*pz))+((sj16*x1155))+((sj16*x1153)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1156=IKcos(j18);
IkReal x1157=(py*sj15);
IkReal x1158=((1.0)*cj16);
IkReal x1159=((1.0)*cj15);
IkReal x1160=(cj15*px);
IkReal x1161=((0.321)*x1156);
evalcond[0]=(((sj16*x1161))+(((0.4)*sj16))+pz);
evalcond[1]=(((px*sj15))+(((-0.321)*(IKsin(j18))))+(((-1.0)*py*x1159)));
evalcond[2]=((0.253041)+(((0.2)*x1157))+(((0.2568)*x1156))+(((-1.0)*pp))+(((0.2)*x1160)));
evalcond[3]=((0.1)+(((-1.0)*px*x1159))+((cj16*x1161))+(((-1.0)*x1157))+(((0.4)*cj16)));
evalcond[4]=((0.4)+x1161+(((-1.0)*x1157*x1158))+(((-1.0)*x1158*x1160))+((pz*sj16))+(((0.1)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1167=IKPowWithIntegerCheck(sj17,-1);
if(!x1167.valid){
continue;
}
IkReal x1162=x1167.value;
IkReal x1163=((0.00311526479750779)*x1162);
IkReal x1164=(px*sj15);
IkReal x1165=(cj15*py);
IkReal x1166=((1000.0)*cj16*cj17);
CheckValue<IkReal> x1168=IKPowWithIntegerCheck(sj16,-1);
if(!x1168.valid){
continue;
}
if( IKabs((x1163*(((((-1000.0)*x1164))+(((1000.0)*x1165)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1163*(x1168.value)*(((((-1000.0)*pz*sj17))+((x1164*x1166))+(((-400.0)*sj16*sj17))+(((-1.0)*x1165*x1166)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1163*(((((-1000.0)*x1164))+(((1000.0)*x1165))))))+IKsqr((x1163*(x1168.value)*(((((-1000.0)*pz*sj17))+((x1164*x1166))+(((-400.0)*sj16*sj17))+(((-1.0)*x1165*x1166))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2((x1163*(((((-1000.0)*x1164))+(((1000.0)*x1165))))), (x1163*(x1168.value)*(((((-1000.0)*pz*sj17))+((x1164*x1166))+(((-400.0)*sj16*sj17))+(((-1.0)*x1165*x1166))))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x1169=IKcos(j18);
IkReal x1170=IKsin(j18);
IkReal x1171=(cj17*sj16);
IkReal x1172=(cj16*cj17);
IkReal x1173=(cj15*px);
IkReal x1174=((1.0)*cj16);
IkReal x1175=(py*sj15);
IkReal x1176=(px*sj15);
IkReal x1177=((0.321)*x1170);
IkReal x1178=((0.321)*x1169);
IkReal x1179=((1.0)*cj15*py);
evalcond[0]=(x1176+((sj17*x1177))+(((-1.0)*x1179)));
evalcond[1]=((0.253041)+(((0.2568)*x1169))+(((0.2)*x1175))+(((0.2)*x1173))+(((-1.0)*pp)));
evalcond[2]=(((sj16*x1178))+(((0.4)*sj16))+((x1172*x1177))+pz);
evalcond[3]=((0.4)+x1178+(((-1.0)*x1173*x1174))+((pz*sj16))+(((-1.0)*x1174*x1175))+(((0.1)*cj16)));
evalcond[4]=((0.1)+((cj16*x1178))+(((-1.0)*x1171*x1177))+(((0.4)*cj16))+(((-1.0)*x1175))+(((-1.0)*x1173)));
evalcond[5]=(x1177+((sj17*x1176))+(((-1.0)*sj17*x1179))+((pz*x1172))+(((-0.1)*x1171))+((x1171*x1175))+((x1171*x1173)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1180=((250.0)*sj16);
IkReal x1181=(py*sj15);
IkReal x1182=(cj15*px);
CheckValue<IkReal> x1183=IKPowWithIntegerCheck(cj16,-1);
if(!x1183.valid){
continue;
}
CheckValue<IkReal> x1184=IKPowWithIntegerCheck(cj17,-1);
if(!x1184.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1183.value)*(x1184.value)*(((((-1000.0)*pz))+((x1180*x1182))+((x1180*x1181))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1182))+(((-0.778816199376947)*x1181)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1183.value)*(x1184.value)*(((((-1000.0)*pz))+((x1180*x1182))+((x1180*x1181))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1182))+(((-0.778816199376947)*x1181))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1183.value)*(x1184.value)*(((((-1000.0)*pz))+((x1180*x1182))+((x1180*x1181))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1182))+(((-0.778816199376947)*x1181))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x1185=IKcos(j18);
IkReal x1186=IKsin(j18);
IkReal x1187=(cj17*sj16);
IkReal x1188=(cj16*cj17);
IkReal x1189=(cj15*px);
IkReal x1190=((1.0)*cj16);
IkReal x1191=(py*sj15);
IkReal x1192=(px*sj15);
IkReal x1193=((0.321)*x1186);
IkReal x1194=((0.321)*x1185);
IkReal x1195=((1.0)*cj15*py);
evalcond[0]=(x1192+(((-1.0)*x1195))+((sj17*x1193)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1191))+(((0.2)*x1189))+(((0.2568)*x1185)));
evalcond[2]=(((x1188*x1193))+(((0.4)*sj16))+((sj16*x1194))+pz);
evalcond[3]=((0.4)+x1194+(((-1.0)*x1189*x1190))+(((-1.0)*x1190*x1191))+((pz*sj16))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((-1.0)*x1187*x1193))+((cj16*x1194))+(((0.4)*cj16))+(((-1.0)*x1189))+(((-1.0)*x1191)));
evalcond[5]=(((x1187*x1189))+x1193+((x1187*x1191))+((pz*x1188))+(((-0.1)*x1187))+(((-1.0)*sj17*x1195))+((sj17*x1192)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1196=IKPowWithIntegerCheck(sj17,-1);
if(!x1196.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1196.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1196.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1196.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x1197=IKcos(j18);
IkReal x1198=IKsin(j18);
IkReal x1199=(cj17*sj16);
IkReal x1200=(cj16*cj17);
IkReal x1201=(cj15*px);
IkReal x1202=((1.0)*cj16);
IkReal x1203=(py*sj15);
IkReal x1204=(px*sj15);
IkReal x1205=((0.321)*x1198);
IkReal x1206=((0.321)*x1197);
IkReal x1207=((1.0)*cj15*py);
evalcond[0]=(x1204+((sj17*x1205))+(((-1.0)*x1207)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2568)*x1197))+(((0.2)*x1201))+(((0.2)*x1203)));
evalcond[2]=(((sj16*x1206))+(((0.4)*sj16))+((x1200*x1205))+pz);
evalcond[3]=((0.4)+x1206+((pz*sj16))+(((-1.0)*x1202*x1203))+(((-1.0)*x1201*x1202))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((-1.0)*x1199*x1205))+(((0.4)*cj16))+(((-1.0)*x1203))+(((-1.0)*x1201))+((cj16*x1206)));
evalcond[5]=(x1205+((sj17*x1204))+(((-0.1)*x1199))+((x1199*x1201))+((x1199*x1203))+(((-1.0)*sj17*x1207))+((pz*x1200)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x194=((1.0)*cj17);
IkReal x195=(cj18*sj16);
IkReal x196=(cj16*sj17);
IkReal x197=(sj16*sj18);
IkReal x198=(sj16*sj17);
IkReal x199=(cj16*cj18);
IkReal x200=(sj17*sj18);
IkReal x201=(cj16*sj18);
IkReal x202=(cj18*sj15*sj17);
IkReal x203=((((-1.0)*x194*x199))+x197);
IkReal x204=(((sj15*x198))+((cj15*cj17)));
IkReal x205=(((cj15*x198))+(((-1.0)*sj15*x194)));
IkReal x206=((((-1.0)*x194*x197))+x199);
IkReal x207=(cj15*x206);
IkReal x208=((((-1.0)*x194*x195))+(((-1.0)*x201)));
IkReal x209=((((-1.0)*x194*x201))+(((-1.0)*x195)));
IkReal x210=(cj15*x208);
IkReal x211=(((cj15*x200))+((sj15*x206)));
IkReal x212=((((-1.0)*sj15*x200))+x207);
IkReal x213=(((cj15*cj18*sj17))+((sj15*x208)));
IkReal x214=(x210+(((-1.0)*x202)));
new_r00=(((r20*x203))+((r00*x214))+((r10*x213)));
new_r01=(((r11*x213))+((r21*x203))+((r01*x214)));
new_r02=(((r02*((x210+(((-1.0)*x202))))))+((r22*x203))+((r12*x213)));
new_r10=(((r20*x196))+((r00*x205))+((r10*x204)));
new_r11=(((r11*x204))+((r01*x205))+((r21*x196)));
new_r12=(((r22*x196))+((r12*x204))+((r02*x205)));
new_r20=(((r00*(((((-1.0)*sj15*x200))+x207))))+((r20*x209))+((r10*x211)));
new_r21=(((r11*x211))+((r21*x209))+((r01*x212)));
new_r22=(((r22*x209))+((r12*x211))+((r02*x212)));
{
IkReal j20array[2], cj20array[2], sj20array[2];
bool j20valid[2]={false};
_nj20 = 2;
cj20array[0]=new_r22;
if( cj20array[0] >= -1-IKFAST_SINCOS_THRESH && cj20array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j20valid[0] = j20valid[1] = true;
    j20array[0] = IKacos(cj20array[0]);
    sj20array[0] = IKsin(j20array[0]);
    cj20array[1] = cj20array[0];
    j20array[1] = -j20array[0];
    sj20array[1] = -sj20array[0];
}
else if( isnan(cj20array[0]) )
{
    // probably any value will work
    j20valid[0] = true;
    cj20array[0] = 1; sj20array[0] = 0; j20array[0] = 0;
}
for(int ij20 = 0; ij20 < 2; ++ij20)
{
if( !j20valid[ij20] )
{
    continue;
}
_ij20[0] = ij20; _ij20[1] = -1;
for(int iij20 = ij20+1; iij20 < 2; ++iij20)
{
if( j20valid[iij20] && IKabs(cj20array[ij20]-cj20array[iij20]) < IKFAST_SOLUTION_THRESH && IKabs(sj20array[ij20]-sj20array[iij20]) < IKFAST_SOLUTION_THRESH )
{
    j20valid[iij20]=false; _ij20[1] = iij20; break; 
}
}
j20 = j20array[ij20]; cj20 = cj20array[ij20]; sj20 = sj20array[ij20];

{
IkReal j19eval[2];
IkReal x215=((1.0)*cj17);
IkReal x216=(cj18*sj16);
IkReal x217=(cj16*sj17);
IkReal x218=(sj16*sj18);
IkReal x219=(sj16*sj17);
IkReal x220=(cj16*cj18);
IkReal x221=(sj17*sj18);
IkReal x222=(cj16*sj18);
IkReal x223=(cj18*sj15*sj17);
IkReal x224=((((-1.0)*x215*x220))+x218);
IkReal x225=x204;
IkReal x226=x205;
IkReal x227=(x220+(((-1.0)*x215*x218)));
IkReal x228=(cj15*x227);
IkReal x229=x208;
IkReal x230=x209;
IkReal x231=(cj15*x229);
IkReal x232=(((cj15*x221))+((sj15*x227)));
IkReal x233=(x228+(((-1.0)*sj15*x221)));
IkReal x234=(((cj15*cj18*sj17))+((sj15*x229)));
IkReal x235=(x231+(((-1.0)*x223)));
new_r00=(((r20*x224))+((r10*x234))+((r00*x235)));
new_r01=(((r11*x234))+((r01*x235))+((r21*x224)));
new_r02=(((r02*((x231+(((-1.0)*x223))))))+((r22*x224))+((r12*x234)));
new_r10=(((r00*x226))+((r10*x225))+((r20*x217)));
new_r11=(((r21*x217))+((r01*x226))+((r11*x225)));
new_r12=(((r12*x225))+((r22*x217))+((r02*x226)));
new_r20=(((r10*x232))+((r00*((x228+(((-1.0)*sj15*x221))))))+((r20*x230)));
new_r21=(((r11*x232))+((r01*x233))+((r21*x230)));
new_r22=(((r02*x233))+((r12*x232))+((r22*x230)));
j19eval[0]=sj20;
j19eval[1]=IKsign(sj20);
if( IKabs(j19eval[0]) < 0.0000010000000000  || IKabs(j19eval[1]) < 0.0000010000000000  )
{
{
IkReal j19eval[1];
IkReal x236=((1.0)*cj17);
IkReal x237=(cj18*sj16);
IkReal x238=(cj16*sj17);
IkReal x239=(sj16*sj18);
IkReal x240=(sj16*sj17);
IkReal x241=(cj16*cj18);
IkReal x242=(sj17*sj18);
IkReal x243=(cj16*sj18);
IkReal x244=(cj18*sj15*sj17);
IkReal x245=((((-1.0)*x236*x241))+x239);
IkReal x246=x204;
IkReal x247=x205;
IkReal x248=(x241+(((-1.0)*x236*x239)));
IkReal x249=(cj15*x248);
IkReal x250=x208;
IkReal x251=x209;
IkReal x252=(cj15*x250);
IkReal x253=(((sj15*x248))+((cj15*x242)));
IkReal x254=(x249+(((-1.0)*sj15*x242)));
IkReal x255=(((cj15*cj18*sj17))+((sj15*x250)));
IkReal x256=((((-1.0)*x244))+x252);
new_r00=(((r00*x256))+((r10*x255))+((r20*x245)));
new_r01=(((r11*x255))+((r01*x256))+((r21*x245)));
new_r02=(((r22*x245))+((r12*x255))+((r02*(((((-1.0)*x244))+x252)))));
new_r10=(((r20*x238))+((r00*x247))+((r10*x246)));
new_r11=(((r01*x247))+((r11*x246))+((r21*x238)));
new_r12=(((r02*x247))+((r12*x246))+((r22*x238)));
new_r20=(((r20*x251))+((r10*x253))+((r00*((x249+(((-1.0)*sj15*x242)))))));
new_r21=(((r21*x251))+((r11*x253))+((r01*x254)));
new_r22=(((r12*x253))+((r22*x251))+((r02*x254)));
j19eval[0]=sj20;
if( IKabs(j19eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j19array[2], cj19array[2], sj19array[2];
bool j19valid[2]={false};
_nj19 = 2;
CheckValue<IkReal> x258 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x258.valid){
continue;
}
IkReal x257=x258.value;
j19array[0]=((-1.0)*x257);
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
j19array[1]=((3.14159265358979)+(((-1.0)*x257)));
sj19array[1]=IKsin(j19array[1]);
cj19array[1]=IKcos(j19array[1]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
if( j19array[1] > IKPI )
{
    j19array[1]-=IK2PI;
}
else if( j19array[1] < -IKPI )
{    j19array[1]+=IK2PI;
}
j19valid[1] = true;
for(int ij19 = 0; ij19 < 2; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 2; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r02*(IKsin(j19))))+((new_r12*(IKcos(j19)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x259=((1.0)*sj19);
if( IKabs(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x259)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x259))+((cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x259))))+IKsqr(((((-1.0)*new_r01*x259))+((cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x259))), ((((-1.0)*new_r01*x259))+((cj19*new_r00))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x260=IKsin(j21);
IkReal x261=IKcos(j21);
IkReal x262=((1.0)*sj19);
IkReal x263=((1.0)*x261);
IkReal x264=(sj19*x260);
IkReal x265=((1.0)*x260);
IkReal x266=(cj19*x263);
evalcond[0]=(x260+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((cj19*x260))+((sj19*x261))+new_r01);
evalcond[2]=((((-1.0)*x263))+((new_r10*sj19))+((cj19*new_r00)));
evalcond[3]=((((-1.0)*new_r00*x262))+((cj19*new_r10))+(((-1.0)*x265)));
evalcond[4]=((((-1.0)*new_r01*x262))+((cj19*new_r11))+(((-1.0)*x263)));
evalcond[5]=(x264+new_r00+(((-1.0)*x266)));
evalcond[6]=(x264+new_r11+(((-1.0)*x266)));
evalcond[7]=((((-1.0)*x261*x262))+new_r10+(((-1.0)*cj19*x265)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j19array[2], cj19array[2], sj19array[2];
bool j19valid[2]={false};
_nj19 = 2;
CheckValue<IkReal> x268 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x268.valid){
continue;
}
IkReal x267=x268.value;
j19array[0]=((-1.0)*x267);
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
j19array[1]=((3.14159265358979)+(((-1.0)*x267)));
sj19array[1]=IKsin(j19array[1]);
cj19array[1]=IKcos(j19array[1]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
if( j19array[1] > IKPI )
{
    j19array[1]-=IK2PI;
}
else if( j19array[1] < -IKPI )
{    j19array[1]+=IK2PI;
}
j19valid[1] = true;
for(int ij19 = 0; ij19 < 2; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 2; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r02*(IKsin(j19))))+((new_r12*(IKcos(j19)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x269=((1.0)*sj19);
if( IKabs(((((-1.0)*new_r00*x269))+((cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x269))+(((-1.0)*cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x269))+((cj19*new_r01))))+IKsqr(((((-1.0)*new_r01*x269))+(((-1.0)*cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((((-1.0)*new_r00*x269))+((cj19*new_r01))), ((((-1.0)*new_r01*x269))+(((-1.0)*cj19*new_r00))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x270=IKsin(j21);
IkReal x271=IKcos(j21);
IkReal x272=((1.0)*cj19);
IkReal x273=((1.0)*sj19);
IkReal x274=((1.0)*x270);
IkReal x275=(sj19*x271);
IkReal x276=(sj19*x270);
IkReal x277=(x270*x272);
evalcond[0]=(x271+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x274))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(x276+((cj19*x271))+new_r00);
evalcond[3]=((((-1.0)*new_r00*x273))+(((-1.0)*x274))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x273))+(((-1.0)*x271))+((cj19*new_r11)));
evalcond[5]=(x275+(((-1.0)*x277))+new_r01);
evalcond[6]=(x275+(((-1.0)*x277))+new_r10);
evalcond[7]=((((-1.0)*x271*x272))+(((-1.0)*x270*x273))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j19, j21]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
CheckValue<IkReal> x279=IKPowWithIntegerCheck(sj20,-1);
if(!x279.valid){
continue;
}
IkReal x278=x279.value;
CheckValue<IkReal> x280=IKPowWithIntegerCheck(new_r12,-1);
if(!x280.valid){
continue;
}
if( IKabs((x278*(x280.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj20*cj20))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x278)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x278*(x280.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj20*cj20)))))))+IKsqr((new_r02*x278))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j19array[0]=IKatan2((x278*(x280.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj20*cj20)))))), (new_r02*x278));
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[8];
IkReal x281=IKcos(j19);
IkReal x282=IKsin(j19);
IkReal x283=((1.0)*sj20);
IkReal x284=(new_r02*x281);
IkReal x285=(new_r12*x282);
IkReal x286=(sj20*x281);
IkReal x287=(sj20*x282);
evalcond[0]=((((-1.0)*x281*x283))+new_r02);
evalcond[1]=((((-1.0)*x282*x283))+new_r12);
evalcond[2]=(((new_r12*x281))+(((-1.0)*new_r02*x282)));
evalcond[3]=(x285+x284+(((-1.0)*x283)));
evalcond[4]=(((cj20*new_r20))+((new_r00*x286))+((new_r10*x287)));
evalcond[5]=(((cj20*new_r21))+((new_r11*x287))+((new_r01*x286)));
evalcond[6]=((-1.0)+((sj20*x285))+((sj20*x284))+((cj20*new_r22)));
evalcond[7]=(((cj20*x284))+((cj20*x285))+(((-1.0)*new_r22*x283)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j21eval[2];
IkReal x288=((1.0)*cj17);
IkReal x289=(cj18*sj16);
IkReal x290=(cj16*sj17);
IkReal x291=(sj16*sj18);
IkReal x292=(sj16*sj17);
IkReal x293=(cj16*cj18);
IkReal x294=(sj17*sj18);
IkReal x295=(cj16*sj18);
IkReal x296=(cj18*sj15*sj17);
IkReal x297=(x291+(((-1.0)*x288*x293)));
IkReal x298=x204;
IkReal x299=x205;
IkReal x300=(x293+(((-1.0)*x288*x291)));
IkReal x301=(cj15*x300);
IkReal x302=x208;
IkReal x303=x209;
IkReal x304=(cj15*x302);
IkReal x305=(((sj15*x300))+((cj15*x294)));
IkReal x306=((((-1.0)*sj15*x294))+x301);
IkReal x307=(((cj15*cj18*sj17))+((sj15*x302)));
IkReal x308=((((-1.0)*x296))+x304);
new_r00=(((r20*x297))+((r10*x307))+((r00*x308)));
new_r01=(((r11*x307))+((r01*x308))+((r21*x297)));
new_r02=(((r02*(((((-1.0)*x296))+x304))))+((r22*x297))+((r12*x307)));
new_r10=(((r20*x290))+((r00*x299))+((r10*x298)));
new_r11=(((r01*x299))+((r21*x290))+((r11*x298)));
new_r12=(((r12*x298))+((r02*x299))+((r22*x290)));
new_r20=(((r00*(((((-1.0)*sj15*x294))+x301))))+((r20*x303))+((r10*x305)));
new_r21=(((r11*x305))+((r21*x303))+((r01*x306)));
new_r22=(((r22*x303))+((r02*x306))+((r12*x305)));
j21eval[0]=sj20;
j21eval[1]=IKsign(sj20);
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )
{
{
IkReal j21eval[2];
IkReal x309=((1.0)*cj17);
IkReal x310=(cj18*sj16);
IkReal x311=(cj16*sj17);
IkReal x312=(sj16*sj18);
IkReal x313=(sj16*sj17);
IkReal x314=(cj16*cj18);
IkReal x315=(sj17*sj18);
IkReal x316=(cj16*sj18);
IkReal x317=(cj18*sj15*sj17);
IkReal x318=(x312+(((-1.0)*x309*x314)));
IkReal x319=x204;
IkReal x320=x205;
IkReal x321=(x314+(((-1.0)*x309*x312)));
IkReal x322=(cj15*x321);
IkReal x323=x208;
IkReal x324=x209;
IkReal x325=(cj15*x323);
IkReal x326=(((cj15*x315))+((sj15*x321)));
IkReal x327=(x322+(((-1.0)*sj15*x315)));
IkReal x328=(((cj15*cj18*sj17))+((sj15*x323)));
IkReal x329=(x325+(((-1.0)*x317)));
new_r00=(((r00*x329))+((r20*x318))+((r10*x328)));
new_r01=(((r11*x328))+((r01*x329))+((r21*x318)));
new_r02=(((r02*((x325+(((-1.0)*x317))))))+((r12*x328))+((r22*x318)));
new_r10=(((r00*x320))+((r20*x311))+((r10*x319)));
new_r11=(((r11*x319))+((r01*x320))+((r21*x311)));
new_r12=(((r02*x320))+((r12*x319))+((r22*x311)));
new_r20=(((r20*x324))+((r10*x326))+((r00*((x322+(((-1.0)*sj15*x315)))))));
new_r21=(((r21*x324))+((r11*x326))+((r01*x327)));
new_r22=(((r02*x327))+((r12*x326))+((r22*x324)));
j21eval[0]=sj20;
j21eval[1]=sj19;
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )
{
{
IkReal j21eval[3];
IkReal x330=((1.0)*cj17);
IkReal x331=(cj18*sj16);
IkReal x332=(cj16*sj17);
IkReal x333=(sj16*sj18);
IkReal x334=(sj16*sj17);
IkReal x335=(cj16*cj18);
IkReal x336=(sj17*sj18);
IkReal x337=(cj16*sj18);
IkReal x338=(cj18*sj15*sj17);
IkReal x339=(x333+(((-1.0)*x330*x335)));
IkReal x340=x204;
IkReal x341=x205;
IkReal x342=(x335+(((-1.0)*x330*x333)));
IkReal x343=(cj15*x342);
IkReal x344=x208;
IkReal x345=x209;
IkReal x346=(cj15*x344);
IkReal x347=(((sj15*x342))+((cj15*x336)));
IkReal x348=(x343+(((-1.0)*sj15*x336)));
IkReal x349=(((cj15*cj18*sj17))+((sj15*x344)));
IkReal x350=(x346+(((-1.0)*x338)));
new_r00=(((r00*x350))+((r20*x339))+((r10*x349)));
new_r01=(((r01*x350))+((r21*x339))+((r11*x349)));
new_r02=(((r22*x339))+((r02*((x346+(((-1.0)*x338))))))+((r12*x349)));
new_r10=(((r00*x341))+((r20*x332))+((r10*x340)));
new_r11=(((r01*x341))+((r21*x332))+((r11*x340)));
new_r12=(((r22*x332))+((r02*x341))+((r12*x340)));
new_r20=(((r00*((x343+(((-1.0)*sj15*x336))))))+((r20*x345))+((r10*x347)));
new_r21=(((r01*x348))+((r21*x345))+((r11*x347)));
new_r22=(((r22*x345))+((r02*x348))+((r12*x347)));
j21eval[0]=cj20;
j21eval[1]=sj19;
j21eval[2]=sj20;
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x351=((1.0)*sj19);
IkReal x352=((((-1.0)*new_r02*x351))+((cj19*new_r12)));
IkReal x353=(((new_r10*sj19))+((cj19*new_r00)));
IkReal x354=(((cj19*new_r01))+((new_r11*sj19)));
IkReal x355=((-1.0)+((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*cj19))+new_r02);
evalcond[3]=((((-1.0)*x351))+new_r12);
evalcond[4]=x352;
evalcond[5]=x352;
evalcond[6]=x355;
evalcond[7]=x354;
evalcond[8]=x353;
evalcond[9]=x353;
evalcond[10]=x354;
evalcond[11]=x355;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x356=IKcos(j21);
IkReal x357=IKsin(j21);
IkReal x358=((1.0)*new_r12);
IkReal x359=((1.0)*x357);
IkReal x360=((1.0)*x356);
evalcond[0]=(x356+new_r20);
evalcond[1]=((((-1.0)*x359))+new_r21);
evalcond[2]=(new_r01+((new_r12*x356)));
evalcond[3]=(new_r00+((new_r12*x357)));
evalcond[4]=(new_r11+(((-1.0)*new_r02*x360)));
evalcond[5]=((((-1.0)*new_r02*x359))+new_r10);
evalcond[6]=((((-1.0)*x359))+((new_r02*new_r10))+(((-1.0)*new_r00*x358)));
evalcond[7]=((((-1.0)*x360))+(((-1.0)*new_r01*x358))+((new_r02*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x361=(new_r12*sj19);
IkReal x362=((1.0)*sj19);
IkReal x363=(cj19*new_r00);
IkReal x364=((1.0)*cj19);
IkReal x365=(((cj19*new_r12))+(((-1.0)*new_r02*x362)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj19+new_r02);
evalcond[3]=(sj19+new_r12);
evalcond[4]=x365;
evalcond[5]=x365;
evalcond[6]=((1.0)+x361+((cj19*new_r02)));
evalcond[7]=(((cj19*new_r01))+((new_r11*sj19)));
evalcond[8]=(x363+((new_r10*sj19)));
evalcond[9]=((((-1.0)*x363))+(((-1.0)*new_r10*x362)));
evalcond[10]=((((-1.0)*new_r11*x362))+(((-1.0)*new_r01*x364)));
evalcond[11]=((-1.0)+(((-1.0)*x361))+(((-1.0)*new_r02*x364)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x366=IKcos(j21);
IkReal x367=IKsin(j21);
IkReal x368=((1.0)*new_r02);
IkReal x369=((1.0)*x366);
IkReal x370=((1.0)*x367);
evalcond[0]=(x367+new_r21);
evalcond[1]=((((-1.0)*x369))+new_r20);
evalcond[2]=(new_r11+((new_r02*x366)));
evalcond[3]=(new_r10+((new_r02*x367)));
evalcond[4]=((((-1.0)*new_r12*x369))+new_r01);
evalcond[5]=((((-1.0)*new_r12*x370))+new_r00);
evalcond[6]=((((-1.0)*x370))+((new_r00*new_r12))+(((-1.0)*new_r10*x368)));
evalcond[7]=((((-1.0)*x369))+((new_r01*new_r12))+(((-1.0)*new_r11*x368)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x371=((((-1.0)*cj20))+new_r22);
IkReal x372=((((-1.0)*sj20))+new_r02);
IkReal x373=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)));
evalcond[1]=x371;
evalcond[2]=x371;
evalcond[3]=x372;
evalcond[4]=new_r12;
evalcond[5]=x372;
evalcond[6]=(((new_r00*sj20))+((cj20*new_r20)));
evalcond[7]=(((new_r01*sj20))+((cj20*new_r21)));
evalcond[8]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));
evalcond[9]=(((cj20*new_r02))+(((-1.0)*new_r22*x373)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x374=IKcos(j21);
IkReal x375=IKsin(j21);
IkReal x376=((1.0)*new_r02);
IkReal x377=((1.0)*x374);
evalcond[0]=(new_r20+((new_r02*x374)));
evalcond[1]=((((-1.0)*x375))+new_r10);
evalcond[2]=((((-1.0)*x377))+new_r11);
evalcond[3]=(new_r01+((new_r22*x375)));
evalcond[4]=(new_r21+(((-1.0)*x375*x376)));
evalcond[5]=((((-1.0)*new_r22*x377))+new_r00);
evalcond[6]=((((-1.0)*new_r21*x376))+((new_r01*new_r22))+x375);
evalcond[7]=((((-1.0)*new_r20*x376))+((new_r00*new_r22))+(((-1.0)*x377)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x378=((((-1.0)*cj20))+new_r22);
IkReal x379=((1.0)*sj20);
IkReal x380=((1.0)*cj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));
evalcond[1]=x378;
evalcond[2]=x378;
evalcond[3]=(sj20+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*x379))+(((-1.0)*new_r02)));
evalcond[6]=((((-1.0)*new_r00*x379))+((cj20*new_r20)));
evalcond[7]=(((cj20*new_r21))+(((-1.0)*new_r01*x379)));
evalcond[8]=((-1.0)+((cj20*new_r22))+(((-1.0)*new_r02*x379)));
evalcond[9]=((((-1.0)*new_r22*x379))+(((-1.0)*new_r02*x380)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x381=IKsin(j21);
IkReal x382=IKcos(j21);
IkReal x383=((1.0)*new_r22);
IkReal x384=((1.0)*x382);
evalcond[0]=(((new_r02*x381))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x384))+new_r20);
evalcond[2]=((((-1.0)*x381))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x384))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x381))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*new_r00))+(((-1.0)*x382*x383)));
evalcond[6]=((((-1.0)*new_r01*x383))+x381+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*new_r00*x383))+(((-1.0)*x384))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x385=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));
IkReal x386=(((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x385;
evalcond[7]=x385;
evalcond[8]=x386;
evalcond[9]=x386;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x387=((1.0)*sj19);
if( IKabs(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x387)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x387))+((cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x387))))+IKsqr(((((-1.0)*new_r01*x387))+((cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x387))), ((((-1.0)*new_r01*x387))+((cj19*new_r00))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x388=IKsin(j21);
IkReal x389=IKcos(j21);
IkReal x390=((1.0)*sj19);
IkReal x391=((1.0)*x389);
IkReal x392=(sj19*x388);
IkReal x393=((1.0)*x388);
IkReal x394=(cj19*x391);
evalcond[0]=(x388+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((cj19*x388))+new_r01+((sj19*x389)));
evalcond[2]=((((-1.0)*x391))+((new_r10*sj19))+((cj19*new_r00)));
evalcond[3]=((((-1.0)*x393))+((cj19*new_r10))+(((-1.0)*new_r00*x390)));
evalcond[4]=((((-1.0)*new_r01*x390))+(((-1.0)*x391))+((cj19*new_r11)));
evalcond[5]=((((-1.0)*x394))+x392+new_r00);
evalcond[6]=((((-1.0)*x394))+x392+new_r11);
evalcond[7]=((((-1.0)*cj19*x393))+(((-1.0)*x389*x390))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x395=(new_r12*sj19);
IkReal x396=((1.0)*new_r02);
IkReal x397=((((-1.0)*sj19*x396))+((cj19*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x397;
evalcond[7]=x397;
evalcond[8]=(x395+((cj19*new_r02)));
evalcond[9]=((((-1.0)*cj19*x396))+(((-1.0)*x395)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x398=((1.0)*sj19);
if( IKabs(((((-1.0)*new_r00*x398))+((cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x398))+(((-1.0)*cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x398))+((cj19*new_r01))))+IKsqr(((((-1.0)*new_r01*x398))+(((-1.0)*cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((((-1.0)*new_r00*x398))+((cj19*new_r01))), ((((-1.0)*new_r01*x398))+(((-1.0)*cj19*new_r00))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x399=IKsin(j21);
IkReal x400=IKcos(j21);
IkReal x401=((1.0)*cj19);
IkReal x402=((1.0)*sj19);
IkReal x403=((1.0)*x399);
IkReal x404=(sj19*x400);
IkReal x405=(sj19*x399);
IkReal x406=(x399*x401);
evalcond[0]=(x400+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=(((cj19*new_r01))+((new_r11*sj19))+(((-1.0)*x403)));
evalcond[2]=(x405+new_r00+((cj19*x400)));
evalcond[3]=((((-1.0)*new_r00*x402))+((cj19*new_r10))+(((-1.0)*x403)));
evalcond[4]=(((cj19*new_r11))+(((-1.0)*new_r01*x402))+(((-1.0)*x400)));
evalcond[5]=(x404+new_r01+(((-1.0)*x406)));
evalcond[6]=(x404+new_r10+(((-1.0)*x406)));
evalcond[7]=((((-1.0)*x400*x401))+(((-1.0)*x399*x402))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j21]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x408=IKPowWithIntegerCheck(sj20,-1);
if(!x408.valid){
continue;
}
IkReal x407=x408.value;
CheckValue<IkReal> x409=IKPowWithIntegerCheck(cj20,-1);
if(!x409.valid){
continue;
}
CheckValue<IkReal> x410=IKPowWithIntegerCheck(sj19,-1);
if(!x410.valid){
continue;
}
if( IKabs((x407*(x409.value)*(x410.value)*(((((-1.0)*new_r11*sj20))+(((-1.0)*cj19*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x407)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x407*(x409.value)*(x410.value)*(((((-1.0)*new_r11*sj20))+(((-1.0)*cj19*new_r20))))))+IKsqr(((-1.0)*new_r20*x407))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((x407*(x409.value)*(x410.value)*(((((-1.0)*new_r11*sj20))+(((-1.0)*cj19*new_r20))))), ((-1.0)*new_r20*x407));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x411=IKsin(j21);
IkReal x412=IKcos(j21);
IkReal x413=(cj20*sj19);
IkReal x414=(cj19*new_r01);
IkReal x415=((1.0)*sj20);
IkReal x416=(cj19*new_r00);
IkReal x417=((1.0)*sj19);
IkReal x418=((1.0)*x412);
IkReal x419=(cj20*x411);
IkReal x420=((1.0)*x411);
IkReal x421=(cj19*x418);
evalcond[0]=(((sj20*x412))+new_r20);
evalcond[1]=((((-1.0)*x411*x415))+new_r21);
evalcond[2]=(x414+x419+((new_r11*sj19)));
evalcond[3]=((((-1.0)*x420))+((cj19*new_r10))+(((-1.0)*new_r00*x417)));
evalcond[4]=(((cj19*new_r11))+(((-1.0)*x418))+(((-1.0)*new_r01*x417)));
evalcond[5]=(((cj19*x419))+new_r01+((sj19*x412)));
evalcond[6]=((((-1.0)*cj20*x418))+x416+((new_r10*sj19)));
evalcond[7]=((((-1.0)*cj20*x421))+new_r00+((sj19*x411)));
evalcond[8]=(((x411*x413))+(((-1.0)*x421))+new_r11);
evalcond[9]=((((-1.0)*x413*x418))+new_r10+(((-1.0)*cj19*x420)));
evalcond[10]=(((cj20*x414))+x411+(((-1.0)*new_r21*x415))+((new_r11*x413)));
evalcond[11]=((((-1.0)*new_r20*x415))+((cj20*x416))+((new_r10*x413))+(((-1.0)*x418)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x423=IKPowWithIntegerCheck(sj20,-1);
if(!x423.valid){
continue;
}
IkReal x422=x423.value;
CheckValue<IkReal> x424=IKPowWithIntegerCheck(sj19,-1);
if(!x424.valid){
continue;
}
if( IKabs((new_r21*x422)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x422*(x424.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x422))+IKsqr((x422*(x424.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((new_r21*x422), (x422*(x424.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21))))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x425=IKsin(j21);
IkReal x426=IKcos(j21);
IkReal x427=(cj20*sj19);
IkReal x428=(cj19*new_r01);
IkReal x429=((1.0)*sj20);
IkReal x430=(cj19*new_r00);
IkReal x431=((1.0)*sj19);
IkReal x432=((1.0)*x426);
IkReal x433=(cj20*x425);
IkReal x434=((1.0)*x425);
IkReal x435=(cj19*x432);
evalcond[0]=(((sj20*x426))+new_r20);
evalcond[1]=((((-1.0)*x425*x429))+new_r21);
evalcond[2]=(x428+x433+((new_r11*sj19)));
evalcond[3]=((((-1.0)*new_r00*x431))+(((-1.0)*x434))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x432))+(((-1.0)*new_r01*x431))+((cj19*new_r11)));
evalcond[5]=(((cj19*x433))+((sj19*x426))+new_r01);
evalcond[6]=((((-1.0)*cj20*x432))+x430+((new_r10*sj19)));
evalcond[7]=(((sj19*x425))+(((-1.0)*cj20*x435))+new_r00);
evalcond[8]=((((-1.0)*x435))+((x425*x427))+new_r11);
evalcond[9]=((((-1.0)*x427*x432))+(((-1.0)*cj19*x434))+new_r10);
evalcond[10]=(((new_r11*x427))+x425+(((-1.0)*new_r21*x429))+((cj20*x428)));
evalcond[11]=((((-1.0)*x432))+((new_r10*x427))+(((-1.0)*new_r20*x429))+((cj20*x430)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x436=IKPowWithIntegerCheck(IKsign(sj20),-1);
if(!x436.valid){
continue;
}
CheckValue<IkReal> x437 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x437.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(((1.5707963267949)*(x436.value)))+(x437.value));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x438=IKsin(j21);
IkReal x439=IKcos(j21);
IkReal x440=(cj20*sj19);
IkReal x441=(cj19*new_r01);
IkReal x442=((1.0)*sj20);
IkReal x443=(cj19*new_r00);
IkReal x444=((1.0)*sj19);
IkReal x445=((1.0)*x439);
IkReal x446=(cj20*x438);
IkReal x447=((1.0)*x438);
IkReal x448=(cj19*x445);
evalcond[0]=(((sj20*x439))+new_r20);
evalcond[1]=((((-1.0)*x438*x442))+new_r21);
evalcond[2]=(x446+x441+((new_r11*sj19)));
evalcond[3]=((((-1.0)*x447))+(((-1.0)*new_r00*x444))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x445))+(((-1.0)*new_r01*x444))+((cj19*new_r11)));
evalcond[5]=(((cj19*x446))+((sj19*x439))+new_r01);
evalcond[6]=((((-1.0)*cj20*x445))+x443+((new_r10*sj19)));
evalcond[7]=(((sj19*x438))+(((-1.0)*cj20*x448))+new_r00);
evalcond[8]=((((-1.0)*x448))+((x438*x440))+new_r11);
evalcond[9]=((((-1.0)*cj19*x447))+new_r10+(((-1.0)*x440*x445)));
evalcond[10]=(((new_r11*x440))+x438+((cj20*x441))+(((-1.0)*new_r21*x442)));
evalcond[11]=((((-1.0)*x445))+((new_r10*x440))+(((-1.0)*new_r20*x442))+((cj20*x443)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
CheckValue<IkReal> x449=IKPowWithIntegerCheck(IKsign(sj20),-1);
if(!x449.valid){
continue;
}
CheckValue<IkReal> x450 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);
if(!x450.valid){
continue;
}
j19array[0]=((-1.5707963267949)+(((1.5707963267949)*(x449.value)))+(x450.value));
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[8];
IkReal x451=IKcos(j19);
IkReal x452=IKsin(j19);
IkReal x453=((1.0)*sj20);
IkReal x454=(new_r02*x451);
IkReal x455=(new_r12*x452);
IkReal x456=(sj20*x451);
IkReal x457=(sj20*x452);
evalcond[0]=((((-1.0)*x451*x453))+new_r02);
evalcond[1]=((((-1.0)*x452*x453))+new_r12);
evalcond[2]=(((new_r12*x451))+(((-1.0)*new_r02*x452)));
evalcond[3]=((((-1.0)*x453))+x454+x455);
evalcond[4]=(((new_r10*x457))+((new_r00*x456))+((cj20*new_r20)));
evalcond[5]=(((new_r11*x457))+((new_r01*x456))+((cj20*new_r21)));
evalcond[6]=((-1.0)+((sj20*x454))+((sj20*x455))+((cj20*new_r22)));
evalcond[7]=(((cj20*x455))+((cj20*x454))+(((-1.0)*new_r22*x453)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j21eval[2];
IkReal x458=((1.0)*cj17);
IkReal x459=(cj18*sj16);
IkReal x460=(cj16*sj17);
IkReal x461=(sj16*sj18);
IkReal x462=(sj16*sj17);
IkReal x463=(cj16*cj18);
IkReal x464=(sj17*sj18);
IkReal x465=(cj16*sj18);
IkReal x466=(cj18*sj15*sj17);
IkReal x467=(x461+(((-1.0)*x458*x463)));
IkReal x468=x204;
IkReal x469=x205;
IkReal x470=(x463+(((-1.0)*x458*x461)));
IkReal x471=(cj15*x470);
IkReal x472=x208;
IkReal x473=x209;
IkReal x474=(cj15*x472);
IkReal x475=(((cj15*x464))+((sj15*x470)));
IkReal x476=(x471+(((-1.0)*sj15*x464)));
IkReal x477=(((cj15*cj18*sj17))+((sj15*x472)));
IkReal x478=((((-1.0)*x466))+x474);
new_r00=(((r10*x477))+((r20*x467))+((r00*x478)));
new_r01=(((r11*x477))+((r21*x467))+((r01*x478)));
new_r02=(((r22*x467))+((r02*(((((-1.0)*x466))+x474))))+((r12*x477)));
new_r10=(((r20*x460))+((r00*x469))+((r10*x468)));
new_r11=(((r11*x468))+((r01*x469))+((r21*x460)));
new_r12=(((r22*x460))+((r12*x468))+((r02*x469)));
new_r20=(((r10*x475))+((r20*x473))+((r00*((x471+(((-1.0)*sj15*x464)))))));
new_r21=(((r21*x473))+((r11*x475))+((r01*x476)));
new_r22=(((r02*x476))+((r12*x475))+((r22*x473)));
j21eval[0]=sj20;
j21eval[1]=IKsign(sj20);
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )
{
{
IkReal j21eval[2];
IkReal x479=((1.0)*cj17);
IkReal x480=(cj18*sj16);
IkReal x481=(cj16*sj17);
IkReal x482=(sj16*sj18);
IkReal x483=(sj16*sj17);
IkReal x484=(cj16*cj18);
IkReal x485=(sj17*sj18);
IkReal x486=(cj16*sj18);
IkReal x487=(cj18*sj15*sj17);
IkReal x488=(x482+(((-1.0)*x479*x484)));
IkReal x489=x204;
IkReal x490=x205;
IkReal x491=(x484+(((-1.0)*x479*x482)));
IkReal x492=(cj15*x491);
IkReal x493=x208;
IkReal x494=x209;
IkReal x495=(cj15*x493);
IkReal x496=(((cj15*x485))+((sj15*x491)));
IkReal x497=((((-1.0)*sj15*x485))+x492);
IkReal x498=(((cj15*cj18*sj17))+((sj15*x493)));
IkReal x499=((((-1.0)*x487))+x495);
new_r00=(((r20*x488))+((r10*x498))+((r00*x499)));
new_r01=(((r11*x498))+((r21*x488))+((r01*x499)));
new_r02=(((r02*(((((-1.0)*x487))+x495))))+((r12*x498))+((r22*x488)));
new_r10=(((r20*x481))+((r10*x489))+((r00*x490)));
new_r11=(((r11*x489))+((r21*x481))+((r01*x490)));
new_r12=(((r02*x490))+((r12*x489))+((r22*x481)));
new_r20=(((r10*x496))+((r00*(((((-1.0)*sj15*x485))+x492))))+((r20*x494)));
new_r21=(((r11*x496))+((r21*x494))+((r01*x497)));
new_r22=(((r02*x497))+((r22*x494))+((r12*x496)));
j21eval[0]=sj20;
j21eval[1]=sj19;
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )
{
{
IkReal j21eval[3];
IkReal x500=((1.0)*cj17);
IkReal x501=(cj18*sj16);
IkReal x502=(cj16*sj17);
IkReal x503=(sj16*sj18);
IkReal x504=(sj16*sj17);
IkReal x505=(cj16*cj18);
IkReal x506=(sj17*sj18);
IkReal x507=(cj16*sj18);
IkReal x508=(cj18*sj15*sj17);
IkReal x509=(x503+(((-1.0)*x500*x505)));
IkReal x510=x204;
IkReal x511=x205;
IkReal x512=(x505+(((-1.0)*x500*x503)));
IkReal x513=(cj15*x512);
IkReal x514=x208;
IkReal x515=x209;
IkReal x516=(cj15*x514);
IkReal x517=(((cj15*x506))+((sj15*x512)));
IkReal x518=((((-1.0)*sj15*x506))+x513);
IkReal x519=(((cj15*cj18*sj17))+((sj15*x514)));
IkReal x520=(x516+(((-1.0)*x508)));
new_r00=(((r20*x509))+((r10*x519))+((r00*x520)));
new_r01=(((r11*x519))+((r21*x509))+((r01*x520)));
new_r02=(((r22*x509))+((r02*((x516+(((-1.0)*x508))))))+((r12*x519)));
new_r10=(((r20*x502))+((r10*x510))+((r00*x511)));
new_r11=(((r01*x511))+((r11*x510))+((r21*x502)));
new_r12=(((r22*x502))+((r02*x511))+((r12*x510)));
new_r20=(((r00*(((((-1.0)*sj15*x506))+x513))))+((r20*x515))+((r10*x517)));
new_r21=(((r01*x518))+((r11*x517))+((r21*x515)));
new_r22=(((r02*x518))+((r22*x515))+((r12*x517)));
j21eval[0]=cj20;
j21eval[1]=sj19;
j21eval[2]=sj20;
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x521=((1.0)*sj19);
IkReal x522=((((-1.0)*new_r02*x521))+((cj19*new_r12)));
IkReal x523=(((new_r10*sj19))+((cj19*new_r00)));
IkReal x524=(((cj19*new_r01))+((new_r11*sj19)));
IkReal x525=((-1.0)+((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*cj19))+new_r02);
evalcond[3]=((((-1.0)*x521))+new_r12);
evalcond[4]=x522;
evalcond[5]=x522;
evalcond[6]=x525;
evalcond[7]=x524;
evalcond[8]=x523;
evalcond[9]=x523;
evalcond[10]=x524;
evalcond[11]=x525;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x526=IKcos(j21);
IkReal x527=IKsin(j21);
IkReal x528=((1.0)*new_r12);
IkReal x529=((1.0)*x527);
IkReal x530=((1.0)*x526);
evalcond[0]=(x526+new_r20);
evalcond[1]=((((-1.0)*x529))+new_r21);
evalcond[2]=(((new_r12*x526))+new_r01);
evalcond[3]=(((new_r12*x527))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*new_r02*x530)));
evalcond[5]=((((-1.0)*new_r02*x529))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x528))+(((-1.0)*x529))+((new_r02*new_r10)));
evalcond[7]=((((-1.0)*x530))+(((-1.0)*new_r01*x528))+((new_r02*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x531=(new_r12*sj19);
IkReal x532=((1.0)*sj19);
IkReal x533=(cj19*new_r00);
IkReal x534=((1.0)*cj19);
IkReal x535=(((cj19*new_r12))+(((-1.0)*new_r02*x532)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj19+new_r02);
evalcond[3]=(sj19+new_r12);
evalcond[4]=x535;
evalcond[5]=x535;
evalcond[6]=((1.0)+x531+((cj19*new_r02)));
evalcond[7]=(((cj19*new_r01))+((new_r11*sj19)));
evalcond[8]=(x533+((new_r10*sj19)));
evalcond[9]=((((-1.0)*x533))+(((-1.0)*new_r10*x532)));
evalcond[10]=((((-1.0)*new_r11*x532))+(((-1.0)*new_r01*x534)));
evalcond[11]=((-1.0)+(((-1.0)*x531))+(((-1.0)*new_r02*x534)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x536=IKcos(j21);
IkReal x537=IKsin(j21);
IkReal x538=((1.0)*new_r02);
IkReal x539=((1.0)*x536);
IkReal x540=((1.0)*x537);
evalcond[0]=(x537+new_r21);
evalcond[1]=((((-1.0)*x539))+new_r20);
evalcond[2]=(((new_r02*x536))+new_r11);
evalcond[3]=(((new_r02*x537))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x539))+new_r01);
evalcond[5]=((((-1.0)*new_r12*x540))+new_r00);
evalcond[6]=(((new_r00*new_r12))+(((-1.0)*x540))+(((-1.0)*new_r10*x538)));
evalcond[7]=(((new_r01*new_r12))+(((-1.0)*x539))+(((-1.0)*new_r11*x538)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x541=((((-1.0)*cj20))+new_r22);
IkReal x542=((((-1.0)*sj20))+new_r02);
IkReal x543=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)));
evalcond[1]=x541;
evalcond[2]=x541;
evalcond[3]=x542;
evalcond[4]=new_r12;
evalcond[5]=x542;
evalcond[6]=(((new_r00*sj20))+((cj20*new_r20)));
evalcond[7]=(((new_r01*sj20))+((cj20*new_r21)));
evalcond[8]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));
evalcond[9]=((((-1.0)*new_r22*x543))+((cj20*new_r02)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x544=IKcos(j21);
IkReal x545=IKsin(j21);
IkReal x546=((1.0)*new_r02);
IkReal x547=((1.0)*x544);
evalcond[0]=(((new_r02*x544))+new_r20);
evalcond[1]=((((-1.0)*x545))+new_r10);
evalcond[2]=((((-1.0)*x547))+new_r11);
evalcond[3]=(((new_r22*x545))+new_r01);
evalcond[4]=((((-1.0)*x545*x546))+new_r21);
evalcond[5]=((((-1.0)*new_r22*x547))+new_r00);
evalcond[6]=(((new_r01*new_r22))+(((-1.0)*new_r21*x546))+x545);
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x546))+(((-1.0)*x547)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x548=((((-1.0)*cj20))+new_r22);
IkReal x549=((1.0)*sj20);
IkReal x550=((1.0)*cj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));
evalcond[1]=x548;
evalcond[2]=x548;
evalcond[3]=(sj20+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*x549))+(((-1.0)*new_r02)));
evalcond[6]=((((-1.0)*new_r00*x549))+((cj20*new_r20)));
evalcond[7]=((((-1.0)*new_r01*x549))+((cj20*new_r21)));
evalcond[8]=((-1.0)+((cj20*new_r22))+(((-1.0)*new_r02*x549)));
evalcond[9]=((((-1.0)*new_r22*x549))+(((-1.0)*new_r02*x550)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x551=IKsin(j21);
IkReal x552=IKcos(j21);
IkReal x553=((1.0)*new_r22);
IkReal x554=((1.0)*x552);
evalcond[0]=(((new_r02*x551))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*new_r02*x554)));
evalcond[2]=((((-1.0)*x551))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x554))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*new_r01))+((new_r22*x551)));
evalcond[5]=((((-1.0)*x552*x553))+(((-1.0)*new_r00)));
evalcond[6]=((((-1.0)*new_r01*x553))+x551+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*new_r00*x553))+(((-1.0)*x554))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x555=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));
IkReal x556=(((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x555;
evalcond[7]=x555;
evalcond[8]=x556;
evalcond[9]=x556;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x557=((1.0)*sj19);
if( IKabs(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x557)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x557))+((cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x557))))+IKsqr(((((-1.0)*new_r01*x557))+((cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x557))), ((((-1.0)*new_r01*x557))+((cj19*new_r00))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x558=IKsin(j21);
IkReal x559=IKcos(j21);
IkReal x560=((1.0)*sj19);
IkReal x561=((1.0)*x559);
IkReal x562=(sj19*x558);
IkReal x563=((1.0)*x558);
IkReal x564=(cj19*x561);
evalcond[0]=(x558+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((cj19*x558))+new_r01+((sj19*x559)));
evalcond[2]=(((new_r10*sj19))+((cj19*new_r00))+(((-1.0)*x561)));
evalcond[3]=((((-1.0)*new_r00*x560))+((cj19*new_r10))+(((-1.0)*x563)));
evalcond[4]=(((cj19*new_r11))+(((-1.0)*x561))+(((-1.0)*new_r01*x560)));
evalcond[5]=(x562+new_r00+(((-1.0)*x564)));
evalcond[6]=(x562+new_r11+(((-1.0)*x564)));
evalcond[7]=((((-1.0)*x559*x560))+(((-1.0)*cj19*x563))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x565=(new_r12*sj19);
IkReal x566=((1.0)*new_r02);
IkReal x567=((((-1.0)*sj19*x566))+((cj19*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x567;
evalcond[7]=x567;
evalcond[8]=(x565+((cj19*new_r02)));
evalcond[9]=((((-1.0)*x565))+(((-1.0)*cj19*x566)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x568=((1.0)*sj19);
if( IKabs(((((-1.0)*new_r00*x568))+((cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x568)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x568))+((cj19*new_r01))))+IKsqr(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x568))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((((-1.0)*new_r00*x568))+((cj19*new_r01))), ((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x568))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x569=IKsin(j21);
IkReal x570=IKcos(j21);
IkReal x571=((1.0)*cj19);
IkReal x572=((1.0)*sj19);
IkReal x573=((1.0)*x569);
IkReal x574=(sj19*x570);
IkReal x575=(sj19*x569);
IkReal x576=(x569*x571);
evalcond[0]=(x570+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x573))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x570))+x575+new_r00);
evalcond[3]=((((-1.0)*x573))+(((-1.0)*new_r00*x572))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x570))+(((-1.0)*new_r01*x572))+((cj19*new_r11)));
evalcond[5]=((((-1.0)*x576))+x574+new_r01);
evalcond[6]=((((-1.0)*x576))+x574+new_r10);
evalcond[7]=((((-1.0)*x569*x572))+(((-1.0)*x570*x571))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j21]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x578=IKPowWithIntegerCheck(sj20,-1);
if(!x578.valid){
continue;
}
IkReal x577=x578.value;
CheckValue<IkReal> x579=IKPowWithIntegerCheck(cj20,-1);
if(!x579.valid){
continue;
}
CheckValue<IkReal> x580=IKPowWithIntegerCheck(sj19,-1);
if(!x580.valid){
continue;
}
if( IKabs((x577*(x579.value)*(x580.value)*(((((-1.0)*new_r11*sj20))+(((-1.0)*cj19*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x577)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x577*(x579.value)*(x580.value)*(((((-1.0)*new_r11*sj20))+(((-1.0)*cj19*new_r20))))))+IKsqr(((-1.0)*new_r20*x577))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((x577*(x579.value)*(x580.value)*(((((-1.0)*new_r11*sj20))+(((-1.0)*cj19*new_r20))))), ((-1.0)*new_r20*x577));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x581=IKsin(j21);
IkReal x582=IKcos(j21);
IkReal x583=(cj20*sj19);
IkReal x584=(cj19*new_r01);
IkReal x585=((1.0)*sj20);
IkReal x586=(cj19*new_r00);
IkReal x587=((1.0)*sj19);
IkReal x588=((1.0)*x582);
IkReal x589=(cj20*x581);
IkReal x590=((1.0)*x581);
IkReal x591=(cj19*x588);
evalcond[0]=(((sj20*x582))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x581*x585)));
evalcond[2]=(x584+x589+((new_r11*sj19)));
evalcond[3]=((((-1.0)*x590))+((cj19*new_r10))+(((-1.0)*new_r00*x587)));
evalcond[4]=((((-1.0)*new_r01*x587))+((cj19*new_r11))+(((-1.0)*x588)));
evalcond[5]=(((sj19*x582))+((cj19*x589))+new_r01);
evalcond[6]=(x586+((new_r10*sj19))+(((-1.0)*cj20*x588)));
evalcond[7]=((((-1.0)*cj20*x591))+((sj19*x581))+new_r00);
evalcond[8]=(((x581*x583))+(((-1.0)*x591))+new_r11);
evalcond[9]=((((-1.0)*cj19*x590))+(((-1.0)*x583*x588))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x585))+((cj20*x584))+x581+((new_r11*x583)));
evalcond[11]=((((-1.0)*new_r20*x585))+((cj20*x586))+(((-1.0)*x588))+((new_r10*x583)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x593=IKPowWithIntegerCheck(sj20,-1);
if(!x593.valid){
continue;
}
IkReal x592=x593.value;
CheckValue<IkReal> x594=IKPowWithIntegerCheck(sj19,-1);
if(!x594.valid){
continue;
}
if( IKabs((new_r21*x592)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x592*(x594.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x592))+IKsqr((x592*(x594.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((new_r21*x592), (x592*(x594.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21))))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x595=IKsin(j21);
IkReal x596=IKcos(j21);
IkReal x597=(cj20*sj19);
IkReal x598=(cj19*new_r01);
IkReal x599=((1.0)*sj20);
IkReal x600=(cj19*new_r00);
IkReal x601=((1.0)*sj19);
IkReal x602=((1.0)*x596);
IkReal x603=(cj20*x595);
IkReal x604=((1.0)*x595);
IkReal x605=(cj19*x602);
evalcond[0]=(((sj20*x596))+new_r20);
evalcond[1]=((((-1.0)*x595*x599))+new_r21);
evalcond[2]=(x598+x603+((new_r11*sj19)));
evalcond[3]=((((-1.0)*x604))+((cj19*new_r10))+(((-1.0)*new_r00*x601)));
evalcond[4]=((((-1.0)*x602))+((cj19*new_r11))+(((-1.0)*new_r01*x601)));
evalcond[5]=(((sj19*x596))+((cj19*x603))+new_r01);
evalcond[6]=((((-1.0)*cj20*x602))+x600+((new_r10*sj19)));
evalcond[7]=(((sj19*x595))+(((-1.0)*cj20*x605))+new_r00);
evalcond[8]=(((x595*x597))+(((-1.0)*x605))+new_r11);
evalcond[9]=((((-1.0)*cj19*x604))+(((-1.0)*x597*x602))+new_r10);
evalcond[10]=(((cj20*x598))+(((-1.0)*new_r21*x599))+((new_r11*x597))+x595);
evalcond[11]=((((-1.0)*new_r20*x599))+((new_r10*x597))+((cj20*x600))+(((-1.0)*x602)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x606=IKPowWithIntegerCheck(IKsign(sj20),-1);
if(!x606.valid){
continue;
}
CheckValue<IkReal> x607 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x607.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(((1.5707963267949)*(x606.value)))+(x607.value));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x608=IKsin(j21);
IkReal x609=IKcos(j21);
IkReal x610=(cj20*sj19);
IkReal x611=(cj19*new_r01);
IkReal x612=((1.0)*sj20);
IkReal x613=(cj19*new_r00);
IkReal x614=((1.0)*sj19);
IkReal x615=((1.0)*x609);
IkReal x616=(cj20*x608);
IkReal x617=((1.0)*x608);
IkReal x618=(cj19*x615);
evalcond[0]=(((sj20*x609))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x608*x612)));
evalcond[2]=(x616+x611+((new_r11*sj19)));
evalcond[3]=((((-1.0)*x617))+(((-1.0)*new_r00*x614))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x615))+((cj19*new_r11))+(((-1.0)*new_r01*x614)));
evalcond[5]=(((sj19*x609))+((cj19*x616))+new_r01);
evalcond[6]=((((-1.0)*cj20*x615))+x613+((new_r10*sj19)));
evalcond[7]=(((sj19*x608))+(((-1.0)*cj20*x618))+new_r00);
evalcond[8]=(((x608*x610))+(((-1.0)*x618))+new_r11);
evalcond[9]=((((-1.0)*x610*x615))+(((-1.0)*cj19*x617))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x612))+((new_r11*x610))+((cj20*x611))+x608);
evalcond[11]=(((new_r10*x610))+((cj20*x613))+(((-1.0)*x615))+(((-1.0)*new_r20*x612)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "72948cfc3ff77d3858ae895ad25226f4"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
