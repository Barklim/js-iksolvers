/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2015-05-22 19:42:31.703880
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42;
x0=IKsin(j[0]);
x1=IKcos(j[0]);
x2=IKcos(j[3]);
x3=IKsin(j[3]);
x4=IKcos(j[1]);
x5=IKcos(j[2]);
x6=IKsin(j[1]);
x7=IKsin(j[2]);
x8=IKsin(j[4]);
x9=IKcos(j[4]);
x10=IKsin(j[5]);
x11=IKcos(j[5]);
x12=((0.331)*x5);
x13=((1.0)*x9);
x14=((1.0)*x7);
x15=((1.0)*x0);
x16=((1.0)*x8);
x17=((1.0)*x5);
x18=(x1*x3);
x19=(x0*x4);
x20=(x1*x4);
x21=(x5*x6);
x22=(x1*x6);
x23=(x4*x7);
x24=(x17*x4);
x25=((0.331)*x6*x7);
x26=(x0*x14*x6);
x27=(x17*x20);
x28=(x21+x23);
x29=((((-1.0)*x24))+((x6*x7)));
x30=((((-1.0)*x14*x6))+x24);
x31=(x2*x29);
x32=(((x19*x5))+(((-1.0)*x26)));
x33=(((x22*x7))+(((-1.0)*x27)));
x34=(x3*x30*x9);
x35=((((-1.0)*x15*x21))+(((-1.0)*x14*x19)));
x36=(((x14*x20))+((x17*x22)));
x37=(x32*x8);
x38=(x33*x8);
x39=(x2*x35);
x40=(((x1*x2))+((x3*x35)));
x41=(((x0*x2))+((x3*x36)));
x42=(((x2*x36))+(((-1.0)*x15*x3)));
eerot[0]=(((x11*((x37+((x40*x9))))))+((x10*(((((-1.0)*x18))+x39)))));
eerot[1]=(((x9*((x26+(((-1.0)*x15*x4*x5))))))+((x40*x8)));
eerot[2]=(((x11*(((((-1.0)*x18))+x39))))+((x10*(((((-1.0)*x16*x32))+(((-1.0)*x13*x40)))))));
eetrans[0]=((0.045416)+(((-0.10015)*x1))+((x0*x25))+(((-1.0)*x12*x19))+(((-0.405)*x19)));
eerot[3]=(((x10*x31))+((x11*(((((-1.0)*x16*x28))+(((-1.0)*x13*x3*x30)))))));
eerot[4]=(((x29*x3*x8))+((x28*x9)));
eerot[5]=(((x11*x31))+((x10*((x34+((x28*x8)))))));
eetrans[1]=((0.302408)+(((0.331)*x23))+(((0.405)*x6))+((x12*x6)));
eerot[6]=(((x11*((((x41*x9))+x38))))+((x10*x42)));
eerot[7]=(((x41*x8))+((x9*(((((-1.0)*x14*x22))+x27)))));
eerot[8]=(((x11*x42))+((x10*(((((-1.0)*x16*x33))+(((-1.0)*x13*x41)))))));
eetrans[2]=((0.467052)+(((-0.10015)*x0))+(((-0.331)*x22*x7))+(((0.405)*x20))+((x12*x20)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r02;
new_r02=((-1.0)*r01);
new_px=((-0.045416)+px);
new_r10=r20;
new_r11=r22;
new_r12=((-1.0)*r21);
new_py=((-0.467052)+pz);
new_r20=((-1.0)*r10);
new_r21=((-1.0)*r12);
new_r22=r11;
new_pz=((0.302408)+(((-1.0)*py)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x43=((1.0)*px);
IkReal x44=((1.0)*pz);
IkReal x45=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x45))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x44)));
rxp0_2=((((-1.0)*r10*x43))+((py*r00)));
rxp1_0=((((-1.0)*r21*x45))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x44)));
rxp1_2=((((-1.0)*r11*x43))+((py*r01)));
rxp2_0=((((-1.0)*r22*x45))+((pz*r12)));
rxp2_1=((((-1.0)*r02*x44))+((px*r22)));
rxp2_2=((((-1.0)*r12*x43))+((py*r02)));
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
cj3array[0]=((-1.05783455484689)+(((3.72981239043676)*pp)));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j1eval[2];
j1eval[0]=((px*px)+(py*py));
j1eval[1]=((IKabs(px))+(IKabs(py)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=((((3.02114803625378)*(IKabs(((0.405)+(((0.331)*cj3)))))))+(IKabs(sj3)));
j2eval[1]=((1.49711119832787)+(sj3*sj3)+(((2.44712990936556)*cj3))+(cj3*cj3));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2]

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x46=((0.405)+(((0.331)*cj3)));
CheckValue<IkReal> x49 = IKatan2WithCheck(IkReal(((0.331)*sj3)),x46,IKFAST_ATAN2_MAGTHRESH);
if(!x49.valid){
continue;
}
IkReal x47=((1.0)*(x49.value));
if((((x46*x46)+(((0.109561)*(sj3*sj3))))) < -0.00001)
continue;
CheckValue<IkReal> x50=IKPowWithIntegerCheck(IKabs(IKsqrt(((x46*x46)+(((0.109561)*(sj3*sj3)))))),-1);
if(!x50.valid){
continue;
}
if( ((pz*(x50.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x50.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x48=IKasin((pz*(x50.value)));
j2array[0]=((((-1.0)*x48))+(((-1.0)*x47)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x47))+x48);
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j1eval[3];
IkReal x51=pz*pz;
IkReal x52=(pp*sj2);
IkReal x53=((6620.0)*sj3);
IkReal x54=((2003.0)*sj2);
IkReal x55=((20000.0)*cj2*pz);
IkReal x56=(sj2*x51);
j1eval[0]=(x52+(((-1.0)*x56)));
j1eval[1]=IKsign(((((20000.0)*x52))+(((-20000.0)*x56))));
j1eval[2]=((IKabs((((px*x55))+((px*x53))+(((-1.0)*py*x54)))))+(IKabs(((((-1.0)*px*x54))+(((-1.0)*py*x55))+(((-1.0)*py*x53))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
IkReal x57=pz*pz;
IkReal x58=((2003.0)*cj2);
IkReal x59=((6620.0)*cj3);
IkReal x60=(cj2*pp);
IkReal x61=((20000.0)*pz*sj2);
IkReal x62=(cj2*x57);
j1eval[0]=(x60+(((-1.0)*x62)));
j1eval[1]=IKsign(((((20000.0)*x60))+(((-20000.0)*x62))));
j1eval[2]=((IKabs(((((-1.0)*px*x61))+(((-1.0)*px*x59))+(((-8100.0)*px))+(((-1.0)*py*x58)))))+(IKabs(((((-1.0)*px*x58))+(((8100.0)*py))+((py*x61))+((py*x59))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
IkReal x63=pz*pz;
IkReal x64=((2000000.0)*pp);
IkReal x65=((1620000.0)*cj2);
IkReal x66=((162243.0)*cj2);
IkReal x67=((1620000.0)*pz*sj2);
j1eval[0]=(((cj2*pp))+(((-1.0)*cj2*x63)));
j1eval[1]=((IKabs(((((-88867.955)*px))+(((-1.0)*px*x67))+(((-1.0)*px*x64))+(((-1.0)*py*x66)))))+(IKabs(((((-1.0)*px*x66))+((py*x67))+((py*x64))+(((88867.955)*py))))));
j1eval[2]=IKsign((((pp*x65))+(((-1.0)*x63*x65))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
IkReal x68=((1.0)*pp);
IkReal x69=((0.405)+(((0.331)*cj3))+pz);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=((0.2836160225)+(((-1.0)*x68))+(((0.26811)*cj3)));
evalcond[2]=x69;
evalcond[3]=x69;
evalcond[4]=((-0.0444339775)+(((-0.81)*pz))+(((-1.0)*x68)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x70=pz*pz;
IkReal x71=((6620.0)*sj3);
j1eval[0]=(pp+(((-1.0)*x70)));
j1eval[1]=IKsign(((((-20000.0)*x70))+(((20000.0)*pp))));
j1eval[2]=((IKabs(((((-1.0)*py*x71))+(((-2003.0)*px)))))+(IKabs((((px*x71))+(((-2003.0)*py))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x72=((6620.0)*sj3);
CheckValue<IkReal> x73 = IKatan2WithCheck(IkReal((((px*x72))+(((-2003.0)*py)))),((((-1.0)*py*x72))+(((-2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x73.valid){
continue;
}
CheckValue<IkReal> x74=IKPowWithIntegerCheck(IKsign(((((-20000.0)*(pz*pz)))+(((20000.0)*pp)))),-1);
if(!x74.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x73.value)+(((1.5707963267949)*(x74.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[2];
IkReal x75=IKcos(j1);
IkReal x76=IKsin(j1);
evalcond[0]=((0.10015)+((py*x76))+((px*x75)));
evalcond[1]=(((py*x75))+(((-1.0)*px*x76))+(((0.331)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x347=((0.331)*cj3);
IkReal x348=((1.0)*pp);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=((0.2836160225)+(((-1.0)*x348))+(((0.26811)*cj3)));
evalcond[2]=((-0.405)+pz+(((-1.0)*x347)));
evalcond[3]=((0.405)+x347+(((-1.0)*pz)));
evalcond[4]=((-0.0444339775)+(((0.81)*pz))+(((-1.0)*x348)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
IkReal x349=pz*pz;
IkReal x350=((6620.0)*sj3);
j1eval[0]=(x349+(((-1.0)*pp)));
j1eval[1]=IKsign(((((20000.0)*x349))+(((-20000.0)*pp))));
j1eval[2]=((IKabs((((px*x350))+(((2003.0)*py)))))+(IKabs(((((-1.0)*py*x350))+(((2003.0)*px))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x351=((6620.0)*sj3);
CheckValue<IkReal> x352 = IKatan2WithCheck(IkReal((((px*x351))+(((2003.0)*py)))),((((-1.0)*py*x351))+(((2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x352.valid){
continue;
}
CheckValue<IkReal> x353=IKPowWithIntegerCheck(IKsign(((((-20000.0)*pp))+(((20000.0)*(pz*pz))))),-1);
if(!x353.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x352.value)+(((1.5707963267949)*(x353.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[2];
IkReal x354=IKsin(j1);
IkReal x355=IKcos(j1);
evalcond[0]=((0.10015)+((px*x355))+((py*x354)));
evalcond[1]=(((px*x354))+(((-1.0)*py*x355))+(((0.331)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x356=(pz+(((0.331)*sj3)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=((0.2836160225)+(((-1.0)*pp))+(((0.26811)*cj3)));
evalcond[2]=x356;
evalcond[3]=x356;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=0;
cj2=1.0;
j2=0;
IkReal x357=pz*pz;
IkReal x358=((6620.0)*cj3);
j1eval[0]=(x357+(((-1.0)*pp)));
j1eval[1]=IKsign(((((-20000.0)*pp))+(((20000.0)*x357))));
j1eval[2]=((IKabs(((((-8100.0)*py))+(((-1.0)*py*x358))+(((2003.0)*px)))))+(IKabs((((px*x358))+(((8100.0)*px))+(((2003.0)*py))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=0;
cj2=1.0;
j2=0;
IkReal x359=pz*pz;
IkReal x360=((2000000.0)*pp);
j1eval[0]=((((-1.0)*x359))+pp);
j1eval[1]=IKsign(((((-1620000.0)*x359))+(((1620000.0)*pp))));
j1eval[2]=((IKabs((((py*x360))+(((-162243.0)*px))+(((88867.955)*py)))))+(IKabs(((((-88867.955)*px))+(((-162243.0)*py))+(((-1.0)*px*x360))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x361=((2000000.0)*pp);
CheckValue<IkReal> x362 = IKatan2WithCheck(IkReal(((((-88867.955)*px))+(((-162243.0)*py))+(((-1.0)*px*x361)))),(((py*x361))+(((-162243.0)*px))+(((88867.955)*py))),IKFAST_ATAN2_MAGTHRESH);
if(!x362.valid){
continue;
}
CheckValue<IkReal> x363=IKPowWithIntegerCheck(IKsign(((((-1620000.0)*(pz*pz)))+(((1620000.0)*pp)))),-1);
if(!x363.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x362.value)+(((1.5707963267949)*(x363.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x364=IKsin(j1);
IkReal x365=IKcos(j1);
IkReal x366=(px*x364);
IkReal x367=(py*x365);
evalcond[0]=((0.10015)+((py*x364))+((px*x365)));
evalcond[1]=((0.405)+(((-1.0)*x367))+(((0.331)*cj3))+x366);
evalcond[2]=((-0.0444339775)+(((-1.0)*pp))+(((0.81)*x367))+(((-0.81)*x366)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x368=((6620.0)*cj3);
CheckValue<IkReal> x369 = IKatan2WithCheck(IkReal(((((8100.0)*px))+((px*x368))+(((2003.0)*py)))),((((-8100.0)*py))+(((-1.0)*py*x368))+(((2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x369.valid){
continue;
}
CheckValue<IkReal> x370=IKPowWithIntegerCheck(IKsign(((((-20000.0)*pp))+(((20000.0)*(pz*pz))))),-1);
if(!x370.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x369.value)+(((1.5707963267949)*(x370.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x371=IKsin(j1);
IkReal x372=IKcos(j1);
IkReal x373=(px*x371);
IkReal x374=(py*x372);
evalcond[0]=((0.10015)+((px*x372))+((py*x371)));
evalcond[1]=((0.405)+(((-1.0)*x374))+(((0.331)*cj3))+x373);
evalcond[2]=((-0.0444339775)+(((-0.81)*x373))+(((-1.0)*pp))+(((0.81)*x374)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x375=((0.331)*sj3);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=((0.2836160225)+(((-1.0)*pp))+(((0.26811)*cj3)));
evalcond[2]=((((-1.0)*x375))+pz);
evalcond[3]=(x375+(((-1.0)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x376=pz*pz;
IkReal x377=((6620.0)*cj3);
j1eval[0]=((((-1.0)*x376))+pp);
j1eval[1]=((IKabs(((((8100.0)*px))+((px*x377))+(((-2003.0)*py)))))+(IKabs(((((-8100.0)*py))+(((-1.0)*py*x377))+(((-2003.0)*px))))));
j1eval[2]=IKsign(((((20000.0)*pp))+(((-20000.0)*x376))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x378=pz*pz;
IkReal x379=((2000000.0)*pp);
j1eval[0]=(x378+(((-1.0)*pp)));
j1eval[1]=((IKabs(((((-88867.955)*px))+(((162243.0)*py))+(((-1.0)*px*x379)))))+(IKabs(((((162243.0)*px))+((py*x379))+(((88867.955)*py))))));
j1eval[2]=IKsign(((((1620000.0)*x378))+(((-1620000.0)*pp))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x380=((2000000.0)*pp);
CheckValue<IkReal> x381=IKPowWithIntegerCheck(IKsign(((((1620000.0)*(pz*pz)))+(((-1620000.0)*pp)))),-1);
if(!x381.valid){
continue;
}
CheckValue<IkReal> x382 = IKatan2WithCheck(IkReal(((((-88867.955)*px))+(((162243.0)*py))+(((-1.0)*px*x380)))),((((162243.0)*px))+((py*x380))+(((88867.955)*py))),IKFAST_ATAN2_MAGTHRESH);
if(!x382.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x381.value)))+(x382.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x383=IKcos(j1);
IkReal x384=IKsin(j1);
IkReal x385=(px*x384);
IkReal x386=(py*x383);
evalcond[0]=((0.10015)+((px*x383))+((py*x384)));
evalcond[1]=((0.405)+(((0.331)*cj3))+x386+(((-1.0)*x385)));
evalcond[2]=((-0.0444339775)+(((0.81)*x385))+(((-1.0)*pp))+(((-0.81)*x386)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x387=((6620.0)*cj3);
CheckValue<IkReal> x388 = IKatan2WithCheck(IkReal((((px*x387))+(((8100.0)*px))+(((-2003.0)*py)))),((((-1.0)*py*x387))+(((-8100.0)*py))+(((-2003.0)*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x388.valid){
continue;
}
CheckValue<IkReal> x389=IKPowWithIntegerCheck(IKsign(((((-20000.0)*(pz*pz)))+(((20000.0)*pp)))),-1);
if(!x389.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x388.value)+(((1.5707963267949)*(x389.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[3];
IkReal x390=IKcos(j1);
IkReal x391=IKsin(j1);
IkReal x392=(px*x391);
IkReal x393=(py*x390);
evalcond[0]=((0.10015)+((py*x391))+((px*x390)));
evalcond[1]=((0.405)+(((-1.0)*x392))+(((0.331)*cj3))+x393);
evalcond[2]=((-0.0444339775)+(((-0.81)*x393))+(((-1.0)*pp))+(((0.81)*x392)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x394=((2000000.0)*pp);
IkReal x395=((1620000.0)*cj2);
IkReal x396=((162243.0)*cj2);
IkReal x397=((1620000.0)*pz*sj2);
CheckValue<IkReal> x398 = IKatan2WithCheck(IkReal(((((-88867.955)*px))+(((-1.0)*py*x396))+(((-1.0)*px*x394))+(((-1.0)*px*x397)))),(((py*x394))+((py*x397))+(((-1.0)*px*x396))+(((88867.955)*py))),IKFAST_ATAN2_MAGTHRESH);
if(!x398.valid){
continue;
}
CheckValue<IkReal> x399=IKPowWithIntegerCheck(IKsign(((((-1.0)*x395*(pz*pz)))+((pp*x395)))),-1);
if(!x399.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x398.value)+(((1.5707963267949)*(x399.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x400=IKcos(j1);
IkReal x401=IKsin(j1);
IkReal x402=((0.331)*sj3);
IkReal x403=((0.331)*cj3);
IkReal x404=((0.81)*cj2);
IkReal x405=(pz*sj2);
IkReal x406=(px*x401);
IkReal x407=(py*x400);
evalcond[0]=((0.10015)+((py*x401))+((px*x400)));
evalcond[1]=(((sj2*x407))+x402+((cj2*pz))+(((-1.0)*sj2*x406)));
evalcond[2]=((0.405)+(((-1.0)*cj2*x407))+x403+x405+((cj2*x406)));
evalcond[3]=((-0.0444339775)+((x404*x407))+(((-0.81)*x405))+(((-1.0)*pp))+(((-1.0)*x404*x406)));
evalcond[4]=((((0.405)*cj2))+x406+(((-1.0)*sj2*x402))+((cj2*x403))+(((-1.0)*x407)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x408=((2003.0)*cj2);
IkReal x409=((6620.0)*cj3);
IkReal x410=((20000.0)*cj2);
IkReal x411=((20000.0)*pz*sj2);
CheckValue<IkReal> x412 = IKatan2WithCheck(IkReal(((((-1.0)*px*x411))+(((-1.0)*px*x409))+(((-8100.0)*px))+(((-1.0)*py*x408)))),(((py*x411))+((py*x409))+(((8100.0)*py))+(((-1.0)*px*x408))),IKFAST_ATAN2_MAGTHRESH);
if(!x412.valid){
continue;
}
CheckValue<IkReal> x413=IKPowWithIntegerCheck(IKsign(((((-1.0)*x410*(pz*pz)))+((pp*x410)))),-1);
if(!x413.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x412.value)+(((1.5707963267949)*(x413.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x414=IKcos(j1);
IkReal x415=IKsin(j1);
IkReal x416=((0.331)*sj3);
IkReal x417=((0.331)*cj3);
IkReal x418=((0.81)*cj2);
IkReal x419=(pz*sj2);
IkReal x420=(px*x415);
IkReal x421=(py*x414);
evalcond[0]=((0.10015)+((py*x415))+((px*x414)));
evalcond[1]=(x416+((cj2*pz))+(((-1.0)*sj2*x420))+((sj2*x421)));
evalcond[2]=((0.405)+x417+x419+((cj2*x420))+(((-1.0)*cj2*x421)));
evalcond[3]=((-0.0444339775)+(((-0.81)*x419))+((x418*x421))+(((-1.0)*pp))+(((-1.0)*x418*x420)));
evalcond[4]=((((-1.0)*x421))+(((0.405)*cj2))+x420+((cj2*x417))+(((-1.0)*sj2*x416)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x422=((20000.0)*sj2);
IkReal x423=((6620.0)*sj3);
IkReal x424=((2003.0)*sj2);
IkReal x425=((20000.0)*cj2*pz);
CheckValue<IkReal> x426 = IKatan2WithCheck(IkReal(((((-1.0)*py*x424))+((px*x425))+((px*x423)))),((((-1.0)*px*x424))+(((-1.0)*py*x425))+(((-1.0)*py*x423))),IKFAST_ATAN2_MAGTHRESH);
if(!x426.valid){
continue;
}
CheckValue<IkReal> x427=IKPowWithIntegerCheck(IKsign((((pp*x422))+(((-1.0)*x422*(pz*pz))))),-1);
if(!x427.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x426.value)+(((1.5707963267949)*(x427.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x428=IKcos(j1);
IkReal x429=IKsin(j1);
IkReal x430=((0.331)*sj3);
IkReal x431=((0.331)*cj3);
IkReal x432=((0.81)*cj2);
IkReal x433=(pz*sj2);
IkReal x434=(px*x429);
IkReal x435=(py*x428);
evalcond[0]=((0.10015)+((py*x429))+((px*x428)));
evalcond[1]=(x430+((sj2*x435))+(((-1.0)*sj2*x434))+((cj2*pz)));
evalcond[2]=((0.405)+x431+x433+((cj2*x434))+(((-1.0)*cj2*x435)));
evalcond[3]=((-0.0444339775)+(((-0.81)*x433))+(((-1.0)*x432*x434))+(((-1.0)*pp))+((x432*x435)));
evalcond[4]=((((-1.0)*x435))+(((0.405)*cj2))+x434+((cj2*x431))+(((-1.0)*sj2*x430)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x438 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);
if(!x438.valid){
continue;
}
IkReal x436=((1.0)*(x438.value));
if((((px*px)+(py*py))) < -0.00001)
continue;
CheckValue<IkReal> x439=IKPowWithIntegerCheck(IKabs(IKsqrt(((px*px)+(py*py)))),-1);
if(!x439.valid){
continue;
}
if( (((0.10015)*(x439.value))) < -1-IKFAST_SINCOS_THRESH || (((0.10015)*(x439.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x437=IKasin(((0.10015)*(x439.value)));
j1array[0]=((((-1.0)*x436))+(((-1.0)*x437)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x436))+x437);
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j2eval[3];
IkReal x440=((331000.0)*sj3);
IkReal x441=(cj1*py);
IkReal x442=((331000.0)*cj3);
IkReal x443=((331000.0)*px*sj1);
j2eval[0]=((1.02042445265003)+cj3);
j2eval[1]=IKsign(((273586.0)+(((268110.0)*cj3))));
j2eval[2]=((IKabs(((((-405000.0)*px*sj1))+(((405000.0)*x441))+(((-1.0)*px*sj1*x442))+((x441*x442))+(((-1.0)*pz*x440)))))+(IKabs((((px*sj1*x440))+(((-405000.0)*pz))+(((-1.0)*pz*x442))+(((-1.0)*x440*x441))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
IkReal x444=((1000.0)*pz);
IkReal x445=(cj1*py);
IkReal x446=(px*sj1);
IkReal x447=((331.0)*cj3);
IkReal x448=(pz*sj3);
j2eval[0]=((((1.22356495468278)*x446))+(((-1.0)*cj3*x445))+(((-1.0)*x448))+(((-1.22356495468278)*x445))+((cj3*x446)));
j2eval[1]=IKsign((((x446*x447))+(((405.0)*x446))+(((-331.0)*x448))+(((-1.0)*x445*x447))+(((-405.0)*x445))));
j2eval[2]=((IKabs(((((-1.0)*x444*x446))+(((134.055)*sj3))+((x444*x445))+(((109.561)*cj3*sj3)))))+(IKabs(((-164.025)+((pz*x444))+(((-268.11)*cj3))+(((-109.561)*(cj3*cj3)))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
IkReal x449=(px*sj1);
IkReal x450=((33100.0)*pp);
IkReal x451=(cj1*py);
IkReal x452=((26811.0)*cj3);
IkReal x453=((81000.0)*pz);
IkReal x454=(pz*sj3);
j2eval[0]=((((-1.0)*cj3*x449))+(((1.22356495468278)*x451))+(((-1.22356495468278)*x449))+((cj3*x451))+x454);
j2eval[1]=IKsign(((((32805.0)*x451))+(((-32805.0)*x449))+(((26811.0)*x454))+((x451*x452))+(((-1.0)*x449*x452))));
j2eval[2]=((IKabs(((1799.57608875)+(((1470.76465525)*cj3))+((cj3*x450))+(((-1.0)*pz*x453))+(((40500.0)*pp)))))+(IKabs(((((-1470.76465525)*sj3))+(((-1.0)*sj3*x450))+((x449*x453))+(((-1.0)*x451*x453))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x455=(px*sj1);
IkReal x456=(cj1*py);
IkReal x457=((26811.0)*cj3);
IkReal x458=((33100.0)*pp);
IkReal x459=((81000.0)*pz);
CheckValue<IkReal> x460=IKPowWithIntegerCheck(IKsign(((((-32805.0)*x455))+(((26811.0)*pz*sj3))+(((32805.0)*x456))+(((-1.0)*x455*x457))+((x456*x457)))),-1);
if(!x460.valid){
continue;
}
CheckValue<IkReal> x461 = IKatan2WithCheck(IkReal(((((-1470.76465525)*sj3))+((x455*x459))+(((-1.0)*x456*x459))+(((-1.0)*sj3*x458)))),((1799.57608875)+(((1470.76465525)*cj3))+((cj3*x458))+(((-1.0)*pz*x459))+(((40500.0)*pp))),IKFAST_ATAN2_MAGTHRESH);
if(!x461.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x460.value)))+(x461.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x462=IKsin(j2);
IkReal x463=IKcos(j2);
IkReal x464=(cj1*py);
IkReal x465=((0.331)*sj3);
IkReal x466=(px*sj1);
IkReal x467=((0.331)*cj3);
IkReal x468=((0.81)*x463);
IkReal x469=(pz*x462);
evalcond[0]=(((x463*x465))+(((0.405)*x462))+pz+((x462*x467)));
evalcond[1]=((((-1.0)*x462*x466))+x465+((pz*x463))+((x462*x464)));
evalcond[2]=((0.405)+((x463*x466))+x469+x467+(((-1.0)*x463*x464)));
evalcond[3]=((-0.0444339775)+(((-1.0)*x466*x468))+(((-1.0)*pp))+(((-0.81)*x469))+((x464*x468)));
evalcond[4]=((((-1.0)*x462*x465))+((x463*x467))+(((-1.0)*x464))+(((0.405)*x463))+x466);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x470=((331.0)*cj3);
IkReal x471=(px*sj1);
IkReal x472=(cj1*py);
IkReal x473=((1000.0)*pz);
CheckValue<IkReal> x474 = IKatan2WithCheck(IkReal((((x472*x473))+(((134.055)*sj3))+(((-1.0)*x471*x473))+(((109.561)*cj3*sj3)))),((-164.025)+((pz*x473))+(((-268.11)*cj3))+(((-109.561)*(cj3*cj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x474.valid){
continue;
}
CheckValue<IkReal> x475=IKPowWithIntegerCheck(IKsign(((((-405.0)*x472))+(((-331.0)*pz*sj3))+((x470*x471))+(((405.0)*x471))+(((-1.0)*x470*x472)))),-1);
if(!x475.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x474.value)+(((1.5707963267949)*(x475.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x476=IKsin(j2);
IkReal x477=IKcos(j2);
IkReal x478=(cj1*py);
IkReal x479=((0.331)*sj3);
IkReal x480=(px*sj1);
IkReal x481=((0.331)*cj3);
IkReal x482=((0.81)*x477);
IkReal x483=(pz*x476);
evalcond[0]=(((x476*x481))+pz+(((0.405)*x476))+((x477*x479)));
evalcond[1]=((((-1.0)*x476*x480))+x479+((pz*x477))+((x476*x478)));
evalcond[2]=((0.405)+(((-1.0)*x477*x478))+x481+x483+((x477*x480)));
evalcond[3]=((-0.0444339775)+(((-0.81)*x483))+(((-1.0)*pp))+((x478*x482))+(((-1.0)*x480*x482)));
evalcond[4]=((((-1.0)*x476*x479))+(((-1.0)*x478))+x480+(((0.405)*x477))+((x477*x481)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x484=((331000.0)*sj3);
IkReal x485=(cj1*py);
IkReal x486=((331000.0)*cj3);
IkReal x487=((331000.0)*px*sj1);
CheckValue<IkReal> x488=IKPowWithIntegerCheck(IKsign(((273586.0)+(((268110.0)*cj3)))),-1);
if(!x488.valid){
continue;
}
CheckValue<IkReal> x489 = IKatan2WithCheck(IkReal(((((-1.0)*x484*x485))+(((-1.0)*pz*x486))+((px*sj1*x484))+(((-405000.0)*pz)))),((((-1.0)*pz*x484))+((x485*x486))+(((-405000.0)*px*sj1))+(((-1.0)*px*sj1*x486))+(((405000.0)*x485))),IKFAST_ATAN2_MAGTHRESH);
if(!x489.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x488.value)))+(x489.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x490=IKsin(j2);
IkReal x491=IKcos(j2);
IkReal x492=(cj1*py);
IkReal x493=((0.331)*sj3);
IkReal x494=(px*sj1);
IkReal x495=((0.331)*cj3);
IkReal x496=((0.81)*x491);
IkReal x497=(pz*x490);
evalcond[0]=((((0.405)*x490))+((x491*x493))+((x490*x495))+pz);
evalcond[1]=(((pz*x491))+((x490*x492))+x493+(((-1.0)*x490*x494)));
evalcond[2]=((0.405)+((x491*x494))+(((-1.0)*x491*x492))+x497+x495);
evalcond[3]=((-0.0444339775)+(((-1.0)*x494*x496))+(((-0.81)*x497))+(((-1.0)*pp))+((x492*x496)));
evalcond[4]=((((0.405)*x491))+((x491*x495))+(((-1.0)*x490*x493))+(((-1.0)*x492))+x494);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
}
}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x77=((1.0)*cj2);
IkReal x78=((1.0)*sj1);
IkReal x79=(cj1*r10);
IkReal x80=(cj1*r11);
IkReal x81=(cj3*sj2);
IkReal x82=(cj1*r12);
IkReal x83=(r02*x78);
IkReal x84=(((sj2*sj3))+(((-1.0)*cj3*x77)));
IkReal x85=(((cj2*sj3))+x81);
IkReal x86=(cj1*x84);
IkReal x87=((((-1.0)*sj3*x77))+(((-1.0)*x81)));
IkReal x88=(x78*x87);
new_r00=(((x79*x87))+((r20*x84))+(((-1.0)*r00*x88)));
new_r01=(((r21*x84))+((x80*x87))+(((-1.0)*r01*x88)));
new_r02=((((-1.0)*x83*x87))+((x82*x87))+((r22*x84)));
new_r10=(((r10*sj1))+((cj1*r00)));
new_r11=(((cj1*r01))+((r11*sj1)));
new_r12=(((cj1*r02))+((r12*sj1)));
new_r20=(((x79*x84))+(((-1.0)*r00*x78*x84))+((r20*x85)));
new_r21=(((r21*x85))+((x80*x84))+(((-1.0)*r01*x78*x84)));
new_r22=((((-1.0)*x83*x84))+((x82*x84))+((r22*x85)));
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=new_r22;
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j4eval[2];
IkReal x89=((1.0)*cj2);
IkReal x90=((1.0)*sj1);
IkReal x91=(cj1*r10);
IkReal x92=(cj1*r11);
IkReal x93=(cj3*sj2);
IkReal x94=(cj1*r12);
IkReal x95=(r02*x90);
IkReal x96=x84;
IkReal x97=(((cj2*sj3))+x93);
IkReal x98=(cj1*x96);
IkReal x99=x87;
IkReal x100=(x90*x99);
new_r00=((((-1.0)*r00*x100))+((r20*x96))+((x91*x99)));
new_r01=(((r21*x96))+(((-1.0)*r01*x100))+((x92*x99)));
new_r02=((((-1.0)*x95*x99))+((r22*x96))+((x94*x99)));
new_r10=(((r10*sj1))+((cj1*r00)));
new_r11=(((cj1*r01))+((r11*sj1)));
new_r12=(((cj1*r02))+((r12*sj1)));
new_r20=(((r20*x97))+(((-1.0)*r00*x90*x96))+((x91*x96)));
new_r21=(((r21*x97))+((x92*x96))+(((-1.0)*r01*x90*x96)));
new_r22=((((-1.0)*x95*x96))+((r22*x97))+((x94*x96)));
j4eval[0]=sj5;
j4eval[1]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x101=((1.0)*cj2);
IkReal x102=((1.0)*sj1);
IkReal x103=(cj1*r10);
IkReal x104=(cj1*r11);
IkReal x105=(cj3*sj2);
IkReal x106=(cj1*r12);
IkReal x107=(r02*x102);
IkReal x108=x84;
IkReal x109=(((cj2*sj3))+x105);
IkReal x110=(cj1*x108);
IkReal x111=x87;
IkReal x112=(x102*x111);
new_r00=((((-1.0)*r00*x112))+((x103*x111))+((r20*x108)));
new_r01=((((-1.0)*r01*x112))+((r21*x108))+((x104*x111)));
new_r02=(((r22*x108))+((x106*x111))+(((-1.0)*x107*x111)));
new_r10=(((r10*sj1))+((cj1*r00)));
new_r11=(((cj1*r01))+((r11*sj1)));
new_r12=(((cj1*r02))+((r12*sj1)));
new_r20=((((-1.0)*r00*x102*x108))+((r20*x109))+((x103*x108)));
new_r21=(((r21*x109))+(((-1.0)*r01*x102*x108))+((x104*x108)));
new_r22=(((x106*x108))+((r22*x109))+(((-1.0)*x107*x108)));
j4eval[0]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r21;
evalcond[4]=new_r02;
evalcond[5]=new_r20;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x114 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x114.valid){
continue;
}
IkReal x113=x114.value;
j4array[0]=((-1.0)*x113);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x113)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x115=((1.0)*cj4);
if( IKabs(((((-1.0)*new_r00*x115))+((new_r01*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x115))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x115))+((new_r01*sj4))))+IKsqr(((((-1.0)*new_r01*x115))+(((-1.0)*new_r00*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r00*x115))+((new_r01*sj4))), ((((-1.0)*new_r01*x115))+(((-1.0)*new_r00*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x116=IKsin(j6);
IkReal x117=IKcos(j6);
IkReal x118=((1.0)*sj4);
IkReal x119=(sj4*x117);
IkReal x120=(cj4*x116);
IkReal x121=((1.0)*x117);
IkReal x122=(x120+x119);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x116);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+x117);
evalcond[2]=((((-1.0)*new_r01*x118))+((cj4*new_r11))+x116);
evalcond[3]=(x122+new_r00);
evalcond[4]=(x122+new_r11);
evalcond[5]=((((-1.0)*x116*x118))+((cj4*x117))+new_r01);
evalcond[6]=(((sj4*x116))+(((-1.0)*cj4*x121))+new_r10);
evalcond[7]=((((-1.0)*new_r00*x118))+((cj4*new_r10))+(((-1.0)*x121)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r21;
evalcond[4]=new_r02;
evalcond[5]=new_r20;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x124 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x124.valid){
continue;
}
IkReal x123=x124.value;
j4array[0]=((-1.0)*x123);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x123)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j4))))+(((-1.0)*new_r02*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x125=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x125)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r00*sj4))+(((-1.0)*cj4*x125)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x125))))+IKsqr((((new_r00*sj4))+(((-1.0)*cj4*x125))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x125))), (((new_r00*sj4))+(((-1.0)*cj4*x125))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x126=IKcos(j6);
IkReal x127=IKsin(j6);
IkReal x128=((1.0)*sj4);
IkReal x129=(cj4*x126);
IkReal x130=(sj4*x127);
IkReal x131=(sj4*x126);
IkReal x132=(cj4*x127);
IkReal x133=(x130+x129);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x127);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+x126);
evalcond[2]=(((cj4*new_r10))+(((-1.0)*new_r00*x128))+x126);
evalcond[3]=(x133+new_r01);
evalcond[4]=(x133+new_r10);
evalcond[5]=((((-1.0)*x126*x128))+x132+new_r00);
evalcond[6]=(x131+(((-1.0)*x132))+new_r11);
evalcond[7]=((((-1.0)*new_r01*x128))+((cj4*new_r11))+(((-1.0)*x127)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x135=IKPowWithIntegerCheck(sj5,-1);
if(!x135.valid){
continue;
}
IkReal x134=x135.value;
CheckValue<IkReal> x136=IKPowWithIntegerCheck(new_r02,-1);
if(!x136.valid){
continue;
}
if( IKabs((x134*(x136.value)*(((1.0)+(((-1.0)*(cj5*cj5)))+(((-1.0)*(new_r12*new_r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x134)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x134*(x136.value)*(((1.0)+(((-1.0)*(cj5*cj5)))+(((-1.0)*(new_r12*new_r12)))))))+IKsqr(((-1.0)*new_r12*x134))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x134*(x136.value)*(((1.0)+(((-1.0)*(cj5*cj5)))+(((-1.0)*(new_r12*new_r12)))))), ((-1.0)*new_r12*x134));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x137=IKcos(j4);
IkReal x138=IKsin(j4);
IkReal x139=(sj5*x138);
IkReal x140=(sj5*x137);
IkReal x141=(new_r12*x137);
IkReal x142=((1.0)*new_r02*x138);
evalcond[0]=(x140+new_r12);
evalcond[1]=((((-1.0)*x139))+new_r02);
evalcond[2]=(((new_r12*x138))+((new_r02*x137)));
evalcond[3]=((((-1.0)*x142))+sj5+x141);
evalcond[4]=(((cj5*x141))+((new_r22*sj5))+(((-1.0)*cj5*x142)));
evalcond[5]=(((new_r00*x139))+((cj5*new_r20))+(((-1.0)*new_r10*x140)));
evalcond[6]=(((new_r01*x139))+((cj5*new_r21))+(((-1.0)*new_r11*x140)));
evalcond[7]=((-1.0)+((cj5*new_r22))+((new_r02*x139))+(((-1.0)*new_r12*x140)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[2];
IkReal x143=((1.0)*cj2);
IkReal x144=((1.0)*sj1);
IkReal x145=(cj1*r10);
IkReal x146=(cj1*r11);
IkReal x147=(cj3*sj2);
IkReal x148=(cj1*r12);
IkReal x149=(r02*x144);
IkReal x150=x84;
IkReal x151=(((cj2*sj3))+x147);
IkReal x152=(cj1*x150);
IkReal x153=x87;
IkReal x154=(x144*x153);
new_r00=(((r20*x150))+(((-1.0)*r00*x154))+((x145*x153)));
new_r01=((((-1.0)*r01*x154))+((x146*x153))+((r21*x150)));
new_r02=(((x148*x153))+(((-1.0)*x149*x153))+((r22*x150)));
new_r10=(((r10*sj1))+((cj1*r00)));
new_r11=(((cj1*r01))+((r11*sj1)));
new_r12=(((cj1*r02))+((r12*sj1)));
new_r20=((((-1.0)*r00*x144*x150))+((r20*x151))+((x145*x150)));
new_r21=((((-1.0)*r01*x144*x150))+((x146*x150))+((r21*x151)));
new_r22=(((x148*x150))+(((-1.0)*x149*x150))+((r22*x151)));
j6eval[0]=sj5;
j6eval[1]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
IkReal x155=((1.0)*cj2);
IkReal x156=((1.0)*sj1);
IkReal x157=(cj1*r10);
IkReal x158=(cj1*r11);
IkReal x159=(cj3*sj2);
IkReal x160=(cj1*r12);
IkReal x161=(r02*x156);
IkReal x162=x84;
IkReal x163=(((cj2*sj3))+x159);
IkReal x164=(cj1*x162);
IkReal x165=x87;
IkReal x166=(x156*x165);
new_r00=(((x157*x165))+((r20*x162))+(((-1.0)*r00*x166)));
new_r01=((((-1.0)*r01*x166))+((r21*x162))+((x158*x165)));
new_r02=(((r22*x162))+(((-1.0)*x161*x165))+((x160*x165)));
new_r10=(((r10*sj1))+((cj1*r00)));
new_r11=(((cj1*r01))+((r11*sj1)));
new_r12=(((cj1*r02))+((r12*sj1)));
new_r20=(((x157*x162))+((r20*x163))+(((-1.0)*r00*x156*x162)));
new_r21=((((-1.0)*r01*x156*x162))+((r21*x163))+((x158*x162)));
new_r22=(((r22*x163))+(((-1.0)*x161*x162))+((x160*x162)));
j6eval[0]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x167=((1.0)*cj2);
IkReal x168=((1.0)*sj1);
IkReal x169=(cj1*r10);
IkReal x170=(cj1*r11);
IkReal x171=(cj3*sj2);
IkReal x172=(cj1*r12);
IkReal x173=(r02*x168);
IkReal x174=x84;
IkReal x175=(((cj2*sj3))+x171);
IkReal x176=(cj1*x174);
IkReal x177=x87;
IkReal x178=(x168*x177);
new_r00=(((x169*x177))+(((-1.0)*r00*x178))+((r20*x174)));
new_r01=((((-1.0)*r01*x178))+((r21*x174))+((x170*x177)));
new_r02=(((r22*x174))+((x172*x177))+(((-1.0)*x173*x177)));
new_r10=(((r10*sj1))+((cj1*r00)));
new_r11=(((cj1*r01))+((r11*sj1)));
new_r12=(((cj1*r02))+((r12*sj1)));
new_r20=(((x169*x174))+((r20*x175))+(((-1.0)*r00*x168*x174)));
new_r21=((((-1.0)*r01*x168*x174))+((r21*x175))+((x170*x174)));
new_r22=(((r22*x175))+((x172*x174))+(((-1.0)*x173*x174)));
j6eval[0]=sj5;
j6eval[1]=sj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[10];
bool bgotonextstatement = true;
do
{
IkReal x179=(((new_r12*sj4))+((cj4*new_r02)));
IkReal x180=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r21;
evalcond[4]=new_r02;
evalcond[5]=new_r20;
evalcond[6]=x179;
evalcond[7]=x179;
evalcond[8]=x180;
evalcond[9]=x180;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x181=((1.0)*cj4);
if( IKabs((((new_r01*sj4))+(((-1.0)*new_r00*x181)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x181))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r01*sj4))+(((-1.0)*new_r00*x181))))+IKsqr(((((-1.0)*new_r01*x181))+(((-1.0)*new_r00*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((new_r01*sj4))+(((-1.0)*new_r00*x181))), ((((-1.0)*new_r01*x181))+(((-1.0)*new_r00*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x182=IKsin(j6);
IkReal x183=IKcos(j6);
IkReal x184=((1.0)*sj4);
IkReal x185=(sj4*x183);
IkReal x186=(cj4*x182);
IkReal x187=((1.0)*x183);
IkReal x188=(x185+x186);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x182);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+x183);
evalcond[2]=(((cj4*new_r11))+x182+(((-1.0)*new_r01*x184)));
evalcond[3]=(x188+new_r00);
evalcond[4]=(x188+new_r11);
evalcond[5]=(new_r01+(((-1.0)*x182*x184))+((cj4*x183)));
evalcond[6]=((((-1.0)*cj4*x187))+((sj4*x182))+new_r10);
evalcond[7]=(((cj4*new_r10))+(((-1.0)*x187))+(((-1.0)*new_r00*x184)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x189=(new_r02*sj4);
IkReal x190=(cj4*new_r12);
IkReal x191=(((new_r12*sj4))+((cj4*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r21;
evalcond[4]=new_r02;
evalcond[5]=new_r20;
evalcond[6]=x191;
evalcond[7]=x191;
evalcond[8]=((((-1.0)*x189))+x190);
evalcond[9]=((((-1.0)*x190))+x189);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x192=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x192)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*x192))+((new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x192))))+IKsqr(((((-1.0)*cj4*x192))+((new_r00*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x192))), ((((-1.0)*cj4*x192))+((new_r00*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x193=IKcos(j6);
IkReal x194=IKsin(j6);
IkReal x195=((1.0)*sj4);
IkReal x196=(cj4*x193);
IkReal x197=(sj4*x194);
IkReal x198=(sj4*x193);
IkReal x199=(cj4*x194);
IkReal x200=(x197+x196);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x194);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+x193);
evalcond[2]=(((cj4*new_r10))+x193+(((-1.0)*new_r00*x195)));
evalcond[3]=(x200+new_r01);
evalcond[4]=(x200+new_r10);
evalcond[5]=(x199+new_r00+(((-1.0)*x193*x195)));
evalcond[6]=((((-1.0)*x199))+x198+new_r11);
evalcond[7]=(((cj4*new_r11))+(((-1.0)*x194))+(((-1.0)*new_r01*x195)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x201=(new_r22+(((-1.0)*cj5)));
IkReal x202=(sj5+new_r12);
IkReal x203=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=x201;
evalcond[2]=x201;
evalcond[3]=x202;
evalcond[4]=new_r02;
evalcond[5]=x202;
evalcond[6]=(((cj5*new_r12))+((new_r22*sj5)));
evalcond[7]=(((cj5*new_r20))+(((-1.0)*new_r10*x203)));
evalcond[8]=(((cj5*new_r21))+(((-1.0)*new_r11*x203)));
evalcond[9]=((-1.0)+(((-1.0)*new_r12*x203))+((cj5*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x204=IKcos(j6);
IkReal x205=IKsin(j6);
IkReal x206=((1.0)*new_r12);
IkReal x207=((1.0)*x204);
evalcond[0]=(x205+new_r00);
evalcond[1]=(x204+new_r01);
evalcond[2]=(((new_r12*x204))+new_r20);
evalcond[3]=(((new_r22*x205))+new_r11);
evalcond[4]=((((-1.0)*x205*x206))+new_r21);
evalcond[5]=((((-1.0)*new_r22*x207))+new_r10);
evalcond[6]=((((-1.0)*new_r21*x206))+x205+((new_r11*new_r22)));
evalcond[7]=((((-1.0)*new_r20*x206))+(((-1.0)*x207))+((new_r10*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x208=(new_r22+(((-1.0)*cj5)));
IkReal x209=((1.0)*cj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=x208;
evalcond[2]=x208;
evalcond[3]=((((-1.0)*sj5))+new_r12);
evalcond[4]=new_r02;
evalcond[5]=(sj5+(((-1.0)*new_r12)));
evalcond[6]=((((-1.0)*new_r12*x209))+((new_r22*sj5)));
evalcond[7]=(((new_r10*sj5))+((cj5*new_r20)));
evalcond[8]=(((new_r11*sj5))+((cj5*new_r21)));
evalcond[9]=((-1.0)+((new_r12*sj5))+((cj5*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x210=IKsin(j6);
IkReal x211=IKcos(j6);
IkReal x212=((1.0)*new_r22);
IkReal x213=((1.0)*x211);
evalcond[0]=(new_r21+((new_r12*x210)));
evalcond[1]=(x210+(((-1.0)*new_r00)));
evalcond[2]=(x211+(((-1.0)*new_r01)));
evalcond[3]=(((new_r22*x211))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x213))+new_r20);
evalcond[5]=((((-1.0)*x210*x212))+new_r11);
evalcond[6]=((((-1.0)*new_r11*x212))+((new_r12*new_r21))+x210);
evalcond[7]=((((-1.0)*new_r10*x212))+((new_r12*new_r20))+(((-1.0)*x213)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x215=IKPowWithIntegerCheck(sj5,-1);
if(!x215.valid){
continue;
}
IkReal x214=x215.value;
CheckValue<IkReal> x216=IKPowWithIntegerCheck(sj4,-1);
if(!x216.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x214)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x214*(x216.value)*(((((-1.0)*new_r11*sj5))+((cj4*cj5*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x214))+IKsqr((x214*(x216.value)*(((((-1.0)*new_r11*sj5))+((cj4*cj5*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*x214), (x214*(x216.value)*(((((-1.0)*new_r11*sj5))+((cj4*cj5*new_r21))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x217=IKsin(j6);
IkReal x218=IKcos(j6);
IkReal x219=(cj4*cj5);
IkReal x220=((1.0)*sj4);
IkReal x221=(cj5*x217);
IkReal x222=((1.0)*x218);
IkReal x223=(sj4*x218);
evalcond[0]=(((sj5*x217))+new_r21);
evalcond[1]=((((-1.0)*sj5*x222))+new_r20);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+x217);
evalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+x218);
evalcond[4]=(((cj4*x217))+((cj5*x223))+new_r00);
evalcond[5]=(x223+new_r11+((x217*x219)));
evalcond[6]=((((-1.0)*new_r01*x220))+((cj4*new_r11))+x221);
evalcond[7]=(((cj4*x218))+(((-1.0)*x220*x221))+new_r01);
evalcond[8]=((((-1.0)*x219*x222))+new_r10+((sj4*x217)));
evalcond[9]=((((-1.0)*cj5*x222))+((cj4*new_r10))+(((-1.0)*new_r00*x220)));
evalcond[10]=(x217+(((-1.0)*cj5*new_r01*x220))+((new_r21*sj5))+((new_r11*x219)));
evalcond[11]=(((new_r20*sj5))+(((-1.0)*cj5*new_r00*x220))+((new_r10*x219))+(((-1.0)*x222)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x224=IKPowWithIntegerCheck(sj5,-1);
if(!x224.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*(x224.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x224.value)))+IKsqr(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*(x224.value)), ((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x225=IKsin(j6);
IkReal x226=IKcos(j6);
IkReal x227=(cj4*cj5);
IkReal x228=((1.0)*sj4);
IkReal x229=(cj5*x225);
IkReal x230=((1.0)*x226);
IkReal x231=(sj4*x226);
evalcond[0]=(((sj5*x225))+new_r21);
evalcond[1]=((((-1.0)*sj5*x230))+new_r20);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+x225);
evalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+x226);
evalcond[4]=(((cj5*x231))+((cj4*x225))+new_r00);
evalcond[5]=(((x225*x227))+x231+new_r11);
evalcond[6]=((((-1.0)*new_r01*x228))+((cj4*new_r11))+x229);
evalcond[7]=((((-1.0)*x228*x229))+((cj4*x226))+new_r01);
evalcond[8]=(((sj4*x225))+(((-1.0)*x227*x230))+new_r10);
evalcond[9]=(((cj4*new_r10))+(((-1.0)*cj5*x230))+(((-1.0)*new_r00*x228)));
evalcond[10]=(x225+(((-1.0)*cj5*new_r01*x228))+((new_r11*x227))+((new_r21*sj5)));
evalcond[11]=(((new_r20*sj5))+(((-1.0)*x230))+(((-1.0)*cj5*new_r00*x228))+((new_r10*x227)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x232 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x232.valid){
continue;
}
CheckValue<IkReal> x233=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x233.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x232.value)+(((1.5707963267949)*(x233.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x234=IKsin(j6);
IkReal x235=IKcos(j6);
IkReal x236=(cj4*cj5);
IkReal x237=((1.0)*sj4);
IkReal x238=(cj5*x234);
IkReal x239=((1.0)*x235);
IkReal x240=(sj4*x235);
evalcond[0]=(new_r21+((sj5*x234)));
evalcond[1]=((((-1.0)*sj5*x239))+new_r20);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+x234);
evalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+x235);
evalcond[4]=(((cj5*x240))+((cj4*x234))+new_r00);
evalcond[5]=(((x234*x236))+x240+new_r11);
evalcond[6]=(((cj4*new_r11))+x238+(((-1.0)*new_r01*x237)));
evalcond[7]=(((cj4*x235))+new_r01+(((-1.0)*x237*x238)));
evalcond[8]=(((sj4*x234))+(((-1.0)*x236*x239))+new_r10);
evalcond[9]=(((cj4*new_r10))+(((-1.0)*cj5*x239))+(((-1.0)*new_r00*x237)));
evalcond[10]=(((new_r11*x236))+(((-1.0)*cj5*new_r01*x237))+x234+((new_r21*sj5)));
evalcond[11]=(((new_r10*x236))+((new_r20*sj5))+(((-1.0)*cj5*new_r00*x237))+(((-1.0)*x239)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x241=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x241.valid){
continue;
}
CheckValue<IkReal> x242 = IKatan2WithCheck(IkReal(new_r02),((-1.0)*new_r12),IKFAST_ATAN2_MAGTHRESH);
if(!x242.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x241.value)))+(x242.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x243=IKcos(j4);
IkReal x244=IKsin(j4);
IkReal x245=(sj5*x244);
IkReal x246=(sj5*x243);
IkReal x247=(new_r12*x243);
IkReal x248=((1.0)*new_r02*x244);
evalcond[0]=(x246+new_r12);
evalcond[1]=((((-1.0)*x245))+new_r02);
evalcond[2]=(((new_r12*x244))+((new_r02*x243)));
evalcond[3]=(sj5+x247+(((-1.0)*x248)));
evalcond[4]=((((-1.0)*cj5*x248))+((cj5*x247))+((new_r22*sj5)));
evalcond[5]=(((cj5*new_r20))+((new_r00*x245))+(((-1.0)*new_r10*x246)));
evalcond[6]=(((cj5*new_r21))+(((-1.0)*new_r11*x246))+((new_r01*x245)));
evalcond[7]=((-1.0)+((cj5*new_r22))+(((-1.0)*new_r12*x246))+((new_r02*x245)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[2];
IkReal x249=((1.0)*cj2);
IkReal x250=((1.0)*sj1);
IkReal x251=(cj1*r10);
IkReal x252=(cj1*r11);
IkReal x253=(cj3*sj2);
IkReal x254=(cj1*r12);
IkReal x255=(r02*x250);
IkReal x256=x84;
IkReal x257=(((cj2*sj3))+x253);
IkReal x258=(cj1*x256);
IkReal x259=x87;
IkReal x260=(x250*x259);
new_r00=(((r20*x256))+((x251*x259))+(((-1.0)*r00*x260)));
new_r01=(((r21*x256))+(((-1.0)*r01*x260))+((x252*x259)));
new_r02=((((-1.0)*x255*x259))+((x254*x259))+((r22*x256)));
new_r10=(((r10*sj1))+((cj1*r00)));
new_r11=(((cj1*r01))+((r11*sj1)));
new_r12=(((cj1*r02))+((r12*sj1)));
new_r20=(((r20*x257))+((x251*x256))+(((-1.0)*r00*x250*x256)));
new_r21=(((r21*x257))+(((-1.0)*r01*x250*x256))+((x252*x256)));
new_r22=((((-1.0)*x255*x256))+((x254*x256))+((r22*x257)));
j6eval[0]=sj5;
j6eval[1]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
IkReal x261=((1.0)*cj2);
IkReal x262=((1.0)*sj1);
IkReal x263=(cj1*r10);
IkReal x264=(cj1*r11);
IkReal x265=(cj3*sj2);
IkReal x266=(cj1*r12);
IkReal x267=(r02*x262);
IkReal x268=x84;
IkReal x269=(((cj2*sj3))+x265);
IkReal x270=(cj1*x268);
IkReal x271=x87;
IkReal x272=(x262*x271);
new_r00=(((x263*x271))+(((-1.0)*r00*x272))+((r20*x268)));
new_r01=(((x264*x271))+(((-1.0)*r01*x272))+((r21*x268)));
new_r02=(((x266*x271))+((r22*x268))+(((-1.0)*x267*x271)));
new_r10=(((r10*sj1))+((cj1*r00)));
new_r11=(((cj1*r01))+((r11*sj1)));
new_r12=(((cj1*r02))+((r12*sj1)));
new_r20=((((-1.0)*r00*x262*x268))+((x263*x268))+((r20*x269)));
new_r21=(((x264*x268))+(((-1.0)*r01*x262*x268))+((r21*x269)));
new_r22=(((x266*x268))+((r22*x269))+(((-1.0)*x267*x268)));
j6eval[0]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x273=((1.0)*cj2);
IkReal x274=((1.0)*sj1);
IkReal x275=(cj1*r10);
IkReal x276=(cj1*r11);
IkReal x277=(cj3*sj2);
IkReal x278=(cj1*r12);
IkReal x279=(r02*x274);
IkReal x280=x84;
IkReal x281=(((cj2*sj3))+x277);
IkReal x282=(cj1*x280);
IkReal x283=x87;
IkReal x284=(x274*x283);
new_r00=(((x275*x283))+(((-1.0)*r00*x284))+((r20*x280)));
new_r01=(((r21*x280))+(((-1.0)*r01*x284))+((x276*x283)));
new_r02=(((x278*x283))+((r22*x280))+(((-1.0)*x279*x283)));
new_r10=(((r10*sj1))+((cj1*r00)));
new_r11=(((cj1*r01))+((r11*sj1)));
new_r12=(((cj1*r02))+((r12*sj1)));
new_r20=(((x275*x280))+(((-1.0)*r00*x274*x280))+((r20*x281)));
new_r21=((((-1.0)*r01*x274*x280))+((r21*x281))+((x276*x280)));
new_r22=(((x278*x280))+((r22*x281))+(((-1.0)*x279*x280)));
j6eval[0]=sj5;
j6eval[1]=sj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[10];
bool bgotonextstatement = true;
do
{
IkReal x285=(((new_r12*sj4))+((cj4*new_r02)));
IkReal x286=((((-1.0)*new_r02*sj4))+((cj4*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r21;
evalcond[4]=new_r02;
evalcond[5]=new_r20;
evalcond[6]=x285;
evalcond[7]=x285;
evalcond[8]=x286;
evalcond[9]=x286;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x287=((1.0)*cj4);
if( IKabs((((new_r01*sj4))+(((-1.0)*new_r00*x287)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x287))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r01*sj4))+(((-1.0)*new_r00*x287))))+IKsqr(((((-1.0)*new_r01*x287))+(((-1.0)*new_r00*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((new_r01*sj4))+(((-1.0)*new_r00*x287))), ((((-1.0)*new_r01*x287))+(((-1.0)*new_r00*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x288=IKsin(j6);
IkReal x289=IKcos(j6);
IkReal x290=((1.0)*sj4);
IkReal x291=(sj4*x289);
IkReal x292=(cj4*x288);
IkReal x293=((1.0)*x289);
IkReal x294=(x291+x292);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x288);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+x289);
evalcond[2]=((((-1.0)*new_r01*x290))+((cj4*new_r11))+x288);
evalcond[3]=(x294+new_r00);
evalcond[4]=(x294+new_r11);
evalcond[5]=((((-1.0)*x288*x290))+new_r01+((cj4*x289)));
evalcond[6]=((((-1.0)*cj4*x293))+new_r10+((sj4*x288)));
evalcond[7]=(((cj4*new_r10))+(((-1.0)*x293))+(((-1.0)*new_r00*x290)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x295=(new_r02*sj4);
IkReal x296=(cj4*new_r12);
IkReal x297=(((new_r12*sj4))+((cj4*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r21;
evalcond[4]=new_r02;
evalcond[5]=new_r20;
evalcond[6]=x297;
evalcond[7]=x297;
evalcond[8]=((((-1.0)*x295))+x296);
evalcond[9]=((((-1.0)*x296))+x295);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x298=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x298)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*x298))+((new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x298))))+IKsqr(((((-1.0)*cj4*x298))+((new_r00*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*new_r00))+(((-1.0)*sj4*x298))), ((((-1.0)*cj4*x298))+((new_r00*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x299=IKcos(j6);
IkReal x300=IKsin(j6);
IkReal x301=((1.0)*sj4);
IkReal x302=(cj4*x299);
IkReal x303=(sj4*x300);
IkReal x304=(sj4*x299);
IkReal x305=(cj4*x300);
IkReal x306=(x302+x303);
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x300);
evalcond[1]=(((cj4*new_r01))+((new_r11*sj4))+x299);
evalcond[2]=(((cj4*new_r10))+x299+(((-1.0)*new_r00*x301)));
evalcond[3]=(x306+new_r01);
evalcond[4]=(x306+new_r10);
evalcond[5]=(x305+(((-1.0)*x299*x301))+new_r00);
evalcond[6]=((((-1.0)*x305))+x304+new_r11);
evalcond[7]=(((cj4*new_r11))+(((-1.0)*x300))+(((-1.0)*new_r01*x301)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x307=(new_r22+(((-1.0)*cj5)));
IkReal x308=(sj5+new_r12);
IkReal x309=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=x307;
evalcond[2]=x307;
evalcond[3]=x308;
evalcond[4]=new_r02;
evalcond[5]=x308;
evalcond[6]=(((cj5*new_r12))+((new_r22*sj5)));
evalcond[7]=(((cj5*new_r20))+(((-1.0)*new_r10*x309)));
evalcond[8]=(((cj5*new_r21))+(((-1.0)*new_r11*x309)));
evalcond[9]=((-1.0)+((cj5*new_r22))+(((-1.0)*new_r12*x309)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x310=IKcos(j6);
IkReal x311=IKsin(j6);
IkReal x312=((1.0)*new_r12);
IkReal x313=((1.0)*x310);
evalcond[0]=(x311+new_r00);
evalcond[1]=(x310+new_r01);
evalcond[2]=(((new_r12*x310))+new_r20);
evalcond[3]=(new_r11+((new_r22*x311)));
evalcond[4]=(new_r21+(((-1.0)*x311*x312)));
evalcond[5]=((((-1.0)*new_r22*x313))+new_r10);
evalcond[6]=((((-1.0)*new_r21*x312))+x311+((new_r11*new_r22)));
evalcond[7]=((((-1.0)*new_r20*x312))+(((-1.0)*x313))+((new_r10*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x314=(new_r22+(((-1.0)*cj5)));
IkReal x315=((1.0)*cj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=x314;
evalcond[2]=x314;
evalcond[3]=((((-1.0)*sj5))+new_r12);
evalcond[4]=new_r02;
evalcond[5]=(sj5+(((-1.0)*new_r12)));
evalcond[6]=((((-1.0)*new_r12*x315))+((new_r22*sj5)));
evalcond[7]=(((new_r10*sj5))+((cj5*new_r20)));
evalcond[8]=(((new_r11*sj5))+((cj5*new_r21)));
evalcond[9]=((-1.0)+((new_r12*sj5))+((cj5*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x316=IKsin(j6);
IkReal x317=IKcos(j6);
IkReal x318=((1.0)*new_r22);
IkReal x319=((1.0)*x317);
evalcond[0]=(((new_r12*x316))+new_r21);
evalcond[1]=(x316+(((-1.0)*new_r00)));
evalcond[2]=(x317+(((-1.0)*new_r01)));
evalcond[3]=(new_r10+((new_r22*x317)));
evalcond[4]=((((-1.0)*new_r12*x319))+new_r20);
evalcond[5]=(new_r11+(((-1.0)*x316*x318)));
evalcond[6]=((((-1.0)*new_r11*x318))+x316+((new_r12*new_r21)));
evalcond[7]=(((new_r12*new_r20))+(((-1.0)*new_r10*x318))+(((-1.0)*x319)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x321=IKPowWithIntegerCheck(sj5,-1);
if(!x321.valid){
continue;
}
IkReal x320=x321.value;
CheckValue<IkReal> x322=IKPowWithIntegerCheck(sj4,-1);
if(!x322.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x320)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x320*(x322.value)*(((((-1.0)*new_r11*sj5))+((cj4*cj5*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x320))+IKsqr((x320*(x322.value)*(((((-1.0)*new_r11*sj5))+((cj4*cj5*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*x320), (x320*(x322.value)*(((((-1.0)*new_r11*sj5))+((cj4*cj5*new_r21))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x323=IKsin(j6);
IkReal x324=IKcos(j6);
IkReal x325=(cj4*cj5);
IkReal x326=((1.0)*sj4);
IkReal x327=(cj5*x323);
IkReal x328=((1.0)*x324);
IkReal x329=(sj4*x324);
evalcond[0]=(((sj5*x323))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*sj5*x328)));
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+x323);
evalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+x324);
evalcond[4]=(((cj5*x329))+((cj4*x323))+new_r00);
evalcond[5]=(((x323*x325))+x329+new_r11);
evalcond[6]=(((cj4*new_r11))+x327+(((-1.0)*new_r01*x326)));
evalcond[7]=((((-1.0)*x326*x327))+((cj4*x324))+new_r01);
evalcond[8]=(((sj4*x323))+(((-1.0)*x325*x328))+new_r10);
evalcond[9]=(((cj4*new_r10))+(((-1.0)*new_r00*x326))+(((-1.0)*cj5*x328)));
evalcond[10]=(x323+((new_r21*sj5))+(((-1.0)*cj5*new_r01*x326))+((new_r11*x325)));
evalcond[11]=(((new_r20*sj5))+(((-1.0)*x328))+(((-1.0)*cj5*new_r00*x326))+((new_r10*x325)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x330=IKPowWithIntegerCheck(sj5,-1);
if(!x330.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*(x330.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x330.value)))+IKsqr(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*(x330.value)), ((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x331=IKsin(j6);
IkReal x332=IKcos(j6);
IkReal x333=(cj4*cj5);
IkReal x334=((1.0)*sj4);
IkReal x335=(cj5*x331);
IkReal x336=((1.0)*x332);
IkReal x337=(sj4*x332);
evalcond[0]=(((sj5*x331))+new_r21);
evalcond[1]=((((-1.0)*sj5*x336))+new_r20);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+x331);
evalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+x332);
evalcond[4]=(((cj4*x331))+((cj5*x337))+new_r00);
evalcond[5]=(((x331*x333))+x337+new_r11);
evalcond[6]=(((cj4*new_r11))+x335+(((-1.0)*new_r01*x334)));
evalcond[7]=(((cj4*x332))+new_r01+(((-1.0)*x334*x335)));
evalcond[8]=((((-1.0)*x333*x336))+((sj4*x331))+new_r10);
evalcond[9]=(((cj4*new_r10))+(((-1.0)*cj5*x336))+(((-1.0)*new_r00*x334)));
evalcond[10]=(((new_r11*x333))+x331+(((-1.0)*cj5*new_r01*x334))+((new_r21*sj5)));
evalcond[11]=(((new_r20*sj5))+((new_r10*x333))+(((-1.0)*x336))+(((-1.0)*cj5*new_r00*x334)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x338 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x338.valid){
continue;
}
CheckValue<IkReal> x339=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x339.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x338.value)+(((1.5707963267949)*(x339.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x340=IKsin(j6);
IkReal x341=IKcos(j6);
IkReal x342=(cj4*cj5);
IkReal x343=((1.0)*sj4);
IkReal x344=(cj5*x340);
IkReal x345=((1.0)*x341);
IkReal x346=(sj4*x341);
evalcond[0]=(((sj5*x340))+new_r21);
evalcond[1]=((((-1.0)*sj5*x345))+new_r20);
evalcond[2]=(((cj4*new_r00))+((new_r10*sj4))+x340);
evalcond[3]=(((cj4*new_r01))+((new_r11*sj4))+x341);
evalcond[4]=(((cj4*x340))+((cj5*x346))+new_r00);
evalcond[5]=(x346+new_r11+((x340*x342)));
evalcond[6]=(((cj4*new_r11))+x344+(((-1.0)*new_r01*x343)));
evalcond[7]=(((cj4*x341))+(((-1.0)*x343*x344))+new_r01);
evalcond[8]=(((sj4*x340))+new_r10+(((-1.0)*x342*x345)));
evalcond[9]=(((cj4*new_r10))+(((-1.0)*cj5*x345))+(((-1.0)*new_r00*x343)));
evalcond[10]=(((new_r11*x342))+(((-1.0)*cj5*new_r01*x343))+x340+((new_r21*sj5)));
evalcond[11]=((((-1.0)*cj5*new_r00*x343))+((new_r20*sj5))+((new_r10*x342))+(((-1.0)*x345)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "932c89545e6a1721f49778d9ea6940ca"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
