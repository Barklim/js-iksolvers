{"version":3,"file":"./solvers/HiroNX_rightarm_torso.html","sources":["./solvers/HiroNX_rightarm_torso.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AA7NA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;;;;;AA+NA;;;;;;;;;;;;;;;AAq7KA;AACA;AACA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-10-07 00:43:49.529193\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68,x69,x70,x71,x72,x73,x74,x75;\nx0=IKsin(j[0]);\nx1=IKsin(j[5]);\nx2=IKsin(j[2]);\nx3=IKsin(j[3]);\nx4=(x2*x3);\nx5=IKcos(j[2]);\nx6=IKcos(j[3]);\nx7=(x5*x6);\nx8=((1.0)*x7);\nx9=(x4+(((-1.0)*(1.0)*x8)));\nx10=(x1*x9);\nx11=((0.258820142606703)*x10);\nx12=IKcos(j[5]);\nx13=((0.258820142606703)*x12);\nx14=IKcos(j[4]);\nx15=(x2*x6);\nx16=((1.0)*x15);\nx17=(x3*x5);\nx18=((1.0)*x17);\nx19=((((-1.0)*(1.0)*x16))+(((-1.0)*(1.0)*x18)));\nx20=(x14*x19);\nx21=(x13*x20);\nx22=IKcos(j[0]);\nx23=IKcos(j[1]);\nIkReal x76=((1.0)*x23);\nx24=((((-1.0)*x18*x76))+(((-1.0)*x16*x76)));\nx25=IKsin(j[4]);\nx26=IKsin(j[1]);\nx27=((1.0)*x26);\nx28=(x25*x27);\nx29=((1.0)*x23*x4);\nx30=(x14*(((((-1.0)*(1.0)*x29))+((x23*x7)))));\nx31=(((x1*x24))+((x12*((x30+(((-1.0)*(1.0)*x28)))))));\nx32=((0.965925532213041)*x1);\nx33=(x2*x26*x6);\nx34=((((-1.0)*(1.0)*x17*x27))+(((-1.0)*(1.0)*x33)));\nx35=(x32*x34);\nx36=((0.965925532213041)*x12);\nx37=(x23*x25);\nx38=(x26*x7);\nx39=(x27*x4);\nx40=(x14*((x38+(((-1.0)*(1.0)*x39)))));\nx41=(x37+x40);\nx42=(x36*x41);\nx43=IKcos(j[6]);\nx44=(x18+x16);\nx45=(x25*x43*x44);\nx46=((0.258820142606703)*x45);\nx47=IKsin(j[6]);\nx48=((1.0)*x12);\nx49=((1.0)*x1);\nx50=((((-1.0)*(1.0)*x14*x44*x49))+(((-1.0)*(1.0)*x48*x9)));\nx51=(x47*x50);\nx52=((0.258820142606703)*x51);\nx53=(x14*x27);\nx54=(x25*((x29+(((-1.0)*(1.0)*x23*x8)))));\nx55=(((x49*(((((1.0)*x30))+(((-1.0)*(1.0)*x28))))))+(((-1.0)*(1.0)*x24*x48)));\nx56=(((x43*(((((-1.0)*(1.0)*x53))+x54))))+((x47*x55)));\nx57=(x14*x23);\nx58=(x25*((x39+(((-1.0)*(1.0)*x27*x7)))));\nx59=(x43*((x58+x57)));\nx60=((0.965925532213041)*x59);\nx61=(((x49*(((((1.0)*x37))+(((1.0)*x40))))))+(((-1.0)*(1.0)*x34*x48)));\nx62=(x47*x61);\nx63=((0.965925532213041)*x62);\nx64=(x19*x25*x47);\nx65=((0.258820142606703)*x64);\nx66=(x43*x50);\nx67=((0.258820142606703)*x66);\nx68=(((x47*(((((-1.0)*(1.0)*x54))+x53))))+((x43*x55)));\nx69=(x47*(((((-1.0)*(1.0)*x58))+(((-1.0)*(1.0)*x57)))));\nx70=((0.965925532213041)*x69);\nx71=(x43*x61);\nx72=((0.965925532213041)*x71);\nx73=((0.258820142606703)*x1);\nx74=((0.04)*x17);\nx75=((0.09)*x17);\neerot[0]=(((x22*x31))+((x0*(((((-1.0)*(1.0)*x35))+(((-1.0)*(1.0)*x42))))))+((x0*((x11+x21)))));\neerot[1]=(((x0*((x46+x52))))+((x0*(((((-1.0)*(1.0)*x60))+(((-1.0)*(1.0)*x63))))))+((x22*x56)));\neerot[2]=(((x22*x68))+((x0*(((((-1.0)*(1.0)*x70))+(((-1.0)*(1.0)*x72))))))+((x0*((x67+x65)))));\neetrans[0]=((((((((-0.0608227335125751)*(IKcos(j[2]))*(IKcos(j[3]))))+(((0.0608227335125751)*(IKsin(j[2]))*(IKsin(j[3]))))+(((0.00776460427820108)*(IKcos(j[3]))*(IKsin(j[2]))))+(((((((0.0232938128346032)*(IKcos(j[3]))*(IKsin(j[2]))))+(((0.0232938128346032)*(IKcos(j[2]))*(IKsin(j[3]))))))*(IKcos(j[4]))*(IKsin(j[5]))))+(((((((0.0103528057042681)*(IKcos(j[3]))*(IKsin(j[2]))))+(((0.0103528057042681)*(IKcos(j[2]))*(IKsin(j[3]))))))*(IKcos(j[4]))*(IKcos(j[5]))))+(((0.00776460427820108)*(IKcos(j[2]))*(IKsin(j[3]))))+(((((((0.0232938128346032)*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.0232938128346032)*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKcos(j[5]))))+(((((((0.0103528057042681)*(IKcos(j[2]))*(IKcos(j[3]))))+(((-0.0103528057042681)*(IKsin(j[2]))*(IKsin(j[3]))))))*(IKsin(j[5]))))+(((-0.0647050356516757)*(IKcos(j[2]))))))*(IKsin(j[0]))))+(((0.145)*(IKsin(j[0]))))+(((((((-0.235)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[3]))))+(((-0.03)*(IKcos(j[1]))*(IKcos(j[2]))*(IKcos(j[3]))))+(((-0.25)*(IKcos(j[1]))*(IKsin(j[2]))))+(((((((0.09)*(IKsin(j[1]))*(IKsin(j[4]))))+(((((((0.09)*(IKcos(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.09)*(IKcos(j[1]))*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((0.04)*(IKsin(j[1]))*(IKsin(j[4]))))+(((((((0.04)*(IKcos(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.04)*(IKcos(j[1]))*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))+(((((((-0.09)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[2]))))+(((-0.09)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[3]))))))*(IKcos(j[5]))))+(((-0.235)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[2]))))+(((0.03)*(IKcos(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((0.095)*(IKsin(j[1]))))+(((((((0.04)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[3]))))+(((0.04)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[2]))))))*(IKsin(j[5]))))))*(IKcos(j[0]))))+(((((((0.0289777659663912)*(IKcos(j[2]))*(IKcos(j[3]))*(IKsin(j[1]))))+(((((((-0.0386370212885216)*(IKcos(j[3]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((-0.0386370212885216)*(IKcos(j[2]))*(IKsin(j[1]))*(IKsin(j[3]))))))*(IKsin(j[5]))))+(((((((0.0869332978991737)*(IKcos(j[1]))*(IKsin(j[4]))))+(((-0.965925532213041)*(((((-0.09)*(IKcos(j[2]))*(IKcos(j[3]))*(IKsin(j[1]))))+(((0.09)*(IKsin(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((0.0386370212885216)*(IKcos(j[1]))*(IKsin(j[4]))))+(((-0.965925532213041)*(((((0.04)*(IKsin(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.04)*(IKcos(j[2]))*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))+(((0.0917629255602389)*(IKcos(j[1]))))+(((((((0.0869332978991737)*(IKcos(j[2]))*(IKsin(j[1]))*(IKsin(j[3]))))+(((0.0869332978991737)*(IKcos(j[3]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKcos(j[5]))))+(((0.226992500070065)*(IKcos(j[3]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((0.226992500070065)*(IKcos(j[2]))*(IKsin(j[1]))*(IKsin(j[3]))))+(((-0.0289777659663912)*(IKsin(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((0.24148138305326)*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKsin(j[0])))));\neerot[3]=(((x22*((x35+x42))))+((x0*x31))+((x22*(((((-1.0)*(1.0)*x21))+(((-1.0)*(1.0)*x11)))))));\neerot[4]=(((x22*(((((-1.0)*(1.0)*x52))+(((-1.0)*(1.0)*x46))))))+((x0*x56))+((x22*((x60+x63)))));\neerot[5]=(((x22*(((((-1.0)*(1.0)*x65))+(((-1.0)*(1.0)*x67))))))+((x0*x68))+((x22*((x70+x72)))));\neetrans[1]=((((((((-0.00776460427820108)*(IKcos(j[3]))*(IKsin(j[2]))))+(((((((0.0103528057042681)*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.0103528057042681)*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKsin(j[5]))))+(((0.0608227335125751)*(IKcos(j[2]))*(IKcos(j[3]))))+(((((((-0.0232938128346032)*(IKsin(j[2]))*(IKsin(j[3]))))+(((0.0232938128346032)*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKcos(j[5]))))+(((((((-0.0103528057042681)*(IKcos(j[2]))*(IKsin(j[3]))))+(((-0.0103528057042681)*(IKcos(j[3]))*(IKsin(j[2]))))))*(IKcos(j[4]))*(IKcos(j[5]))))+(((-0.0608227335125751)*(IKsin(j[2]))*(IKsin(j[3]))))+(((0.0647050356516757)*(IKcos(j[2]))))+(((-0.00776460427820108)*(IKcos(j[2]))*(IKsin(j[3]))))+(((((((-0.0232938128346032)*(IKcos(j[3]))*(IKsin(j[2]))))+(((-0.0232938128346032)*(IKcos(j[2]))*(IKsin(j[3]))))))*(IKcos(j[4]))*(IKsin(j[5]))))))*(IKcos(j[0]))))+(((((((((((-0.0869332978991737)*(IKcos(j[2]))*(IKsin(j[1]))*(IKsin(j[3]))))+(((-0.0869332978991737)*(IKcos(j[3]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKcos(j[5]))))+(((-0.226992500070065)*(IKcos(j[2]))*(IKsin(j[1]))*(IKsin(j[3]))))+(((((((0.965925532213041)*(((((-0.09)*(IKcos(j[2]))*(IKcos(j[3]))*(IKsin(j[1]))))+(((0.09)*(IKsin(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))))*(IKcos(j[4]))))+(((-0.0869332978991737)*(IKcos(j[1]))*(IKsin(j[4]))))))*(IKsin(j[5]))))+(((-0.226992500070065)*(IKcos(j[3]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((-0.0917629255602389)*(IKcos(j[1]))))+(((0.0289777659663912)*(IKsin(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((((((-0.0386370212885216)*(IKcos(j[1]))*(IKsin(j[4]))))+(((0.965925532213041)*(((((0.04)*(IKsin(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.04)*(IKcos(j[2]))*(IKcos(j[3]))*(IKsin(j[1]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))+(((((((0.0386370212885216)*(IKcos(j[2]))*(IKsin(j[1]))*(IKsin(j[3]))))+(((0.0386370212885216)*(IKcos(j[3]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKsin(j[5]))))+(((-0.0289777659663912)*(IKcos(j[2]))*(IKcos(j[3]))*(IKsin(j[1]))))+(((-0.24148138305326)*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKcos(j[0]))))+(((-0.145)*(IKcos(j[0]))))+(((((((-0.235)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[3]))))+(((-0.03)*(IKcos(j[1]))*(IKcos(j[2]))*(IKcos(j[3]))))+(((-0.25)*(IKcos(j[1]))*(IKsin(j[2]))))+(((((((0.09)*(IKsin(j[1]))*(IKsin(j[4]))))+(((((((0.09)*(IKcos(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.09)*(IKcos(j[1]))*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKsin(j[5]))))+(((((((0.04)*(IKsin(j[1]))*(IKsin(j[4]))))+(((((((0.04)*(IKcos(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((-0.04)*(IKcos(j[1]))*(IKcos(j[2]))*(IKcos(j[3]))))))*(IKcos(j[4]))))))*(IKcos(j[5]))))+(((((((-0.09)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[2]))))+(((-0.09)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[3]))))))*(IKcos(j[5]))))+(((-0.235)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[2]))))+(((0.03)*(IKcos(j[1]))*(IKsin(j[2]))*(IKsin(j[3]))))+(((0.095)*(IKsin(j[1]))))+(((((((0.04)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[3]))))+(((0.04)*(IKcos(j[1]))*(IKcos(j[3]))*(IKsin(j[2]))))))*(IKsin(j[5]))))))*(IKsin(j[0])))));\neerot[6]=(((x34*x73))+(((0.965925532213041)*x10))+((x13*x41))+((x20*x36)));\neerot[7]=((((0.965925532213041)*x45))+(((0.258820142606703)*x59))+(((0.965925532213041)*x51))+(((0.258820142606703)*x62)));\neerot[8]=((((0.965925532213041)*x66))+(((0.258820142606703)*x71))+(((0.258820142606703)*x69))+(((0.965925532213041)*x64)));\neetrans[2]=((0.370296)+((x14*x36*(((((0.04)*x15))+x74))))+((x36*(((((0.09)*x4))+(((-1.0)*(0.09)*x7))))))+(((-1.0)*(0.0647050356516757)*x2*x26))+((x14*x32*((x75+(((0.09)*x15))))))+(((0.0289777659663912)*x17))+((x73*(((((0.04)*x33))+((x26*x74))))))+(((-1.0)*(0.24148138305326)*x5))+((x13*(((((-1.0)*(0.09)*x33))+(((-1.0)*(1.0)*x26*x75))))))+(((0.00776460427820108)*x26*x4))+(((0.226992500070065)*x4))+((x73*(((((-1.0)*(0.09)*x40))+(((-1.0)*(0.09)*x37))))))+(((-1.0)*(0.0608227335125751)*x33))+((x32*(((((-1.0)*(0.04)*x4))+(((0.04)*x7))))))+(((0.0289777659663912)*x15))+(((-1.0)*(0.0245879135476367)*x23))+(((-1.0)*(0.00776460427820108)*x38))+((x13*(((((-1.0)*(0.04)*x37))+(((-1.0)*(0.04)*x40))))))+(((-1.0)*(0.226992500070065)*x7))+(((-1.0)*(0.0608227335125751)*x17*x26)));\n}\n\nIKFAST_API int GetNumFreeParameters() { return 1; }\nIKFAST_API int* GetFreeParameters() { static int freeparams[] = {0}; return freeparams; }\nIKFAST_API int GetNumJoints() { return 7; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j7,cj7,sj7,htj7,j7mul,j8,cj8,sj8,htj8,j8mul,j0,cj0,sj0,htj0,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij7[2], _nj7,_ij8[2], _nj8,_ij0[2], _nj0;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1; j7=numeric_limits<IkReal>::quiet_NaN(); _ij7[0] = -1; _ij7[1] = -1; _nj7 = -1; j8=numeric_limits<IkReal>::quiet_NaN(); _ij8[0] = -1; _ij8[1] = -1; _nj8 = -1;  _ij0[0] = -1; _ij0[1] = -1; _nj0 = 0; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nj0=pfree[0]; cj0=cos(pfree[0]); sj0=sin(pfree[0]), htj0=tan(pfree[0]*0.5);\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=((((-1.0)*(1.0)*r12*(IKsin(j0))))+(((-1.0)*(1.0)*r02*(IKcos(j0)))));\nnew_r01=(((r01*(IKcos(j0))))+((r11*(IKsin(j0)))));\nnew_r02=(((r00*(IKcos(j0))))+((r10*(IKsin(j0)))));\nnew_px=(((((px+(((0.04)*r00))))*(IKcos(j0))))+(((((((0.04)*r10))+py))*(IKsin(j0)))));\nnew_r10=((((0.965925532213041)*r02*(IKsin(j0))))+(((-1.0)*(0.965925532213041)*r12*(IKcos(j0))))+(((-1.0)*(0.258820142606703)*r22)));\nnew_r11=((((0.258820142606703)*r21))+(((-1.0)*(0.965925532213041)*r01*(IKsin(j0))))+(((0.965925532213041)*r11*(IKcos(j0)))));\nnew_r12=((((0.258820142606703)*r20))+(((0.965925532213041)*r10*(IKcos(j0))))+(((-1.0)*(0.965925532213041)*r00*(IKsin(j0)))));\nnew_py=((0.0442191386441994)+(((0.258820142606703)*pz))+(((0.0103528057042681)*r20))+(((((((0.0386370212885216)*r10))+(((0.965925532213041)*py))))*(IKcos(j0))))+(((((((-1.0)*(0.0386370212885216)*r00))+(((-1.0)*(0.965925532213041)*px))))*(IKsin(j0)))));\nnew_r20=((((-1.0)*(0.965925532213041)*r22))+(((0.258820142606703)*r12*(IKcos(j0))))+(((-1.0)*(0.258820142606703)*r02*(IKsin(j0)))));\nnew_r21=((((0.258820142606703)*r01*(IKsin(j0))))+(((-1.0)*(0.258820142606703)*r11*(IKcos(j0))))+(((0.965925532213041)*r21)));\nnew_r22=((((0.258820142606703)*r00*(IKsin(j0))))+(((-1.0)*(0.258820142606703)*r10*(IKcos(j0))))+(((0.965925532213041)*r20)));\nnew_pz=((-0.395207281554332)+(((((((0.0103528057042681)*r00))+(((0.258820142606703)*px))))*(IKsin(j0))))+(((((((-1.0)*(0.258820142606703)*py))+(((-1.0)*(0.0103528057042681)*r10))))*(IKcos(j0))))+(((0.965925532213041)*pz))+(((0.0386370212885216)*r20)));\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x77=((1.0)*py);\nIkReal x78=((1.0)*pz);\nIkReal x79=((1.0)*px);\npp=((pz*pz)+(py*py)+(px*px));\nnpx=(((pz*r20))+((py*r10))+((px*r00)));\nnpy=(((pz*r21))+((py*r11))+((px*r01)));\nnpz=(((px*r02))+((pz*r22))+((py*r12)));\nrxp0_0=((((-1.0)*r20*x77))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x78)));\nrxp0_2=((((-1.0)*r10*x79))+((py*r00)));\nrxp1_0=(((pz*r11))+(((-1.0)*r21*x77)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x78)));\nrxp1_2=((((-1.0)*r11*x79))+((py*r01)));\nrxp2_0=((((-1.0)*r22*x77))+((pz*r12)));\nrxp2_1=((((-1.0)*r02*x78))+((px*r22)));\nrxp2_2=((((-1.0)*r12*x79))+((py*r02)));\nIkReal op[72], zeror[48];\nint numroots;;\nIkReal x80=(cj6*r21);\nIkReal x81=(r22*sj6);\nIkReal x82=((2.0)*r20);\nIkReal x83=(cj6*x82);\nIkReal x84=((-1.0)*x80);\nIkReal x85=((0.57)*r20);\nIkReal x86=((6.0)*rxp0_0);\nIkReal x87=(x86+(((-1.0)*x85)));\nIkReal x88=((65.0)*npx);\nIkReal x89=((100.0)*pp);\nIkReal x90=((6.0)*rxp0_1);\nIkReal x91=(x90+x89);\nIkReal x92=((1.14)*r21);\nIkReal x93=((12.0)*rxp1_0);\nIkReal x94=((12.0)*rxp1_1);\nIkReal x95=((((-1.0)*x86))+x85);\nIkReal x96=(x89+(((-1.0)*x90)));\nIkReal x97=(r21*sj6);\nIkReal x98=(cj6*r22);\nIkReal x99=((-1.0)*x98);\nIkReal x100=((2.0)*r01);\nIkReal x101=(sj6*x82);\nIkReal x102=((2.0)*r11);\nIkReal x103=((-1.0)*(((1.0)*r00)));\nIkReal x104=((-1.0)*x97);\nIkReal x105=((-1.0)*(((1.0)*r10)));\nIkReal x106=((0.095)*r00);\nIkReal x107=(x106+rxp0_2);\nIkReal x108=((0.095)*r10);\nIkReal x109=((0.19)*r01);\nIkReal x110=((2.0)*rxp1_2);\nIkReal x111=((0.19)*r11);\nIkReal x112=((((-1.0)*x106))+(((-1.0)*(1.0)*rxp0_2)));\nIkReal x113=((-1.0)*x108);\nIkReal x114=((1.08)*r01);\nIkReal x115=((((12.0)*rxp2_0))+(((-1.0)*(1.14)*r22)));\nIkReal x116=((1.08)*r11);\nIkReal x117=((((12.0)*rxp2_1))+(((-1.0)*(94.0)*npz)));\nIkReal x118=((2.0)*r02);\nIkReal x119=((2.0)*r12);\nIkReal x120=((0.18)*r21);\nIkReal x121=((((2.0)*rxp2_2))+(((0.19)*r02)));\nIkReal x122=((0.19)*r12);\nIkReal x123=((-1.0)*x81);\nIkReal x124=((29.0)*npx);\nop[0]=(x81+x80);\nop[1]=0;\nop[2]=x83;\nop[3]=0;\nop[4]=(x81+x84);\nop[5]=0;\nop[6]=x87;\nop[7]=((3.5)+x91+(((-1.0)*x88)));\nop[8]=(x92+(((-1.0)*x93)));\nop[9]=((((-1.0)*x94))+(((130.0)*npy)));\nop[10]=x95;\nop[11]=((3.5)+x96+x88);\nop[12]=(x99+x97+r00);\nop[13]=r10;\nop[14]=(x101+(((-1.0)*x100)));\nop[15]=((-1.0)*x102);\nop[16]=(x103+x104+x99);\nop[17]=x105;\nop[18]=x107;\nop[19]=x108;\nop[20]=((((-1.0)*x110))+(((-1.0)*x109)));\nop[21]=((-1.0)*x111);\nop[22]=x112;\nop[23]=x113;\nop[24]=((-1.0)*x101);\nop[25]=0;\nop[26]=((4.0)*x97);\nop[27]=0;\nop[28]=x101;\nop[29]=0;\nop[30]=((((-1.0)*x114))+x115);\nop[31]=((((-1.0)*x116))+x117);\nop[32]=((-1.0)*(((2.16)*r00)));\nop[33]=((-1.0)*(((2.16)*r10)));\nop[34]=(x115+x114);\nop[35]=(x117+x116);\nop[36]=(x83+x118);\nop[37]=x119;\nop[38]=((-4.0)*x80);\nop[39]=0;\nop[40]=((((-1.0)*x83))+x118);\nop[41]=x119;\nop[42]=(x121+(((-1.0)*x120)));\nop[43]=x122;\nop[44]=((-1.0)*(((0.36)*r20)));\nop[45]=0;\nop[46]=(x120+x121);\nop[47]=x122;\nop[48]=(x123+x80);\nop[49]=0;\nop[50]=x83;\nop[51]=0;\nop[52]=(x123+x84);\nop[53]=0;\nop[54]=x95;\nop[55]=((-4.96)+x124+x96);\nop[56]=(x93+(((-1.0)*x92)));\nop[57]=(x94+(((-1.0)*(58.0)*npy)));\nop[58]=x87;\nop[59]=((-4.96)+x91+(((-1.0)*x124)));\nop[60]=(x103+x98+x97);\nop[61]=x105;\nop[62]=(x100+x101);\nop[63]=x102;\nop[64]=(x104+x98+r00);\nop[65]=r10;\nop[66]=x112;\nop[67]=x113;\nop[68]=(x109+x110);\nop[69]=x111;\nop[70]=x107;\nop[71]=x108;\nsolvedialyticpoly8qep(op,zeror,numroots);\nIkReal j7array[16], cj7array[16], sj7array[16], j8array[16], cj8array[16], sj8array[16], j3array[16], cj3array[16], sj3array[16];\nint numsolutions = 0;\nfor(int ij7 = 0; ij7 < numroots; ij7 += 3)\n{\nIkReal htj7 = zeror[ij7+0], htj8 = zeror[ij7+1], htj3 = zeror[ij7+2];\nif(isnan(htj7)||isnan(htj8)||isnan(htj3)){\ncontinue;\n}\nj7array[numsolutions]=((2.0)*(atan(htj7)));\nj8array[numsolutions]=((2.0)*(atan(htj8)));\nj3array[numsolutions]=((2.0)*(atan(htj3)));\nif(isinf(htj7)){\ncj7array[numsolutions] = IKcos(j7array[numsolutions]);\nsj7array[numsolutions] = IKsin(j7array[numsolutions]);\n}\nelse{\nIkReal x125=htj7*htj7;\nCheckValue<IkReal> x126=IKPowWithIntegerCheck(((1.0)+x125),-1);\nif(!x126.valid){\ncontinue;\n}\ncj7array[numsolutions]=((x126.value)*(((1.0)+(((-1.0)*x125)))));\nCheckValue<IkReal> x127=IKPowWithIntegerCheck(((1.0)+(htj7*htj7)),-1);\nif(!x127.valid){\ncontinue;\n}\nsj7array[numsolutions]=((2.0)*htj7*(x127.value));\n}\nif(isinf(htj8)){\ncj8array[numsolutions] = IKcos(j8array[numsolutions]);\nsj8array[numsolutions] = IKsin(j8array[numsolutions]);\n}\nelse{\nIkReal x128=htj8*htj8;\nCheckValue<IkReal> x129=IKPowWithIntegerCheck(((1.0)+x128),-1);\nif(!x129.valid){\ncontinue;\n}\ncj8array[numsolutions]=((x129.value)*(((1.0)+(((-1.0)*x128)))));\nCheckValue<IkReal> x130=IKPowWithIntegerCheck(((1.0)+(htj8*htj8)),-1);\nif(!x130.valid){\ncontinue;\n}\nsj8array[numsolutions]=((2.0)*htj8*(x130.value));\n}\nif(isinf(htj3)){\ncj3array[numsolutions] = IKcos(j3array[numsolutions]);\nsj3array[numsolutions] = IKsin(j3array[numsolutions]);\n}\nelse{\nIkReal x131=htj3*htj3;\nCheckValue<IkReal> x132=IKPowWithIntegerCheck(((1.0)+x131),-1);\nif(!x132.valid){\ncontinue;\n}\ncj3array[numsolutions]=((x132.value)*(((1.0)+(((-1.0)*x131)))));\nCheckValue<IkReal> x133=IKPowWithIntegerCheck(((1.0)+(htj3*htj3)),-1);\nif(!x133.valid){\ncontinue;\n}\nsj3array[numsolutions]=((2.0)*htj3*(x133.value));\n}\nif( j7array[numsolutions] > IKPI )\n{\n    j7array[numsolutions]-=IK2PI;\n}\nelse if( j7array[numsolutions] < -IKPI )\n{\n    j7array[numsolutions]+=IK2PI;\n}\nif( j8array[numsolutions] > IKPI )\n{\n    j8array[numsolutions]-=IK2PI;\n}\nelse if( j8array[numsolutions] < -IKPI )\n{\n    j8array[numsolutions]+=IK2PI;\n}\nif( j3array[numsolutions] > IKPI )\n{\n    j3array[numsolutions]-=IK2PI;\n}\nelse if( j3array[numsolutions] < -IKPI )\n{\n    j3array[numsolutions]+=IK2PI;\n}\nnumsolutions++;\n}\nbool j7valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};\n_nj7 = 16;\n_nj8 = 1;\n_nj3 = 1;\nfor(int ij7 = 0; ij7 < numsolutions; ++ij7)\n    {\nif( !j7valid[ij7] )\n{\n    continue;\n}\n_ij7[0] = ij7; _ij7[1] = -1;\n_ij8[0] = 0; _ij8[1] = -1;\n_ij3[0] = 0; _ij3[1] = -1;\nfor(int iij7 = ij7+1; iij7 < numsolutions; ++iij7)\n{\nif( !j7valid[iij7] ) { continue; }\nif( IKabs(cj7array[ij7]-cj7array[iij7]) < IKFAST_SOLUTION_THRESH && IKabs(sj7array[ij7]-sj7array[iij7]) < IKFAST_SOLUTION_THRESH && IKabs(cj8array[ij7]-cj8array[iij7]) < IKFAST_SOLUTION_THRESH && IKabs(sj8array[ij7]-sj8array[iij7]) < IKFAST_SOLUTION_THRESH && IKabs(cj3array[ij7]-cj3array[iij7]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij7]-sj3array[iij7]) < IKFAST_SOLUTION_THRESH &&  1 )\n{\n    j7valid[iij7]=false; _ij7[1] = iij7; _ij8[1] = 0; _ij3[1] = 0;  break; \n}\n}\n    j7 = j7array[ij7]; cj7 = cj7array[ij7]; sj7 = sj7array[ij7];\n\n    j8 = j8array[ij7]; cj8 = cj8array[ij7]; sj8 = sj8array[ij7];\n\n    j3 = j3array[ij7]; cj3 = cj3array[ij7]; sj3 = sj3array[ij7];\n\ninnerfn(solutions);\n    }\n}\nreturn solutions.GetNumSolutions()>0;\n}\nstatic inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[3];\n    const int maxsteps = 110;\n    for(int i = 0; i < 3; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[3];\n    IkReal err[3];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 3; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 3; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 3; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 3; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[3] = {false};\n    for(int i = 0; i < 3; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 3; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {\n    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];\n    if( det < 0 ) {\n        numroots=0;\n    }\n    else if( det == 0 ) {\n        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];\n        numroots = 1;\n    }\n    else {\n        det = IKsqrt(det);\n        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);\n        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);\n        numroots = 2;\n    }\n}\nstatic inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[5];\n    const int maxsteps = 110;\n    for(int i = 0; i < 5; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[5];\n    IkReal err[5];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 5; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 5; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 5; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 5; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[5] = {false};\n    for(int i = 0; i < 5; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 5; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[4];\n    const int maxsteps = 110;\n    for(int i = 0; i < 4; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[4];\n    IkReal err[4];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 4; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 4; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 4; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 4; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[4] = {false};\n    for(int i = 0; i < 4; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 4; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[6];\n    const int maxsteps = 110;\n    for(int i = 0; i < 6; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[6];\n    IkReal err[6];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 6; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 6; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 6; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 6; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[6] = {false};\n    for(int i = 0; i < 6; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 6; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\ninline void innerfn(IkSolutionListBase<IkReal>& solutions) {\nfor(int fniter = 0; fniter < 1; ++fniter) {\n{\nIkReal j6eval[3];\nIkReal x134=((1.0)*cj7);\nIkReal x135=(((cj7*r01*sj8))+(((-1.0)*cj8*r00*x134))+(((-1.0)*r02*sj7)));\nIkReal x136=(cj3*cj8);\nIkReal x137=(cj3*sj8);\nj6eval[0]=x135;\nj6eval[1]=((IKabs((((r20*x137))+((r21*x136)))))+(IKabs(((((-1.0)*cj3*r22*x134))+(((-1.0)*r21*sj7*x137))+((r20*sj7*x136))))));\nj6eval[2]=IKsign(x135);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[3];\nIkReal x138=((((-1.0)*(1.0)*cj7*r11*sj8))+((cj7*cj8*r10))+((r12*sj7)));\nIkReal x139=(r21*sj3);\nIkReal x140=(r20*sj3);\nj6eval[0]=x138;\nj6eval[1]=((IKabs((((cj7*r22*sj3))+(((-1.0)*cj8*sj7*x140))+((sj7*sj8*x139)))))+(IKabs((((cj8*x139))+((sj8*x140))))));\nj6eval[2]=IKsign(x138);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[2];\nIkReal x141=(((cj7*r21*sj8))+(((-1.0)*(1.0)*r22*sj7))+(((-1.0)*(1.0)*cj7*cj8*r20)));\nj6eval[0]=x141;\nj6eval[1]=IKsign(x141);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x142=(cj8*r10);\nIkReal x143=(r11*sj8);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));\nevalcond[1]=(((cj7*x142))+(((-1.0)*cj7*x143))+((r12*sj7)));\nevalcond[2]=((-0.095)+(((-1.0)*(1.0)*py))+(((-0.09)*x143))+(((0.09)*x142)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6eval[3];\nsj3=0;\ncj3=1.0;\nj3=0;\nIkReal x144=((1.0)*cj7);\nIkReal x145=(((cj7*cj8*r20))+(((-1.0)*r21*sj8*x144))+((r22*sj7)));\nj6eval[0]=x145;\nj6eval[1]=IKsign(x145);\nj6eval[2]=((IKabs((((cj8*r01))+((r00*sj8)))))+(IKabs(((((-1.0)*r02*x144))+(((-1.0)*(1.0)*r01*sj7*sj8))+((cj8*r00*sj7))))));\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[3];\nsj3=0;\ncj3=1.0;\nj3=0;\nIkReal x146=((1.0)*sj7);\nIkReal x147=((1.0)*cj7);\nIkReal x148=((((-1.0)*cj8*r00*x147))+((cj7*r01*sj8))+(((-1.0)*r02*x146)));\nj6eval[0]=x148;\nj6eval[1]=((IKabs(((((-1.0)*r22*x147))+((cj8*r20*sj7))+(((-1.0)*r21*sj8*x146)))))+(IKabs((((r20*sj8))+((cj8*r21))))));\nj6eval[2]=IKsign(x148);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[3];\nsj3=0;\ncj3=1.0;\nj3=0;\nIkReal x149=r10*r10;\nIkReal x150=r11*r11;\nIkReal x151=cj7*cj7;\nIkReal x152=((2.0)*cj7*r12);\nIkReal x153=(cj8*r10*sj7);\nIkReal x154=(r11*sj7*sj8);\nIkReal x155=(x150*x151);\nIkReal x156=(r10*sj8);\nIkReal x157=cj8*cj8;\nIkReal x158=(((x155*x157))+x150+x149+(((2.0)*cj8*r11*x151*x156))+(((-1.0)*x152*x153))+(((-1.0)*x149*x151*x157))+((x152*x154))+(((-1.0)*x155))+((x151*(r12*r12))));\nj6eval[0]=x158;\nj6eval[1]=IKsign(x158);\nj6eval[2]=((IKabs(((((-1.0)*x153))+x154+((cj7*r12)))))+(IKabs((x156+((cj8*r11))))));\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j4, j5, j6]\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x159=(r11*sj7*sj8);\nIkReal x160=(cj8*r10*sj7);\nIkReal x161=(r10*sj8);\nIkReal x162=r10*r10;\nIkReal x163=r11*r11;\nIkReal x164=cj7*cj7;\nIkReal x165=((2.0)*cj7*r12);\nIkReal x166=(x163*x164);\nIkReal x167=cj8*cj8;\nCheckValue<IkReal> x168 = IKatan2WithCheck(IkReal((x159+((cj7*r12))+(((-1.0)*x160)))),IkReal((((cj8*r11))+x161)),IKFAST_ATAN2_MAGTHRESH);\nif(!x168.valid){\ncontinue;\n}\nCheckValue<IkReal> x169=IKPowWithIntegerCheck(IKsign(((((-1.0)*x160*x165))+((x166*x167))+((x164*(r12*r12)))+((x159*x165))+x163+x162+(((2.0)*cj8*r11*x161*x164))+(((-1.0)*x166))+(((-1.0)*x162*x164*x167)))),-1);\nif(!x169.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x168.value)+(((1.5707963267949)*(x169.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[4];\nIkReal x170=IKsin(j6);\nIkReal x171=(cj8*r11);\nIkReal x172=(r10*sj8);\nIkReal x173=IKcos(j6);\nIkReal x174=((1.0)*x173);\nIkReal x175=((1.0)*sj8*x173);\nIkReal x176=((1.0)*cj7*x170);\nIkReal x177=((1.0)*cj8*x173);\nIkReal x178=(cj8*sj7*x170);\nIkReal x179=((1.0)*sj7*sj8*x170);\nevalcond[0]=((((-1.0)*r11*sj7*x175))+((x170*x171))+((x170*x172))+((cj8*r10*sj7*x173))+(((-1.0)*cj7*r12*x174)));\nevalcond[1]=((((-1.0)*r21*x177))+(((-1.0)*r21*x179))+(((-1.0)*r22*x176))+(((-1.0)*r20*x175))+((r20*x178)));\nevalcond[2]=((((-1.0)*r02*x176))+(((-1.0)*r01*x179))+(((-1.0)*r01*x177))+(((-1.0)*r00*x175))+((r00*x178)));\nevalcond[3]=((1.0)+(((-1.0)*x171*x174))+(((-1.0)*x172*x174))+(((-1.0)*r12*x176))+((r10*x178))+(((-1.0)*r11*x179)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nsj3=0;\ncj3=1.0;\nj3=0;\nIkReal x180=(cj8*r20);\nIkReal x181=(r02*sj7);\nIkReal x182=(r21*sj8);\nIkReal x183=(r22*sj7);\nIkReal x184=(cj7*cj8*r00);\nIkReal x185=(cj7*cj8*r20);\nIkReal x186=(cj7*r01*sj8);\nIkReal x187=(cj7*r21*sj8);\nIkReal x188=((((-1.0)*(12.0)*pz))+(((-0.36)*x181))+(((-2.82)*x187))+(((-0.36)*x184))+(((2.82)*x183))+(((1.08)*x180))+(((2.82)*x185))+(((-1.08)*x182))+(((0.36)*x186)));\nj4eval[0]=((IKabs(((1.0)+(((-0.12)*x181))+(((-1.0)*(4.0)*pz))+(((-0.36)*x182))+(((-0.12)*x184))+(((0.94)*x185))+(((0.94)*x183))+(((-0.94)*x187))+(((0.36)*x180))+(((0.12)*x186)))))+(IKabs(((-1.0)+x188)))+(IKabs(((1.0)+x188))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x189=(cj8*r20);\nIkReal x190=(r02*sj7);\nIkReal x191=(r21*sj8);\nIkReal x192=(r22*sj7);\nIkReal x193=(cj7*cj8*r00);\nIkReal x194=(cj7*cj8*r20);\nIkReal x195=(cj7*r01*sj8);\nIkReal x196=(cj7*r21*sj8);\nIkReal x197=((((0.94)*x192))+(((-0.94)*x196))+(((-1.0)*(4.0)*pz))+(((-0.36)*x191))+(((0.36)*x189))+(((0.94)*x194))+(((0.12)*x195))+(((-0.12)*x193))+(((-0.12)*x190)));\nIkReal x198=((((1.08)*x189))+(((-0.36)*x193))+(((-1.0)*(12.0)*pz))+(((0.36)*x195))+(((2.82)*x194))+(((-1.08)*x191))+(((-2.82)*x196))+(((-0.36)*x190))+(((2.82)*x192)));\nop[0]=((1.0)+x197);\nop[1]=0;\nop[2]=((1.0)+x198);\nop[3]=0;\nop[4]=((-1.0)+x198);\nop[5]=0;\nop[6]=((-1.0)+x197);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x199=(cj8*r00);\nIkReal x200=(cj8*r20);\nIkReal x201=(r01*sj8);\nIkReal x202=(r21*sj8);\nIkReal x203=(r22*sj7);\nIkReal x204=(cj7*cj8*r20);\nIkReal x205=(cj7*r21*sj8);\nIkReal x206=((((-0.0846)*x202))+(((0.0846)*x200))+(((-0.2245)*x205))+(((-0.0108)*x201))+(((0.0108)*x199))+(((-1.0)*(0.94)*pz))+(((0.2245)*x204))+(((0.2245)*x203))+(((-1.0)*(0.12)*px)));\nIkReal x207=((((0.6735)*x204))+(((-0.6735)*x205))+(((-0.0324)*x201))+(((0.6735)*x203))+(((-1.0)*(0.36)*px))+(((0.2538)*x200))+(((-0.2538)*x202))+(((-1.0)*(2.82)*pz))+(((0.0324)*x199)));\nj4evalpoly[0]=((-0.235)+(((htj4*htj4*htj4*htj4)*(((0.235)+x207))))+(((-1.0)*(0.12)*(htj4*htj4*htj4)))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((0.235)+x206))))+(((-1.0)*(0.06)*(htj4*htj4*htj4*htj4*htj4)))+(((-1.0)*(0.06)*htj4))+(((htj4*htj4)*(((-0.235)+x207))))+x206);\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x208=(r22*sj7);\nIkReal x209=((1.0)*cj4);\nIkReal x210=(r02*sj7);\nIkReal x211=(cj4*cj7*sj8);\nIkReal x212=(cj7*sj4);\nIkReal x213=(cj8*r20);\nIkReal x214=(cj8*r00);\nIkReal x215=((1.0)*cj4*cj7);\nIkReal x216=((1.0)*cj7*sj4);\nif( IKabs((((r01*x211))+(((-1.0)*x209*x210))+(((-1.0)*x214*x215))+(((-1.0)*r21*sj8*x216))+((x212*x213))+((sj4*x208)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r01*sj8*x212))+(((-1.0)*sj4*x210))+(((-1.0)*x214*x216))+((r21*x211))+(((-1.0)*x213*x215))+(((-1.0)*x208*x209)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*x211))+(((-1.0)*x209*x210))+(((-1.0)*x214*x215))+(((-1.0)*r21*sj8*x216))+((x212*x213))+((sj4*x208))))+IKsqr((((r01*sj8*x212))+(((-1.0)*sj4*x210))+(((-1.0)*x214*x216))+((r21*x211))+(((-1.0)*x213*x215))+(((-1.0)*x208*x209))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2((((r01*x211))+(((-1.0)*x209*x210))+(((-1.0)*x214*x215))+(((-1.0)*r21*sj8*x216))+((x212*x213))+((sj4*x208))), (((r01*sj8*x212))+(((-1.0)*sj4*x210))+(((-1.0)*x214*x216))+((r21*x211))+(((-1.0)*x213*x215))+(((-1.0)*x208*x209))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[6];\nIkReal x217=IKsin(j5);\nIkReal x218=(cj4*x217);\nIkReal x219=IKcos(j5);\nIkReal x220=(sj4*x219);\nIkReal x221=(cj7*cj8);\nIkReal x222=((1.0)*cj7*sj8);\nIkReal x223=(cj4*x219);\nIkReal x224=(sj4*x217);\nIkReal x225=((((-1.0)*x224))+x223);\nIkReal x226=(cj8*sj6);\nIkReal x227=(sj6*sj8);\nIkReal x228=((1.0)*cj6*cj7);\nIkReal x229=(cj6*cj8*sj7);\nIkReal x230=((1.0)*cj6*sj7*sj8);\nIkReal x231=((0.09)*cj8);\nIkReal x232=((0.09)*sj8);\nevalcond[0]=(((r02*sj7))+(((-1.0)*r01*x222))+((r00*x221))+x218+x220);\nevalcond[1]=((((-1.0)*r21*x222))+((r20*x221))+((r22*sj7))+x225);\nevalcond[2]=(((r00*x227))+((r00*x229))+(((-1.0)*r02*x228))+((r01*x226))+x225+(((-1.0)*r01*x230)));\nevalcond[3]=((((-1.0)*r21*x230))+((r20*x229))+(((-1.0)*x218))+((r20*x227))+(((-1.0)*r22*x228))+((r21*x226))+(((-1.0)*x220)));\nevalcond[4]=(((r20*x231))+(((-0.235)*x223))+(((-1.0)*(1.0)*pz))+(((0.03)*x220))+(((0.235)*x224))+(((-1.0)*(0.25)*cj4))+(((-1.0)*r21*x232))+(((0.03)*x218)));\nevalcond[5]=((((-1.0)*(1.0)*px))+(((-1.0)*r01*x232))+(((-0.235)*x218))+(((-0.235)*x220))+(((-0.03)*x223))+(((0.03)*x224))+(((-1.0)*(0.25)*sj4))+((r00*x231)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x233=((1.0)*sj7);\nIkReal x234=((1.0)*cj7);\nCheckValue<IkReal> x235=IKPowWithIntegerCheck(IKsign((((cj7*r01*sj8))+(((-1.0)*r02*x233))+(((-1.0)*cj8*r00*x234)))),-1);\nif(!x235.valid){\ncontinue;\n}\nCheckValue<IkReal> x236 = IKatan2WithCheck(IkReal((((r20*sj8))+((cj8*r21)))),IkReal((((cj8*r20*sj7))+(((-1.0)*r22*x234))+(((-1.0)*r21*sj8*x233)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x236.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x235.value)))+(x236.value));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[4];\nIkReal x237=IKsin(j6);\nIkReal x238=(cj8*r11);\nIkReal x239=(r10*sj8);\nIkReal x240=IKcos(j6);\nIkReal x241=((1.0)*x240);\nIkReal x242=((1.0)*sj8*x240);\nIkReal x243=((1.0)*cj7*x237);\nIkReal x244=((1.0)*cj8*x240);\nIkReal x245=(cj8*sj7*x237);\nIkReal x246=((1.0)*sj7*sj8*x237);\nevalcond[0]=((((-1.0)*cj7*r12*x241))+((x237*x239))+((x237*x238))+(((-1.0)*r11*sj7*x242))+((cj8*r10*sj7*x240)));\nevalcond[1]=((((-1.0)*r20*x242))+(((-1.0)*r21*x244))+(((-1.0)*r21*x246))+(((-1.0)*r22*x243))+((r20*x245)));\nevalcond[2]=((((-1.0)*r00*x242))+(((-1.0)*r01*x246))+((r00*x245))+(((-1.0)*r01*x244))+(((-1.0)*r02*x243)));\nevalcond[3]=((1.0)+(((-1.0)*r11*x246))+(((-1.0)*x239*x241))+(((-1.0)*r12*x243))+((r10*x245))+(((-1.0)*x238*x241)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nsj3=0;\ncj3=1.0;\nj3=0;\nIkReal x247=(cj8*r20);\nIkReal x248=(r02*sj7);\nIkReal x249=(r21*sj8);\nIkReal x250=(r22*sj7);\nIkReal x251=(cj7*cj8*r00);\nIkReal x252=(cj7*cj8*r20);\nIkReal x253=(cj7*r01*sj8);\nIkReal x254=(cj7*r21*sj8);\nIkReal x255=((((2.82)*x250))+(((-1.0)*(12.0)*pz))+(((-2.82)*x254))+(((-0.36)*x248))+(((2.82)*x252))+(((-1.08)*x249))+(((0.36)*x253))+(((1.08)*x247))+(((-0.36)*x251)));\nj4eval[0]=((IKabs(((1.0)+(((0.36)*x247))+(((-1.0)*(4.0)*pz))+(((-0.12)*x248))+(((0.94)*x250))+(((0.94)*x252))+(((-0.12)*x251))+(((-0.36)*x249))+(((-0.94)*x254))+(((0.12)*x253)))))+(IKabs(((-1.0)+x255)))+(IKabs(((1.0)+x255))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x256=(cj8*r20);\nIkReal x257=(r02*sj7);\nIkReal x258=(r21*sj8);\nIkReal x259=(r22*sj7);\nIkReal x260=(cj7*cj8*r00);\nIkReal x261=(cj7*cj8*r20);\nIkReal x262=(cj7*r01*sj8);\nIkReal x263=(cj7*r21*sj8);\nIkReal x264=((((-0.94)*x263))+(((0.36)*x256))+(((-0.12)*x260))+(((-1.0)*(4.0)*pz))+(((-0.36)*x258))+(((-0.12)*x257))+(((0.12)*x262))+(((0.94)*x259))+(((0.94)*x261)));\nIkReal x265=((((-0.36)*x260))+(((-1.0)*(12.0)*pz))+(((0.36)*x262))+(((-1.08)*x258))+(((-0.36)*x257))+(((2.82)*x259))+(((-2.82)*x263))+(((2.82)*x261))+(((1.08)*x256)));\nop[0]=((1.0)+x264);\nop[1]=0;\nop[2]=((1.0)+x265);\nop[3]=0;\nop[4]=((-1.0)+x265);\nop[5]=0;\nop[6]=((-1.0)+x264);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x266=(cj8*r00);\nIkReal x267=(cj8*r20);\nIkReal x268=(r01*sj8);\nIkReal x269=(r21*sj8);\nIkReal x270=(r22*sj7);\nIkReal x271=(cj7*cj8*r20);\nIkReal x272=(cj7*r21*sj8);\nIkReal x273=((((-0.0846)*x269))+(((0.2245)*x271))+(((-0.2245)*x272))+(((-0.0108)*x268))+(((-1.0)*(0.94)*pz))+(((0.0108)*x266))+(((0.0846)*x267))+(((-1.0)*(0.12)*px))+(((0.2245)*x270)));\nIkReal x274=((((-1.0)*(0.36)*px))+(((-0.6735)*x272))+(((-0.0324)*x268))+(((-1.0)*(2.82)*pz))+(((0.2538)*x267))+(((0.6735)*x270))+(((0.0324)*x266))+(((0.6735)*x271))+(((-0.2538)*x269)));\nj4evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj4*htj4*htj4)))+(((htj4*htj4)*(((-0.235)+x274))))+(((htj4*htj4*htj4*htj4)*(((0.235)+x274))))+(((-1.0)*(0.06)*(htj4*htj4*htj4*htj4*htj4)))+x273+(((-1.0)*(0.06)*htj4))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((0.235)+x273)))));\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x275=(r22*sj7);\nIkReal x276=((1.0)*cj4);\nIkReal x277=(r02*sj7);\nIkReal x278=(cj4*cj7*sj8);\nIkReal x279=(cj7*sj4);\nIkReal x280=(cj8*r20);\nIkReal x281=(cj8*r00);\nIkReal x282=((1.0)*cj4*cj7);\nIkReal x283=((1.0)*cj7*sj4);\nif( IKabs(((((-1.0)*x276*x277))+((x279*x280))+(((-1.0)*r21*sj8*x283))+((sj4*x275))+((r01*x278))+(((-1.0)*x281*x282)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r01*sj8*x279))+(((-1.0)*x281*x283))+(((-1.0)*sj4*x277))+(((-1.0)*x275*x276))+((r21*x278))+(((-1.0)*x280*x282)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x276*x277))+((x279*x280))+(((-1.0)*r21*sj8*x283))+((sj4*x275))+((r01*x278))+(((-1.0)*x281*x282))))+IKsqr((((r01*sj8*x279))+(((-1.0)*x281*x283))+(((-1.0)*sj4*x277))+(((-1.0)*x275*x276))+((r21*x278))+(((-1.0)*x280*x282))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((((-1.0)*x276*x277))+((x279*x280))+(((-1.0)*r21*sj8*x283))+((sj4*x275))+((r01*x278))+(((-1.0)*x281*x282))), (((r01*sj8*x279))+(((-1.0)*x281*x283))+(((-1.0)*sj4*x277))+(((-1.0)*x275*x276))+((r21*x278))+(((-1.0)*x280*x282))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[6];\nIkReal x284=IKsin(j5);\nIkReal x285=(cj4*x284);\nIkReal x286=IKcos(j5);\nIkReal x287=(sj4*x286);\nIkReal x288=(cj7*cj8);\nIkReal x289=((1.0)*cj7*sj8);\nIkReal x290=(cj4*x286);\nIkReal x291=(sj4*x284);\nIkReal x292=(x290+(((-1.0)*x291)));\nIkReal x293=(cj8*sj6);\nIkReal x294=(sj6*sj8);\nIkReal x295=((1.0)*cj6*cj7);\nIkReal x296=(cj6*cj8*sj7);\nIkReal x297=((1.0)*cj6*sj7*sj8);\nIkReal x298=((0.09)*cj8);\nIkReal x299=((0.09)*sj8);\nevalcond[0]=((((-1.0)*r01*x289))+((r00*x288))+((r02*sj7))+x287+x285);\nevalcond[1]=(x292+((r20*x288))+(((-1.0)*r21*x289))+((r22*sj7)));\nevalcond[2]=(x292+(((-1.0)*r01*x297))+((r01*x293))+(((-1.0)*r02*x295))+((r00*x296))+((r00*x294)));\nevalcond[3]=((((-1.0)*r22*x295))+((r20*x294))+(((-1.0)*r21*x297))+(((-1.0)*x287))+((r21*x293))+((r20*x296))+(((-1.0)*x285)));\nevalcond[4]=(((r20*x298))+(((0.03)*x285))+(((-1.0)*(1.0)*pz))+(((-1.0)*(0.25)*cj4))+(((-1.0)*r21*x299))+(((0.235)*x291))+(((0.03)*x287))+(((-0.235)*x290)));\nevalcond[5]=((((-1.0)*(1.0)*px))+((r00*x298))+(((0.03)*x291))+(((-1.0)*r01*x299))+(((-0.03)*x290))+(((-0.235)*x285))+(((-1.0)*(0.25)*sj4))+(((-0.235)*x287)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x300=((1.0)*cj7);\nCheckValue<IkReal> x301 = IKatan2WithCheck(IkReal((((cj8*r01))+((r00*sj8)))),IkReal(((((-1.0)*r02*x300))+(((-1.0)*(1.0)*r01*sj7*sj8))+((cj8*r00*sj7)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x301.valid){\ncontinue;\n}\nCheckValue<IkReal> x302=IKPowWithIntegerCheck(IKsign(((((-1.0)*r21*sj8*x300))+((cj7*cj8*r20))+((r22*sj7)))),-1);\nif(!x302.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x301.value)+(((1.5707963267949)*(x302.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[4];\nIkReal x303=IKsin(j6);\nIkReal x304=(cj8*r11);\nIkReal x305=(r10*sj8);\nIkReal x306=IKcos(j6);\nIkReal x307=((1.0)*x306);\nIkReal x308=((1.0)*sj8*x306);\nIkReal x309=((1.0)*cj7*x303);\nIkReal x310=((1.0)*cj8*x306);\nIkReal x311=(cj8*sj7*x303);\nIkReal x312=((1.0)*sj7*sj8*x303);\nevalcond[0]=((((-1.0)*r11*sj7*x308))+((x303*x304))+(((-1.0)*cj7*r12*x307))+((cj8*r10*sj7*x306))+((x303*x305)));\nevalcond[1]=(((r20*x311))+(((-1.0)*r20*x308))+(((-1.0)*r21*x312))+(((-1.0)*r21*x310))+(((-1.0)*r22*x309)));\nevalcond[2]=((((-1.0)*r01*x312))+(((-1.0)*r00*x308))+(((-1.0)*r02*x309))+((r00*x311))+(((-1.0)*r01*x310)));\nevalcond[3]=((1.0)+(((-1.0)*x305*x307))+((r10*x311))+(((-1.0)*r11*x312))+(((-1.0)*r12*x309))+(((-1.0)*x304*x307)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nsj3=0;\ncj3=1.0;\nj3=0;\nIkReal x313=(cj8*r20);\nIkReal x314=(r02*sj7);\nIkReal x315=(r21*sj8);\nIkReal x316=(r22*sj7);\nIkReal x317=(cj7*cj8*r00);\nIkReal x318=(cj7*cj8*r20);\nIkReal x319=(cj7*r01*sj8);\nIkReal x320=(cj7*r21*sj8);\nIkReal x321=((((-1.0)*(12.0)*pz))+(((-2.82)*x320))+(((-0.36)*x317))+(((2.82)*x316))+(((-0.36)*x314))+(((0.36)*x319))+(((2.82)*x318))+(((-1.08)*x315))+(((1.08)*x313)));\nj4eval[0]=((IKabs(((1.0)+x321)))+(IKabs(((-1.0)+x321)))+(IKabs(((1.0)+(((-0.36)*x315))+(((0.36)*x313))+(((-0.94)*x320))+(((-1.0)*(4.0)*pz))+(((0.12)*x319))+(((0.94)*x316))+(((-0.12)*x314))+(((0.94)*x318))+(((-0.12)*x317))))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x322=(cj8*r20);\nIkReal x323=(r02*sj7);\nIkReal x324=(r21*sj8);\nIkReal x325=(r22*sj7);\nIkReal x326=(cj7*cj8*r00);\nIkReal x327=(cj7*cj8*r20);\nIkReal x328=(cj7*r01*sj8);\nIkReal x329=(cj7*r21*sj8);\nIkReal x330=((((0.94)*x327))+(((-0.12)*x326))+(((-0.12)*x323))+(((-1.0)*(4.0)*pz))+(((0.36)*x322))+(((-0.36)*x324))+(((0.12)*x328))+(((0.94)*x325))+(((-0.94)*x329)));\nIkReal x331=((((-0.36)*x326))+(((0.36)*x328))+(((-1.0)*(12.0)*pz))+(((-1.08)*x324))+(((-2.82)*x329))+(((2.82)*x325))+(((-0.36)*x323))+(((2.82)*x327))+(((1.08)*x322)));\nop[0]=((1.0)+x330);\nop[1]=0;\nop[2]=((1.0)+x331);\nop[3]=0;\nop[4]=((-1.0)+x331);\nop[5]=0;\nop[6]=((-1.0)+x330);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x332=(cj8*r00);\nIkReal x333=(cj8*r20);\nIkReal x334=(r01*sj8);\nIkReal x335=(r21*sj8);\nIkReal x336=(r22*sj7);\nIkReal x337=(cj7*cj8*r20);\nIkReal x338=(cj7*r21*sj8);\nIkReal x339=((((0.2245)*x337))+(((-0.2245)*x338))+(((0.0846)*x333))+(((-0.0846)*x335))+(((-0.0108)*x334))+(((-1.0)*(0.94)*pz))+(((0.2245)*x336))+(((0.0108)*x332))+(((-1.0)*(0.12)*px)));\nIkReal x340=((((0.0324)*x332))+(((-0.6735)*x338))+(((-1.0)*(0.36)*px))+(((0.2538)*x333))+(((-0.2538)*x335))+(((0.6735)*x337))+(((-1.0)*(2.82)*pz))+(((0.6735)*x336))+(((-0.0324)*x334)));\nj4evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj4*htj4*htj4)))+(((-1.0)*(0.06)*(htj4*htj4*htj4*htj4*htj4)))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((0.235)+x339))))+(((htj4*htj4)*(((-0.235)+x340))))+x339+(((-1.0)*(0.06)*htj4))+(((htj4*htj4*htj4*htj4)*(((0.235)+x340)))));\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x341=(r22*sj7);\nIkReal x342=((1.0)*cj4);\nIkReal x343=(r02*sj7);\nIkReal x344=(cj4*cj7*sj8);\nIkReal x345=(cj7*sj4);\nIkReal x346=(cj8*r20);\nIkReal x347=(cj8*r00);\nIkReal x348=((1.0)*cj4*cj7);\nIkReal x349=((1.0)*cj7*sj4);\nif( IKabs(((((-1.0)*x342*x343))+((r01*x344))+(((-1.0)*x347*x348))+((sj4*x341))+((x345*x346))+(((-1.0)*r21*sj8*x349)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r21*x344))+(((-1.0)*x341*x342))+(((-1.0)*sj4*x343))+(((-1.0)*x346*x348))+((r01*sj8*x345))+(((-1.0)*x347*x349)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x342*x343))+((r01*x344))+(((-1.0)*x347*x348))+((sj4*x341))+((x345*x346))+(((-1.0)*r21*sj8*x349))))+IKsqr((((r21*x344))+(((-1.0)*x341*x342))+(((-1.0)*sj4*x343))+(((-1.0)*x346*x348))+((r01*sj8*x345))+(((-1.0)*x347*x349))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((((-1.0)*x342*x343))+((r01*x344))+(((-1.0)*x347*x348))+((sj4*x341))+((x345*x346))+(((-1.0)*r21*sj8*x349))), (((r21*x344))+(((-1.0)*x341*x342))+(((-1.0)*sj4*x343))+(((-1.0)*x346*x348))+((r01*sj8*x345))+(((-1.0)*x347*x349))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[6];\nIkReal x350=IKsin(j5);\nIkReal x351=(cj4*x350);\nIkReal x352=IKcos(j5);\nIkReal x353=(sj4*x352);\nIkReal x354=(cj7*cj8);\nIkReal x355=((1.0)*cj7*sj8);\nIkReal x356=(cj4*x352);\nIkReal x357=(sj4*x350);\nIkReal x358=((((-1.0)*x357))+x356);\nIkReal x359=(cj8*sj6);\nIkReal x360=(sj6*sj8);\nIkReal x361=((1.0)*cj6*cj7);\nIkReal x362=(cj6*cj8*sj7);\nIkReal x363=((1.0)*cj6*sj7*sj8);\nIkReal x364=((0.09)*cj8);\nIkReal x365=((0.09)*sj8);\nevalcond[0]=(((r02*sj7))+x351+x353+((r00*x354))+(((-1.0)*r01*x355)));\nevalcond[1]=(((r20*x354))+x358+(((-1.0)*r21*x355))+((r22*sj7)));\nevalcond[2]=(((r01*x359))+((r00*x360))+((r00*x362))+x358+(((-1.0)*r01*x363))+(((-1.0)*r02*x361)));\nevalcond[3]=((((-1.0)*x351))+((r20*x362))+(((-1.0)*r21*x363))+(((-1.0)*x353))+((r20*x360))+((r21*x359))+(((-1.0)*r22*x361)));\nevalcond[4]=((((0.235)*x357))+(((0.03)*x353))+(((-1.0)*(1.0)*pz))+((r20*x364))+(((0.03)*x351))+(((-1.0)*r21*x365))+(((-0.235)*x356))+(((-1.0)*(0.25)*cj4)));\nevalcond[5]=((((-1.0)*(1.0)*px))+(((-0.235)*x351))+((r00*x364))+(((-1.0)*r01*x365))+(((-0.235)*x353))+(((0.03)*x357))+(((-1.0)*(0.25)*sj4))+(((-0.03)*x356)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x366=(cj8*r10);\nIkReal x367=(r11*sj8);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));\nevalcond[1]=(((cj7*x366))+(((-1.0)*cj7*x367))+((r12*sj7)));\nevalcond[2]=((0.095)+(((-1.0)*(1.0)*py))+(((-0.09)*x367))+(((0.09)*x366)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6eval[3];\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nIkReal x368=((1.0)*sj8);\nIkReal x369=(((cj7*cj8*r20))+((r22*sj7))+(((-1.0)*cj7*r21*x368)));\nIkReal x370=((1.0)*cj8);\nj6eval[0]=x369;\nj6eval[1]=IKsign(x369);\nj6eval[2]=((IKabs((((r01*sj7*sj8))+(((-1.0)*r00*sj7*x370))+((cj7*r02)))))+(IKabs(((((-1.0)*r01*x370))+(((-1.0)*r00*x368))))));\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[3];\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nIkReal x371=((1.0)*cj8);\nIkReal x372=(((cj7*r01*sj8))+(((-1.0)*cj7*r00*x371))+(((-1.0)*(1.0)*r02*sj7)));\nj6eval[0]=x372;\nj6eval[1]=IKsign(x372);\nj6eval[2]=((IKabs(((((-1.0)*r21*x371))+(((-1.0)*(1.0)*r20*sj8)))))+(IKabs((((cj7*r22))+((r21*sj7*sj8))+(((-1.0)*r20*sj7*x371))))));\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[3];\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nIkReal x373=r10*r10;\nIkReal x374=r11*r11;\nIkReal x375=cj7*cj7;\nIkReal x376=((2.0)*cj7*r12);\nIkReal x377=(cj8*r10*sj7);\nIkReal x378=(x374*x375);\nIkReal x379=(r10*sj8);\nIkReal x380=cj8*cj8;\nIkReal x381=((((-1.0)*x378))+(((2.0)*cj8*r11*x375*x379))+((x378*x380))+((x375*(r12*r12)))+(((-1.0)*x373*x375*x380))+((r11*sj7*sj8*x376))+(((-1.0)*x376*x377))+x374+x373);\nIkReal x382=((1.0)*r11);\nj6eval[0]=x381;\nj6eval[1]=IKsign(x381);\nj6eval[2]=((IKabs(((((-1.0)*sj7*sj8*x382))+x377+(((-1.0)*cj7*r12)))))+(IKabs(((((-1.0)*x379))+(((-1.0)*cj8*x382))))));\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j4, j5, j6]\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x383=(cj8*r10*sj7);\nIkReal x384=((1.0)*r11);\nIkReal x385=(r10*sj8);\nIkReal x386=r10*r10;\nIkReal x387=r11*r11;\nIkReal x388=cj7*cj7;\nIkReal x389=((2.0)*cj7*r12);\nIkReal x390=(x387*x388);\nIkReal x391=cj8*cj8;\nCheckValue<IkReal> x392 = IKatan2WithCheck(IkReal(((((-1.0)*sj7*sj8*x384))+x383+(((-1.0)*cj7*r12)))),IkReal(((((-1.0)*cj8*x384))+(((-1.0)*x385)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x392.valid){\ncontinue;\n}\nCheckValue<IkReal> x393=IKPowWithIntegerCheck(IKsign(((((-1.0)*x386*x388*x391))+((x390*x391))+((r11*sj7*sj8*x389))+(((-1.0)*x383*x389))+((x388*(r12*r12)))+(((-1.0)*x390))+x387+x386+(((2.0)*cj8*r11*x385*x388)))),-1);\nif(!x393.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x392.value)+(((1.5707963267949)*(x393.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[4];\nIkReal x394=IKsin(j6);\nIkReal x395=(cj8*r11);\nIkReal x396=(r10*sj8);\nIkReal x397=IKcos(j6);\nIkReal x398=((1.0)*x397);\nIkReal x399=((1.0)*sj8*x397);\nIkReal x400=((1.0)*cj7*x394);\nIkReal x401=((1.0)*cj8*x397);\nIkReal x402=(cj8*sj7*x394);\nIkReal x403=((1.0)*sj7*sj8*x394);\nevalcond[0]=(((cj8*r10*sj7*x397))+((x394*x395))+((x394*x396))+(((-1.0)*r11*sj7*x399))+(((-1.0)*cj7*r12*x398)));\nevalcond[1]=((((-1.0)*r21*x401))+(((-1.0)*r20*x399))+((r20*x402))+(((-1.0)*r21*x403))+(((-1.0)*r22*x400)));\nevalcond[2]=((((-1.0)*r00*x399))+(((-1.0)*r02*x400))+(((-1.0)*r01*x403))+(((-1.0)*r01*x401))+((r00*x402)));\nevalcond[3]=((-1.0)+(((-1.0)*x396*x398))+((r10*x402))+(((-1.0)*r11*x403))+(((-1.0)*x395*x398))+(((-1.0)*r12*x400)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nIkReal x404=(cj8*r20);\nIkReal x405=(r02*sj7);\nIkReal x406=(r21*sj8);\nIkReal x407=(r22*sj7);\nIkReal x408=(cj7*cj8*r00);\nIkReal x409=(cj7*cj8*r20);\nIkReal x410=(cj7*r01*sj8);\nIkReal x411=(cj7*r21*sj8);\nIkReal x412=((((2.82)*x411))+(((-0.36)*x408))+(((-0.36)*x405))+(((0.36)*x410))+(((-2.82)*x409))+(((1.08)*x406))+(((-1.08)*x404))+(((12.0)*pz))+(((-2.82)*x407)));\nj4eval[0]=((IKabs(((-1.0)+(((-0.12)*x405))+(((-0.94)*x409))+(((-0.12)*x408))+(((0.36)*x406))+(((-0.94)*x407))+(((0.94)*x411))+(((-0.36)*x404))+(((4.0)*pz))+(((0.12)*x410)))))+(IKabs(((1.0)+x412)))+(IKabs(((-1.0)+x412))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x413=(cj8*r20);\nIkReal x414=(r02*sj7);\nIkReal x415=(r21*sj8);\nIkReal x416=(r22*sj7);\nIkReal x417=(cj7*cj8*r00);\nIkReal x418=(cj7*cj8*r20);\nIkReal x419=(cj7*r01*sj8);\nIkReal x420=(cj7*r21*sj8);\nIkReal x421=((((-0.12)*x414))+(((-0.12)*x417))+(((-0.94)*x416))+(((-0.94)*x418))+(((4.0)*pz))+(((0.36)*x415))+(((0.12)*x419))+(((-0.36)*x413))+(((0.94)*x420)));\nIkReal x422=((((2.82)*x420))+(((1.08)*x415))+(((-2.82)*x416))+(((-0.36)*x417))+(((-1.08)*x413))+(((12.0)*pz))+(((-0.36)*x414))+(((0.36)*x419))+(((-2.82)*x418)));\nop[0]=((-1.0)+x421);\nop[1]=0;\nop[2]=((-1.0)+x422);\nop[3]=0;\nop[4]=((1.0)+x422);\nop[5]=0;\nop[6]=((1.0)+x421);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x423=(cj8*r20);\nIkReal x424=((0.36)*x423);\nIkReal x425=(r21*sj8);\nIkReal x426=((0.36)*x425);\nIkReal x427=(r22*sj7);\nIkReal x428=(cj6*cj7*r22);\nIkReal x429=(cj7*cj8*r20);\nIkReal x430=(cj7*r21*sj8);\nIkReal x431=(cj8*r21*sj6);\nIkReal x432=(r20*sj6*sj8);\nIkReal x433=((0.12)*cj6*sj7);\nIkReal x434=((((0.94)*x427))+(((0.12)*x431))+(((-1.0)*x426))+(((-1.0)*(4.0)*pz))+((x423*x433))+x424+(((0.12)*x432))+(((-0.94)*x430))+(((-1.0)*x425*x433))+(((-0.12)*x428))+(((0.94)*x429)));\nIkReal x435=(cj6*sj7);\nIkReal x436=((((2.82)*x427))+(((-1.0)*(12.0)*pz))+(((-1.08)*x425))+(((0.36)*x431))+(((1.08)*x423))+(((0.36)*x432))+(((-1.0)*x426*x435))+(((-0.36)*x428))+(((-2.82)*x430))+((x424*x435))+(((2.82)*x429)));\nj4evalpoly[0]=((-1.0)+(((htj4*htj4)*(((-1.0)+x436))))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((1.0)+x434))))+x434+(((htj4*htj4*htj4*htj4)*(((1.0)+x436)))));\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x437=(r02*sj7);\nIkReal x438=(r22*sj7);\nIkReal x439=(cj4*cj7);\nIkReal x440=(cj8*r00);\nIkReal x441=(cj7*sj4);\nIkReal x442=(cj8*r20);\nIkReal x443=(r01*sj8);\nIkReal x444=((1.0)*cj4*cj7);\nIkReal x445=(r21*sj8);\nIkReal x446=((1.0)*cj7*sj4);\nif( IKabs((((x441*x442))+((sj4*x438))+((cj4*x437))+((x439*x440))+(((-1.0)*x445*x446))+(((-1.0)*x443*x444)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x443*x446))+(((-1.0)*cj4*x438))+(((-1.0)*x442*x444))+((x439*x445))+((x440*x441))+((sj4*x437)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x441*x442))+((sj4*x438))+((cj4*x437))+((x439*x440))+(((-1.0)*x445*x446))+(((-1.0)*x443*x444))))+IKsqr(((((-1.0)*x443*x446))+(((-1.0)*cj4*x438))+(((-1.0)*x442*x444))+((x439*x445))+((x440*x441))+((sj4*x437))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2((((x441*x442))+((sj4*x438))+((cj4*x437))+((x439*x440))+(((-1.0)*x445*x446))+(((-1.0)*x443*x444))), ((((-1.0)*x443*x446))+(((-1.0)*cj4*x438))+(((-1.0)*x442*x444))+((x439*x445))+((x440*x441))+((sj4*x437))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[6];\nIkReal x447=IKcos(j5);\nIkReal x448=(cj4*x447);\nIkReal x449=(cj7*cj8);\nIkReal x450=IKsin(j5);\nIkReal x451=(sj4*x450);\nIkReal x452=((1.0)*cj7*sj8);\nIkReal x453=(cj4*x450);\nIkReal x454=(sj4*x447);\nIkReal x455=((((-1.0)*x454))+(((-1.0)*x453)));\nIkReal x456=(cj8*sj6);\nIkReal x457=(sj6*sj8);\nIkReal x458=((1.0)*cj6*cj7);\nIkReal x459=(cj6*cj8*sj7);\nIkReal x460=((1.0)*cj6*sj7*sj8);\nIkReal x461=((0.09)*cj8);\nIkReal x462=((0.09)*sj8);\nevalcond[0]=((((-1.0)*x451))+x448+((r22*sj7))+((r20*x449))+(((-1.0)*r21*x452)));\nevalcond[1]=(((r02*sj7))+((r00*x449))+(((-1.0)*r01*x452))+x455);\nevalcond[2]=(((r00*x457))+((r00*x459))+(((-1.0)*x448))+(((-1.0)*r01*x460))+((r01*x456))+(((-1.0)*r02*x458))+x451);\nevalcond[3]=((((-1.0)*r21*x460))+((r20*x459))+x455+((r20*x457))+(((-1.0)*r22*x458))+((r21*x456)));\nevalcond[4]=((((0.03)*x453))+(((0.235)*x451))+(((-1.0)*(1.0)*pz))+(((0.03)*x454))+((r20*x461))+(((-0.235)*x448))+(((-1.0)*r21*x462))+(((-1.0)*(0.25)*cj4)));\nevalcond[5]=((((-1.0)*r01*x462))+(((-1.0)*(1.0)*px))+(((0.03)*x448))+(((0.25)*sj4))+(((-0.03)*x451))+(((0.235)*x454))+((r00*x461))+(((0.235)*x453)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x463=((1.0)*cj8);\nCheckValue<IkReal> x464 = IKatan2WithCheck(IkReal(((((-1.0)*r21*x463))+(((-1.0)*(1.0)*r20*sj8)))),IkReal((((cj7*r22))+(((-1.0)*r20*sj7*x463))+((r21*sj7*sj8)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x464.valid){\ncontinue;\n}\nCheckValue<IkReal> x465=IKPowWithIntegerCheck(IKsign((((cj7*r01*sj8))+(((-1.0)*(1.0)*r02*sj7))+(((-1.0)*cj7*r00*x463)))),-1);\nif(!x465.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x464.value)+(((1.5707963267949)*(x465.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[4];\nIkReal x466=IKsin(j6);\nIkReal x467=(cj8*r11);\nIkReal x468=(r10*sj8);\nIkReal x469=IKcos(j6);\nIkReal x470=((1.0)*x469);\nIkReal x471=((1.0)*sj8*x469);\nIkReal x472=((1.0)*cj7*x466);\nIkReal x473=((1.0)*cj8*x469);\nIkReal x474=(cj8*sj7*x466);\nIkReal x475=((1.0)*sj7*sj8*x466);\nevalcond[0]=((((-1.0)*r11*sj7*x471))+((cj8*r10*sj7*x469))+((x466*x468))+((x466*x467))+(((-1.0)*cj7*r12*x470)));\nevalcond[1]=((((-1.0)*r20*x471))+((r20*x474))+(((-1.0)*r22*x472))+(((-1.0)*r21*x473))+(((-1.0)*r21*x475)));\nevalcond[2]=((((-1.0)*r00*x471))+((r00*x474))+(((-1.0)*r02*x472))+(((-1.0)*r01*x473))+(((-1.0)*r01*x475)));\nevalcond[3]=((-1.0)+(((-1.0)*x467*x470))+(((-1.0)*x468*x470))+((r10*x474))+(((-1.0)*r12*x472))+(((-1.0)*r11*x475)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nIkReal x476=(cj8*r20);\nIkReal x477=(r02*sj7);\nIkReal x478=(r21*sj8);\nIkReal x479=(r22*sj7);\nIkReal x480=(cj7*cj8*r00);\nIkReal x481=(cj7*cj8*r20);\nIkReal x482=(cj7*r01*sj8);\nIkReal x483=(cj7*r21*sj8);\nIkReal x484=((((-2.82)*x479))+(((-1.08)*x476))+(((-0.36)*x477))+(((-0.36)*x480))+(((1.08)*x478))+(((12.0)*pz))+(((2.82)*x483))+(((-2.82)*x481))+(((0.36)*x482)));\nj4eval[0]=((IKabs(((-1.0)+(((0.36)*x478))+(((-0.36)*x476))+(((4.0)*pz))+(((0.12)*x482))+(((-0.94)*x479))+(((-0.94)*x481))+(((0.94)*x483))+(((-0.12)*x480))+(((-0.12)*x477)))))+(IKabs(((1.0)+x484)))+(IKabs(((-1.0)+x484))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x485=(cj8*r20);\nIkReal x486=(r02*sj7);\nIkReal x487=(r21*sj8);\nIkReal x488=(r22*sj7);\nIkReal x489=(cj7*cj8*r00);\nIkReal x490=(cj7*cj8*r20);\nIkReal x491=(cj7*r01*sj8);\nIkReal x492=(cj7*r21*sj8);\nIkReal x493=((((-0.12)*x486))+(((-0.94)*x488))+(((0.36)*x487))+(((4.0)*pz))+(((-0.36)*x485))+(((0.12)*x491))+(((0.94)*x492))+(((-0.12)*x489))+(((-0.94)*x490)));\nIkReal x494=((((-2.82)*x488))+(((-0.36)*x486))+(((-0.36)*x489))+(((-2.82)*x490))+(((-1.08)*x485))+(((1.08)*x487))+(((12.0)*pz))+(((2.82)*x492))+(((0.36)*x491)));\nop[0]=((-1.0)+x493);\nop[1]=0;\nop[2]=((-1.0)+x494);\nop[3]=0;\nop[4]=((1.0)+x494);\nop[5]=0;\nop[6]=((1.0)+x493);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x495=(cj8*r20);\nIkReal x496=((0.36)*x495);\nIkReal x497=(r21*sj8);\nIkReal x498=((0.36)*x497);\nIkReal x499=(r22*sj7);\nIkReal x500=(cj6*cj7*r22);\nIkReal x501=(cj7*cj8*r20);\nIkReal x502=(cj7*r21*sj8);\nIkReal x503=(cj8*r21*sj6);\nIkReal x504=(r20*sj6*sj8);\nIkReal x505=((0.12)*cj6*sj7);\nIkReal x506=((((-1.0)*x497*x505))+(((-1.0)*(4.0)*pz))+(((0.94)*x501))+(((-0.94)*x502))+((x495*x505))+(((-1.0)*x498))+(((-0.12)*x500))+(((0.12)*x504))+(((0.94)*x499))+(((0.12)*x503))+x496);\nIkReal x507=(cj6*sj7);\nIkReal x508=((((-1.0)*x498*x507))+(((-0.36)*x500))+(((2.82)*x499))+(((-1.0)*(12.0)*pz))+(((0.36)*x503))+(((2.82)*x501))+(((-1.08)*x497))+(((0.36)*x504))+(((1.08)*x495))+(((-2.82)*x502))+((x496*x507)));\nj4evalpoly[0]=((-1.0)+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((1.0)+x506))))+(((htj4*htj4)*(((-1.0)+x508))))+x506+(((htj4*htj4*htj4*htj4)*(((1.0)+x508)))));\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x509=(r02*sj7);\nIkReal x510=(r22*sj7);\nIkReal x511=(cj4*cj7);\nIkReal x512=(cj8*r00);\nIkReal x513=(cj7*sj4);\nIkReal x514=(cj8*r20);\nIkReal x515=(r01*sj8);\nIkReal x516=((1.0)*cj4*cj7);\nIkReal x517=(r21*sj8);\nIkReal x518=((1.0)*cj7*sj4);\nif( IKabs(((((-1.0)*x515*x516))+((x511*x512))+((cj4*x509))+(((-1.0)*x517*x518))+((sj4*x510))+((x513*x514)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj4*x509))+(((-1.0)*x515*x518))+((x511*x517))+(((-1.0)*cj4*x510))+(((-1.0)*x514*x516))+((x512*x513)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x515*x516))+((x511*x512))+((cj4*x509))+(((-1.0)*x517*x518))+((sj4*x510))+((x513*x514))))+IKsqr((((sj4*x509))+(((-1.0)*x515*x518))+((x511*x517))+(((-1.0)*cj4*x510))+(((-1.0)*x514*x516))+((x512*x513))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((((-1.0)*x515*x516))+((x511*x512))+((cj4*x509))+(((-1.0)*x517*x518))+((sj4*x510))+((x513*x514))), (((sj4*x509))+(((-1.0)*x515*x518))+((x511*x517))+(((-1.0)*cj4*x510))+(((-1.0)*x514*x516))+((x512*x513))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[6];\nIkReal x519=IKcos(j5);\nIkReal x520=(cj4*x519);\nIkReal x521=(cj7*cj8);\nIkReal x522=IKsin(j5);\nIkReal x523=(sj4*x522);\nIkReal x524=((1.0)*cj7*sj8);\nIkReal x525=(cj4*x522);\nIkReal x526=(sj4*x519);\nIkReal x527=((((-1.0)*x526))+(((-1.0)*x525)));\nIkReal x528=(cj8*sj6);\nIkReal x529=(sj6*sj8);\nIkReal x530=((1.0)*cj6*cj7);\nIkReal x531=(cj6*cj8*sj7);\nIkReal x532=((1.0)*cj6*sj7*sj8);\nIkReal x533=((0.09)*cj8);\nIkReal x534=((0.09)*sj8);\nevalcond[0]=((((-1.0)*r21*x524))+(((-1.0)*x523))+((r22*sj7))+((r20*x521))+x520);\nevalcond[1]=(((r02*sj7))+(((-1.0)*r01*x524))+((r00*x521))+x527);\nevalcond[2]=(((r00*x529))+((r01*x528))+(((-1.0)*x520))+((r00*x531))+(((-1.0)*r01*x532))+(((-1.0)*r02*x530))+x523);\nevalcond[3]=((((-1.0)*r22*x530))+((r20*x531))+(((-1.0)*r21*x532))+((r21*x528))+((r20*x529))+x527);\nevalcond[4]=((((0.235)*x523))+(((-1.0)*r21*x534))+((r20*x533))+(((-1.0)*(1.0)*pz))+(((0.03)*x525))+(((-0.235)*x520))+(((-1.0)*(0.25)*cj4))+(((0.03)*x526)));\nevalcond[5]=((((-1.0)*(1.0)*px))+(((-1.0)*r01*x534))+(((0.235)*x525))+((r00*x533))+(((0.25)*sj4))+(((0.03)*x520))+(((0.235)*x526))+(((-0.03)*x523)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x535=((1.0)*sj8);\nIkReal x536=((1.0)*cj8);\nCheckValue<IkReal> x537=IKPowWithIntegerCheck(IKsign((((cj7*cj8*r20))+((r22*sj7))+(((-1.0)*cj7*r21*x535)))),-1);\nif(!x537.valid){\ncontinue;\n}\nCheckValue<IkReal> x538 = IKatan2WithCheck(IkReal(((((-1.0)*r01*x536))+(((-1.0)*r00*x535)))),IkReal(((((-1.0)*r00*sj7*x536))+((r01*sj7*sj8))+((cj7*r02)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x538.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x537.value)))+(x538.value));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[4];\nIkReal x539=IKsin(j6);\nIkReal x540=(cj8*r11);\nIkReal x541=(r10*sj8);\nIkReal x542=IKcos(j6);\nIkReal x543=((1.0)*x542);\nIkReal x544=((1.0)*sj8*x542);\nIkReal x545=((1.0)*cj7*x539);\nIkReal x546=((1.0)*cj8*x542);\nIkReal x547=(cj8*sj7*x539);\nIkReal x548=((1.0)*sj7*sj8*x539);\nevalcond[0]=(((x539*x541))+(((-1.0)*cj7*r12*x543))+(((-1.0)*r11*sj7*x544))+((x539*x540))+((cj8*r10*sj7*x542)));\nevalcond[1]=((((-1.0)*r20*x544))+(((-1.0)*r21*x548))+(((-1.0)*r22*x545))+((r20*x547))+(((-1.0)*r21*x546)));\nevalcond[2]=((((-1.0)*r00*x544))+(((-1.0)*r02*x545))+(((-1.0)*r01*x546))+((r00*x547))+(((-1.0)*r01*x548)));\nevalcond[3]=((-1.0)+(((-1.0)*r11*x548))+(((-1.0)*r12*x545))+(((-1.0)*x541*x543))+(((-1.0)*x540*x543))+((r10*x547)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nsj3=0;\ncj3=-1.0;\nj3=3.14159265358979;\nIkReal x549=(cj8*r20);\nIkReal x550=(r02*sj7);\nIkReal x551=(r21*sj8);\nIkReal x552=(r22*sj7);\nIkReal x553=(cj7*cj8*r00);\nIkReal x554=(cj7*cj8*r20);\nIkReal x555=(cj7*r01*sj8);\nIkReal x556=(cj7*r21*sj8);\nIkReal x557=((((1.08)*x551))+(((-1.08)*x549))+(((-2.82)*x554))+(((-2.82)*x552))+(((2.82)*x556))+(((0.36)*x555))+(((-0.36)*x553))+(((-0.36)*x550))+(((12.0)*pz)));\nj4eval[0]=((IKabs(((-1.0)+x557)))+(IKabs(((1.0)+x557)))+(IKabs(((-1.0)+(((0.36)*x551))+(((0.12)*x555))+(((-0.12)*x553))+(((-0.36)*x549))+(((-0.94)*x552))+(((4.0)*pz))+(((0.94)*x556))+(((-0.12)*x550))+(((-0.94)*x554))))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x558=(cj8*r20);\nIkReal x559=(r02*sj7);\nIkReal x560=(r21*sj8);\nIkReal x561=(r22*sj7);\nIkReal x562=(cj7*cj8*r00);\nIkReal x563=(cj7*cj8*r20);\nIkReal x564=(cj7*r01*sj8);\nIkReal x565=(cj7*r21*sj8);\nIkReal x566=((((-0.94)*x561))+(((4.0)*pz))+(((-0.12)*x559))+(((-0.12)*x562))+(((0.94)*x565))+(((-0.36)*x558))+(((0.12)*x564))+(((0.36)*x560))+(((-0.94)*x563)));\nIkReal x567=((((-2.82)*x563))+(((1.08)*x560))+(((-0.36)*x562))+(((-0.36)*x559))+(((-2.82)*x561))+(((0.36)*x564))+(((-1.08)*x558))+(((12.0)*pz))+(((2.82)*x565)));\nop[0]=((-1.0)+x566);\nop[1]=0;\nop[2]=((-1.0)+x567);\nop[3]=0;\nop[4]=((1.0)+x567);\nop[5]=0;\nop[6]=((1.0)+x566);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x568=(cj8*r20);\nIkReal x569=((0.36)*x568);\nIkReal x570=(r21*sj8);\nIkReal x571=((0.36)*x570);\nIkReal x572=(r22*sj7);\nIkReal x573=(cj6*cj7*r22);\nIkReal x574=(cj7*cj8*r20);\nIkReal x575=(cj7*r21*sj8);\nIkReal x576=(cj8*r21*sj6);\nIkReal x577=(r20*sj6*sj8);\nIkReal x578=((0.12)*cj6*sj7);\nIkReal x579=((((0.94)*x572))+(((-0.94)*x575))+(((-1.0)*(4.0)*pz))+(((-0.12)*x573))+(((0.94)*x574))+((x568*x578))+(((0.12)*x576))+(((-1.0)*x570*x578))+(((-1.0)*x571))+(((0.12)*x577))+x569);\nIkReal x580=(cj6*sj7);\nIkReal x581=((((-1.0)*(12.0)*pz))+(((-1.08)*x570))+(((0.36)*x577))+((x569*x580))+(((1.08)*x568))+(((2.82)*x572))+(((2.82)*x574))+(((0.36)*x576))+(((-1.0)*x571*x580))+(((-2.82)*x575))+(((-0.36)*x573)));\nj4evalpoly[0]=((-1.0)+x579+(((htj4*htj4)*(((-1.0)+x581))))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((1.0)+x579))))+(((htj4*htj4*htj4*htj4)*(((1.0)+x581)))));\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x582=(r02*sj7);\nIkReal x583=(r22*sj7);\nIkReal x584=(cj4*cj7);\nIkReal x585=(cj8*r00);\nIkReal x586=(cj7*sj4);\nIkReal x587=(cj8*r20);\nIkReal x588=(r01*sj8);\nIkReal x589=((1.0)*cj4*cj7);\nIkReal x590=(r21*sj8);\nIkReal x591=((1.0)*cj7*sj4);\nif( IKabs((((cj4*x582))+((sj4*x583))+((x584*x585))+(((-1.0)*x588*x589))+((x586*x587))+(((-1.0)*x590*x591)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x584*x590))+((sj4*x582))+(((-1.0)*cj4*x583))+(((-1.0)*x588*x591))+((x585*x586))+(((-1.0)*x587*x589)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*x582))+((sj4*x583))+((x584*x585))+(((-1.0)*x588*x589))+((x586*x587))+(((-1.0)*x590*x591))))+IKsqr((((x584*x590))+((sj4*x582))+(((-1.0)*cj4*x583))+(((-1.0)*x588*x591))+((x585*x586))+(((-1.0)*x587*x589))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2((((cj4*x582))+((sj4*x583))+((x584*x585))+(((-1.0)*x588*x589))+((x586*x587))+(((-1.0)*x590*x591))), (((x584*x590))+((sj4*x582))+(((-1.0)*cj4*x583))+(((-1.0)*x588*x591))+((x585*x586))+(((-1.0)*x587*x589))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[6];\nIkReal x592=IKcos(j5);\nIkReal x593=(cj4*x592);\nIkReal x594=(cj7*cj8);\nIkReal x595=IKsin(j5);\nIkReal x596=(sj4*x595);\nIkReal x597=((1.0)*cj7*sj8);\nIkReal x598=(cj4*x595);\nIkReal x599=(sj4*x592);\nIkReal x600=((((-1.0)*x598))+(((-1.0)*x599)));\nIkReal x601=(cj8*sj6);\nIkReal x602=(sj6*sj8);\nIkReal x603=((1.0)*cj6*cj7);\nIkReal x604=(cj6*cj8*sj7);\nIkReal x605=((1.0)*cj6*sj7*sj8);\nIkReal x606=((0.09)*cj8);\nIkReal x607=((0.09)*sj8);\nevalcond[0]=((((-1.0)*x596))+(((-1.0)*r21*x597))+((r20*x594))+((r22*sj7))+x593);\nevalcond[1]=(((r02*sj7))+(((-1.0)*r01*x597))+((r00*x594))+x600);\nevalcond[2]=((((-1.0)*x593))+(((-1.0)*r02*x603))+((r00*x602))+((r01*x601))+(((-1.0)*r01*x605))+((r00*x604))+x596);\nevalcond[3]=((((-1.0)*r22*x603))+(((-1.0)*r21*x605))+((r20*x602))+((r20*x604))+((r21*x601))+x600);\nevalcond[4]=((((-1.0)*r21*x607))+(((-1.0)*(1.0)*pz))+(((0.235)*x596))+((r20*x606))+(((-0.235)*x593))+(((-1.0)*(0.25)*cj4))+(((0.03)*x599))+(((0.03)*x598)));\nevalcond[5]=((((0.235)*x599))+((r00*x606))+(((-1.0)*(1.0)*px))+(((0.235)*x598))+(((-1.0)*r01*x607))+(((0.03)*x593))+(((0.25)*sj4))+(((-0.03)*x596)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x608=(cj8*r00);\nIkReal x609=(r01*sj8);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));\nevalcond[1]=(((cj7*x608))+(((-1.0)*cj7*x609))+((r02*sj7)));\nevalcond[2]=((0.095)+(((-1.0)*(1.0)*px))+(((-0.09)*x609))+(((0.09)*x608)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6eval[3];\nsj3=1.0;\ncj3=0;\nj3=1.5707963267949;\nIkReal x610=((1.0)*sj8);\nIkReal x611=((((-1.0)*cj7*r11*x610))+((cj7*cj8*r10))+((r12*sj7)));\nIkReal x612=((1.0)*cj8);\nj6eval[0]=x611;\nj6eval[1]=IKsign(x611);\nj6eval[2]=((IKabs(((((-1.0)*r21*x612))+(((-1.0)*r20*x610)))))+(IKabs((((cj7*r22))+(((-1.0)*r20*sj7*x612))+((r21*sj7*sj8))))));\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[3];\nsj3=1.0;\ncj3=0;\nj3=1.5707963267949;\nIkReal x613=((1.0)*cj8);\nIkReal x614=(((cj7*r21*sj8))+(((-1.0)*(1.0)*r22*sj7))+(((-1.0)*cj7*r20*x613)));\nj6eval[0]=x614;\nj6eval[1]=((IKabs(((((-1.0)*r11*x613))+(((-1.0)*(1.0)*r10*sj8)))))+(IKabs(((((-1.0)*r10*sj7*x613))+((cj7*r12))+((r11*sj7*sj8))))));\nj6eval[2]=IKsign(x614);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[3];\nsj3=1.0;\ncj3=0;\nj3=1.5707963267949;\nIkReal x615=r00*r00;\nIkReal x616=r01*r01;\nIkReal x617=cj7*cj7;\nIkReal x618=((2.0)*cj7*r02);\nIkReal x619=(cj8*r00*sj7);\nIkReal x620=(x616*x617);\nIkReal x621=(r00*sj8);\nIkReal x622=cj8*cj8;\nIkReal x623=(x616+x615+(((-1.0)*x620))+((x620*x622))+(((-1.0)*x615*x617*x622))+(((2.0)*cj8*r01*x617*x621))+((x617*(r02*r02)))+((r01*sj7*sj8*x618))+(((-1.0)*x618*x619)));\nIkReal x624=((1.0)*r01);\nj6eval[0]=x623;\nj6eval[1]=((IKabs((x619+(((-1.0)*cj7*r02))+(((-1.0)*sj7*sj8*x624)))))+(IKabs(((((-1.0)*cj8*x624))+(((-1.0)*x621))))));\nj6eval[2]=IKsign(x623);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j4, j5, j6]\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x625=(cj8*r00*sj7);\nIkReal x626=((1.0)*r01);\nIkReal x627=(r00*sj8);\nIkReal x628=r00*r00;\nIkReal x629=r01*r01;\nIkReal x630=cj7*cj7;\nIkReal x631=((2.0)*cj7*r02);\nIkReal x632=(x629*x630);\nIkReal x633=cj8*cj8;\nCheckValue<IkReal> x634=IKPowWithIntegerCheck(IKsign(((((-1.0)*x625*x631))+(((-1.0)*x632))+x628+x629+(((2.0)*cj8*r01*x627*x630))+((x632*x633))+((r01*sj7*sj8*x631))+((x630*(r02*r02)))+(((-1.0)*x628*x630*x633)))),-1);\nif(!x634.valid){\ncontinue;\n}\nCheckValue<IkReal> x635 = IKatan2WithCheck(IkReal(((((-1.0)*cj7*r02))+x625+(((-1.0)*sj7*sj8*x626)))),IkReal(((((-1.0)*x627))+(((-1.0)*cj8*x626)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x635.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x634.value)))+(x635.value));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[4];\nIkReal x636=IKsin(j6);\nIkReal x637=(cj8*r01);\nIkReal x638=(r00*sj8);\nIkReal x639=IKcos(j6);\nIkReal x640=((1.0)*cj7*r02);\nIkReal x641=(cj8*r00*sj7);\nIkReal x642=(r01*sj7);\nIkReal x643=((1.0)*sj8*x639);\nIkReal x644=((1.0)*cj7*x636);\nIkReal x645=((1.0)*cj8*x639);\nIkReal x646=(cj8*sj7*x636);\nIkReal x647=((1.0)*sj7*sj8*x636);\nIkReal x648=((1.0)*x639);\nevalcond[0]=(((x639*x641))+(((-1.0)*x642*x643))+((x636*x637))+((x636*x638))+(((-1.0)*x639*x640)));\nevalcond[1]=((((-1.0)*r21*x645))+((r20*x646))+(((-1.0)*r21*x647))+(((-1.0)*r20*x643))+(((-1.0)*r22*x644)));\nevalcond[2]=((((-1.0)*r12*x644))+(((-1.0)*r11*x647))+((r10*x646))+(((-1.0)*r10*x643))+(((-1.0)*r11*x645)));\nevalcond[3]=((-1.0)+(((-1.0)*x636*x640))+(((-1.0)*x637*x648))+(((-1.0)*sj8*x636*x642))+((x636*x641))+(((-1.0)*x638*x648)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nsj3=1.0;\ncj3=0;\nj3=1.5707963267949;\nIkReal x649=(cj8*r20);\nIkReal x650=(r12*sj7);\nIkReal x651=(r21*sj8);\nIkReal x652=(r22*sj7);\nIkReal x653=(cj7*cj8*r10);\nIkReal x654=(cj7*cj8*r20);\nIkReal x655=(cj7*r11*sj8);\nIkReal x656=(cj7*r21*sj8);\nIkReal x657=((((2.82)*x652))+(((-1.0)*(12.0)*pz))+(((1.08)*x649))+(((2.82)*x654))+(((-0.36)*x653))+(((-0.36)*x650))+(((-1.08)*x651))+(((-2.82)*x656))+(((0.36)*x655)));\nj4eval[0]=((IKabs(((1.0)+(((0.12)*x655))+(((0.94)*x654))+(((0.36)*x649))+(((-1.0)*(4.0)*pz))+(((-0.94)*x656))+(((0.94)*x652))+(((-0.36)*x651))+(((-0.12)*x650))+(((-0.12)*x653)))))+(IKabs(((1.0)+x657)))+(IKabs(((-1.0)+x657))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x658=(cj8*r20);\nIkReal x659=(r12*sj7);\nIkReal x660=(r21*sj8);\nIkReal x661=(r22*sj7);\nIkReal x662=(cj7*cj8*r10);\nIkReal x663=(cj7*cj8*r20);\nIkReal x664=(cj7*r11*sj8);\nIkReal x665=(cj7*r21*sj8);\nIkReal x666=((((0.12)*x664))+(((0.94)*x661))+(((0.94)*x663))+(((-0.94)*x665))+(((-1.0)*(4.0)*pz))+(((-0.12)*x662))+(((-0.12)*x659))+(((-0.36)*x660))+(((0.36)*x658)));\nIkReal x667=((((1.08)*x658))+(((-1.0)*(12.0)*pz))+(((-1.08)*x660))+(((0.36)*x664))+(((-2.82)*x665))+(((2.82)*x661))+(((-0.36)*x659))+(((-0.36)*x662))+(((2.82)*x663)));\nop[0]=((1.0)+x666);\nop[1]=0;\nop[2]=((1.0)+x667);\nop[3]=0;\nop[4]=((-1.0)+x667);\nop[5]=0;\nop[6]=((-1.0)+x666);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x668=(cj8*r10);\nIkReal x669=(cj8*r20);\nIkReal x670=(r11*sj8);\nIkReal x671=(r21*sj8);\nIkReal x672=(r22*sj7);\nIkReal x673=(cj7*cj8*r20);\nIkReal x674=(cj7*r21*sj8);\nIkReal x675=((((0.2245)*x672))+(((-1.0)*(0.12)*py))+(((0.0846)*x669))+(((-0.0846)*x671))+(((0.0108)*x668))+(((-0.2245)*x674))+(((-1.0)*(0.94)*pz))+(((-0.0108)*x670))+(((0.2245)*x673)));\nIkReal x676=((((-1.0)*(0.36)*py))+(((-0.6735)*x674))+(((0.6735)*x672))+(((0.0324)*x668))+(((-1.0)*(2.82)*pz))+(((0.6735)*x673))+(((-0.0324)*x670))+(((-0.2538)*x671))+(((0.2538)*x669)));\nj4evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj4*htj4*htj4)))+(((htj4*htj4)*(((-0.235)+x676))))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((0.235)+x675))))+(((htj4*htj4*htj4*htj4)*(((0.235)+x676))))+(((-1.0)*(0.06)*(htj4*htj4*htj4*htj4*htj4)))+(((-1.0)*(0.06)*htj4))+x675);\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x677=(r22*sj7);\nIkReal x678=((1.0)*cj4);\nIkReal x679=(r12*sj7);\nIkReal x680=(cj4*cj7*sj8);\nIkReal x681=(cj7*sj4);\nIkReal x682=(cj8*r20);\nIkReal x683=(cj8*r10);\nIkReal x684=((1.0)*cj4*cj7);\nIkReal x685=((1.0)*cj7*sj4);\nif( IKabs(((((-1.0)*r21*sj8*x685))+((r11*x680))+(((-1.0)*x678*x679))+((sj4*x677))+(((-1.0)*x683*x684))+((x681*x682)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x683*x685))+((r21*x680))+(((-1.0)*sj4*x679))+(((-1.0)*x677*x678))+(((-1.0)*x682*x684))+((r11*sj8*x681)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r21*sj8*x685))+((r11*x680))+(((-1.0)*x678*x679))+((sj4*x677))+(((-1.0)*x683*x684))+((x681*x682))))+IKsqr(((((-1.0)*x683*x685))+((r21*x680))+(((-1.0)*sj4*x679))+(((-1.0)*x677*x678))+(((-1.0)*x682*x684))+((r11*sj8*x681))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((((-1.0)*r21*sj8*x685))+((r11*x680))+(((-1.0)*x678*x679))+((sj4*x677))+(((-1.0)*x683*x684))+((x681*x682))), ((((-1.0)*x683*x685))+((r21*x680))+(((-1.0)*sj4*x679))+(((-1.0)*x677*x678))+(((-1.0)*x682*x684))+((r11*sj8*x681))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[6];\nIkReal x686=IKsin(j5);\nIkReal x687=(cj4*x686);\nIkReal x688=IKcos(j5);\nIkReal x689=(sj4*x688);\nIkReal x690=(cj7*cj8);\nIkReal x691=((1.0)*cj7*sj8);\nIkReal x692=(cj4*x688);\nIkReal x693=(sj4*x686);\nIkReal x694=(x692+(((-1.0)*x693)));\nIkReal x695=(cj8*sj6);\nIkReal x696=(sj6*sj8);\nIkReal x697=((1.0)*cj6*cj7);\nIkReal x698=(cj6*cj8*sj7);\nIkReal x699=((1.0)*cj6*sj7*sj8);\nIkReal x700=((0.09)*cj8);\nIkReal x701=((0.09)*sj8);\nevalcond[0]=((((-1.0)*r11*x691))+((r10*x690))+((r12*sj7))+x687+x689);\nevalcond[1]=(((r20*x690))+(((-1.0)*r21*x691))+x694+((r22*sj7)));\nevalcond[2]=((((-1.0)*r11*x699))+(((-1.0)*r12*x697))+((r10*x696))+x694+((r10*x698))+((r11*x695)));\nevalcond[3]=((((-1.0)*x689))+((r20*x696))+(((-1.0)*r21*x699))+(((-1.0)*x687))+(((-1.0)*r22*x697))+((r21*x695))+((r20*x698)));\nevalcond[4]=((((0.235)*x693))+(((-0.235)*x692))+((r20*x700))+(((-1.0)*(1.0)*pz))+(((-1.0)*r21*x701))+(((-1.0)*(0.25)*cj4))+(((0.03)*x689))+(((0.03)*x687)));\nevalcond[5]=((((-1.0)*r11*x701))+(((-1.0)*(1.0)*py))+((r10*x700))+(((-0.235)*x689))+(((-0.03)*x692))+(((0.03)*x693))+(((-1.0)*(0.25)*sj4))+(((-0.235)*x687)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x702=((1.0)*cj8);\nCheckValue<IkReal> x703=IKPowWithIntegerCheck(IKsign((((cj7*r21*sj8))+(((-1.0)*(1.0)*r22*sj7))+(((-1.0)*cj7*r20*x702)))),-1);\nif(!x703.valid){\ncontinue;\n}\nCheckValue<IkReal> x704 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x702))+(((-1.0)*(1.0)*r10*sj8)))),IkReal((((cj7*r12))+((r11*sj7*sj8))+(((-1.0)*r10*sj7*x702)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x704.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x703.value)))+(x704.value));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[4];\nIkReal x705=IKsin(j6);\nIkReal x706=(cj8*r01);\nIkReal x707=(r00*sj8);\nIkReal x708=IKcos(j6);\nIkReal x709=((1.0)*cj7*r02);\nIkReal x710=(cj8*r00*sj7);\nIkReal x711=(r01*sj7);\nIkReal x712=((1.0)*sj8*x708);\nIkReal x713=((1.0)*cj7*x705);\nIkReal x714=((1.0)*cj8*x708);\nIkReal x715=(cj8*sj7*x705);\nIkReal x716=((1.0)*sj7*sj8*x705);\nIkReal x717=((1.0)*x708);\nevalcond[0]=(((x705*x707))+(((-1.0)*x711*x712))+((x705*x706))+(((-1.0)*x708*x709))+((x708*x710)));\nevalcond[1]=((((-1.0)*r21*x716))+(((-1.0)*r22*x713))+((r20*x715))+(((-1.0)*r21*x714))+(((-1.0)*r20*x712)));\nevalcond[2]=((((-1.0)*r11*x714))+((r10*x715))+(((-1.0)*r10*x712))+(((-1.0)*r12*x713))+(((-1.0)*r11*x716)));\nevalcond[3]=((-1.0)+((x705*x710))+(((-1.0)*x706*x717))+(((-1.0)*x705*x709))+(((-1.0)*x707*x717))+(((-1.0)*sj8*x705*x711)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nsj3=1.0;\ncj3=0;\nj3=1.5707963267949;\nIkReal x718=(cj8*r20);\nIkReal x719=(r12*sj7);\nIkReal x720=(r21*sj8);\nIkReal x721=(r22*sj7);\nIkReal x722=(cj7*cj8*r10);\nIkReal x723=(cj7*cj8*r20);\nIkReal x724=(cj7*r11*sj8);\nIkReal x725=(cj7*r21*sj8);\nIkReal x726=((((-1.0)*(12.0)*pz))+(((-0.36)*x719))+(((-1.08)*x720))+(((2.82)*x721))+(((2.82)*x723))+(((-0.36)*x722))+(((0.36)*x724))+(((-2.82)*x725))+(((1.08)*x718)));\nj4eval[0]=((IKabs(((1.0)+x726)))+(IKabs(((-1.0)+x726)))+(IKabs(((1.0)+(((-0.94)*x725))+(((0.94)*x723))+(((0.12)*x724))+(((0.36)*x718))+(((-0.12)*x719))+(((-1.0)*(4.0)*pz))+(((-0.12)*x722))+(((-0.36)*x720))+(((0.94)*x721))))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x727=(cj8*r20);\nIkReal x728=(r12*sj7);\nIkReal x729=(r21*sj8);\nIkReal x730=(r22*sj7);\nIkReal x731=(cj7*cj8*r10);\nIkReal x732=(cj7*cj8*r20);\nIkReal x733=(cj7*r11*sj8);\nIkReal x734=(cj7*r21*sj8);\nIkReal x735=((((-0.12)*x728))+(((0.94)*x730))+(((-0.36)*x729))+(((-1.0)*(4.0)*pz))+(((-0.12)*x731))+(((-0.94)*x734))+(((0.12)*x733))+(((0.36)*x727))+(((0.94)*x732)));\nIkReal x736=((((-1.0)*(12.0)*pz))+(((1.08)*x727))+(((-2.82)*x734))+(((-0.36)*x728))+(((0.36)*x733))+(((-1.08)*x729))+(((2.82)*x730))+(((-0.36)*x731))+(((2.82)*x732)));\nop[0]=((1.0)+x735);\nop[1]=0;\nop[2]=((1.0)+x736);\nop[3]=0;\nop[4]=((-1.0)+x736);\nop[5]=0;\nop[6]=((-1.0)+x735);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x737=(cj8*r10);\nIkReal x738=(cj8*r20);\nIkReal x739=(r11*sj8);\nIkReal x740=(r21*sj8);\nIkReal x741=(r22*sj7);\nIkReal x742=(cj7*cj8*r20);\nIkReal x743=(cj7*r21*sj8);\nIkReal x744=((((0.0108)*x737))+(((-1.0)*(0.12)*py))+(((0.2245)*x741))+(((-0.0846)*x740))+(((-0.0108)*x739))+(((-0.2245)*x743))+(((0.0846)*x738))+(((-1.0)*(0.94)*pz))+(((0.2245)*x742)));\nIkReal x745=((((-0.0324)*x739))+(((-1.0)*(0.36)*py))+(((0.0324)*x737))+(((-0.2538)*x740))+(((-0.6735)*x743))+(((0.6735)*x742))+(((-1.0)*(2.82)*pz))+(((0.2538)*x738))+(((0.6735)*x741)));\nj4evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj4*htj4*htj4)))+(((htj4*htj4)*(((-0.235)+x745))))+(((-1.0)*(0.06)*(htj4*htj4*htj4*htj4*htj4)))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((0.235)+x744))))+(((htj4*htj4*htj4*htj4)*(((0.235)+x745))))+(((-1.0)*(0.06)*htj4))+x744);\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x746=(r22*sj7);\nIkReal x747=((1.0)*cj4);\nIkReal x748=(r12*sj7);\nIkReal x749=(cj4*cj7*sj8);\nIkReal x750=(cj7*sj4);\nIkReal x751=(cj8*r20);\nIkReal x752=(cj8*r10);\nIkReal x753=((1.0)*cj4*cj7);\nIkReal x754=((1.0)*cj7*sj4);\nif( IKabs((((x750*x751))+(((-1.0)*x752*x753))+((sj4*x746))+((r11*x749))+(((-1.0)*x747*x748))+(((-1.0)*r21*sj8*x754)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj4*x748))+((r11*sj8*x750))+((r21*x749))+(((-1.0)*x752*x754))+(((-1.0)*x746*x747))+(((-1.0)*x751*x753)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x750*x751))+(((-1.0)*x752*x753))+((sj4*x746))+((r11*x749))+(((-1.0)*x747*x748))+(((-1.0)*r21*sj8*x754))))+IKsqr(((((-1.0)*sj4*x748))+((r11*sj8*x750))+((r21*x749))+(((-1.0)*x752*x754))+(((-1.0)*x746*x747))+(((-1.0)*x751*x753))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2((((x750*x751))+(((-1.0)*x752*x753))+((sj4*x746))+((r11*x749))+(((-1.0)*x747*x748))+(((-1.0)*r21*sj8*x754))), ((((-1.0)*sj4*x748))+((r11*sj8*x750))+((r21*x749))+(((-1.0)*x752*x754))+(((-1.0)*x746*x747))+(((-1.0)*x751*x753))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[6];\nIkReal x755=IKsin(j5);\nIkReal x756=(cj4*x755);\nIkReal x757=IKcos(j5);\nIkReal x758=(sj4*x757);\nIkReal x759=(cj7*cj8);\nIkReal x760=((1.0)*cj7*sj8);\nIkReal x761=(cj4*x757);\nIkReal x762=(sj4*x755);\nIkReal x763=(x761+(((-1.0)*x762)));\nIkReal x764=(cj8*sj6);\nIkReal x765=(sj6*sj8);\nIkReal x766=((1.0)*cj6*cj7);\nIkReal x767=(cj6*cj8*sj7);\nIkReal x768=((1.0)*cj6*sj7*sj8);\nIkReal x769=((0.09)*cj8);\nIkReal x770=((0.09)*sj8);\nevalcond[0]=((((-1.0)*r11*x760))+((r12*sj7))+x758+x756+((r10*x759)));\nevalcond[1]=((((-1.0)*r21*x760))+x763+((r22*sj7))+((r20*x759)));\nevalcond[2]=((((-1.0)*r12*x766))+((r10*x767))+((r10*x765))+x763+((r11*x764))+(((-1.0)*r11*x768)));\nevalcond[3]=((((-1.0)*r22*x766))+((r20*x767))+(((-1.0)*r21*x768))+((r20*x765))+(((-1.0)*x756))+(((-1.0)*x758))+((r21*x764)));\nevalcond[4]=((((-0.235)*x761))+(((-1.0)*(1.0)*pz))+(((0.03)*x758))+((r20*x769))+(((-1.0)*(0.25)*cj4))+(((0.235)*x762))+(((-1.0)*r21*x770))+(((0.03)*x756)));\nevalcond[5]=((((-1.0)*(1.0)*py))+(((-0.03)*x761))+(((-1.0)*r11*x770))+(((-0.235)*x758))+((r10*x769))+(((-1.0)*(0.25)*sj4))+(((-0.235)*x756))+(((0.03)*x762)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x771=((1.0)*sj8);\nIkReal x772=((1.0)*cj8);\nCheckValue<IkReal> x773=IKPowWithIntegerCheck(IKsign((((cj7*cj8*r10))+(((-1.0)*cj7*r11*x771))+((r12*sj7)))),-1);\nif(!x773.valid){\ncontinue;\n}\nCheckValue<IkReal> x774 = IKatan2WithCheck(IkReal(((((-1.0)*r21*x772))+(((-1.0)*r20*x771)))),IkReal((((cj7*r22))+(((-1.0)*r20*sj7*x772))+((r21*sj7*sj8)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x774.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x773.value)))+(x774.value));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[4];\nIkReal x775=IKsin(j6);\nIkReal x776=(cj8*r01);\nIkReal x777=(r00*sj8);\nIkReal x778=IKcos(j6);\nIkReal x779=((1.0)*cj7*r02);\nIkReal x780=(cj8*r00*sj7);\nIkReal x781=(r01*sj7);\nIkReal x782=((1.0)*sj8*x778);\nIkReal x783=((1.0)*cj7*x775);\nIkReal x784=((1.0)*cj8*x778);\nIkReal x785=(cj8*sj7*x775);\nIkReal x786=((1.0)*sj7*sj8*x775);\nIkReal x787=((1.0)*x778);\nevalcond[0]=(((x778*x780))+((x775*x777))+(((-1.0)*x781*x782))+(((-1.0)*x778*x779))+((x775*x776)));\nevalcond[1]=(((r20*x785))+(((-1.0)*r21*x784))+(((-1.0)*r20*x782))+(((-1.0)*r21*x786))+(((-1.0)*r22*x783)));\nevalcond[2]=((((-1.0)*r12*x783))+(((-1.0)*r10*x782))+(((-1.0)*r11*x784))+(((-1.0)*r11*x786))+((r10*x785)));\nevalcond[3]=((-1.0)+(((-1.0)*x775*x779))+(((-1.0)*x777*x787))+(((-1.0)*x776*x787))+(((-1.0)*sj8*x775*x781))+((x775*x780)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nsj3=1.0;\ncj3=0;\nj3=1.5707963267949;\nIkReal x788=(cj8*r20);\nIkReal x789=(r12*sj7);\nIkReal x790=(r21*sj8);\nIkReal x791=(r22*sj7);\nIkReal x792=(cj7*cj8*r10);\nIkReal x793=(cj7*cj8*r20);\nIkReal x794=(cj7*r11*sj8);\nIkReal x795=(cj7*r21*sj8);\nIkReal x796=((((1.08)*x788))+(((-1.0)*(12.0)*pz))+(((-2.82)*x795))+(((0.36)*x794))+(((2.82)*x791))+(((-0.36)*x792))+(((-1.08)*x790))+(((2.82)*x793))+(((-0.36)*x789)));\nj4eval[0]=((IKabs(((1.0)+(((0.94)*x791))+(((-1.0)*(4.0)*pz))+(((-0.12)*x789))+(((-0.94)*x795))+(((-0.12)*x792))+(((-0.36)*x790))+(((0.36)*x788))+(((0.94)*x793))+(((0.12)*x794)))))+(IKabs(((-1.0)+x796)))+(IKabs(((1.0)+x796))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x797=(cj8*r20);\nIkReal x798=(r12*sj7);\nIkReal x799=(r21*sj8);\nIkReal x800=(r22*sj7);\nIkReal x801=(cj7*cj8*r10);\nIkReal x802=(cj7*cj8*r20);\nIkReal x803=(cj7*r11*sj8);\nIkReal x804=(cj7*r21*sj8);\nIkReal x805=((((0.12)*x803))+(((-0.36)*x799))+(((-0.94)*x804))+(((0.94)*x802))+(((0.94)*x800))+(((-1.0)*(4.0)*pz))+(((0.36)*x797))+(((-0.12)*x801))+(((-0.12)*x798)));\nIkReal x806=((((-1.08)*x799))+(((0.36)*x803))+(((-1.0)*(12.0)*pz))+(((1.08)*x797))+(((2.82)*x802))+(((-0.36)*x801))+(((2.82)*x800))+(((-0.36)*x798))+(((-2.82)*x804)));\nop[0]=((1.0)+x805);\nop[1]=0;\nop[2]=((1.0)+x806);\nop[3]=0;\nop[4]=((-1.0)+x806);\nop[5]=0;\nop[6]=((-1.0)+x805);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x807=(cj8*r10);\nIkReal x808=(cj8*r20);\nIkReal x809=(r11*sj8);\nIkReal x810=(r21*sj8);\nIkReal x811=(r22*sj7);\nIkReal x812=(cj7*cj8*r20);\nIkReal x813=(cj7*r21*sj8);\nIkReal x814=((((-1.0)*(0.12)*py))+(((0.0108)*x807))+(((0.2245)*x812))+(((-0.0846)*x810))+(((-0.0108)*x809))+(((-0.2245)*x813))+(((-1.0)*(0.94)*pz))+(((0.0846)*x808))+(((0.2245)*x811)));\nIkReal x815=((((-1.0)*(0.36)*py))+(((-0.2538)*x810))+(((-1.0)*(2.82)*pz))+(((-0.6735)*x813))+(((0.6735)*x812))+(((0.0324)*x807))+(((0.6735)*x811))+(((-0.0324)*x809))+(((0.2538)*x808)));\nj4evalpoly[0]=((-0.235)+(((htj4*htj4*htj4*htj4)*(((0.235)+x815))))+(((-1.0)*(0.12)*(htj4*htj4*htj4)))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((0.235)+x814))))+(((-1.0)*(0.06)*(htj4*htj4*htj4*htj4*htj4)))+(((-1.0)*(0.06)*htj4))+(((htj4*htj4)*(((-0.235)+x815))))+x814);\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x816=(r22*sj7);\nIkReal x817=((1.0)*cj4);\nIkReal x818=(r12*sj7);\nIkReal x819=(cj4*cj7*sj8);\nIkReal x820=(cj7*sj4);\nIkReal x821=(cj8*r20);\nIkReal x822=(cj8*r10);\nIkReal x823=((1.0)*cj4*cj7);\nIkReal x824=((1.0)*cj7*sj4);\nif( IKabs((((x820*x821))+((r11*x819))+(((-1.0)*x822*x823))+(((-1.0)*x817*x818))+(((-1.0)*r21*sj8*x824))+((sj4*x816)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x816*x817))+((r11*sj8*x820))+((r21*x819))+(((-1.0)*x822*x824))+(((-1.0)*x821*x823))+(((-1.0)*sj4*x818)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x820*x821))+((r11*x819))+(((-1.0)*x822*x823))+(((-1.0)*x817*x818))+(((-1.0)*r21*sj8*x824))+((sj4*x816))))+IKsqr(((((-1.0)*x816*x817))+((r11*sj8*x820))+((r21*x819))+(((-1.0)*x822*x824))+(((-1.0)*x821*x823))+(((-1.0)*sj4*x818))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2((((x820*x821))+((r11*x819))+(((-1.0)*x822*x823))+(((-1.0)*x817*x818))+(((-1.0)*r21*sj8*x824))+((sj4*x816))), ((((-1.0)*x816*x817))+((r11*sj8*x820))+((r21*x819))+(((-1.0)*x822*x824))+(((-1.0)*x821*x823))+(((-1.0)*sj4*x818))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[6];\nIkReal x825=IKsin(j5);\nIkReal x826=(cj4*x825);\nIkReal x827=IKcos(j5);\nIkReal x828=(sj4*x827);\nIkReal x829=(cj7*cj8);\nIkReal x830=((1.0)*cj7*sj8);\nIkReal x831=(cj4*x827);\nIkReal x832=(sj4*x825);\nIkReal x833=(x831+(((-1.0)*x832)));\nIkReal x834=(cj8*sj6);\nIkReal x835=(sj6*sj8);\nIkReal x836=((1.0)*cj6*cj7);\nIkReal x837=(cj6*cj8*sj7);\nIkReal x838=((1.0)*cj6*sj7*sj8);\nIkReal x839=((0.09)*cj8);\nIkReal x840=((0.09)*sj8);\nevalcond[0]=((((-1.0)*r11*x830))+((r12*sj7))+x826+x828+((r10*x829)));\nevalcond[1]=(x833+((r20*x829))+((r22*sj7))+(((-1.0)*r21*x830)));\nevalcond[2]=(x833+((r11*x834))+((r10*x837))+((r10*x835))+(((-1.0)*r12*x836))+(((-1.0)*r11*x838)));\nevalcond[3]=(((r20*x837))+(((-1.0)*r22*x836))+((r20*x835))+(((-1.0)*r21*x838))+(((-1.0)*x826))+(((-1.0)*x828))+((r21*x834)));\nevalcond[4]=((((0.03)*x826))+(((-1.0)*(1.0)*pz))+(((-0.235)*x831))+((r20*x839))+(((0.03)*x828))+(((-1.0)*(0.25)*cj4))+(((0.235)*x832))+(((-1.0)*r21*x840)));\nevalcond[5]=((((-1.0)*r11*x840))+(((-1.0)*(1.0)*py))+(((0.03)*x832))+((r10*x839))+(((-0.235)*x828))+(((-0.235)*x826))+(((-1.0)*(0.25)*sj4))+(((-0.03)*x831)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x841=(cj8*r00);\nIkReal x842=(r01*sj8);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));\nevalcond[1]=(((r02*sj7))+(((-1.0)*cj7*x842))+((cj7*x841)));\nevalcond[2]=((-0.095)+(((-1.0)*(1.0)*px))+(((-0.09)*x842))+(((0.09)*x841)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j6eval[3];\nsj3=-1.0;\ncj3=0;\nj3=-1.5707963267949;\nIkReal x843=((1.0)*cj7);\nIkReal x844=(((cj7*cj8*r10))+((r12*sj7))+(((-1.0)*r11*sj8*x843)));\nj6eval[0]=x844;\nj6eval[1]=((IKabs(((((-1.0)*r22*x843))+((cj8*r20*sj7))+(((-1.0)*(1.0)*r21*sj7*sj8)))))+(IKabs((((r20*sj8))+((cj8*r21))))));\nj6eval[2]=IKsign(x844);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[3];\nsj3=-1.0;\ncj3=0;\nj3=-1.5707963267949;\nIkReal x845=((1.0)*sj7);\nIkReal x846=((1.0)*cj7);\nIkReal x847=(((cj7*r21*sj8))+(((-1.0)*r22*x845))+(((-1.0)*cj8*r20*x846)));\nj6eval[0]=x847;\nj6eval[1]=((IKabs((((r10*sj8))+((cj8*r11)))))+(IKabs(((((-1.0)*r11*sj8*x845))+(((-1.0)*r12*x846))+((cj8*r10*sj7))))));\nj6eval[2]=IKsign(x847);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j6eval[3];\nsj3=-1.0;\ncj3=0;\nj3=-1.5707963267949;\nIkReal x848=r00*r00;\nIkReal x849=r01*r01;\nIkReal x850=cj7*cj7;\nIkReal x851=((2.0)*cj7*r02);\nIkReal x852=(cj8*r00*sj7);\nIkReal x853=(r01*sj7*sj8);\nIkReal x854=(x849*x850);\nIkReal x855=(r00*sj8);\nIkReal x856=cj8*cj8;\nIkReal x857=(x848+x849+(((-1.0)*x851*x852))+((x850*(r02*r02)))+(((-1.0)*x854))+(((2.0)*cj8*r01*x850*x855))+((x854*x856))+((x851*x853))+(((-1.0)*x848*x850*x856)));\nj6eval[0]=x857;\nj6eval[1]=((IKabs((((cj8*r01))+x855)))+(IKabs(((((-1.0)*x852))+x853+((cj7*r02))))));\nj6eval[2]=IKsign(x857);\nif( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j4, j5, j6]\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x858=(r01*sj7*sj8);\nIkReal x859=(cj8*r00*sj7);\nIkReal x860=(r00*sj8);\nIkReal x861=r00*r00;\nIkReal x862=r01*r01;\nIkReal x863=cj7*cj7;\nIkReal x864=((2.0)*cj7*r02);\nIkReal x865=(x862*x863);\nIkReal x866=cj8*cj8;\nCheckValue<IkReal> x867 = IKatan2WithCheck(IkReal(((((-1.0)*x859))+x858+((cj7*r02)))),IkReal((((cj8*r01))+x860)),IKFAST_ATAN2_MAGTHRESH);\nif(!x867.valid){\ncontinue;\n}\nCheckValue<IkReal> x868=IKPowWithIntegerCheck(IKsign((((x858*x864))+(((-1.0)*x861*x863*x866))+(((-1.0)*x859*x864))+((x865*x866))+((x863*(r02*r02)))+(((-1.0)*x865))+x861+x862+(((2.0)*cj8*r01*x860*x863)))),-1);\nif(!x868.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x867.value)+(((1.5707963267949)*(x868.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[4];\nIkReal x869=IKsin(j6);\nIkReal x870=(cj8*r01);\nIkReal x871=(r00*sj8);\nIkReal x872=IKcos(j6);\nIkReal x873=((1.0)*cj7*r02);\nIkReal x874=(cj8*r00*sj7);\nIkReal x875=(r01*sj7);\nIkReal x876=((1.0)*sj8*x872);\nIkReal x877=((1.0)*cj7*x869);\nIkReal x878=((1.0)*cj8*x872);\nIkReal x879=(cj8*sj7*x869);\nIkReal x880=((1.0)*sj7*sj8*x869);\nIkReal x881=((1.0)*x872);\nevalcond[0]=((((-1.0)*x875*x876))+((x872*x874))+((x869*x870))+((x869*x871))+(((-1.0)*x872*x873)));\nevalcond[1]=((((-1.0)*r21*x880))+(((-1.0)*r21*x878))+((r20*x879))+(((-1.0)*r22*x877))+(((-1.0)*r20*x876)));\nevalcond[2]=((((-1.0)*r11*x878))+(((-1.0)*r12*x877))+(((-1.0)*r11*x880))+((r10*x879))+(((-1.0)*r10*x876)));\nevalcond[3]=((1.0)+((x869*x874))+(((-1.0)*x870*x881))+(((-1.0)*x871*x881))+(((-1.0)*x869*x873))+(((-1.0)*sj8*x869*x875)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nsj3=-1.0;\ncj3=0;\nj3=-1.5707963267949;\nIkReal x882=(cj8*r20);\nIkReal x883=(r12*sj7);\nIkReal x884=(r21*sj8);\nIkReal x885=(r22*sj7);\nIkReal x886=(cj7*cj8*r10);\nIkReal x887=(cj7*cj8*r20);\nIkReal x888=(cj7*r11*sj8);\nIkReal x889=(cj7*r21*sj8);\nIkReal x890=((((2.82)*x889))+(((-0.36)*x886))+(((1.08)*x884))+(((-2.82)*x885))+(((-1.08)*x882))+(((12.0)*pz))+(((-2.82)*x887))+(((-0.36)*x883))+(((0.36)*x888)));\nj4eval[0]=((IKabs(((-1.0)+(((-0.12)*x883))+(((-0.94)*x887))+(((-0.36)*x882))+(((0.94)*x889))+(((0.36)*x884))+(((4.0)*pz))+(((0.12)*x888))+(((-0.12)*x886))+(((-0.94)*x885)))))+(IKabs(((-1.0)+x890)))+(IKabs(((1.0)+x890))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x891=(cj8*r20);\nIkReal x892=(r12*sj7);\nIkReal x893=(r21*sj8);\nIkReal x894=(r22*sj7);\nIkReal x895=(cj7*cj8*r10);\nIkReal x896=(cj7*cj8*r20);\nIkReal x897=(cj7*r11*sj8);\nIkReal x898=(cj7*r21*sj8);\nIkReal x899=((((0.94)*x898))+(((-0.94)*x896))+(((-0.94)*x894))+(((4.0)*pz))+(((-0.12)*x892))+(((0.12)*x897))+(((-0.12)*x895))+(((0.36)*x893))+(((-0.36)*x891)));\nIkReal x900=((((-2.82)*x896))+(((-2.82)*x894))+(((1.08)*x893))+(((0.36)*x897))+(((2.82)*x898))+(((-0.36)*x895))+(((12.0)*pz))+(((-1.08)*x891))+(((-0.36)*x892)));\nop[0]=((-1.0)+x899);\nop[1]=0;\nop[2]=((-1.0)+x900);\nop[3]=0;\nop[4]=((1.0)+x900);\nop[5]=0;\nop[6]=((1.0)+x899);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x901=(cj8*r20);\nIkReal x902=((0.36)*x901);\nIkReal x903=(r21*sj8);\nIkReal x904=((0.36)*x903);\nIkReal x905=(r22*sj7);\nIkReal x906=(cj6*cj7*r22);\nIkReal x907=(cj7*cj8*r20);\nIkReal x908=(cj7*r21*sj8);\nIkReal x909=(cj8*r21*sj6);\nIkReal x910=(r20*sj6*sj8);\nIkReal x911=((0.12)*cj6*sj7);\nIkReal x912=((((-1.0)*x903*x911))+(((-0.12)*x906))+(((-1.0)*(4.0)*pz))+x902+((x901*x911))+(((-0.94)*x908))+(((0.94)*x905))+(((0.94)*x907))+(((0.12)*x910))+(((0.12)*x909))+(((-1.0)*x904)));\nIkReal x913=(cj6*sj7);\nIkReal x914=((((1.08)*x901))+(((-1.0)*(12.0)*pz))+(((2.82)*x905))+(((0.36)*x909))+(((2.82)*x907))+(((-1.08)*x903))+(((-1.0)*x904*x913))+(((0.36)*x910))+(((-2.82)*x908))+((x902*x913))+(((-0.36)*x906)));\nj4evalpoly[0]=((-1.0)+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((1.0)+x912))))+x912+(((htj4*htj4)*(((-1.0)+x914))))+(((htj4*htj4*htj4*htj4)*(((1.0)+x914)))));\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x915=(r12*sj7);\nIkReal x916=(r22*sj7);\nIkReal x917=(cj4*cj7);\nIkReal x918=(cj8*r10);\nIkReal x919=(cj7*sj4);\nIkReal x920=(cj8*r20);\nIkReal x921=(r11*sj8);\nIkReal x922=((1.0)*cj4*cj7);\nIkReal x923=(r21*sj8);\nIkReal x924=((1.0)*cj7*sj4);\nif( IKabs((((cj4*x915))+(((-1.0)*x923*x924))+((x917*x918))+(((-1.0)*x921*x922))+((sj4*x916))+((x919*x920)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*x916))+((x917*x923))+((sj4*x915))+((x918*x919))+(((-1.0)*x921*x924))+(((-1.0)*x920*x922)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*x915))+(((-1.0)*x923*x924))+((x917*x918))+(((-1.0)*x921*x922))+((sj4*x916))+((x919*x920))))+IKsqr(((((-1.0)*cj4*x916))+((x917*x923))+((sj4*x915))+((x918*x919))+(((-1.0)*x921*x924))+(((-1.0)*x920*x922))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2((((cj4*x915))+(((-1.0)*x923*x924))+((x917*x918))+(((-1.0)*x921*x922))+((sj4*x916))+((x919*x920))), ((((-1.0)*cj4*x916))+((x917*x923))+((sj4*x915))+((x918*x919))+(((-1.0)*x921*x924))+(((-1.0)*x920*x922))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[6];\nIkReal x925=IKcos(j5);\nIkReal x926=(cj4*x925);\nIkReal x927=(cj7*cj8);\nIkReal x928=IKsin(j5);\nIkReal x929=(sj4*x928);\nIkReal x930=((1.0)*cj7*sj8);\nIkReal x931=(cj4*x928);\nIkReal x932=(sj4*x925);\nIkReal x933=((((-1.0)*x932))+(((-1.0)*x931)));\nIkReal x934=(cj8*sj6);\nIkReal x935=(sj6*sj8);\nIkReal x936=((1.0)*cj6*cj7);\nIkReal x937=(cj6*cj8*sj7);\nIkReal x938=((1.0)*cj6*sj7*sj8);\nIkReal x939=((0.09)*cj8);\nIkReal x940=((0.09)*sj8);\nevalcond[0]=(((r22*sj7))+(((-1.0)*x929))+(((-1.0)*r21*x930))+((r20*x927))+x926);\nevalcond[1]=((((-1.0)*r11*x930))+((r10*x927))+((r12*sj7))+x933);\nevalcond[2]=(((r11*x934))+((r10*x937))+((r10*x935))+(((-1.0)*r11*x938))+(((-1.0)*r12*x936))+(((-1.0)*x926))+x929);\nevalcond[3]=(((r21*x934))+(((-1.0)*r21*x938))+(((-1.0)*r22*x936))+((r20*x937))+((r20*x935))+x933);\nevalcond[4]=(((r20*x939))+(((0.235)*x929))+(((-1.0)*(1.0)*pz))+(((0.03)*x932))+(((-1.0)*(0.25)*cj4))+(((-0.235)*x926))+(((0.03)*x931))+(((-1.0)*r21*x940)));\nevalcond[5]=((((-0.03)*x929))+(((0.235)*x932))+(((-1.0)*(1.0)*py))+(((0.235)*x931))+(((0.03)*x926))+(((0.25)*sj4))+((r10*x939))+(((-1.0)*r11*x940)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x941=((1.0)*sj7);\nIkReal x942=((1.0)*cj7);\nCheckValue<IkReal> x943 = IKatan2WithCheck(IkReal((((r10*sj8))+((cj8*r11)))),IkReal(((((-1.0)*r12*x942))+(((-1.0)*r11*sj8*x941))+((cj8*r10*sj7)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x943.valid){\ncontinue;\n}\nCheckValue<IkReal> x944=IKPowWithIntegerCheck(IKsign((((cj7*r21*sj8))+(((-1.0)*cj8*r20*x942))+(((-1.0)*r22*x941)))),-1);\nif(!x944.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x943.value)+(((1.5707963267949)*(x944.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[4];\nIkReal x945=IKsin(j6);\nIkReal x946=(cj8*r01);\nIkReal x947=(r00*sj8);\nIkReal x948=IKcos(j6);\nIkReal x949=((1.0)*cj7*r02);\nIkReal x950=(cj8*r00*sj7);\nIkReal x951=(r01*sj7);\nIkReal x952=((1.0)*sj8*x948);\nIkReal x953=((1.0)*cj7*x945);\nIkReal x954=((1.0)*cj8*x948);\nIkReal x955=(cj8*sj7*x945);\nIkReal x956=((1.0)*sj7*sj8*x945);\nIkReal x957=((1.0)*x948);\nevalcond[0]=((((-1.0)*x948*x949))+((x945*x947))+(((-1.0)*x951*x952))+((x945*x946))+((x948*x950)));\nevalcond[1]=((((-1.0)*r21*x954))+(((-1.0)*r20*x952))+(((-1.0)*r21*x956))+((r20*x955))+(((-1.0)*r22*x953)));\nevalcond[2]=((((-1.0)*r12*x953))+(((-1.0)*r11*x954))+(((-1.0)*r11*x956))+(((-1.0)*r10*x952))+((r10*x955)));\nevalcond[3]=((1.0)+(((-1.0)*x945*x949))+(((-1.0)*x947*x957))+((x945*x950))+(((-1.0)*sj8*x945*x951))+(((-1.0)*x946*x957)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nsj3=-1.0;\ncj3=0;\nj3=-1.5707963267949;\nIkReal x958=(cj8*r20);\nIkReal x959=(r12*sj7);\nIkReal x960=(r21*sj8);\nIkReal x961=(r22*sj7);\nIkReal x962=(cj7*cj8*r10);\nIkReal x963=(cj7*cj8*r20);\nIkReal x964=(cj7*r11*sj8);\nIkReal x965=(cj7*r21*sj8);\nIkReal x966=((((1.08)*x960))+(((-0.36)*x962))+(((-2.82)*x961))+(((-2.82)*x963))+(((-0.36)*x959))+(((12.0)*pz))+(((-1.08)*x958))+(((2.82)*x965))+(((0.36)*x964)));\nj4eval[0]=((IKabs(((-1.0)+(((0.12)*x964))+(((4.0)*pz))+(((0.94)*x965))+(((-0.36)*x958))+(((-0.94)*x961))+(((0.36)*x960))+(((-0.12)*x959))+(((-0.94)*x963))+(((-0.12)*x962)))))+(IKabs(((-1.0)+x966)))+(IKabs(((1.0)+x966))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x967=(cj8*r20);\nIkReal x968=(r12*sj7);\nIkReal x969=(r21*sj8);\nIkReal x970=(r22*sj7);\nIkReal x971=(cj7*cj8*r10);\nIkReal x972=(cj7*cj8*r20);\nIkReal x973=(cj7*r11*sj8);\nIkReal x974=(cj7*r21*sj8);\nIkReal x975=((((-0.12)*x971))+(((-0.36)*x967))+(((-0.94)*x970))+(((4.0)*pz))+(((0.94)*x974))+(((-0.94)*x972))+(((-0.12)*x968))+(((0.12)*x973))+(((0.36)*x969)));\nIkReal x976=((((2.82)*x974))+(((0.36)*x973))+(((-0.36)*x971))+(((-2.82)*x970))+(((1.08)*x969))+(((12.0)*pz))+(((-1.08)*x967))+(((-2.82)*x972))+(((-0.36)*x968)));\nop[0]=((-1.0)+x975);\nop[1]=0;\nop[2]=((-1.0)+x976);\nop[3]=0;\nop[4]=((1.0)+x976);\nop[5]=0;\nop[6]=((1.0)+x975);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x977=(cj8*r20);\nIkReal x978=((0.36)*x977);\nIkReal x979=(r21*sj8);\nIkReal x980=((0.36)*x979);\nIkReal x981=(r22*sj7);\nIkReal x982=(cj6*cj7*r22);\nIkReal x983=(cj7*cj8*r20);\nIkReal x984=(cj7*r21*sj8);\nIkReal x985=(cj8*r21*sj6);\nIkReal x986=(r20*sj6*sj8);\nIkReal x987=((0.12)*cj6*sj7);\nIkReal x988=(((x977*x987))+(((0.12)*x985))+(((-0.94)*x984))+(((-1.0)*x979*x987))+(((0.94)*x981))+(((-1.0)*(4.0)*pz))+(((-0.12)*x982))+(((-1.0)*x980))+(((0.94)*x983))+x978+(((0.12)*x986)));\nIkReal x989=(cj6*sj7);\nIkReal x990=((((-1.08)*x979))+(((-1.0)*(12.0)*pz))+(((-0.36)*x982))+(((0.36)*x985))+((x978*x989))+(((2.82)*x981))+(((-1.0)*x980*x989))+(((0.36)*x986))+(((1.08)*x977))+(((-2.82)*x984))+(((2.82)*x983)));\nj4evalpoly[0]=((-1.0)+(((htj4*htj4*htj4*htj4)*(((1.0)+x990))))+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((1.0)+x988))))+(((htj4*htj4)*(((-1.0)+x990))))+x988);\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x991=(r12*sj7);\nIkReal x992=(r22*sj7);\nIkReal x993=(cj4*cj7);\nIkReal x994=(cj8*r10);\nIkReal x995=(cj7*sj4);\nIkReal x996=(cj8*r20);\nIkReal x997=(r11*sj8);\nIkReal x998=((1.0)*cj4*cj7);\nIkReal x999=(r21*sj8);\nIkReal x1000=((1.0)*cj7*sj4);\nif( IKabs((((cj4*x991))+((x993*x994))+((x995*x996))+(((-1.0)*x997*x998))+(((-1.0)*x1000*x999))+((sj4*x992)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*x992))+((x994*x995))+(((-1.0)*x996*x998))+(((-1.0)*x1000*x997))+((x993*x999))+((sj4*x991)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*x991))+((x993*x994))+((x995*x996))+(((-1.0)*x997*x998))+(((-1.0)*x1000*x999))+((sj4*x992))))+IKsqr(((((-1.0)*cj4*x992))+((x994*x995))+(((-1.0)*x996*x998))+(((-1.0)*x1000*x997))+((x993*x999))+((sj4*x991))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2((((cj4*x991))+((x993*x994))+((x995*x996))+(((-1.0)*x997*x998))+(((-1.0)*x1000*x999))+((sj4*x992))), ((((-1.0)*cj4*x992))+((x994*x995))+(((-1.0)*x996*x998))+(((-1.0)*x1000*x997))+((x993*x999))+((sj4*x991))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[6];\nIkReal x1001=IKcos(j5);\nIkReal x1002=(cj4*x1001);\nIkReal x1003=(cj7*cj8);\nIkReal x1004=IKsin(j5);\nIkReal x1005=(sj4*x1004);\nIkReal x1006=((1.0)*cj7*sj8);\nIkReal x1007=(cj4*x1004);\nIkReal x1008=(sj4*x1001);\nIkReal x1009=((((-1.0)*x1008))+(((-1.0)*x1007)));\nIkReal x1010=(cj8*sj6);\nIkReal x1011=(sj6*sj8);\nIkReal x1012=((1.0)*cj6*cj7);\nIkReal x1013=(cj6*cj8*sj7);\nIkReal x1014=((1.0)*cj6*sj7*sj8);\nIkReal x1015=((0.09)*cj8);\nIkReal x1016=((0.09)*sj8);\nevalcond[0]=((((-1.0)*x1005))+((r20*x1003))+x1002+(((-1.0)*r21*x1006))+((r22*sj7)));\nevalcond[1]=(((r10*x1003))+x1009+(((-1.0)*r11*x1006))+((r12*sj7)));\nevalcond[2]=((((-1.0)*r12*x1012))+((r10*x1013))+(((-1.0)*x1002))+((r11*x1010))+x1005+((r10*x1011))+(((-1.0)*r11*x1014)));\nevalcond[3]=((((-1.0)*r22*x1012))+(((-1.0)*r21*x1014))+x1009+((r21*x1010))+((r20*x1013))+((r20*x1011)));\nevalcond[4]=(((r20*x1015))+(((-1.0)*(1.0)*pz))+(((0.235)*x1005))+(((-1.0)*r21*x1016))+(((-0.235)*x1002))+(((-1.0)*(0.25)*cj4))+(((0.03)*x1007))+(((0.03)*x1008)));\nevalcond[5]=((((-1.0)*r11*x1016))+(((-1.0)*(1.0)*py))+(((0.25)*sj4))+(((0.03)*x1002))+((r10*x1015))+(((-0.03)*x1005))+(((0.235)*x1008))+(((0.235)*x1007)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x1017=((1.0)*cj7);\nCheckValue<IkReal> x1018 = IKatan2WithCheck(IkReal((((r20*sj8))+((cj8*r21)))),IkReal((((cj8*r20*sj7))+(((-1.0)*(1.0)*r21*sj7*sj8))+(((-1.0)*r22*x1017)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1018.valid){\ncontinue;\n}\nCheckValue<IkReal> x1019=IKPowWithIntegerCheck(IKsign(((((-1.0)*r11*sj8*x1017))+((cj7*cj8*r10))+((r12*sj7)))),-1);\nif(!x1019.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x1018.value)+(((1.5707963267949)*(x1019.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[4];\nIkReal x1020=IKsin(j6);\nIkReal x1021=(cj8*r01);\nIkReal x1022=(r00*sj8);\nIkReal x1023=IKcos(j6);\nIkReal x1024=((1.0)*cj7*r02);\nIkReal x1025=(cj8*r00*sj7);\nIkReal x1026=(r01*sj7);\nIkReal x1027=((1.0)*sj8*x1023);\nIkReal x1028=((1.0)*cj7*x1020);\nIkReal x1029=((1.0)*cj8*x1023);\nIkReal x1030=(cj8*sj7*x1020);\nIkReal x1031=((1.0)*sj7*sj8*x1020);\nIkReal x1032=((1.0)*x1023);\nevalcond[0]=(((x1020*x1021))+(((-1.0)*x1026*x1027))+((x1020*x1022))+(((-1.0)*x1023*x1024))+((x1023*x1025)));\nevalcond[1]=((((-1.0)*r21*x1031))+(((-1.0)*r20*x1027))+(((-1.0)*r22*x1028))+(((-1.0)*r21*x1029))+((r20*x1030)));\nevalcond[2]=((((-1.0)*r11*x1031))+(((-1.0)*r10*x1027))+(((-1.0)*r11*x1029))+(((-1.0)*r12*x1028))+((r10*x1030)));\nevalcond[3]=((1.0)+((x1020*x1025))+(((-1.0)*x1022*x1032))+(((-1.0)*x1021*x1032))+(((-1.0)*x1020*x1024))+(((-1.0)*sj8*x1020*x1026)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nsj3=-1.0;\ncj3=0;\nj3=-1.5707963267949;\nIkReal x1033=(cj8*r20);\nIkReal x1034=(r12*sj7);\nIkReal x1035=(r21*sj8);\nIkReal x1036=(r22*sj7);\nIkReal x1037=(cj7*cj8*r10);\nIkReal x1038=(cj7*cj8*r20);\nIkReal x1039=(cj7*r11*sj8);\nIkReal x1040=(cj7*r21*sj8);\nIkReal x1041=((((2.82)*x1040))+(((-0.36)*x1037))+(((-0.36)*x1034))+(((-2.82)*x1038))+(((1.08)*x1035))+(((-2.82)*x1036))+(((12.0)*pz))+(((0.36)*x1039))+(((-1.08)*x1033)));\nj4eval[0]=((IKabs(((-1.0)+(((-0.36)*x1033))+(((-0.94)*x1038))+(((0.36)*x1035))+(((0.94)*x1040))+(((-0.12)*x1037))+(((4.0)*pz))+(((-0.12)*x1034))+(((0.12)*x1039))+(((-0.94)*x1036)))))+(IKabs(((1.0)+x1041)))+(IKabs(((-1.0)+x1041))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x1042=(cj8*r20);\nIkReal x1043=(r12*sj7);\nIkReal x1044=(r21*sj8);\nIkReal x1045=(r22*sj7);\nIkReal x1046=(cj7*cj8*r10);\nIkReal x1047=(cj7*cj8*r20);\nIkReal x1048=(cj7*r11*sj8);\nIkReal x1049=(cj7*r21*sj8);\nIkReal x1050=((((-0.36)*x1042))+(((0.12)*x1048))+(((-0.94)*x1045))+(((-0.12)*x1043))+(((-0.94)*x1047))+(((4.0)*pz))+(((-0.12)*x1046))+(((0.36)*x1044))+(((0.94)*x1049)));\nIkReal x1051=((((-2.82)*x1047))+(((0.36)*x1048))+(((-1.08)*x1042))+(((-0.36)*x1046))+(((1.08)*x1044))+(((2.82)*x1049))+(((-2.82)*x1045))+(((-0.36)*x1043))+(((12.0)*pz)));\nop[0]=((-1.0)+x1050);\nop[1]=0;\nop[2]=((-1.0)+x1051);\nop[3]=0;\nop[4]=((1.0)+x1051);\nop[5]=0;\nop[6]=((1.0)+x1050);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x1052=(cj8*r20);\nIkReal x1053=((0.36)*x1052);\nIkReal x1054=(r21*sj8);\nIkReal x1055=((0.36)*x1054);\nIkReal x1056=(r22*sj7);\nIkReal x1057=(cj6*cj7*r22);\nIkReal x1058=(cj7*cj8*r20);\nIkReal x1059=(cj7*r21*sj8);\nIkReal x1060=(cj8*r21*sj6);\nIkReal x1061=(r20*sj6*sj8);\nIkReal x1062=((0.12)*cj6*sj7);\nIkReal x1063=((((0.94)*x1056))+(((-1.0)*(4.0)*pz))+x1053+(((-1.0)*x1054*x1062))+(((-0.94)*x1059))+(((-1.0)*x1055))+(((-0.12)*x1057))+(((0.94)*x1058))+((x1052*x1062))+(((0.12)*x1060))+(((0.12)*x1061)));\nIkReal x1064=(cj6*sj7);\nIkReal x1065=((((1.08)*x1052))+(((-1.0)*(12.0)*pz))+(((2.82)*x1058))+(((2.82)*x1056))+(((-1.0)*x1055*x1064))+(((-0.36)*x1057))+(((0.36)*x1060))+(((0.36)*x1061))+(((-1.08)*x1054))+((x1053*x1064))+(((-2.82)*x1059)));\nj4evalpoly[0]=((-1.0)+(((htj4*htj4*htj4*htj4)*(((1.0)+x1065))))+x1063+(((htj4*htj4*htj4*htj4*htj4*htj4)*(((1.0)+x1063))))+(((htj4*htj4)*(((-1.0)+x1065)))));\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x1066=(r12*sj7);\nIkReal x1067=(r22*sj7);\nIkReal x1068=(cj4*cj7);\nIkReal x1069=(cj8*r10);\nIkReal x1070=(cj7*sj4);\nIkReal x1071=(cj8*r20);\nIkReal x1072=(r11*sj8);\nIkReal x1073=((1.0)*cj4*cj7);\nIkReal x1074=(r21*sj8);\nIkReal x1075=((1.0)*cj7*sj4);\nif( IKabs(((((-1.0)*x1072*x1073))+((cj4*x1066))+(((-1.0)*x1074*x1075))+((x1068*x1069))+((sj4*x1067))+((x1070*x1071)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x1068*x1074))+(((-1.0)*x1072*x1075))+(((-1.0)*x1071*x1073))+((sj4*x1066))+(((-1.0)*cj4*x1067))+((x1069*x1070)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1072*x1073))+((cj4*x1066))+(((-1.0)*x1074*x1075))+((x1068*x1069))+((sj4*x1067))+((x1070*x1071))))+IKsqr((((x1068*x1074))+(((-1.0)*x1072*x1075))+(((-1.0)*x1071*x1073))+((sj4*x1066))+(((-1.0)*cj4*x1067))+((x1069*x1070))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((((-1.0)*x1072*x1073))+((cj4*x1066))+(((-1.0)*x1074*x1075))+((x1068*x1069))+((sj4*x1067))+((x1070*x1071))), (((x1068*x1074))+(((-1.0)*x1072*x1075))+(((-1.0)*x1071*x1073))+((sj4*x1066))+(((-1.0)*cj4*x1067))+((x1069*x1070))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[6];\nIkReal x1076=IKcos(j5);\nIkReal x1077=(cj4*x1076);\nIkReal x1078=(cj7*cj8);\nIkReal x1079=IKsin(j5);\nIkReal x1080=(sj4*x1079);\nIkReal x1081=((1.0)*cj7*sj8);\nIkReal x1082=(cj4*x1079);\nIkReal x1083=(sj4*x1076);\nIkReal x1084=((((-1.0)*x1083))+(((-1.0)*x1082)));\nIkReal x1085=(cj8*sj6);\nIkReal x1086=(sj6*sj8);\nIkReal x1087=((1.0)*cj6*cj7);\nIkReal x1088=(cj6*cj8*sj7);\nIkReal x1089=((1.0)*cj6*sj7*sj8);\nIkReal x1090=((0.09)*cj8);\nIkReal x1091=((0.09)*sj8);\nevalcond[0]=((((-1.0)*r21*x1081))+(((-1.0)*x1080))+((r20*x1078))+x1077+((r22*sj7)));\nevalcond[1]=((((-1.0)*r11*x1081))+((r10*x1078))+x1084+((r12*sj7)));\nevalcond[2]=((((-1.0)*r11*x1089))+((r10*x1088))+x1080+(((-1.0)*x1077))+((r10*x1086))+((r11*x1085))+(((-1.0)*r12*x1087)));\nevalcond[3]=((((-1.0)*r22*x1087))+((r21*x1085))+((r20*x1086))+((r20*x1088))+x1084+(((-1.0)*r21*x1089)));\nevalcond[4]=((((0.235)*x1080))+(((-1.0)*(1.0)*pz))+((r20*x1090))+(((-1.0)*r21*x1091))+(((-1.0)*(0.25)*cj4))+(((-0.235)*x1077))+(((0.03)*x1083))+(((0.03)*x1082)));\nevalcond[5]=((((0.03)*x1077))+(((-1.0)*(1.0)*py))+(((-1.0)*r11*x1091))+((r10*x1090))+(((0.25)*sj4))+(((-0.03)*x1080))+(((0.235)*x1083))+(((0.235)*x1082)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j4, j5, j6]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x1092=((1.0)*cj8);\nIkReal x1093=((1.0)*cj3);\nIkReal x1094=(r11*sj3);\nIkReal x1095=(r10*sj3);\nIkReal x1096=(sj7*sj8);\nIkReal x1097=((1.0)*cj8*sj7);\nCheckValue<IkReal> x1098 = IKatan2WithCheck(IkReal(((((-1.0)*x1092*x1094))+(((-1.0)*cj8*r01*x1093))+(((-1.0)*r00*sj8*x1093))+(((-1.0)*sj8*x1095)))),IkReal(((((-1.0)*x1095*x1097))+((cj3*cj7*r02))+((x1094*x1096))+((cj3*r01*x1096))+(((-1.0)*cj3*r00*x1097))+((cj7*r12*sj3)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1098.valid){\ncontinue;\n}\nCheckValue<IkReal> x1099=IKPowWithIntegerCheck(IKsign((((cj7*r21*sj8))+(((-1.0)*cj7*r20*x1092))+(((-1.0)*r22*sj7)))),-1);\nif(!x1099.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(x1098.value)+(((1.5707963267949)*(x1099.value))));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[3];\nIkReal x1100=IKsin(j6);\nIkReal x1101=((1.0)*cj7*x1100);\nIkReal x1102=IKcos(j6);\nIkReal x1103=((1.0)*cj8*x1102);\nIkReal x1104=((1.0)*sj8*x1102);\nIkReal x1105=(cj8*sj7*x1100);\nIkReal x1106=((1.0)*sj7*sj8*x1100);\nevalcond[0]=((((-1.0)*r22*x1101))+(((-1.0)*r21*x1103))+((r20*x1105))+(((-1.0)*r20*x1104))+(((-1.0)*r21*x1106)));\nevalcond[1]=((((-1.0)*r12*x1101))+(((-1.0)*r10*x1104))+(((-1.0)*r11*x1106))+cj3+((r10*x1105))+(((-1.0)*r11*x1103)));\nevalcond[2]=(((r00*x1105))+(((-1.0)*r02*x1101))+(((-1.0)*r01*x1103))+(((-1.0)*r00*x1104))+(((-1.0)*(1.0)*sj3))+(((-1.0)*r01*x1106)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nIkReal x1107=(cj3*pz);\nIkReal x1108=(r02*sj7);\nIkReal x1109=(cj3*cj8*r20);\nIkReal x1110=(cj3*r21*sj8);\nIkReal x1111=(cj3*r22*sj7);\nIkReal x1112=(cj7*cj8*r00);\nIkReal x1113=(cj7*r01*sj8);\nIkReal x1114=(cj3*cj7*cj8*r20);\nIkReal x1115=(cj3*cj7*r21*sj8);\nIkReal x1116=((((-2.82)*x1115))+(((0.36)*x1113))+(((-0.36)*x1112))+(((1.08)*x1109))+(((-1.08)*x1110))+(((2.82)*x1114))+(((-12.0)*x1107))+(((2.82)*x1111))+(((-0.36)*x1108)));\nj4eval[0]=((IKabs(((((-0.12)*x1112))+(((-4.0)*x1107))+(((-0.94)*x1115))+(((0.94)*x1114))+(((-0.12)*x1108))+cj3+(((0.36)*x1109))+(((-0.36)*x1110))+(((0.94)*x1111))+(((0.12)*x1113)))))+(IKabs((x1116+(((-1.0)*(1.0)*cj3)))))+(IKabs((x1116+cj3))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x1117=(cj3*pz);\nIkReal x1118=(r02*sj7);\nIkReal x1119=(cj3*cj8*r20);\nIkReal x1120=(cj3*r21*sj8);\nIkReal x1121=(cj3*r22*sj7);\nIkReal x1122=(cj7*cj8*r00);\nIkReal x1123=(cj7*r01*sj8);\nIkReal x1124=(cj3*cj7*cj8*r20);\nIkReal x1125=(cj3*cj7*r21*sj8);\nIkReal x1126=((((-0.36)*x1120))+(((-4.0)*x1117))+(((0.94)*x1124))+(((0.94)*x1121))+(((-0.12)*x1118))+(((-0.94)*x1125))+(((0.12)*x1123))+(((0.36)*x1119))+(((-0.12)*x1122)));\nIkReal x1127=((((-0.36)*x1122))+(((0.36)*x1123))+(((-1.08)*x1120))+(((-12.0)*x1117))+(((1.08)*x1119))+(((2.82)*x1124))+(((2.82)*x1121))+(((-0.36)*x1118))+(((-2.82)*x1125)));\nIkReal x1128=((-1.0)*(((1.0)*cj3)));\nop[0]=(x1126+cj3);\nop[1]=0;\nop[2]=(x1127+cj3);\nop[3]=0;\nop[4]=(x1128+x1127);\nop[5]=0;\nop[6]=(x1126+x1128);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x1129=(pz*sj3);\nIkReal x1130=(r12*sj7);\nIkReal x1131=(cj7*cj8*r10);\nIkReal x1132=(cj7*r11*sj8);\nIkReal x1133=(cj8*r20*sj3);\nIkReal x1134=(r21*sj3*sj8);\nIkReal x1135=(r22*sj3*sj7);\nIkReal x1136=(cj7*cj8*r20*sj3);\nIkReal x1137=(cj7*r21*sj3*sj8);\nIkReal x1138=((((-4.0)*x1129))+(((-0.12)*x1131))+(((0.94)*x1135))+(((0.94)*x1136))+(((0.36)*x1133))+(((0.12)*x1132))+(((-0.94)*x1137))+(((-0.12)*x1130))+(((-0.36)*x1134)));\nIkReal x1139=((-1.0)*(((1.0)*sj3)));\nIkReal x1140=((((-0.36)*x1130))+(((-12.0)*x1129))+(((-1.08)*x1134))+(((2.82)*x1136))+(((2.82)*x1135))+(((-2.82)*x1137))+(((0.36)*x1132))+(((1.08)*x1133))+(((-0.36)*x1131)));\nj4evalpoly[0]=((((htj4*htj4*htj4*htj4)*((x1140+sj3))))+(((htj4*htj4*htj4*htj4*htj4*htj4)*((sj3+x1138))))+x1139+x1138+(((htj4*htj4)*((x1140+x1139)))));\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x1141=(r22*sj7);\nIkReal x1142=(cj4*r21);\nIkReal x1143=(cj8*sj6);\nIkReal x1144=(r20*sj6*sj8);\nIkReal x1145=(cj7*cj8*r20);\nIkReal x1146=((1.0)*cj4);\nIkReal x1147=(cj6*cj7*r22);\nIkReal x1148=(cj7*sj8);\nIkReal x1149=((1.0)*r21*sj4);\nIkReal x1150=(cj6*cj8*r20*sj7);\nIkReal x1151=(cj6*sj7*sj8);\nif( IKabs(((((-1.0)*x1148*x1149))+((x1142*x1143))+((cj4*x1150))+((cj4*x1144))+((sj4*x1145))+(((-1.0)*x1146*x1147))+((sj4*x1141))+(((-1.0)*cj4*r21*x1151)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x1142*x1148))+((sj4*x1144))+(((-1.0)*x1149*x1151))+(((-1.0)*sj4*x1147))+(((-1.0)*x1141*x1146))+(((-1.0)*x1145*x1146))+((r21*sj4*x1143))+((sj4*x1150)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1148*x1149))+((x1142*x1143))+((cj4*x1150))+((cj4*x1144))+((sj4*x1145))+(((-1.0)*x1146*x1147))+((sj4*x1141))+(((-1.0)*cj4*r21*x1151))))+IKsqr((((x1142*x1148))+((sj4*x1144))+(((-1.0)*x1149*x1151))+(((-1.0)*sj4*x1147))+(((-1.0)*x1141*x1146))+(((-1.0)*x1145*x1146))+((r21*sj4*x1143))+((sj4*x1150))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((((-1.0)*x1148*x1149))+((x1142*x1143))+((cj4*x1150))+((cj4*x1144))+((sj4*x1145))+(((-1.0)*x1146*x1147))+((sj4*x1141))+(((-1.0)*cj4*r21*x1151))), (((x1142*x1148))+((sj4*x1144))+(((-1.0)*x1149*x1151))+(((-1.0)*sj4*x1147))+(((-1.0)*x1141*x1146))+(((-1.0)*x1145*x1146))+((r21*sj4*x1143))+((sj4*x1150))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[9];\nIkReal x1152=IKcos(j5);\nIkReal x1153=(cj4*x1152);\nIkReal x1154=(cj7*cj8);\nIkReal x1155=IKsin(j5);\nIkReal x1156=(sj4*x1155);\nIkReal x1157=((1.0)*x1156);\nIkReal x1158=((1.0)*cj7*sj8);\nIkReal x1159=(cj4*x1155);\nIkReal x1160=(cj3*x1159);\nIkReal x1161=(sj4*x1152);\nIkReal x1162=(cj3*x1161);\nIkReal x1163=(sj3*x1159);\nIkReal x1164=(sj3*x1161);\nIkReal x1165=(cj8*sj6);\nIkReal x1166=(sj6*sj8);\nIkReal x1167=((1.0)*cj6*cj7);\nIkReal x1168=(cj6*cj8*sj7);\nIkReal x1169=((1.0)*cj6*sj7*sj8);\nIkReal x1170=((0.09)*cj8);\nIkReal x1171=((0.09)*sj8);\nIkReal x1172=(cj3*x1153);\nIkReal x1173=(sj3*x1153);\nIkReal x1174=((0.25)*sj4);\nIkReal x1175=((0.03)*sj4*x1155);\nevalcond[0]=((((-1.0)*r21*x1158))+x1153+((r20*x1154))+(((-1.0)*x1157))+((r22*sj7)));\nevalcond[1]=(((r02*sj7))+((r00*x1154))+(((-1.0)*r01*x1158))+x1160+x1162);\nevalcond[2]=((((-1.0)*r11*x1158))+((r10*x1154))+x1163+x1164+((r12*sj7)));\nevalcond[3]=((((-1.0)*x1161))+(((-1.0)*r21*x1169))+(((-1.0)*r22*x1167))+((r20*x1168))+(((-1.0)*x1159))+((r21*x1165))+((r20*x1166)));\nevalcond[4]=((((-1.0)*(1.0)*pz))+(((0.03)*x1161))+(((-0.235)*x1153))+(((-1.0)*(0.25)*cj4))+(((0.03)*x1159))+((r20*x1170))+(((-1.0)*r21*x1171))+(((0.235)*x1156)));\nevalcond[5]=((((-1.0)*cj3*x1157))+((r00*x1168))+((r01*x1165))+x1172+(((-1.0)*r01*x1169))+(((-1.0)*r02*x1167))+((r00*x1166)));\nevalcond[6]=(((r11*x1165))+(((-1.0)*r12*x1167))+((r10*x1168))+(((-1.0)*sj3*x1157))+(((-1.0)*r11*x1169))+x1173+((r10*x1166)));\nevalcond[7]=((((-1.0)*(1.0)*px))+((r00*x1170))+((cj3*x1175))+(((-0.235)*x1160))+(((-0.03)*x1172))+(((-1.0)*cj3*x1174))+(((-1.0)*r01*x1171))+(((-0.235)*x1162))+(((0.095)*sj3)));\nevalcond[8]=((((-1.0)*sj3*x1174))+(((-1.0)*(0.095)*cj3))+(((-1.0)*(1.0)*py))+(((-0.03)*x1173))+(((-0.235)*x1164))+((sj3*x1175))+(((-0.235)*x1163))+((r10*x1170))+(((-1.0)*r11*x1171)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x1176=((1.0)*sj8);\nIkReal x1177=(r21*sj3);\nIkReal x1178=(r20*sj3);\nCheckValue<IkReal> x1179=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj7*r11*x1176))+((cj7*cj8*r10))+((r12*sj7)))),-1);\nif(!x1179.valid){\ncontinue;\n}\nCheckValue<IkReal> x1180 = IKatan2WithCheck(IkReal(((((-1.0)*cj8*x1177))+(((-1.0)*x1176*x1178)))),IkReal(((((-1.0)*cj8*sj7*x1178))+((cj7*r22*sj3))+((sj7*sj8*x1177)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1180.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1179.value)))+(x1180.value));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[3];\nIkReal x1181=IKsin(j6);\nIkReal x1182=((1.0)*cj7*x1181);\nIkReal x1183=IKcos(j6);\nIkReal x1184=((1.0)*cj8*x1183);\nIkReal x1185=((1.0)*sj8*x1183);\nIkReal x1186=(cj8*sj7*x1181);\nIkReal x1187=((1.0)*sj7*sj8*x1181);\nevalcond[0]=((((-1.0)*r21*x1187))+(((-1.0)*r22*x1182))+(((-1.0)*r20*x1185))+((r20*x1186))+(((-1.0)*r21*x1184)));\nevalcond[1]=((((-1.0)*r12*x1182))+((r10*x1186))+(((-1.0)*r11*x1187))+cj3+(((-1.0)*r10*x1185))+(((-1.0)*r11*x1184)));\nevalcond[2]=((((-1.0)*r01*x1187))+(((-1.0)*r00*x1185))+((r00*x1186))+(((-1.0)*r02*x1182))+(((-1.0)*(1.0)*sj3))+(((-1.0)*r01*x1184)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nIkReal x1188=(cj3*pz);\nIkReal x1189=(r02*sj7);\nIkReal x1190=(cj3*cj8*r20);\nIkReal x1191=(cj3*r21*sj8);\nIkReal x1192=(cj3*r22*sj7);\nIkReal x1193=(cj7*cj8*r00);\nIkReal x1194=(cj7*r01*sj8);\nIkReal x1195=(cj3*cj7*cj8*r20);\nIkReal x1196=(cj3*cj7*r21*sj8);\nIkReal x1197=((((-12.0)*x1188))+(((2.82)*x1192))+(((-0.36)*x1193))+(((-0.36)*x1189))+(((1.08)*x1190))+(((-1.08)*x1191))+(((0.36)*x1194))+(((2.82)*x1195))+(((-2.82)*x1196)));\nj4eval[0]=((IKabs((cj3+x1197)))+(IKabs(((((-0.12)*x1189))+(((0.12)*x1194))+(((0.94)*x1192))+(((0.94)*x1195))+(((-0.94)*x1196))+cj3+(((-4.0)*x1188))+(((0.36)*x1190))+(((-0.12)*x1193))+(((-0.36)*x1191)))))+(IKabs(((((-1.0)*(1.0)*cj3))+x1197))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x1198=(cj3*pz);\nIkReal x1199=(r02*sj7);\nIkReal x1200=(cj3*cj8*r20);\nIkReal x1201=(cj3*r21*sj8);\nIkReal x1202=(cj3*r22*sj7);\nIkReal x1203=(cj7*cj8*r00);\nIkReal x1204=(cj7*r01*sj8);\nIkReal x1205=(cj3*cj7*cj8*r20);\nIkReal x1206=(cj3*cj7*r21*sj8);\nIkReal x1207=((((0.36)*x1200))+(((-0.94)*x1206))+(((-4.0)*x1198))+(((0.94)*x1205))+(((-0.12)*x1199))+(((-0.12)*x1203))+(((-0.36)*x1201))+(((0.94)*x1202))+(((0.12)*x1204)));\nIkReal x1208=((((2.82)*x1202))+(((-12.0)*x1198))+(((0.36)*x1204))+(((1.08)*x1200))+(((-0.36)*x1199))+(((2.82)*x1205))+(((-1.08)*x1201))+(((-0.36)*x1203))+(((-2.82)*x1206)));\nIkReal x1209=((-1.0)*(((1.0)*cj3)));\nop[0]=(x1207+cj3);\nop[1]=0;\nop[2]=(x1208+cj3);\nop[3]=0;\nop[4]=(x1209+x1208);\nop[5]=0;\nop[6]=(x1207+x1209);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x1210=(pz*sj3);\nIkReal x1211=(r12*sj7);\nIkReal x1212=(cj7*cj8*r10);\nIkReal x1213=(cj7*r11*sj8);\nIkReal x1214=(cj8*r20*sj3);\nIkReal x1215=(r21*sj3*sj8);\nIkReal x1216=(r22*sj3*sj7);\nIkReal x1217=(cj7*cj8*r20*sj3);\nIkReal x1218=(cj7*r21*sj3*sj8);\nIkReal x1219=((((-0.36)*x1215))+(((-0.94)*x1218))+(((0.94)*x1217))+(((0.12)*x1213))+(((0.36)*x1214))+(((0.94)*x1216))+(((-4.0)*x1210))+(((-0.12)*x1211))+(((-0.12)*x1212)));\nIkReal x1220=((-1.0)*(((1.0)*sj3)));\nIkReal x1221=((((-1.08)*x1215))+(((-2.82)*x1218))+(((2.82)*x1217))+(((0.36)*x1213))+(((-0.36)*x1211))+(((-0.36)*x1212))+(((2.82)*x1216))+(((-12.0)*x1210))+(((1.08)*x1214)));\nj4evalpoly[0]=((((htj4*htj4)*((x1221+x1220))))+(((htj4*htj4*htj4*htj4)*((sj3+x1221))))+x1220+x1219+(((htj4*htj4*htj4*htj4*htj4*htj4)*((sj3+x1219)))));\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x1222=(r22*sj7);\nIkReal x1223=(cj4*r21);\nIkReal x1224=(cj8*sj6);\nIkReal x1225=(r20*sj6*sj8);\nIkReal x1226=(cj7*cj8*r20);\nIkReal x1227=((1.0)*cj4);\nIkReal x1228=(cj6*cj7*r22);\nIkReal x1229=(cj7*sj8);\nIkReal x1230=((1.0)*r21*sj4);\nIkReal x1231=(cj6*cj8*r20*sj7);\nIkReal x1232=(cj6*sj7*sj8);\nif( IKabs((((sj4*x1222))+((cj4*x1225))+((cj4*x1231))+((sj4*x1226))+(((-1.0)*x1229*x1230))+((x1223*x1224))+(((-1.0)*cj4*r21*x1232))+(((-1.0)*x1227*x1228)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x1223*x1229))+(((-1.0)*sj4*x1228))+((sj4*x1231))+((sj4*x1225))+((r21*sj4*x1224))+(((-1.0)*x1226*x1227))+(((-1.0)*x1222*x1227))+(((-1.0)*x1230*x1232)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj4*x1222))+((cj4*x1225))+((cj4*x1231))+((sj4*x1226))+(((-1.0)*x1229*x1230))+((x1223*x1224))+(((-1.0)*cj4*r21*x1232))+(((-1.0)*x1227*x1228))))+IKsqr((((x1223*x1229))+(((-1.0)*sj4*x1228))+((sj4*x1231))+((sj4*x1225))+((r21*sj4*x1224))+(((-1.0)*x1226*x1227))+(((-1.0)*x1222*x1227))+(((-1.0)*x1230*x1232))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2((((sj4*x1222))+((cj4*x1225))+((cj4*x1231))+((sj4*x1226))+(((-1.0)*x1229*x1230))+((x1223*x1224))+(((-1.0)*cj4*r21*x1232))+(((-1.0)*x1227*x1228))), (((x1223*x1229))+(((-1.0)*sj4*x1228))+((sj4*x1231))+((sj4*x1225))+((r21*sj4*x1224))+(((-1.0)*x1226*x1227))+(((-1.0)*x1222*x1227))+(((-1.0)*x1230*x1232))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[9];\nIkReal x1233=IKcos(j5);\nIkReal x1234=(cj4*x1233);\nIkReal x1235=(cj7*cj8);\nIkReal x1236=IKsin(j5);\nIkReal x1237=(sj4*x1236);\nIkReal x1238=((1.0)*x1237);\nIkReal x1239=((1.0)*cj7*sj8);\nIkReal x1240=(cj4*x1236);\nIkReal x1241=(cj3*x1240);\nIkReal x1242=(sj4*x1233);\nIkReal x1243=(cj3*x1242);\nIkReal x1244=(sj3*x1240);\nIkReal x1245=(sj3*x1242);\nIkReal x1246=(cj8*sj6);\nIkReal x1247=(sj6*sj8);\nIkReal x1248=((1.0)*cj6*cj7);\nIkReal x1249=(cj6*cj8*sj7);\nIkReal x1250=((1.0)*cj6*sj7*sj8);\nIkReal x1251=((0.09)*cj8);\nIkReal x1252=((0.09)*sj8);\nIkReal x1253=(cj3*x1234);\nIkReal x1254=(sj3*x1234);\nIkReal x1255=((0.25)*sj4);\nIkReal x1256=((0.03)*sj4*x1236);\nevalcond[0]=((((-1.0)*x1238))+x1234+(((-1.0)*r21*x1239))+((r20*x1235))+((r22*sj7)));\nevalcond[1]=(((r02*sj7))+(((-1.0)*r01*x1239))+x1241+x1243+((r00*x1235)));\nevalcond[2]=(((r10*x1235))+((r12*sj7))+(((-1.0)*r11*x1239))+x1245+x1244);\nevalcond[3]=((((-1.0)*r22*x1248))+((r20*x1249))+(((-1.0)*x1242))+(((-1.0)*r21*x1250))+((r20*x1247))+((r21*x1246))+(((-1.0)*x1240)));\nevalcond[4]=((((-1.0)*(1.0)*pz))+(((0.235)*x1237))+(((0.03)*x1240))+(((0.03)*x1242))+(((-1.0)*r21*x1252))+((r20*x1251))+(((-1.0)*(0.25)*cj4))+(((-0.235)*x1234)));\nevalcond[5]=((((-1.0)*cj3*x1238))+(((-1.0)*r01*x1250))+x1253+(((-1.0)*r02*x1248))+((r00*x1249))+((r00*x1247))+((r01*x1246)));\nevalcond[6]=(x1254+((r11*x1246))+(((-1.0)*r12*x1248))+((r10*x1249))+(((-1.0)*sj3*x1238))+((r10*x1247))+(((-1.0)*r11*x1250)));\nevalcond[7]=((((-1.0)*cj3*x1255))+(((-1.0)*(1.0)*px))+((r00*x1251))+(((-1.0)*r01*x1252))+(((-0.03)*x1253))+(((-0.235)*x1243))+(((0.095)*sj3))+((cj3*x1256))+(((-0.235)*x1241)));\nevalcond[8]=((((-1.0)*(0.095)*cj3))+(((-1.0)*(1.0)*py))+((r10*x1251))+((sj3*x1256))+(((-1.0)*sj3*x1255))+(((-0.235)*x1244))+(((-0.235)*x1245))+(((-1.0)*r11*x1252))+(((-0.03)*x1254)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j6array[1], cj6array[1], sj6array[1];\nbool j6valid[1]={false};\n_nj6 = 1;\nIkReal x1257=((1.0)*cj7);\nIkReal x1258=(cj3*cj8);\nIkReal x1259=(cj3*sj8);\nCheckValue<IkReal> x1260=IKPowWithIntegerCheck(IKsign((((cj7*r01*sj8))+(((-1.0)*cj8*r00*x1257))+(((-1.0)*r02*sj7)))),-1);\nif(!x1260.valid){\ncontinue;\n}\nCheckValue<IkReal> x1261 = IKatan2WithCheck(IkReal((((r20*x1259))+((r21*x1258)))),IkReal(((((-1.0)*cj3*r22*x1257))+(((-1.0)*r21*sj7*x1259))+((r20*sj7*x1258)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1261.valid){\ncontinue;\n}\nj6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1260.value)))+(x1261.value));\nsj6array[0]=IKsin(j6array[0]);\ncj6array[0]=IKcos(j6array[0]);\nif( j6array[0] > IKPI )\n{\n    j6array[0]-=IK2PI;\n}\nelse if( j6array[0] < -IKPI )\n{    j6array[0]+=IK2PI;\n}\nj6valid[0] = true;\nfor(int ij6 = 0; ij6 < 1; ++ij6)\n{\nif( !j6valid[ij6] )\n{\n    continue;\n}\n_ij6[0] = ij6; _ij6[1] = -1;\nfor(int iij6 = ij6+1; iij6 < 1; ++iij6)\n{\nif( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )\n{\n    j6valid[iij6]=false; _ij6[1] = iij6; break; \n}\n}\nj6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];\n{\nIkReal evalcond[3];\nIkReal x1262=IKsin(j6);\nIkReal x1263=((1.0)*cj7*x1262);\nIkReal x1264=IKcos(j6);\nIkReal x1265=((1.0)*cj8*x1264);\nIkReal x1266=((1.0)*sj8*x1264);\nIkReal x1267=(cj8*sj7*x1262);\nIkReal x1268=((1.0)*sj7*sj8*x1262);\nevalcond[0]=((((-1.0)*r20*x1266))+(((-1.0)*r21*x1268))+(((-1.0)*r22*x1263))+(((-1.0)*r21*x1265))+((r20*x1267)));\nevalcond[1]=((((-1.0)*r12*x1263))+(((-1.0)*r11*x1268))+((r10*x1267))+cj3+(((-1.0)*r10*x1266))+(((-1.0)*r11*x1265)));\nevalcond[2]=(((r00*x1267))+(((-1.0)*r01*x1265))+(((-1.0)*r02*x1263))+(((-1.0)*r00*x1266))+(((-1.0)*r01*x1268))+(((-1.0)*(1.0)*sj3)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j4eval[1];\nIkReal x1269=(cj3*pz);\nIkReal x1270=(r02*sj7);\nIkReal x1271=(cj3*cj8*r20);\nIkReal x1272=(cj3*r21*sj8);\nIkReal x1273=(cj3*r22*sj7);\nIkReal x1274=(cj7*cj8*r00);\nIkReal x1275=(cj7*r01*sj8);\nIkReal x1276=(cj3*cj7*cj8*r20);\nIkReal x1277=(cj3*cj7*r21*sj8);\nIkReal x1278=((((-0.36)*x1270))+(((-12.0)*x1269))+(((1.08)*x1271))+(((2.82)*x1276))+(((-1.08)*x1272))+(((-0.36)*x1274))+(((0.36)*x1275))+(((2.82)*x1273))+(((-2.82)*x1277)));\nj4eval[0]=((IKabs(((((0.94)*x1273))+(((-4.0)*x1269))+(((-0.12)*x1274))+(((0.36)*x1271))+cj3+(((0.94)*x1276))+(((-0.94)*x1277))+(((0.12)*x1275))+(((-0.12)*x1270))+(((-0.36)*x1272)))))+(IKabs((x1278+cj3)))+(IKabs(((((-1.0)*(1.0)*cj3))+x1278))));\nif( IKabs(j4eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j4, j5]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j4evalpoly[1];\nIkReal x1279=(cj3*pz);\nIkReal x1280=(r02*sj7);\nIkReal x1281=(cj3*cj8*r20);\nIkReal x1282=(cj3*r21*sj8);\nIkReal x1283=(cj3*r22*sj7);\nIkReal x1284=(cj7*cj8*r00);\nIkReal x1285=(cj7*r01*sj8);\nIkReal x1286=(cj3*cj7*cj8*r20);\nIkReal x1287=(cj3*cj7*r21*sj8);\nIkReal x1288=((((0.94)*x1286))+(((-0.12)*x1284))+(((-0.12)*x1280))+(((-4.0)*x1279))+(((-0.94)*x1287))+(((-0.36)*x1282))+(((0.36)*x1281))+(((0.12)*x1285))+(((0.94)*x1283)));\nIkReal x1289=((((-12.0)*x1279))+(((-0.36)*x1284))+(((1.08)*x1281))+(((0.36)*x1285))+(((-1.08)*x1282))+(((2.82)*x1283))+(((2.82)*x1286))+(((-0.36)*x1280))+(((-2.82)*x1287)));\nIkReal x1290=((-1.0)*(((1.0)*cj3)));\nop[0]=(cj3+x1288);\nop[1]=0;\nop[2]=(cj3+x1289);\nop[3]=0;\nop[4]=(x1290+x1289);\nop[5]=0;\nop[6]=(x1290+x1288);\npolyroots6(op,zeror,numroots);\nIkReal j4array[6], cj4array[6], sj4array[6], tempj4array[1];\nint numsolutions = 0;\nfor(int ij4 = 0; ij4 < numroots; ++ij4)\n{\nIkReal htj4 = zeror[ij4];\ntempj4array[0]=((2.0)*(atan(htj4)));\nfor(int kj4 = 0; kj4 < 1; ++kj4)\n{\nj4array[numsolutions] = tempj4array[kj4];\nif( j4array[numsolutions] > IKPI )\n{\n    j4array[numsolutions]-=IK2PI;\n}\nelse if( j4array[numsolutions] < -IKPI )\n{\n    j4array[numsolutions]+=IK2PI;\n}\nsj4array[numsolutions] = IKsin(j4array[numsolutions]);\ncj4array[numsolutions] = IKcos(j4array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j4valid[6]={true,true,true,true,true,true};\n_nj4 = 6;\nfor(int ij4 = 0; ij4 < numsolutions; ++ij4)\n    {\nif( !j4valid[ij4] )\n{\n    continue;\n}\n    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];\nhtj4 = IKtan(j4/2);\n\nIkReal x1291=(pz*sj3);\nIkReal x1292=(r12*sj7);\nIkReal x1293=(cj7*cj8*r10);\nIkReal x1294=(cj7*r11*sj8);\nIkReal x1295=(cj8*r20*sj3);\nIkReal x1296=(r21*sj3*sj8);\nIkReal x1297=(r22*sj3*sj7);\nIkReal x1298=(cj7*cj8*r20*sj3);\nIkReal x1299=(cj7*r21*sj3*sj8);\nIkReal x1300=((((-0.36)*x1296))+(((0.94)*x1298))+(((0.94)*x1297))+(((0.12)*x1294))+(((-4.0)*x1291))+(((-0.94)*x1299))+(((-0.12)*x1293))+(((0.36)*x1295))+(((-0.12)*x1292)));\nIkReal x1301=((-1.0)*(((1.0)*sj3)));\nIkReal x1302=((((1.08)*x1295))+(((-2.82)*x1299))+(((2.82)*x1298))+(((-12.0)*x1291))+(((0.36)*x1294))+(((-0.36)*x1292))+(((-0.36)*x1293))+(((-1.08)*x1296))+(((2.82)*x1297)));\nj4evalpoly[0]=((((htj4*htj4*htj4*htj4*htj4*htj4)*((x1300+sj3))))+(((htj4*htj4)*((x1302+x1301))))+x1300+x1301+(((htj4*htj4*htj4*htj4)*((x1302+sj3)))));\nif( IKabs(j4evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij4[0] = ij4; _ij4[1] = -1;\nfor(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)\n{\nif( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )\n{\n    j4valid[iij4]=false; _ij4[1] = iij4; break; \n}\n}\n{\nIkReal j5array[1], cj5array[1], sj5array[1];\nbool j5valid[1]={false};\n_nj5 = 1;\nIkReal x1303=(r22*sj7);\nIkReal x1304=(cj4*r21);\nIkReal x1305=(cj8*sj6);\nIkReal x1306=(r20*sj6*sj8);\nIkReal x1307=(cj7*cj8*r20);\nIkReal x1308=((1.0)*cj4);\nIkReal x1309=(cj6*cj7*r22);\nIkReal x1310=(cj7*sj8);\nIkReal x1311=((1.0)*r21*sj4);\nIkReal x1312=(cj6*cj8*r20*sj7);\nIkReal x1313=(cj6*sj7*sj8);\nif( IKabs(((((-1.0)*cj4*r21*x1313))+((x1304*x1305))+((sj4*x1303))+((cj4*x1312))+(((-1.0)*x1308*x1309))+((sj4*x1307))+((cj4*x1306))+(((-1.0)*x1310*x1311)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1311*x1313))+((x1304*x1310))+(((-1.0)*sj4*x1309))+((sj4*x1306))+((sj4*x1312))+(((-1.0)*x1307*x1308))+((r21*sj4*x1305))+(((-1.0)*x1303*x1308)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*r21*x1313))+((x1304*x1305))+((sj4*x1303))+((cj4*x1312))+(((-1.0)*x1308*x1309))+((sj4*x1307))+((cj4*x1306))+(((-1.0)*x1310*x1311))))+IKsqr(((((-1.0)*x1311*x1313))+((x1304*x1310))+(((-1.0)*sj4*x1309))+((sj4*x1306))+((sj4*x1312))+(((-1.0)*x1307*x1308))+((r21*sj4*x1305))+(((-1.0)*x1303*x1308))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj5array[0]=IKatan2(((((-1.0)*cj4*r21*x1313))+((x1304*x1305))+((sj4*x1303))+((cj4*x1312))+(((-1.0)*x1308*x1309))+((sj4*x1307))+((cj4*x1306))+(((-1.0)*x1310*x1311))), ((((-1.0)*x1311*x1313))+((x1304*x1310))+(((-1.0)*sj4*x1309))+((sj4*x1306))+((sj4*x1312))+(((-1.0)*x1307*x1308))+((r21*sj4*x1305))+(((-1.0)*x1303*x1308))));\nsj5array[0]=IKsin(j5array[0]);\ncj5array[0]=IKcos(j5array[0]);\nif( j5array[0] > IKPI )\n{\n    j5array[0]-=IK2PI;\n}\nelse if( j5array[0] < -IKPI )\n{    j5array[0]+=IK2PI;\n}\nj5valid[0] = true;\nfor(int ij5 = 0; ij5 < 1; ++ij5)\n{\nif( !j5valid[ij5] )\n{\n    continue;\n}\n_ij5[0] = ij5; _ij5[1] = -1;\nfor(int iij5 = ij5+1; iij5 < 1; ++iij5)\n{\nif( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )\n{\n    j5valid[iij5]=false; _ij5[1] = iij5; break; \n}\n}\nj5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];\n{\nIkReal evalcond[9];\nIkReal x1314=IKcos(j5);\nIkReal x1315=(cj4*x1314);\nIkReal x1316=(cj7*cj8);\nIkReal x1317=IKsin(j5);\nIkReal x1318=(sj4*x1317);\nIkReal x1319=((1.0)*x1318);\nIkReal x1320=((1.0)*cj7*sj8);\nIkReal x1321=(cj4*x1317);\nIkReal x1322=(cj3*x1321);\nIkReal x1323=(sj4*x1314);\nIkReal x1324=(cj3*x1323);\nIkReal x1325=(sj3*x1321);\nIkReal x1326=(sj3*x1323);\nIkReal x1327=(cj8*sj6);\nIkReal x1328=(sj6*sj8);\nIkReal x1329=((1.0)*cj6*cj7);\nIkReal x1330=(cj6*cj8*sj7);\nIkReal x1331=((1.0)*cj6*sj7*sj8);\nIkReal x1332=((0.09)*cj8);\nIkReal x1333=((0.09)*sj8);\nIkReal x1334=(cj3*x1315);\nIkReal x1335=(sj3*x1315);\nIkReal x1336=((0.25)*sj4);\nIkReal x1337=((0.03)*sj4*x1317);\nevalcond[0]=((((-1.0)*r21*x1320))+((r22*sj7))+(((-1.0)*x1319))+((r20*x1316))+x1315);\nevalcond[1]=(x1324+x1322+((r02*sj7))+(((-1.0)*r01*x1320))+((r00*x1316)));\nevalcond[2]=(x1326+x1325+(((-1.0)*r11*x1320))+((r10*x1316))+((r12*sj7)));\nevalcond[3]=((((-1.0)*x1321))+(((-1.0)*r22*x1329))+((r20*x1330))+((r21*x1327))+(((-1.0)*r21*x1331))+(((-1.0)*x1323))+((r20*x1328)));\nevalcond[4]=(((r20*x1332))+(((0.03)*x1321))+(((-1.0)*(1.0)*pz))+(((-0.235)*x1315))+(((-1.0)*r21*x1333))+(((0.235)*x1318))+(((-1.0)*(0.25)*cj4))+(((0.03)*x1323)));\nevalcond[5]=((((-1.0)*r02*x1329))+(((-1.0)*cj3*x1319))+x1334+((r00*x1328))+((r00*x1330))+((r01*x1327))+(((-1.0)*r01*x1331)));\nevalcond[6]=((((-1.0)*r11*x1331))+(((-1.0)*sj3*x1319))+((r10*x1330))+x1335+((r11*x1327))+((r10*x1328))+(((-1.0)*r12*x1329)));\nevalcond[7]=(((r00*x1332))+(((-1.0)*(1.0)*px))+(((-0.03)*x1334))+(((-0.235)*x1322))+(((-1.0)*cj3*x1336))+(((-1.0)*r01*x1333))+(((0.095)*sj3))+(((-0.235)*x1324))+((cj3*x1337)));\nevalcond[8]=(((sj3*x1337))+(((-1.0)*(0.095)*cj3))+(((-1.0)*(1.0)*py))+(((-1.0)*r11*x1333))+(((-1.0)*sj3*x1336))+((r10*x1332))+(((-0.235)*x1325))+(((-0.03)*x1335))+(((-0.235)*x1326)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j0;\nvinfos[0].indices[0] = _ij0[0];\nvinfos[0].indices[1] = _ij0[1];\nvinfos[0].maxsolutions = _nj0;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j3;\nvinfos[1].indices[0] = _ij3[0];\nvinfos[1].indices[1] = _ij3[1];\nvinfos[1].maxsolutions = _nj3;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j4;\nvinfos[2].indices[0] = _ij4[0];\nvinfos[2].indices[1] = _ij4[1];\nvinfos[2].maxsolutions = _nj4;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j5;\nvinfos[3].indices[0] = _ij5[0];\nvinfos[3].indices[1] = _ij5[1];\nvinfos[3].maxsolutions = _nj5;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j6;\nvinfos[4].indices[0] = _ij6[0];\nvinfos[4].indices[1] = _ij6[1];\nvinfos[4].maxsolutions = _nj6;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j7;\nvinfos[5].indices[0] = _ij7[0];\nvinfos[5].indices[1] = _ij7[1];\nvinfos[5].maxsolutions = _nj7;\nvinfos[6].jointtype = 1;\nvinfos[6].foffset = j8;\nvinfos[6].indices[0] = _ij8[0];\nvinfos[6].indices[1] = _ij8[1];\nvinfos[6].maxsolutions = _nj8;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])\nstatic inline bool checkconsistency8(const IkReal* Breal)\n{\n    IkReal norm = 0.1;\n    for(int i = 0; i < 7; ++i) {\n        norm += IKabs(Breal[i]);\n    }\n    // HACK should be 1e-5*norm\n    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved\n    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;\n}\n/// \\brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)\n///\n/// matcoeffs is of length 54*3, for 3 matrices\nstatic inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)\n{\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};\n    IkReal IKFAST_ALIGNED16(A[8*8]);\n    IkReal IKFAST_ALIGNED16(work[16*16*15]);\n    int ipiv[8];\n    int info, coeffindex;\n    const int worksize=16*16*15;\n    const int matrixdim = 8;\n    const int matrixdim2 = 16;\n    numroots = 0;\n    // first setup M = [0 I; -C -B] and A\n    coeffindex = 0;\n    for(int j = 0; j < 4; ++j) {\n        for(int k = 0; k < 6; ++k) {\n            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];\n        }\n    }\n    for(int j = 0; j < 4; ++j) {\n        for(int k = 0; k < 6; ++k) {\n            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];\n        }\n    }\n    for(int j = 0; j < 4; ++j) {\n        for(int k = 0; k < 6; ++k) {\n            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];\n        }\n        for(int k = 0; k < 2; ++k) {\n            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;\n        }\n    }\n    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};\n    int lfindex = -1;\n    bool bsingular = true;\n    do {\n        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);\n        if( info == 0 ) {\n            bsingular = false;\n            for(int j = 0; j < matrixdim; ++j) {\n                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {\n                    bsingular = true;\n                    break;\n                }\n            }\n            if( !bsingular ) {\n                break;\n            }\n        }\n        if( lfindex == 3 ) {\n            break;\n        }\n        // transform by the linear functional\n        lfindex++;\n        const IkReal* lf = lfpossibilities[lfindex];\n        // have to reinitialize A\n        coeffindex = 0;\n        for(int j = 0; j < 4; ++j) {\n            for(int k = 0; k < 6; ++k) {\n                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];\n                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;\n                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);\n                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);\n                coeffindex++;\n            }\n            for(int k = 0; k < 2; ++k) {\n                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;\n            }\n        }\n    } while(lfindex<4);\n\n    if( bsingular ) {\n        return;\n    }\n    dgetrs_(\"No transpose\", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);\n    if( info != 0 ) {\n        return;\n    }\n\n    // set identity in upper corner\n    for(int j = 0; j < matrixdim; ++j) {\n        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;\n    }\n    IkReal IKFAST_ALIGNED16(wr[16]);\n    IkReal IKFAST_ALIGNED16(wi[16]);\n    IkReal IKFAST_ALIGNED16(vr[16*16]);\n    int one=1;\n    dgeev_(\"N\", \"V\", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);\n    if( info != 0 ) {\n        return;\n    }\n    IkReal Breal[matrixdim-1];\n    for(int i = 0; i < matrixdim2; ++i) {\n        // HACK should be tol*100\n        if( IKabs(wi[i]) < 5e-5 ) {\n            IkReal* ev = vr+matrixdim2*i;\n            if( IKabs(wr[i]) > 1 ) {\n                ev += matrixdim;\n            }\n            // consistency has to be checked!!\n            if( IKabs(ev[0]) < tol ) {\n                continue;\n            }\n            IkReal iconst = 1/ev[0];\n            for(int j = 1; j < matrixdim; ++j) {\n                Breal[j-1] = ev[j]*iconst;\n            }\n            if( checkconsistency8(Breal) ) {\n                if( lfindex >= 0 ) {\n                    const IkReal* lf = lfpossibilities[lfindex];\n                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);\n                }\n                else {\n                    rawroots[numroots++] = wr[i];\n                }\n                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);\n                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);\n                if( bsmall0 && bsmall1 ) {\n                    rawroots[numroots++] = ev[2]/ev[0];\n                    rawroots[numroots++] = ev[1]/ev[0];\n                }\n                else if( bsmall0 && !bsmall1 ) {\n                    rawroots[numroots++] = ev[3]/ev[1];\n                    rawroots[numroots++] = ev[1]/ev[0];\n                }\n                else if( !bsmall0 && bsmall1 ) {\n                    rawroots[numroots++] = ev[6]/ev[4];\n                    rawroots[numroots++] = ev[7]/ev[6];\n                }\n                else if( !bsmall0 && !bsmall1 ) {\n                    rawroots[numroots++] = ev[7]/ev[5];\n                    rawroots[numroots++] = ev[7]/ev[6];\n                }\n            }\n        }\n    }\n}};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"1178b25b2a7573d3b092bbd22e2d12d7\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\nchar* ComputeFkWrapper(const IkReal* j) {\n    IkReal eetrans[3] = {0};\n    IkReal eerot[9] = {0};\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n\nstd::vector<IkReal> TrueComputeIk(int argc, char** argv)\n{\n    std::vector<IkReal> solvalues(GetNumJoints());\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return solvalues;\n}\n"]}