{"version":3,"file":"./solvers/HiroNX_leftarm.html","sources":["./solvers/HiroNX_leftarm.tmp.cpp"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4SA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAvNA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;;;;;AAyNA;;;;;;;;;;;;;;;AAy2KA;AACA;AACA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA","sourcesContent":["/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE\n/// \\author Rosen Diankov\n///\n/// Licensed under the Apache License, Version 2.0 (the \"License\");\n/// you may not use this file except in compliance with the License.\n/// You may obtain a copy of the License at\n///     http://www.apache.org/licenses/LICENSE-2.0\n/// \n/// Unless required by applicable law or agreed to in writing, software\n/// distributed under the License is distributed on an \"AS IS\" BASIS,\n/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n/// See the License for the specific language governing permissions and\n/// limitations under the License.\n///\n/// ikfast version 0x10000048 generated on 2015-10-07 00:43:46.438128\n/// To compile with gcc:\n///     gcc -lstdc++ ik.cpp\n/// To compile without any main function as a shared object (might need -llapack):\n///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp\n#define IKFAST_HAS_LIBRARY\n#include \"ikfast.h\" // found inside share/openrave-X.Y/python/ikfast.h\nusing namespace ikfast;\n\n// check if the included ikfast version matches what this file was compiled with\n#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]\nIKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);\n\n#include <cmath>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <complex>\n\n#ifndef IKFAST_ASSERT\n#include <stdexcept>\n#include <sstream>\n#include <iostream>\n\n#ifdef _MSC_VER\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __FUNCDNAME__\n#endif\n#endif\n\n#ifndef __PRETTY_FUNCTION__\n#define __PRETTY_FUNCTION__ __func__\n#endif\n\n#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << \"ikfast exception: \" << __FILE__ << \":\" << __LINE__ << \": \" <<__PRETTY_FUNCTION__ << \": Assertion '\" << #b << \"' failed\"; throw std::runtime_error(ss.str()); } }\n\n#endif\n\n#if defined(_MSC_VER)\n#define IKFAST_ALIGNED16(x) __declspec(align(16)) x\n#else\n#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))\n#endif\n\n#define IK2PI  ((IkReal)6.28318530717959)\n#define IKPI  ((IkReal)3.14159265358979)\n#define IKPI_2  ((IkReal)1.57079632679490)\n\n#ifdef _MSC_VER\n#ifndef isnan\n#define isnan _isnan\n#endif\n#ifndef isinf\n#define isinf _isinf\n#endif\n//#ifndef isfinite\n//#define isfinite _isfinite\n//#endif\n#endif // _MSC_VER\n\n// lapack routines\nextern \"C\" {\n  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);\n  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);\n  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);\n  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);\n  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);\n  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);\n}\n\nusing namespace std; // necessary to get std math routines\n\n#ifdef IKFAST_NAMESPACE\nnamespace IKFAST_NAMESPACE {\n#endif\n\ninline float IKabs(float f) { return fabsf(f); }\ninline double IKabs(double f) { return fabs(f); }\n\ninline float IKsqr(float f) { return f*f; }\ninline double IKsqr(double f) { return f*f; }\n\ninline float IKlog(float f) { return logf(f); }\ninline double IKlog(double f) { return log(f); }\n\n// allows asin and acos to exceed 1\n#ifndef IKFAST_SINCOS_THRESH\n#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)\n#endif\n\n// used to check input to atan2 for degenerate cases\n#ifndef IKFAST_ATAN2_MAGTHRESH\n#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)\n#endif\n\n// minimum distance of separate solutions\n#ifndef IKFAST_SOLUTION_THRESH\n#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)\n#endif\n\n// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate\n#ifndef IKFAST_EVALCOND_THRESH\n#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)\n#endif\n\n\ninline float IKasin(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(-IKPI_2);\nelse if( f >= 1 ) return float(IKPI_2);\nreturn asinf(f);\n}\ninline double IKasin(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return -IKPI_2;\nelse if( f >= 1 ) return IKPI_2;\nreturn asin(f);\n}\n\n// return positive value in [0,y)\ninline float IKfmod(float x, float y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmodf(x,y);\n}\n\n// return positive value in [0,y)\ninline double IKfmod(double x, double y)\n{\n    while(x < 0) {\n        x += y;\n    }\n    return fmod(x,y);\n}\n\ninline float IKacos(float f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return float(IKPI);\nelse if( f >= 1 ) return float(0);\nreturn acosf(f);\n}\ninline double IKacos(double f)\n{\nIKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver\nif( f <= -1 ) return IKPI;\nelse if( f >= 1 ) return 0;\nreturn acos(f);\n}\ninline float IKsin(float f) { return sinf(f); }\ninline double IKsin(double f) { return sin(f); }\ninline float IKcos(float f) { return cosf(f); }\ninline double IKcos(double f) { return cos(f); }\ninline float IKtan(float f) { return tanf(f); }\ninline double IKtan(double f) { return tan(f); }\ninline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }\ninline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }\ninline float IKatan2Simple(float fy, float fx) {\n    return atan2f(fy,fx);\n}\ninline float IKatan2(float fy, float fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return float(IKPI_2);\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2f(fy,fx);\n}\ninline double IKatan2Simple(double fy, double fx) {\n    return atan2(fy,fx);\n}\ninline double IKatan2(double fy, double fx) {\n    if( isnan(fy) ) {\n        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned\n        return IKPI_2;\n    }\n    else if( isnan(fx) ) {\n        return 0;\n    }\n    return atan2(fy,fx);\n}\n\ntemplate <typename T>\nstruct CheckValue\n{\n    T value;\n    bool valid;\n};\n\ntemplate <typename T>\ninline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)\n{\n    CheckValue<T> ret;\n    ret.valid = false;\n    ret.value = 0;\n    if( !isnan(fy) && !isnan(fx) ) {\n        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {\n            ret.value = IKatan2Simple(fy,fx);\n            ret.valid = true;\n        }\n    }\n    return ret;\n}\n\ninline float IKsign(float f) {\n    if( f > 0 ) {\n        return float(1);\n    }\n    else if( f < 0 ) {\n        return float(-1);\n    }\n    return 0;\n}\n\ninline double IKsign(double f) {\n    if( f > 0 ) {\n        return 1.0;\n    }\n    else if( f < 0 ) {\n        return -1.0;\n    }\n    return 0;\n}\n\ntemplate <typename T>\ninline CheckValue<T> IKPowWithIntegerCheck(T f, int n)\n{\n    CheckValue<T> ret;\n    ret.valid = true;\n    if( n == 0 ) {\n        ret.value = 1.0;\n        return ret;\n    }\n    else if( n == 1 )\n    {\n        ret.value = f;\n        return ret;\n    }\n    else if( n < 0 )\n    {\n        if( f == 0 )\n        {\n            ret.valid = false;\n            ret.value = (T)1.0e30;\n            return ret;\n        }\n        if( n == -1 ) {\n            ret.value = T(1.0)/f;\n            return ret;\n        }\n    }\n\n    int num = n > 0 ? n : -n;\n    if( num == 2 ) {\n        ret.value = f*f;\n    }\n    else if( num == 3 ) {\n        ret.value = f*f*f;\n    }\n    else {\n        ret.value = 1.0;\n        while(num>0) {\n            if( num & 1 ) {\n                ret.value *= f;\n            }\n            num >>= 1;\n            f *= f;\n        }\n    }\n    \n    if( n < 0 ) {\n        ret.value = T(1.0)/ret.value;\n    }\n    return ret;\n}\n\n/// solves the forward kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {\nIkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68,x69,x70;\nx0=IKsin(j[4]);\nx1=IKsin(j[1]);\nx2=IKcos(j[0]);\nx3=IKcos(j[2]);\nx4=(x1*x2*x3);\nx5=IKsin(j[2]);\nx6=IKcos(j[1]);\nx7=(x5*x6);\nx8=((1.0)*x7);\nx9=((((-1.0)*(1.0)*x2*x8))+(((-1.0)*(1.0)*x4)));\nx10=IKcos(j[4]);\nx11=IKsin(j[0]);\nx12=IKsin(j[3]);\nx13=(x11*x12);\nx14=((1.0)*x13);\nx15=IKcos(j[3]);\nx16=(x3*x6);\nx17=(x16*x2);\nx18=(x1*x2*x5);\nx19=((1.0)*x18);\nx20=(x15*((x17+(((-1.0)*(1.0)*x19)))));\nx21=IKcos(j[5]);\nx22=((1.0)*x11);\nx23=(x15*x22);\nx24=((1.0)*x16);\nx25=(x12*((x19+(((-1.0)*(1.0)*x2*x24)))));\nx26=IKsin(j[5]);\nx27=((1.0)*x10);\nx28=((1.0)*x0);\nx29=((((-1.0)*(1.0)*x27*x9))+((x28*(((((1.0)*x20))+(((-1.0)*(1.0)*x14)))))));\nx30=((0.09)*x7);\nx31=((0.04)*x7);\nx32=(x1*x5);\nx33=(x32+(((-1.0)*(1.0)*x24)));\nx34=(x0*x33);\nx35=(x1*x3);\nx36=((1.0)*x35);\nx37=((((-1.0)*(1.0)*x36))+(((-1.0)*(1.0)*x8)));\nx38=(x10*x15*x37);\nx39=(x1*x11*x3);\nx40=((((-1.0)*(1.0)*x22*x7))+(((-1.0)*(1.0)*x39)));\nx41=(x0*x40);\nx42=(x12*x2);\nx43=(x11*x16);\nx44=(x22*x32);\nx45=(x15*(((((-1.0)*(1.0)*x44))+x43)));\nx46=(x10*((x42+x45)));\nx47=(x36+x8);\nx48=(x12*x21*x47);\nx49=(x15*x2);\nx50=(x12*((x44+(((-1.0)*(1.0)*x16*x22)))));\nx51=(x21*((x49+x50)));\nx52=((((-1.0)*(1.0)*x27*x33))+(((-1.0)*(1.0)*x15*x28*x47)));\nx53=(x26*x52);\nx54=((((-1.0)*(1.0)*x27*x40))+((x28*(((((1.0)*x45))+(((1.0)*x42)))))));\nx55=(x26*x54);\nx56=(x12*x26*x37);\nx57=(x26*(((((-1.0)*(1.0)*x49))+(((-1.0)*(1.0)*x50)))));\nx58=(x21*x52);\nx59=(x21*x54);\nx60=(x1*x11);\nx61=(x1*x11*x5);\nx62=(x11*x5*x6);\nx63=(x0*(((((0.04)*x16))+(((-1.0)*(0.04)*x32)))));\nx64=(x10*(((((0.09)*x32))+(((-1.0)*(0.09)*x16)))));\nx65=(x10*x15*((x31+(((0.04)*x35)))));\nx66=(x0*x15*((x30+(((0.09)*x35)))));\nx67=(x10*(((((-1.0)*(1.0)*x11*x30))+(((-1.0)*(0.09)*x39)))));\nx68=(x0*((((x11*x31))+(((0.04)*x39)))));\nx69=(x0*(((((-1.0)*(0.09)*x45))+(((-1.0)*(0.09)*x42)))));\nx70=(x10*(((((-1.0)*(0.04)*x42))+(((-1.0)*(0.04)*x45)))));\neerot[0]=(((x0*x9))+((x10*(((((-1.0)*(1.0)*x14))+x20)))));\neerot[1]=(((x21*(((((-1.0)*(1.0)*x23))+x25))))+((x26*x29)));\neerot[2]=(((x21*x29))+((x26*((x23+(((-1.0)*(1.0)*x25)))))));\neetrans[0]=(((x10*(((((-1.0)*(1.0)*x2*x30))+(((-1.0)*(0.09)*x4))))))+(((-1.0)*(0.235)*x4))+((x10*(((((-1.0)*(0.04)*x20))+(((0.04)*x13))))))+(((-1.0)*(0.25)*x1*x2))+((x0*((((x2*x31))+(((0.04)*x4))))))+((x0*(((((0.09)*x13))+(((-1.0)*(0.09)*x20))))))+(((0.03)*x18))+(((-1.0)*(0.235)*x2*x7))+(((-1.0)*(0.03)*x17))+(((-1.0)*(0.095)*x11)));\neerot[3]=((((0.965925532213041)*x41))+(((0.258820142606703)*x38))+(((0.965925532213041)*x46))+(((0.258820142606703)*x34)));\neerot[4]=((((0.258820142606703)*x48))+(((0.965925532213041)*x51))+(((0.258820142606703)*x53))+(((0.965925532213041)*x55)));\neerot[5]=((((0.258820142606703)*x58))+(((0.965925532213041)*x59))+(((0.965925532213041)*x57))+(((0.258820142606703)*x56)));\neetrans[1]=((0.145)+(((-1.0)*(0.0289777659663912)*x43))+(((0.965925532213041)*x70))+(((0.0608227335125751)*x32))+(((0.965925532213041)*x68))+(((-1.0)*(0.226992500070065)*x62))+(((0.00776460427820108)*x35))+(((-1.0)*(0.0608227335125751)*x16))+(((0.965925532213041)*x69))+(((0.258820142606703)*x63))+(((-1.0)*(0.226992500070065)*x39))+(((0.0917629255602389)*x2))+(((-1.0)*(0.0647050356516757)*x6))+(((0.0289777659663912)*x61))+(((0.258820142606703)*x64))+(((0.258820142606703)*x65))+(((0.00776460427820108)*x7))+(((-1.0)*(0.24148138305326)*x60))+(((0.258820142606703)*x66))+(((0.965925532213041)*x67)));\neerot[6]=((((0.965925532213041)*x38))+(((0.965925532213041)*x34))+(((-1.0)*(0.258820142606703)*x41))+(((-1.0)*(0.258820142606703)*x46)));\neerot[7]=((((-1.0)*(0.258820142606703)*x55))+(((0.965925532213041)*x53))+(((-1.0)*(0.258820142606703)*x51))+(((0.965925532213041)*x48)));\neerot[8]=((((-1.0)*(0.258820142606703)*x59))+(((0.965925532213041)*x56))+(((-1.0)*(0.258820142606703)*x57))+(((0.965925532213041)*x58)));\neetrans[2]=((0.370296)+(((0.0608227335125751)*x62))+(((-1.0)*(0.00776460427820108)*x61))+(((-1.0)*(0.258820142606703)*x68))+(((0.0289777659663912)*x35))+(((-1.0)*(0.258820142606703)*x70))+(((0.965925532213041)*x66))+(((-1.0)*(0.226992500070065)*x16))+(((-1.0)*(0.258820142606703)*x69))+(((-1.0)*(0.0245879135476367)*x2))+(((0.0647050356516757)*x60))+(((-1.0)*(0.24148138305326)*x6))+(((0.226992500070065)*x32))+(((0.00776460427820108)*x43))+(((0.0289777659663912)*x7))+(((0.0608227335125751)*x39))+(((0.965925532213041)*x63))+(((0.965925532213041)*x65))+(((0.965925532213041)*x64))+(((-1.0)*(0.258820142606703)*x67)));\n}\n\nIKFAST_API int GetNumFreeParameters() { return 0; }\nIKFAST_API int* GetFreeParameters() { return NULL; }\nIKFAST_API int GetNumJoints() { return 6; }\n\nIKFAST_API int GetIkRealSize() { return sizeof(IkReal); }\n\nIKFAST_API int GetIkType() { return 0x67000001; }\n\nclass IKSolver {\npublic:\nIkReal j11,cj11,sj11,htj11,j11mul,j12,cj12,sj12,htj12,j12mul,j13,cj13,sj13,htj13,j13mul,j14,cj14,sj14,htj14,j14mul,j15,cj15,sj15,htj15,j15mul,j16,cj16,sj16,htj16,j16mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;\nunsigned char _ij11[2], _nj11,_ij12[2], _nj12,_ij13[2], _nj13,_ij14[2], _nj14,_ij15[2], _nj15,_ij16[2], _nj16;\n\nIkReal j100, cj100, sj100;\nunsigned char _ij100[2], _nj100;\nbool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nj11=numeric_limits<IkReal>::quiet_NaN(); _ij11[0] = -1; _ij11[1] = -1; _nj11 = -1; j12=numeric_limits<IkReal>::quiet_NaN(); _ij12[0] = -1; _ij12[1] = -1; _nj12 = -1; j13=numeric_limits<IkReal>::quiet_NaN(); _ij13[0] = -1; _ij13[1] = -1; _nj13 = -1; j14=numeric_limits<IkReal>::quiet_NaN(); _ij14[0] = -1; _ij14[1] = -1; _nj14 = -1; j15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1; j16=numeric_limits<IkReal>::quiet_NaN(); _ij16[0] = -1; _ij16[1] = -1; _nj16 = -1; \nfor(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n    solutions.Clear();\nr00 = eerot[0*3+0];\nr01 = eerot[0*3+1];\nr02 = eerot[0*3+2];\nr10 = eerot[1*3+0];\nr11 = eerot[1*3+1];\nr12 = eerot[1*3+2];\nr20 = eerot[2*3+0];\nr21 = eerot[2*3+1];\nr22 = eerot[2*3+2];\npx = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\nnew_r00=((-1.0)*(((1.0)*r02)));\nnew_r01=r01;\nnew_r02=r00;\nnew_px=(px+(((0.04)*r00)));\nnew_r10=((((-1.0)*(0.965925532213041)*r12))+(((0.258820142606703)*r22)));\nnew_r11=((((-1.0)*(0.258820142606703)*r21))+(((0.965925532213041)*r11)));\nnew_r12=((((0.965925532213041)*r10))+(((-1.0)*(0.258820142606703)*r20)));\nnew_py=((-0.0442191386441994)+(((-1.0)*(0.258820142606703)*pz))+(((0.0386370212885216)*r10))+(((0.965925532213041)*py))+(((-1.0)*(0.0103528057042681)*r20)));\nnew_r20=((((-1.0)*(0.965925532213041)*r22))+(((-1.0)*(0.258820142606703)*r12)));\nnew_r21=((((0.965925532213041)*r21))+(((0.258820142606703)*r11)));\nnew_r22=((((0.258820142606703)*r10))+(((0.965925532213041)*r20)));\nnew_pz=((-0.395207281554332)+(((0.0103528057042681)*r10))+(((0.965925532213041)*pz))+(((0.0386370212885216)*r20))+(((0.258820142606703)*py)));\nr00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;\nIkReal x71=((1.0)*py);\nIkReal x72=((1.0)*pz);\nIkReal x73=((1.0)*px);\npp=((pz*pz)+(py*py)+(px*px));\nnpx=(((pz*r20))+((py*r10))+((px*r00)));\nnpy=(((pz*r21))+((py*r11))+((px*r01)));\nnpz=(((px*r02))+((pz*r22))+((py*r12)));\nrxp0_0=((((-1.0)*r20*x71))+((pz*r10)));\nrxp0_1=(((px*r20))+(((-1.0)*r00*x72)));\nrxp0_2=(((py*r00))+(((-1.0)*r10*x73)));\nrxp1_0=((((-1.0)*r21*x71))+((pz*r11)));\nrxp1_1=(((px*r21))+(((-1.0)*r01*x72)));\nrxp1_2=(((py*r01))+(((-1.0)*r11*x73)));\nrxp2_0=((((-1.0)*r22*x71))+((pz*r12)));\nrxp2_1=((((-1.0)*r02*x72))+((px*r22)));\nrxp2_2=((((-1.0)*r12*x73))+((py*r02)));\nIkReal op[72], zeror[48];\nint numroots;;\nIkReal x74=(cj14*r21);\nIkReal x75=(r22*sj14);\nIkReal x76=((2.0)*r20);\nIkReal x77=(cj14*x76);\nIkReal x78=((-1.0)*x74);\nIkReal x79=((0.57)*r20);\nIkReal x80=((6.0)*rxp0_0);\nIkReal x81=(x80+x79);\nIkReal x82=((65.0)*npx);\nIkReal x83=((100.0)*pp);\nIkReal x84=((6.0)*rxp0_1);\nIkReal x85=(x83+x84);\nIkReal x86=((1.14)*r21);\nIkReal x87=((12.0)*rxp1_0);\nIkReal x88=((12.0)*rxp1_1);\nIkReal x89=((((-1.0)*x80))+(((-1.0)*x79)));\nIkReal x90=(x83+(((-1.0)*x84)));\nIkReal x91=(r21*sj14);\nIkReal x92=(cj14*r22);\nIkReal x93=((-1.0)*x92);\nIkReal x94=((2.0)*r01);\nIkReal x95=(sj14*x76);\nIkReal x96=((2.0)*r11);\nIkReal x97=((-1.0)*(((1.0)*r00)));\nIkReal x98=((-1.0)*x91);\nIkReal x99=((-1.0)*(((1.0)*r10)));\nIkReal x100=((0.095)*r00);\nIkReal x101=(rxp0_2+(((-1.0)*x100)));\nIkReal x102=((0.095)*r10);\nIkReal x103=((-1.0)*x102);\nIkReal x104=((0.19)*r01);\nIkReal x105=((2.0)*rxp1_2);\nIkReal x106=((0.19)*r11);\nIkReal x107=(x100+(((-1.0)*(1.0)*rxp0_2)));\nIkReal x108=((1.08)*r01);\nIkReal x109=((((1.14)*r22))+(((12.0)*rxp2_0)));\nIkReal x110=((1.08)*r11);\nIkReal x111=((((12.0)*rxp2_1))+(((-1.0)*(94.0)*npz)));\nIkReal x112=((2.0)*r02);\nIkReal x113=((2.0)*r12);\nIkReal x114=((0.18)*r21);\nIkReal x115=((((2.0)*rxp2_2))+(((-1.0)*(0.19)*r02)));\nIkReal x116=((-1.0)*(((0.19)*r12)));\nIkReal x117=((-1.0)*x75);\nIkReal x118=((29.0)*npx);\nop[0]=(x75+x74);\nop[1]=0;\nop[2]=x77;\nop[3]=0;\nop[4]=(x75+x78);\nop[5]=0;\nop[6]=x81;\nop[7]=((3.5)+(((-1.0)*x82))+x85);\nop[8]=((((-1.0)*x86))+(((-1.0)*x87)));\nop[9]=((((130.0)*npy))+(((-1.0)*x88)));\nop[10]=x89;\nop[11]=((3.5)+x90+x82);\nop[12]=(x91+x93+r00);\nop[13]=r10;\nop[14]=((((-1.0)*x94))+x95);\nop[15]=((-1.0)*x96);\nop[16]=(x98+x93+x97);\nop[17]=x99;\nop[18]=x101;\nop[19]=x103;\nop[20]=(x104+(((-1.0)*x105)));\nop[21]=x106;\nop[22]=x107;\nop[23]=x102;\nop[24]=((-1.0)*x95);\nop[25]=0;\nop[26]=((4.0)*x91);\nop[27]=0;\nop[28]=x95;\nop[29]=0;\nop[30]=(x109+(((-1.0)*x108)));\nop[31]=((((-1.0)*x110))+x111);\nop[32]=((-1.0)*(((2.16)*r00)));\nop[33]=((-1.0)*(((2.16)*r10)));\nop[34]=(x109+x108);\nop[35]=(x111+x110);\nop[36]=(x77+x112);\nop[37]=x113;\nop[38]=((-4.0)*x74);\nop[39]=0;\nop[40]=((((-1.0)*x77))+x112);\nop[41]=x113;\nop[42]=((((-1.0)*x114))+x115);\nop[43]=x116;\nop[44]=((-1.0)*(((0.36)*r20)));\nop[45]=0;\nop[46]=(x115+x114);\nop[47]=x116;\nop[48]=(x74+x117);\nop[49]=0;\nop[50]=x77;\nop[51]=0;\nop[52]=(x78+x117);\nop[53]=0;\nop[54]=x89;\nop[55]=((-4.96)+x90+x118);\nop[56]=(x86+x87);\nop[57]=(x88+(((-1.0)*(58.0)*npy)));\nop[58]=x81;\nop[59]=((-4.96)+(((-1.0)*x118))+x85);\nop[60]=(x91+x92+x97);\nop[61]=x99;\nop[62]=(x95+x94);\nop[63]=x96;\nop[64]=(x98+x92+r00);\nop[65]=r10;\nop[66]=x107;\nop[67]=x102;\nop[68]=(x105+(((-1.0)*x104)));\nop[69]=((-1.0)*x106);\nop[70]=x101;\nop[71]=x103;\nsolvedialyticpoly8qep(op,zeror,numroots);\nIkReal j15array[16], cj15array[16], sj15array[16], j16array[16], cj16array[16], sj16array[16], j11array[16], cj11array[16], sj11array[16];\nint numsolutions = 0;\nfor(int ij15 = 0; ij15 < numroots; ij15 += 3)\n{\nIkReal htj15 = zeror[ij15+0], htj16 = zeror[ij15+1], htj11 = zeror[ij15+2];\nif(isnan(htj15)||isnan(htj16)||isnan(htj11)){\ncontinue;\n}\nj15array[numsolutions]=((2.0)*(atan(htj15)));\nj16array[numsolutions]=((2.0)*(atan(htj16)));\nj11array[numsolutions]=((2.0)*(atan(htj11)));\nif(isinf(htj15)){\ncj15array[numsolutions] = IKcos(j15array[numsolutions]);\nsj15array[numsolutions] = IKsin(j15array[numsolutions]);\n}\nelse{\nIkReal x119=htj15*htj15;\nCheckValue<IkReal> x120=IKPowWithIntegerCheck(((1.0)+x119),-1);\nif(!x120.valid){\ncontinue;\n}\ncj15array[numsolutions]=((x120.value)*(((1.0)+(((-1.0)*x119)))));\nCheckValue<IkReal> x121=IKPowWithIntegerCheck(((1.0)+(htj15*htj15)),-1);\nif(!x121.valid){\ncontinue;\n}\nsj15array[numsolutions]=((2.0)*htj15*(x121.value));\n}\nif(isinf(htj16)){\ncj16array[numsolutions] = IKcos(j16array[numsolutions]);\nsj16array[numsolutions] = IKsin(j16array[numsolutions]);\n}\nelse{\nIkReal x122=htj16*htj16;\nCheckValue<IkReal> x123=IKPowWithIntegerCheck(((1.0)+x122),-1);\nif(!x123.valid){\ncontinue;\n}\ncj16array[numsolutions]=((x123.value)*(((1.0)+(((-1.0)*x122)))));\nCheckValue<IkReal> x124=IKPowWithIntegerCheck(((1.0)+(htj16*htj16)),-1);\nif(!x124.valid){\ncontinue;\n}\nsj16array[numsolutions]=((2.0)*htj16*(x124.value));\n}\nif(isinf(htj11)){\ncj11array[numsolutions] = IKcos(j11array[numsolutions]);\nsj11array[numsolutions] = IKsin(j11array[numsolutions]);\n}\nelse{\nIkReal x125=htj11*htj11;\nCheckValue<IkReal> x126=IKPowWithIntegerCheck(((1.0)+x125),-1);\nif(!x126.valid){\ncontinue;\n}\ncj11array[numsolutions]=((x126.value)*(((1.0)+(((-1.0)*x125)))));\nCheckValue<IkReal> x127=IKPowWithIntegerCheck(((1.0)+(htj11*htj11)),-1);\nif(!x127.valid){\ncontinue;\n}\nsj11array[numsolutions]=((2.0)*htj11*(x127.value));\n}\nif( j15array[numsolutions] > IKPI )\n{\n    j15array[numsolutions]-=IK2PI;\n}\nelse if( j15array[numsolutions] < -IKPI )\n{\n    j15array[numsolutions]+=IK2PI;\n}\nif( j16array[numsolutions] > IKPI )\n{\n    j16array[numsolutions]-=IK2PI;\n}\nelse if( j16array[numsolutions] < -IKPI )\n{\n    j16array[numsolutions]+=IK2PI;\n}\nif( j11array[numsolutions] > IKPI )\n{\n    j11array[numsolutions]-=IK2PI;\n}\nelse if( j11array[numsolutions] < -IKPI )\n{\n    j11array[numsolutions]+=IK2PI;\n}\nnumsolutions++;\n}\nbool j15valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};\n_nj15 = 16;\n_nj16 = 1;\n_nj11 = 1;\nfor(int ij15 = 0; ij15 < numsolutions; ++ij15)\n    {\nif( !j15valid[ij15] )\n{\n    continue;\n}\n_ij15[0] = ij15; _ij15[1] = -1;\n_ij16[0] = 0; _ij16[1] = -1;\n_ij11[0] = 0; _ij11[1] = -1;\nfor(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)\n{\nif( !j15valid[iij15] ) { continue; }\nif( IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(cj16array[ij15]-cj16array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij15]-sj16array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(cj11array[ij15]-cj11array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj11array[ij15]-sj11array[iij15]) < IKFAST_SOLUTION_THRESH &&  1 )\n{\n    j15valid[iij15]=false; _ij15[1] = iij15; _ij16[1] = 0; _ij11[1] = 0;  break; \n}\n}\n    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];\n\n    j16 = j16array[ij15]; cj16 = cj16array[ij15]; sj16 = sj16array[ij15];\n\n    j11 = j11array[ij15]; cj11 = cj11array[ij15]; sj11 = sj11array[ij15];\n\ninnerfn(solutions);\n    }\n}\nreturn solutions.GetNumSolutions()>0;\n}\nstatic inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[3];\n    const int maxsteps = 110;\n    for(int i = 0; i < 3; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[3];\n    IkReal err[3];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 3; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 3; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 3; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 3; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[3] = {false};\n    for(int i = 0; i < 3; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 3; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {\n    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];\n    if( det < 0 ) {\n        numroots=0;\n    }\n    else if( det == 0 ) {\n        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];\n        numroots = 1;\n    }\n    else {\n        det = IKsqrt(det);\n        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);\n        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);\n        numroots = 2;\n    }\n}\nstatic inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[5];\n    const int maxsteps = 110;\n    for(int i = 0; i < 5; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[5];\n    IkReal err[5];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 5; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 5; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 5; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 5; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[5] = {false};\n    for(int i = 0; i < 5; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 5; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[4];\n    const int maxsteps = 110;\n    for(int i = 0; i < 4; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[4];\n    IkReal err[4];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 4; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 4; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 4; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 4; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[4] = {false};\n    for(int i = 0; i < 4; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 4; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\nstatic inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)\n{\n    using std::complex;\n    if( rawcoeffs[0] == 0 ) {\n        // solve with one reduced degree\n        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);\n        return;\n    }\n    IKFAST_ASSERT(rawcoeffs[0] != 0);\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());\n    complex<IkReal> coeffs[6];\n    const int maxsteps = 110;\n    for(int i = 0; i < 6; ++i) {\n        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);\n    }\n    complex<IkReal> roots[6];\n    IkReal err[6];\n    roots[0] = complex<IkReal>(1,0);\n    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works\n    err[0] = 1.0;\n    err[1] = 1.0;\n    for(int i = 2; i < 6; ++i) {\n        roots[i] = roots[i-1]*roots[1];\n        err[i] = 1.0;\n    }\n    for(int step = 0; step < maxsteps; ++step) {\n        bool changed = false;\n        for(int i = 0; i < 6; ++i) {\n            if ( err[i] >= tol ) {\n                changed = true;\n                // evaluate\n                complex<IkReal> x = roots[i] + coeffs[0];\n                for(int j = 1; j < 6; ++j) {\n                    x = roots[i] * x + coeffs[j];\n                }\n                for(int j = 0; j < 6; ++j) {\n                    if( i != j ) {\n                        if( roots[i] != roots[j] ) {\n                            x /= (roots[i] - roots[j]);\n                        }\n                    }\n                }\n                roots[i] -= x;\n                err[i] = abs(x);\n            }\n        }\n        if( !changed ) {\n            break;\n        }\n    }\n\n    numroots = 0;\n    bool visited[6] = {false};\n    for(int i = 0; i < 6; ++i) {\n        if( !visited[i] ) {\n            // might be a multiple root, in which case it will have more error than the other roots\n            // find any neighboring roots, and take the average\n            complex<IkReal> newroot=roots[i];\n            int n = 1;\n            for(int j = i+1; j < 6; ++j) {\n                // care about error in real much more than imaginary\n                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {\n                    newroot += roots[j];\n                    n += 1;\n                    visited[j] = true;\n                }\n            }\n            if( n > 1 ) {\n                newroot /= n;\n            }\n            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt\n            if( IKabs(imag(newroot)) < tolsqrt ) {\n                rawroots[numroots++] = real(newroot);\n            }\n        }\n    }\n}\ninline void innerfn(IkSolutionListBase<IkReal>& solutions) {\nfor(int fniter = 0; fniter < 1; ++fniter) {\n{\nIkReal j14eval[3];\nIkReal x128=((1.0)*cj15);\nIkReal x129=((((-1.0)*cj16*r00*x128))+((cj15*r01*sj16))+(((-1.0)*r02*sj15)));\nIkReal x130=(cj11*cj16);\nIkReal x131=(cj11*sj16);\nj14eval[0]=x129;\nj14eval[1]=IKsign(x129);\nj14eval[2]=((IKabs((((r21*x130))+((r20*x131)))))+(IKabs(((((-1.0)*r21*sj15*x131))+((r20*sj15*x130))+(((-1.0)*cj11*r22*x128))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nIkReal x132=(((cj15*cj16*r10))+((r12*sj15))+(((-1.0)*(1.0)*cj15*r11*sj16)));\nIkReal x133=(r21*sj11);\nIkReal x134=(r20*sj11);\nj14eval[0]=x132;\nj14eval[1]=IKsign(x132);\nj14eval[2]=((IKabs(((((-1.0)*cj16*sj15*x134))+((cj15*r22*sj11))+((sj15*sj16*x133)))))+(IKabs((((cj16*x133))+((sj16*x134))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[2];\nIkReal x135=((((-1.0)*(1.0)*r22*sj15))+((cj15*r21*sj16))+(((-1.0)*(1.0)*cj15*cj16*r20)));\nj14eval[0]=x135;\nj14eval[1]=IKsign(x135);\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  )\n{\n{\nIkReal evalcond[3];\nbool bgotonextstatement = true;\ndo\n{\nIkReal x136=(cj16*r10);\nIkReal x137=(r11*sj16);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j11))), 6.28318530717959)));\nevalcond[1]=(((r12*sj15))+(((-1.0)*cj15*x137))+((cj15*x136)));\nevalcond[2]=((0.095)+(((-1.0)*(1.0)*py))+(((-0.09)*x137))+(((0.09)*x136)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j14eval[3];\nsj11=0;\ncj11=1.0;\nj11=0;\nIkReal x138=((1.0)*cj15);\nIkReal x139=(((r22*sj15))+(((-1.0)*r21*sj16*x138))+((cj15*cj16*r20)));\nj14eval[0]=x139;\nj14eval[1]=((IKabs((((r00*sj16))+((cj16*r01)))))+(IKabs(((((-1.0)*(1.0)*r01*sj15*sj16))+(((-1.0)*r02*x138))+((cj16*r00*sj15))))));\nj14eval[2]=IKsign(x139);\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=0;\ncj11=1.0;\nj11=0;\nIkReal x140=((1.0)*sj15);\nIkReal x141=((1.0)*cj15);\nIkReal x142=((((-1.0)*cj16*r00*x141))+(((-1.0)*r02*x140))+((cj15*r01*sj16)));\nj14eval[0]=x142;\nj14eval[1]=IKsign(x142);\nj14eval[2]=((IKabs((((cj16*r21))+((r20*sj16)))))+(IKabs((((cj16*r20*sj15))+(((-1.0)*r21*sj16*x140))+(((-1.0)*r22*x141))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=0;\ncj11=1.0;\nj11=0;\nIkReal x143=r10*r10;\nIkReal x144=r11*r11;\nIkReal x145=cj15*cj15;\nIkReal x146=((2.0)*cj15*r12);\nIkReal x147=(cj16*r10*sj15);\nIkReal x148=(r11*sj15*sj16);\nIkReal x149=(x144*x145);\nIkReal x150=(r10*sj16);\nIkReal x151=cj16*cj16;\nIkReal x152=((((2.0)*cj16*r11*x145*x150))+(((-1.0)*x149))+((x145*(r12*r12)))+(((-1.0)*x143*x145*x151))+x143+x144+(((-1.0)*x146*x147))+((x146*x148))+((x149*x151)));\nj14eval[0]=x152;\nj14eval[1]=((IKabs((x150+((cj16*r11)))))+(IKabs((x148+(((-1.0)*x147))+((cj15*r12))))));\nj14eval[2]=IKsign(x152);\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j12, j13, j14]\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x153=(r11*sj15*sj16);\nIkReal x154=(cj16*r10*sj15);\nIkReal x155=(r10*sj16);\nIkReal x156=r10*r10;\nIkReal x157=r11*r11;\nIkReal x158=cj15*cj15;\nIkReal x159=((2.0)*cj15*r12);\nIkReal x160=(x157*x158);\nIkReal x161=cj16*cj16;\nCheckValue<IkReal> x162 = IKatan2WithCheck(IkReal(((((-1.0)*x154))+x153+((cj15*r12)))),IkReal((x155+((cj16*r11)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x162.valid){\ncontinue;\n}\nCheckValue<IkReal> x163=IKPowWithIntegerCheck(IKsign((x156+x157+(((-1.0)*x156*x158*x161))+((x158*(r12*r12)))+((x153*x159))+(((-1.0)*x154*x159))+(((-1.0)*x160))+((x160*x161))+(((2.0)*cj16*r11*x155*x158)))),-1);\nif(!x163.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x162.value)+(((1.5707963267949)*(x163.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x164=IKsin(j14);\nIkReal x165=(cj16*r11);\nIkReal x166=(r10*sj16);\nIkReal x167=IKcos(j14);\nIkReal x168=((1.0)*x167);\nIkReal x169=((1.0)*sj16*x167);\nIkReal x170=((1.0)*cj15*x164);\nIkReal x171=((1.0)*cj16*x167);\nIkReal x172=(cj16*sj15*x164);\nIkReal x173=((1.0)*sj15*sj16*x164);\nevalcond[0]=(((cj16*r10*sj15*x167))+(((-1.0)*cj15*r12*x168))+(((-1.0)*r11*sj15*x169))+((x164*x166))+((x164*x165)));\nevalcond[1]=((((-1.0)*r20*x169))+((r20*x172))+(((-1.0)*r21*x173))+(((-1.0)*r21*x171))+(((-1.0)*r22*x170)));\nevalcond[2]=((((-1.0)*r02*x170))+(((-1.0)*r00*x169))+(((-1.0)*r01*x173))+(((-1.0)*r01*x171))+((r00*x172)));\nevalcond[3]=((1.0)+(((-1.0)*r11*x173))+((r10*x172))+(((-1.0)*r12*x170))+(((-1.0)*x166*x168))+(((-1.0)*x165*x168)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=0;\ncj11=1.0;\nj11=0;\nIkReal x174=(cj16*r20);\nIkReal x175=(r02*sj15);\nIkReal x176=(r21*sj16);\nIkReal x177=(r22*sj15);\nIkReal x178=(cj15*cj16*r00);\nIkReal x179=(cj15*cj16*r20);\nIkReal x180=(cj15*r01*sj16);\nIkReal x181=(cj15*r21*sj16);\nIkReal x182=((((-1.0)*(12.0)*pz))+(((2.82)*x177))+(((-0.36)*x178))+(((1.08)*x174))+(((-1.08)*x176))+(((-0.36)*x175))+(((2.82)*x179))+(((-2.82)*x181))+(((0.36)*x180)));\nj12eval[0]=((IKabs(((1.0)+x182)))+(IKabs(((1.0)+(((0.12)*x180))+(((-1.0)*(4.0)*pz))+(((0.36)*x174))+(((-0.12)*x175))+(((-0.36)*x176))+(((-0.94)*x181))+(((0.94)*x179))+(((-0.12)*x178))+(((0.94)*x177)))))+(IKabs(((-1.0)+x182))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x183=(cj16*r20);\nIkReal x184=(r02*sj15);\nIkReal x185=(r21*sj16);\nIkReal x186=(r22*sj15);\nIkReal x187=(cj15*cj16*r00);\nIkReal x188=(cj15*cj16*r20);\nIkReal x189=(cj15*r01*sj16);\nIkReal x190=(cj15*r21*sj16);\nIkReal x191=((((0.94)*x188))+(((-0.94)*x190))+(((-1.0)*(4.0)*pz))+(((-0.12)*x184))+(((0.12)*x189))+(((-0.36)*x185))+(((0.94)*x186))+(((-0.12)*x187))+(((0.36)*x183)));\nIkReal x192=((((-1.0)*(12.0)*pz))+(((-1.08)*x185))+(((2.82)*x188))+(((-0.36)*x187))+(((0.36)*x189))+(((-2.82)*x190))+(((-0.36)*x184))+(((2.82)*x186))+(((1.08)*x183)));\nop[0]=((1.0)+x191);\nop[1]=0;\nop[2]=((1.0)+x192);\nop[3]=0;\nop[4]=((-1.0)+x192);\nop[5]=0;\nop[6]=((-1.0)+x191);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x193=(cj16*r00);\nIkReal x194=(cj16*r20);\nIkReal x195=(r01*sj16);\nIkReal x196=(r21*sj16);\nIkReal x197=(r22*sj15);\nIkReal x198=(cj15*cj16*r20);\nIkReal x199=(cj15*r21*sj16);\nIkReal x200=((((0.0846)*x194))+(((-0.0108)*x195))+(((0.2245)*x198))+(((-1.0)*(0.94)*pz))+(((0.0108)*x193))+(((-0.2245)*x199))+(((0.2245)*x197))+(((-0.0846)*x196))+(((-1.0)*(0.12)*px)));\nIkReal x201=((((0.0324)*x193))+(((0.6735)*x198))+(((-0.2538)*x196))+(((-1.0)*(0.36)*px))+(((0.2538)*x194))+(((-0.0324)*x195))+(((-0.6735)*x199))+(((-1.0)*(2.82)*pz))+(((0.6735)*x197)));\nj12evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj12*htj12*htj12)))+(((-1.0)*(0.06)*htj12))+(((htj12*htj12)*(((-0.235)+x201))))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((0.235)+x200))))+x200+(((htj12*htj12*htj12*htj12)*(((0.235)+x201))))+(((-1.0)*(0.06)*(htj12*htj12*htj12*htj12*htj12))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x202=(r22*sj15);\nIkReal x203=((1.0)*cj12);\nIkReal x204=(r02*sj15);\nIkReal x205=(cj12*cj15*sj16);\nIkReal x206=(cj15*sj12);\nIkReal x207=(cj16*r20);\nIkReal x208=(cj16*r00);\nIkReal x209=((1.0)*cj12*cj15);\nIkReal x210=((1.0)*cj15*sj12);\nif( IKabs(((((-1.0)*x203*x204))+((x206*x207))+((sj12*x202))+((r01*x205))+(((-1.0)*r21*sj16*x210))+(((-1.0)*x208*x209)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x202*x203))+(((-1.0)*x207*x209))+((r21*x205))+((r01*sj16*x206))+(((-1.0)*x208*x210))+(((-1.0)*sj12*x204)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x203*x204))+((x206*x207))+((sj12*x202))+((r01*x205))+(((-1.0)*r21*sj16*x210))+(((-1.0)*x208*x209))))+IKsqr(((((-1.0)*x202*x203))+(((-1.0)*x207*x209))+((r21*x205))+((r01*sj16*x206))+(((-1.0)*x208*x210))+(((-1.0)*sj12*x204))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*x203*x204))+((x206*x207))+((sj12*x202))+((r01*x205))+(((-1.0)*r21*sj16*x210))+(((-1.0)*x208*x209))), ((((-1.0)*x202*x203))+(((-1.0)*x207*x209))+((r21*x205))+((r01*sj16*x206))+(((-1.0)*x208*x210))+(((-1.0)*sj12*x204))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x211=IKsin(j13);\nIkReal x212=(cj12*x211);\nIkReal x213=IKcos(j13);\nIkReal x214=(sj12*x213);\nIkReal x215=(cj15*cj16);\nIkReal x216=((1.0)*cj15*sj16);\nIkReal x217=(cj12*x213);\nIkReal x218=(sj12*x211);\nIkReal x219=((((-1.0)*x218))+x217);\nIkReal x220=(cj16*sj14);\nIkReal x221=(sj14*sj16);\nIkReal x222=((1.0)*cj14*cj15);\nIkReal x223=(cj14*cj16*sj15);\nIkReal x224=((1.0)*cj14*sj15*sj16);\nIkReal x225=((0.09)*cj16);\nIkReal x226=((0.09)*sj16);\nevalcond[0]=((((-1.0)*r01*x216))+((r02*sj15))+x214+x212+((r00*x215)));\nevalcond[1]=(((r20*x215))+((r22*sj15))+x219+(((-1.0)*r21*x216)));\nevalcond[2]=(((r00*x223))+(((-1.0)*r02*x222))+(((-1.0)*r01*x224))+((r00*x221))+x219+((r01*x220)));\nevalcond[3]=((((-1.0)*x212))+(((-1.0)*r21*x224))+(((-1.0)*r22*x222))+((r20*x223))+((r20*x221))+(((-1.0)*x214))+((r21*x220)));\nevalcond[4]=((((-1.0)*r21*x226))+(((-1.0)*(1.0)*pz))+(((0.03)*x212))+(((-0.235)*x217))+((r20*x225))+(((0.03)*x214))+(((-1.0)*(0.25)*cj12))+(((0.235)*x218)));\nevalcond[5]=((((-1.0)*(1.0)*px))+(((-1.0)*(0.25)*sj12))+(((-0.235)*x212))+(((-0.235)*x214))+(((-0.03)*x217))+(((-1.0)*r01*x226))+(((0.03)*x218))+((r00*x225)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x227=((1.0)*sj15);\nIkReal x228=((1.0)*cj15);\nCheckValue<IkReal> x229 = IKatan2WithCheck(IkReal((((cj16*r21))+((r20*sj16)))),IkReal(((((-1.0)*r21*sj16*x227))+(((-1.0)*r22*x228))+((cj16*r20*sj15)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x229.valid){\ncontinue;\n}\nCheckValue<IkReal> x230=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj16*r00*x228))+(((-1.0)*r02*x227))+((cj15*r01*sj16)))),-1);\nif(!x230.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x229.value)+(((1.5707963267949)*(x230.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x231=IKsin(j14);\nIkReal x232=(cj16*r11);\nIkReal x233=(r10*sj16);\nIkReal x234=IKcos(j14);\nIkReal x235=((1.0)*x234);\nIkReal x236=((1.0)*sj16*x234);\nIkReal x237=((1.0)*cj15*x231);\nIkReal x238=((1.0)*cj16*x234);\nIkReal x239=(cj16*sj15*x231);\nIkReal x240=((1.0)*sj15*sj16*x231);\nevalcond[0]=(((x231*x233))+((x231*x232))+((cj16*r10*sj15*x234))+(((-1.0)*r11*sj15*x236))+(((-1.0)*cj15*r12*x235)));\nevalcond[1]=((((-1.0)*r22*x237))+(((-1.0)*r21*x240))+(((-1.0)*r20*x236))+((r20*x239))+(((-1.0)*r21*x238)));\nevalcond[2]=((((-1.0)*r02*x237))+(((-1.0)*r01*x238))+((r00*x239))+(((-1.0)*r01*x240))+(((-1.0)*r00*x236)));\nevalcond[3]=((1.0)+(((-1.0)*r12*x237))+(((-1.0)*x233*x235))+(((-1.0)*x232*x235))+(((-1.0)*r11*x240))+((r10*x239)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=0;\ncj11=1.0;\nj11=0;\nIkReal x241=(cj16*r20);\nIkReal x242=(r02*sj15);\nIkReal x243=(r21*sj16);\nIkReal x244=(r22*sj15);\nIkReal x245=(cj15*cj16*r00);\nIkReal x246=(cj15*cj16*r20);\nIkReal x247=(cj15*r01*sj16);\nIkReal x248=(cj15*r21*sj16);\nIkReal x249=((((-0.36)*x242))+(((-2.82)*x248))+(((0.36)*x247))+(((-1.0)*(12.0)*pz))+(((1.08)*x241))+(((2.82)*x244))+(((-1.08)*x243))+(((2.82)*x246))+(((-0.36)*x245)));\nj12eval[0]=((IKabs(((1.0)+(((-0.94)*x248))+(((-1.0)*(4.0)*pz))+(((0.12)*x247))+(((0.36)*x241))+(((0.94)*x244))+(((0.94)*x246))+(((-0.12)*x242))+(((-0.12)*x245))+(((-0.36)*x243)))))+(IKabs(((1.0)+x249)))+(IKabs(((-1.0)+x249))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x250=(cj16*r20);\nIkReal x251=(r02*sj15);\nIkReal x252=(r21*sj16);\nIkReal x253=(r22*sj15);\nIkReal x254=(cj15*cj16*r00);\nIkReal x255=(cj15*cj16*r20);\nIkReal x256=(cj15*r01*sj16);\nIkReal x257=(cj15*r21*sj16);\nIkReal x258=((((-0.36)*x252))+(((-1.0)*(4.0)*pz))+(((0.12)*x256))+(((0.36)*x250))+(((0.94)*x253))+(((-0.12)*x254))+(((0.94)*x255))+(((-0.12)*x251))+(((-0.94)*x257)));\nIkReal x259=((((2.82)*x255))+(((0.36)*x256))+(((-1.0)*(12.0)*pz))+(((-2.82)*x257))+(((-1.08)*x252))+(((-0.36)*x254))+(((-0.36)*x251))+(((1.08)*x250))+(((2.82)*x253)));\nop[0]=((1.0)+x258);\nop[1]=0;\nop[2]=((1.0)+x259);\nop[3]=0;\nop[4]=((-1.0)+x259);\nop[5]=0;\nop[6]=((-1.0)+x258);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x260=(cj16*r00);\nIkReal x261=(cj16*r20);\nIkReal x262=(r01*sj16);\nIkReal x263=(r21*sj16);\nIkReal x264=(r22*sj15);\nIkReal x265=(cj15*cj16*r20);\nIkReal x266=(cj15*r21*sj16);\nIkReal x267=((((0.0108)*x260))+(((-0.0846)*x263))+(((0.2245)*x264))+(((-1.0)*(0.94)*pz))+(((0.0846)*x261))+(((0.2245)*x265))+(((-0.0108)*x262))+(((-0.2245)*x266))+(((-1.0)*(0.12)*px)));\nIkReal x268=((((0.0324)*x260))+(((-1.0)*(0.36)*px))+(((0.6735)*x264))+(((-0.6735)*x266))+(((-0.2538)*x263))+(((-0.0324)*x262))+(((0.6735)*x265))+(((-1.0)*(2.82)*pz))+(((0.2538)*x261)));\nj12evalpoly[0]=((-0.235)+(((htj12*htj12)*(((-0.235)+x268))))+x267+(((-1.0)*(0.12)*(htj12*htj12*htj12)))+(((-1.0)*(0.06)*htj12))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((0.235)+x267))))+(((htj12*htj12*htj12*htj12)*(((0.235)+x268))))+(((-1.0)*(0.06)*(htj12*htj12*htj12*htj12*htj12))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x269=(r22*sj15);\nIkReal x270=((1.0)*cj12);\nIkReal x271=(r02*sj15);\nIkReal x272=(cj12*cj15*sj16);\nIkReal x273=(cj15*sj12);\nIkReal x274=(cj16*r20);\nIkReal x275=(cj16*r00);\nIkReal x276=((1.0)*cj12*cj15);\nIkReal x277=((1.0)*cj15*sj12);\nif( IKabs(((((-1.0)*x275*x276))+((x273*x274))+((sj12*x269))+(((-1.0)*r21*sj16*x277))+((r01*x272))+(((-1.0)*x270*x271)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj12*x271))+(((-1.0)*x274*x276))+((r21*x272))+((r01*sj16*x273))+(((-1.0)*x269*x270))+(((-1.0)*x275*x277)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x275*x276))+((x273*x274))+((sj12*x269))+(((-1.0)*r21*sj16*x277))+((r01*x272))+(((-1.0)*x270*x271))))+IKsqr(((((-1.0)*sj12*x271))+(((-1.0)*x274*x276))+((r21*x272))+((r01*sj16*x273))+(((-1.0)*x269*x270))+(((-1.0)*x275*x277))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*x275*x276))+((x273*x274))+((sj12*x269))+(((-1.0)*r21*sj16*x277))+((r01*x272))+(((-1.0)*x270*x271))), ((((-1.0)*sj12*x271))+(((-1.0)*x274*x276))+((r21*x272))+((r01*sj16*x273))+(((-1.0)*x269*x270))+(((-1.0)*x275*x277))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x278=IKsin(j13);\nIkReal x279=(cj12*x278);\nIkReal x280=IKcos(j13);\nIkReal x281=(sj12*x280);\nIkReal x282=(cj15*cj16);\nIkReal x283=((1.0)*cj15*sj16);\nIkReal x284=(cj12*x280);\nIkReal x285=(sj12*x278);\nIkReal x286=(x284+(((-1.0)*x285)));\nIkReal x287=(cj16*sj14);\nIkReal x288=(sj14*sj16);\nIkReal x289=((1.0)*cj14*cj15);\nIkReal x290=(cj14*cj16*sj15);\nIkReal x291=((1.0)*cj14*sj15*sj16);\nIkReal x292=((0.09)*cj16);\nIkReal x293=((0.09)*sj16);\nevalcond[0]=((((-1.0)*r01*x283))+((r00*x282))+((r02*sj15))+x279+x281);\nevalcond[1]=((((-1.0)*r21*x283))+((r22*sj15))+((r20*x282))+x286);\nevalcond[2]=(((r00*x288))+((r00*x290))+(((-1.0)*r02*x289))+(((-1.0)*r01*x291))+((r01*x287))+x286);\nevalcond[3]=(((r21*x287))+(((-1.0)*r21*x291))+(((-1.0)*r22*x289))+(((-1.0)*x281))+((r20*x288))+((r20*x290))+(((-1.0)*x279)));\nevalcond[4]=(((r20*x292))+(((0.235)*x285))+(((-1.0)*(1.0)*pz))+(((-0.235)*x284))+(((-1.0)*(0.25)*cj12))+(((0.03)*x281))+(((0.03)*x279))+(((-1.0)*r21*x293)));\nevalcond[5]=((((-1.0)*r01*x293))+(((-1.0)*(1.0)*px))+(((0.03)*x285))+((r00*x292))+(((-0.235)*x281))+(((-1.0)*(0.25)*sj12))+(((-0.235)*x279))+(((-0.03)*x284)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x294=((1.0)*cj15);\nCheckValue<IkReal> x295 = IKatan2WithCheck(IkReal((((r00*sj16))+((cj16*r01)))),IkReal(((((-1.0)*r02*x294))+(((-1.0)*(1.0)*r01*sj15*sj16))+((cj16*r00*sj15)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x295.valid){\ncontinue;\n}\nCheckValue<IkReal> x296=IKPowWithIntegerCheck(IKsign((((r22*sj15))+(((-1.0)*r21*sj16*x294))+((cj15*cj16*r20)))),-1);\nif(!x296.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x295.value)+(((1.5707963267949)*(x296.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x297=IKsin(j14);\nIkReal x298=(cj16*r11);\nIkReal x299=(r10*sj16);\nIkReal x300=IKcos(j14);\nIkReal x301=((1.0)*x300);\nIkReal x302=((1.0)*sj16*x300);\nIkReal x303=((1.0)*cj15*x297);\nIkReal x304=((1.0)*cj16*x300);\nIkReal x305=(cj16*sj15*x297);\nIkReal x306=((1.0)*sj15*sj16*x297);\nevalcond[0]=(((x297*x298))+((cj16*r10*sj15*x300))+(((-1.0)*cj15*r12*x301))+((x297*x299))+(((-1.0)*r11*sj15*x302)));\nevalcond[1]=(((r20*x305))+(((-1.0)*r21*x304))+(((-1.0)*r22*x303))+(((-1.0)*r21*x306))+(((-1.0)*r20*x302)));\nevalcond[2]=((((-1.0)*r02*x303))+(((-1.0)*r00*x302))+(((-1.0)*r01*x304))+((r00*x305))+(((-1.0)*r01*x306)));\nevalcond[3]=((1.0)+(((-1.0)*r12*x303))+((r10*x305))+(((-1.0)*x298*x301))+(((-1.0)*x299*x301))+(((-1.0)*r11*x306)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=0;\ncj11=1.0;\nj11=0;\nIkReal x307=(cj16*r20);\nIkReal x308=(r02*sj15);\nIkReal x309=(r21*sj16);\nIkReal x310=(r22*sj15);\nIkReal x311=(cj15*cj16*r00);\nIkReal x312=(cj15*cj16*r20);\nIkReal x313=(cj15*r01*sj16);\nIkReal x314=(cj15*r21*sj16);\nIkReal x315=((((1.08)*x307))+(((0.36)*x313))+(((-1.0)*(12.0)*pz))+(((-0.36)*x308))+(((-0.36)*x311))+(((-1.08)*x309))+(((-2.82)*x314))+(((2.82)*x310))+(((2.82)*x312)));\nj12eval[0]=((IKabs(((1.0)+x315)))+(IKabs(((1.0)+(((-1.0)*(4.0)*pz))+(((0.94)*x310))+(((0.94)*x312))+(((-0.36)*x309))+(((0.36)*x307))+(((0.12)*x313))+(((-0.12)*x311))+(((-0.94)*x314))+(((-0.12)*x308)))))+(IKabs(((-1.0)+x315))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x316=(cj16*r20);\nIkReal x317=(r02*sj15);\nIkReal x318=(r21*sj16);\nIkReal x319=(r22*sj15);\nIkReal x320=(cj15*cj16*r00);\nIkReal x321=(cj15*cj16*r20);\nIkReal x322=(cj15*r01*sj16);\nIkReal x323=(cj15*r21*sj16);\nIkReal x324=((((-0.12)*x320))+(((-1.0)*(4.0)*pz))+(((-0.94)*x323))+(((0.12)*x322))+(((0.36)*x316))+(((-0.36)*x318))+(((0.94)*x319))+(((-0.12)*x317))+(((0.94)*x321)));\nIkReal x325=((((-1.0)*(12.0)*pz))+(((0.36)*x322))+(((-2.82)*x323))+(((-0.36)*x317))+(((1.08)*x316))+(((2.82)*x319))+(((2.82)*x321))+(((-0.36)*x320))+(((-1.08)*x318)));\nop[0]=((1.0)+x324);\nop[1]=0;\nop[2]=((1.0)+x325);\nop[3]=0;\nop[4]=((-1.0)+x325);\nop[5]=0;\nop[6]=((-1.0)+x324);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x326=(cj16*r00);\nIkReal x327=(cj16*r20);\nIkReal x328=(r01*sj16);\nIkReal x329=(r21*sj16);\nIkReal x330=(r22*sj15);\nIkReal x331=(cj15*cj16*r20);\nIkReal x332=(cj15*r21*sj16);\nIkReal x333=((((0.0846)*x327))+(((-0.0108)*x328))+(((0.2245)*x331))+(((0.2245)*x330))+(((0.0108)*x326))+(((-0.2245)*x332))+(((-0.0846)*x329))+(((-1.0)*(0.94)*pz))+(((-1.0)*(0.12)*px)));\nIkReal x334=((((-1.0)*(0.36)*px))+(((0.6735)*x331))+(((0.6735)*x330))+(((0.2538)*x327))+(((-0.0324)*x328))+(((-0.6735)*x332))+(((-0.2538)*x329))+(((-1.0)*(2.82)*pz))+(((0.0324)*x326)));\nj12evalpoly[0]=((-0.235)+(((htj12*htj12*htj12*htj12)*(((0.235)+x334))))+(((htj12*htj12)*(((-0.235)+x334))))+(((-1.0)*(0.12)*(htj12*htj12*htj12)))+(((-1.0)*(0.06)*htj12))+x333+(((-1.0)*(0.06)*(htj12*htj12*htj12*htj12*htj12)))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((0.235)+x333)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x335=(r22*sj15);\nIkReal x336=((1.0)*cj12);\nIkReal x337=(r02*sj15);\nIkReal x338=(cj12*cj15*sj16);\nIkReal x339=(cj15*sj12);\nIkReal x340=(cj16*r20);\nIkReal x341=(cj16*r00);\nIkReal x342=((1.0)*cj12*cj15);\nIkReal x343=((1.0)*cj15*sj12);\nif( IKabs(((((-1.0)*r21*sj16*x343))+(((-1.0)*x341*x342))+((x339*x340))+((sj12*x335))+((r01*x338))+(((-1.0)*x336*x337)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x341*x343))+((r21*x338))+((r01*sj16*x339))+(((-1.0)*x340*x342))+(((-1.0)*x335*x336))+(((-1.0)*sj12*x337)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r21*sj16*x343))+(((-1.0)*x341*x342))+((x339*x340))+((sj12*x335))+((r01*x338))+(((-1.0)*x336*x337))))+IKsqr(((((-1.0)*x341*x343))+((r21*x338))+((r01*sj16*x339))+(((-1.0)*x340*x342))+(((-1.0)*x335*x336))+(((-1.0)*sj12*x337))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*r21*sj16*x343))+(((-1.0)*x341*x342))+((x339*x340))+((sj12*x335))+((r01*x338))+(((-1.0)*x336*x337))), ((((-1.0)*x341*x343))+((r21*x338))+((r01*sj16*x339))+(((-1.0)*x340*x342))+(((-1.0)*x335*x336))+(((-1.0)*sj12*x337))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x344=IKsin(j13);\nIkReal x345=(cj12*x344);\nIkReal x346=IKcos(j13);\nIkReal x347=(sj12*x346);\nIkReal x348=(cj15*cj16);\nIkReal x349=((1.0)*cj15*sj16);\nIkReal x350=(cj12*x346);\nIkReal x351=(sj12*x344);\nIkReal x352=(x350+(((-1.0)*x351)));\nIkReal x353=(cj16*sj14);\nIkReal x354=(sj14*sj16);\nIkReal x355=((1.0)*cj14*cj15);\nIkReal x356=(cj14*cj16*sj15);\nIkReal x357=((1.0)*cj14*sj15*sj16);\nIkReal x358=((0.09)*cj16);\nIkReal x359=((0.09)*sj16);\nevalcond[0]=(((r02*sj15))+((r00*x348))+(((-1.0)*r01*x349))+x345+x347);\nevalcond[1]=(((r22*sj15))+x352+((r20*x348))+(((-1.0)*r21*x349)));\nevalcond[2]=(((r01*x353))+((r00*x356))+(((-1.0)*r02*x355))+(((-1.0)*r01*x357))+x352+((r00*x354)));\nevalcond[3]=((((-1.0)*x347))+((r20*x354))+(((-1.0)*r22*x355))+(((-1.0)*x345))+(((-1.0)*r21*x357))+((r20*x356))+((r21*x353)));\nevalcond[4]=((((-0.235)*x350))+(((-1.0)*(1.0)*pz))+(((0.235)*x351))+(((0.03)*x347))+(((-1.0)*r21*x359))+(((0.03)*x345))+(((-1.0)*(0.25)*cj12))+((r20*x358)));\nevalcond[5]=((((-1.0)*r01*x359))+(((-1.0)*(1.0)*px))+(((-0.235)*x345))+(((-0.235)*x347))+(((-1.0)*(0.25)*sj12))+(((0.03)*x351))+(((-0.03)*x350))+((r00*x358)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x360=(cj16*r10);\nIkReal x361=(r11*sj16);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j11)))), 6.28318530717959)));\nevalcond[1]=((((-1.0)*cj15*x361))+((r12*sj15))+((cj15*x360)));\nevalcond[2]=((-0.095)+(((0.09)*x360))+(((-1.0)*(1.0)*py))+(((-0.09)*x361)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j14eval[3];\nsj11=0;\ncj11=-1.0;\nj11=3.14159265358979;\nIkReal x362=((1.0)*sj16);\nIkReal x363=(((r22*sj15))+(((-1.0)*cj15*r21*x362))+((cj15*cj16*r20)));\nIkReal x364=((1.0)*cj16);\nj14eval[0]=x363;\nj14eval[1]=((IKabs((((r01*sj15*sj16))+(((-1.0)*r00*sj15*x364))+((cj15*r02)))))+(IKabs(((((-1.0)*r00*x362))+(((-1.0)*r01*x364))))));\nj14eval[2]=IKsign(x363);\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=0;\ncj11=-1.0;\nj11=3.14159265358979;\nIkReal x365=((1.0)*cj16);\nIkReal x366=((((-1.0)*(1.0)*r02*sj15))+(((-1.0)*cj15*r00*x365))+((cj15*r01*sj16)));\nj14eval[0]=x366;\nj14eval[1]=IKsign(x366);\nj14eval[2]=((IKabs((((r21*sj15*sj16))+((cj15*r22))+(((-1.0)*r20*sj15*x365)))))+(IKabs(((((-1.0)*r21*x365))+(((-1.0)*(1.0)*r20*sj16))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=0;\ncj11=-1.0;\nj11=3.14159265358979;\nIkReal x367=r10*r10;\nIkReal x368=r11*r11;\nIkReal x369=cj15*cj15;\nIkReal x370=((2.0)*cj15*r12);\nIkReal x371=(cj16*r10*sj15);\nIkReal x372=(x368*x369);\nIkReal x373=(r10*sj16);\nIkReal x374=cj16*cj16;\nIkReal x375=(((x372*x374))+(((-1.0)*x367*x369*x374))+(((-1.0)*x370*x371))+(((-1.0)*x372))+x368+x367+(((2.0)*cj16*r11*x369*x373))+((r11*sj15*sj16*x370))+((x369*(r12*r12))));\nIkReal x376=((1.0)*r11);\nj14eval[0]=x375;\nj14eval[1]=((IKabs(((((-1.0)*sj15*sj16*x376))+x371+(((-1.0)*cj15*r12)))))+(IKabs(((((-1.0)*x373))+(((-1.0)*cj16*x376))))));\nj14eval[2]=IKsign(x375);\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j12, j13, j14]\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x377=(cj16*r10*sj15);\nIkReal x378=((1.0)*r11);\nIkReal x379=(r10*sj16);\nIkReal x380=r10*r10;\nIkReal x381=r11*r11;\nIkReal x382=cj15*cj15;\nIkReal x383=((2.0)*cj15*r12);\nIkReal x384=(x381*x382);\nIkReal x385=cj16*cj16;\nCheckValue<IkReal> x386 = IKatan2WithCheck(IkReal(((((-1.0)*sj15*sj16*x378))+x377+(((-1.0)*cj15*r12)))),IkReal(((((-1.0)*x379))+(((-1.0)*cj16*x378)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x386.valid){\ncontinue;\n}\nCheckValue<IkReal> x387=IKPowWithIntegerCheck(IKsign((((r11*sj15*sj16*x383))+(((2.0)*cj16*r11*x379*x382))+((x384*x385))+((x382*(r12*r12)))+x381+x380+(((-1.0)*x377*x383))+(((-1.0)*x380*x382*x385))+(((-1.0)*x384)))),-1);\nif(!x387.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x386.value)+(((1.5707963267949)*(x387.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x388=IKsin(j14);\nIkReal x389=(cj16*r11);\nIkReal x390=(r10*sj16);\nIkReal x391=IKcos(j14);\nIkReal x392=((1.0)*x391);\nIkReal x393=((1.0)*sj16*x391);\nIkReal x394=((1.0)*cj15*x388);\nIkReal x395=((1.0)*cj16*x391);\nIkReal x396=(cj16*sj15*x388);\nIkReal x397=((1.0)*sj15*sj16*x388);\nevalcond[0]=(((x388*x390))+((cj16*r10*sj15*x391))+((x388*x389))+(((-1.0)*r11*sj15*x393))+(((-1.0)*cj15*r12*x392)));\nevalcond[1]=((((-1.0)*r21*x397))+(((-1.0)*r20*x393))+(((-1.0)*r22*x394))+((r20*x396))+(((-1.0)*r21*x395)));\nevalcond[2]=((((-1.0)*r02*x394))+(((-1.0)*r01*x397))+((r00*x396))+(((-1.0)*r00*x393))+(((-1.0)*r01*x395)));\nevalcond[3]=((-1.0)+(((-1.0)*r12*x394))+((r10*x396))+(((-1.0)*r11*x397))+(((-1.0)*x390*x392))+(((-1.0)*x389*x392)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=0;\ncj11=-1.0;\nj11=3.14159265358979;\nIkReal x398=(cj16*r20);\nIkReal x399=(r02*sj15);\nIkReal x400=(r21*sj16);\nIkReal x401=(r22*sj15);\nIkReal x402=(cj15*cj16*r00);\nIkReal x403=(cj15*cj16*r20);\nIkReal x404=(cj15*r01*sj16);\nIkReal x405=(cj15*r21*sj16);\nIkReal x406=((((-0.36)*x399))+(((-0.36)*x402))+(((-2.82)*x401))+(((2.82)*x405))+(((-2.82)*x403))+(((0.36)*x404))+(((1.08)*x400))+(((-1.08)*x398))+(((12.0)*pz)));\nj12eval[0]=((IKabs(((-1.0)+(((0.12)*x404))+(((0.36)*x400))+(((-0.12)*x399))+(((-0.36)*x398))+(((4.0)*pz))+(((-0.94)*x401))+(((-0.12)*x402))+(((-0.94)*x403))+(((0.94)*x405)))))+(IKabs(((1.0)+x406)))+(IKabs(((-1.0)+x406))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x407=(cj16*r20);\nIkReal x408=(r02*sj15);\nIkReal x409=(r21*sj16);\nIkReal x410=(r22*sj15);\nIkReal x411=(cj15*cj16*r00);\nIkReal x412=(cj15*cj16*r20);\nIkReal x413=(cj15*r01*sj16);\nIkReal x414=(cj15*r21*sj16);\nIkReal x415=((((-0.12)*x408))+(((0.94)*x414))+(((0.12)*x413))+(((-0.94)*x412))+(((0.36)*x409))+(((4.0)*pz))+(((-0.94)*x410))+(((-0.12)*x411))+(((-0.36)*x407)));\nIkReal x416=((((-1.08)*x407))+(((1.08)*x409))+(((-0.36)*x408))+(((-0.36)*x411))+(((2.82)*x414))+(((0.36)*x413))+(((12.0)*pz))+(((-2.82)*x412))+(((-2.82)*x410)));\nop[0]=((-1.0)+x415);\nop[1]=0;\nop[2]=((-1.0)+x416);\nop[3]=0;\nop[4]=((1.0)+x416);\nop[5]=0;\nop[6]=((1.0)+x415);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x417=(cj16*r20);\nIkReal x418=((0.36)*x417);\nIkReal x419=(r21*sj16);\nIkReal x420=((0.36)*x419);\nIkReal x421=(r22*sj15);\nIkReal x422=(cj14*cj15*r22);\nIkReal x423=(cj15*cj16*r20);\nIkReal x424=(cj15*r21*sj16);\nIkReal x425=(cj16*r21*sj14);\nIkReal x426=(r20*sj14*sj16);\nIkReal x427=((0.12)*cj14*sj15);\nIkReal x428=((((0.94)*x421))+(((-0.94)*x424))+(((-1.0)*x419*x427))+(((0.12)*x425))+(((-1.0)*(4.0)*pz))+(((-1.0)*x420))+x418+((x417*x427))+(((0.12)*x426))+(((0.94)*x423))+(((-0.12)*x422)));\nIkReal x429=(cj14*sj15);\nIkReal x430=((((0.36)*x425))+(((-2.82)*x424))+(((-1.0)*(12.0)*pz))+(((-1.0)*x420*x429))+(((2.82)*x421))+((x418*x429))+(((-1.08)*x419))+(((0.36)*x426))+(((2.82)*x423))+(((-0.36)*x422))+(((1.08)*x417)));\nj12evalpoly[0]=((-1.0)+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((1.0)+x428))))+(((htj12*htj12)*(((-1.0)+x430))))+x428+(((htj12*htj12*htj12*htj12)*(((1.0)+x430)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x431=(r02*sj15);\nIkReal x432=(r22*sj15);\nIkReal x433=(cj12*cj15);\nIkReal x434=(cj16*r00);\nIkReal x435=(cj15*sj12);\nIkReal x436=(cj16*r20);\nIkReal x437=(r01*sj16);\nIkReal x438=((1.0)*cj12*cj15);\nIkReal x439=(r21*sj16);\nIkReal x440=((1.0)*cj15*sj12);\nif( IKabs(((((-1.0)*x439*x440))+((x435*x436))+((x433*x434))+((cj12*x431))+((sj12*x432))+(((-1.0)*x437*x438)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj12*x432))+(((-1.0)*x437*x440))+((sj12*x431))+((x434*x435))+((x433*x439))+(((-1.0)*x436*x438)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x439*x440))+((x435*x436))+((x433*x434))+((cj12*x431))+((sj12*x432))+(((-1.0)*x437*x438))))+IKsqr(((((-1.0)*cj12*x432))+(((-1.0)*x437*x440))+((sj12*x431))+((x434*x435))+((x433*x439))+(((-1.0)*x436*x438))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*x439*x440))+((x435*x436))+((x433*x434))+((cj12*x431))+((sj12*x432))+(((-1.0)*x437*x438))), ((((-1.0)*cj12*x432))+(((-1.0)*x437*x440))+((sj12*x431))+((x434*x435))+((x433*x439))+(((-1.0)*x436*x438))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x441=IKcos(j13);\nIkReal x442=(cj12*x441);\nIkReal x443=(cj15*cj16);\nIkReal x444=IKsin(j13);\nIkReal x445=(sj12*x444);\nIkReal x446=((1.0)*cj15*sj16);\nIkReal x447=(cj12*x444);\nIkReal x448=(sj12*x441);\nIkReal x449=((((-1.0)*x448))+(((-1.0)*x447)));\nIkReal x450=(cj16*sj14);\nIkReal x451=(sj14*sj16);\nIkReal x452=((1.0)*cj14*cj15);\nIkReal x453=(cj14*cj16*sj15);\nIkReal x454=((1.0)*cj14*sj15*sj16);\nIkReal x455=((0.09)*cj16);\nIkReal x456=((0.09)*sj16);\nevalcond[0]=((((-1.0)*r21*x446))+((r22*sj15))+((r20*x443))+x442+(((-1.0)*x445)));\nevalcond[1]=(((r02*sj15))+(((-1.0)*r01*x446))+((r00*x443))+x449);\nevalcond[2]=((((-1.0)*r02*x452))+((r01*x450))+(((-1.0)*r01*x454))+(((-1.0)*x442))+((r00*x453))+x445+((r00*x451)));\nevalcond[3]=((((-1.0)*r21*x454))+((r20*x453))+x449+(((-1.0)*r22*x452))+((r21*x450))+((r20*x451)));\nevalcond[4]=(((r20*x455))+(((0.03)*x448))+(((-1.0)*(1.0)*pz))+(((-1.0)*r21*x456))+(((0.235)*x445))+(((-0.235)*x442))+(((0.03)*x447))+(((-1.0)*(0.25)*cj12)));\nevalcond[5]=((((-1.0)*(1.0)*px))+(((0.235)*x447))+(((0.03)*x442))+(((-1.0)*r01*x456))+(((-0.03)*x445))+((r00*x455))+(((0.25)*sj12))+(((0.235)*x448)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x457=((1.0)*cj16);\nCheckValue<IkReal> x458 = IKatan2WithCheck(IkReal(((((-1.0)*r21*x457))+(((-1.0)*(1.0)*r20*sj16)))),IkReal(((((-1.0)*r20*sj15*x457))+((r21*sj15*sj16))+((cj15*r22)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x458.valid){\ncontinue;\n}\nCheckValue<IkReal> x459=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj15*r00*x457))+(((-1.0)*(1.0)*r02*sj15))+((cj15*r01*sj16)))),-1);\nif(!x459.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x458.value)+(((1.5707963267949)*(x459.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x460=IKsin(j14);\nIkReal x461=(cj16*r11);\nIkReal x462=(r10*sj16);\nIkReal x463=IKcos(j14);\nIkReal x464=((1.0)*x463);\nIkReal x465=((1.0)*sj16*x463);\nIkReal x466=((1.0)*cj15*x460);\nIkReal x467=((1.0)*cj16*x463);\nIkReal x468=(cj16*sj15*x460);\nIkReal x469=((1.0)*sj15*sj16*x460);\nevalcond[0]=((((-1.0)*cj15*r12*x464))+(((-1.0)*r11*sj15*x465))+((cj16*r10*sj15*x463))+((x460*x462))+((x460*x461)));\nevalcond[1]=(((r20*x468))+(((-1.0)*r21*x469))+(((-1.0)*r22*x466))+(((-1.0)*r20*x465))+(((-1.0)*r21*x467)));\nevalcond[2]=((((-1.0)*r02*x466))+(((-1.0)*r01*x469))+(((-1.0)*r01*x467))+((r00*x468))+(((-1.0)*r00*x465)));\nevalcond[3]=((-1.0)+(((-1.0)*r12*x466))+(((-1.0)*x461*x464))+(((-1.0)*x462*x464))+(((-1.0)*r11*x469))+((r10*x468)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=0;\ncj11=-1.0;\nj11=3.14159265358979;\nIkReal x470=(cj16*r20);\nIkReal x471=(r02*sj15);\nIkReal x472=(r21*sj16);\nIkReal x473=(r22*sj15);\nIkReal x474=(cj15*cj16*r00);\nIkReal x475=(cj15*cj16*r20);\nIkReal x476=(cj15*r01*sj16);\nIkReal x477=(cj15*r21*sj16);\nIkReal x478=((((2.82)*x477))+(((0.36)*x476))+(((-1.08)*x470))+(((-2.82)*x473))+(((-2.82)*x475))+(((1.08)*x472))+(((-0.36)*x474))+(((12.0)*pz))+(((-0.36)*x471)));\nj12eval[0]=((IKabs(((-1.0)+(((0.12)*x476))+(((-0.12)*x474))+(((0.94)*x477))+(((0.36)*x472))+(((4.0)*pz))+(((-0.94)*x475))+(((-0.12)*x471))+(((-0.36)*x470))+(((-0.94)*x473)))))+(IKabs(((-1.0)+x478)))+(IKabs(((1.0)+x478))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x479=(cj16*r20);\nIkReal x480=(r02*sj15);\nIkReal x481=(r21*sj16);\nIkReal x482=(r22*sj15);\nIkReal x483=(cj15*cj16*r00);\nIkReal x484=(cj15*cj16*r20);\nIkReal x485=(cj15*r01*sj16);\nIkReal x486=(cj15*r21*sj16);\nIkReal x487=((((-0.94)*x484))+(((-0.94)*x482))+(((0.12)*x485))+(((4.0)*pz))+(((0.94)*x486))+(((0.36)*x481))+(((-0.36)*x479))+(((-0.12)*x480))+(((-0.12)*x483)));\nIkReal x488=((((1.08)*x481))+(((-0.36)*x483))+(((0.36)*x485))+(((-1.08)*x479))+(((-2.82)*x484))+(((-0.36)*x480))+(((-2.82)*x482))+(((2.82)*x486))+(((12.0)*pz)));\nop[0]=((-1.0)+x487);\nop[1]=0;\nop[2]=((-1.0)+x488);\nop[3]=0;\nop[4]=((1.0)+x488);\nop[5]=0;\nop[6]=((1.0)+x487);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x489=(cj16*r20);\nIkReal x490=((0.36)*x489);\nIkReal x491=(r21*sj16);\nIkReal x492=((0.36)*x491);\nIkReal x493=(r22*sj15);\nIkReal x494=(cj14*cj15*r22);\nIkReal x495=(cj15*cj16*r20);\nIkReal x496=(cj15*r21*sj16);\nIkReal x497=(cj16*r21*sj14);\nIkReal x498=(r20*sj14*sj16);\nIkReal x499=((0.12)*cj14*sj15);\nIkReal x500=((((0.94)*x493))+(((-1.0)*(4.0)*pz))+(((-1.0)*x491*x499))+(((0.12)*x497))+(((0.94)*x495))+((x489*x499))+(((-1.0)*x492))+(((0.12)*x498))+(((-0.12)*x494))+x490+(((-0.94)*x496)));\nIkReal x501=(cj14*sj15);\nIkReal x502=((((0.36)*x497))+((x490*x501))+(((-1.0)*(12.0)*pz))+(((2.82)*x495))+(((2.82)*x493))+(((-0.36)*x494))+(((-2.82)*x496))+(((-1.08)*x491))+(((-1.0)*x492*x501))+(((0.36)*x498))+(((1.08)*x489)));\nj12evalpoly[0]=((-1.0)+(((htj12*htj12)*(((-1.0)+x502))))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((1.0)+x500))))+x500+(((htj12*htj12*htj12*htj12)*(((1.0)+x502)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x503=(r02*sj15);\nIkReal x504=(r22*sj15);\nIkReal x505=(cj12*cj15);\nIkReal x506=(cj16*r00);\nIkReal x507=(cj15*sj12);\nIkReal x508=(cj16*r20);\nIkReal x509=(r01*sj16);\nIkReal x510=((1.0)*cj12*cj15);\nIkReal x511=(r21*sj16);\nIkReal x512=((1.0)*cj15*sj12);\nif( IKabs(((((-1.0)*x511*x512))+(((-1.0)*x509*x510))+((x507*x508))+((x505*x506))+((cj12*x503))+((sj12*x504)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x509*x512))+((x506*x507))+(((-1.0)*cj12*x504))+((sj12*x503))+((x505*x511))+(((-1.0)*x508*x510)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x511*x512))+(((-1.0)*x509*x510))+((x507*x508))+((x505*x506))+((cj12*x503))+((sj12*x504))))+IKsqr(((((-1.0)*x509*x512))+((x506*x507))+(((-1.0)*cj12*x504))+((sj12*x503))+((x505*x511))+(((-1.0)*x508*x510))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*x511*x512))+(((-1.0)*x509*x510))+((x507*x508))+((x505*x506))+((cj12*x503))+((sj12*x504))), ((((-1.0)*x509*x512))+((x506*x507))+(((-1.0)*cj12*x504))+((sj12*x503))+((x505*x511))+(((-1.0)*x508*x510))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x513=IKcos(j13);\nIkReal x514=(cj12*x513);\nIkReal x515=(cj15*cj16);\nIkReal x516=IKsin(j13);\nIkReal x517=(sj12*x516);\nIkReal x518=((1.0)*cj15*sj16);\nIkReal x519=(cj12*x516);\nIkReal x520=(sj12*x513);\nIkReal x521=((((-1.0)*x519))+(((-1.0)*x520)));\nIkReal x522=(cj16*sj14);\nIkReal x523=(sj14*sj16);\nIkReal x524=((1.0)*cj14*cj15);\nIkReal x525=(cj14*cj16*sj15);\nIkReal x526=((1.0)*cj14*sj15*sj16);\nIkReal x527=((0.09)*cj16);\nIkReal x528=((0.09)*sj16);\nevalcond[0]=(((r20*x515))+((r22*sj15))+(((-1.0)*x517))+(((-1.0)*r21*x518))+x514);\nevalcond[1]=(((r02*sj15))+((r00*x515))+(((-1.0)*r01*x518))+x521);\nevalcond[2]=(((r00*x523))+(((-1.0)*r02*x524))+(((-1.0)*x514))+x517+((r01*x522))+((r00*x525))+(((-1.0)*r01*x526)));\nevalcond[3]=(((r20*x523))+((r21*x522))+(((-1.0)*r21*x526))+((r20*x525))+(((-1.0)*r22*x524))+x521);\nevalcond[4]=((((-1.0)*(1.0)*pz))+(((0.235)*x517))+(((-1.0)*r21*x528))+(((0.03)*x519))+(((-0.235)*x514))+(((0.03)*x520))+((r20*x527))+(((-1.0)*(0.25)*cj12)));\nevalcond[5]=((((-1.0)*(1.0)*px))+((r00*x527))+(((0.235)*x520))+(((0.235)*x519))+(((0.25)*sj12))+(((-1.0)*r01*x528))+(((0.03)*x514))+(((-0.03)*x517)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x529=((1.0)*sj16);\nIkReal x530=((1.0)*cj16);\nCheckValue<IkReal> x531=IKPowWithIntegerCheck(IKsign((((r22*sj15))+(((-1.0)*cj15*r21*x529))+((cj15*cj16*r20)))),-1);\nif(!x531.valid){\ncontinue;\n}\nCheckValue<IkReal> x532 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x529))+(((-1.0)*r01*x530)))),IkReal((((r01*sj15*sj16))+(((-1.0)*r00*sj15*x530))+((cj15*r02)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x532.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x531.value)))+(x532.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x533=IKsin(j14);\nIkReal x534=(cj16*r11);\nIkReal x535=(r10*sj16);\nIkReal x536=IKcos(j14);\nIkReal x537=((1.0)*x536);\nIkReal x538=((1.0)*sj16*x536);\nIkReal x539=((1.0)*cj15*x533);\nIkReal x540=((1.0)*cj16*x536);\nIkReal x541=(cj16*sj15*x533);\nIkReal x542=((1.0)*sj15*sj16*x533);\nevalcond[0]=(((x533*x534))+(((-1.0)*r11*sj15*x538))+((cj16*r10*sj15*x536))+(((-1.0)*cj15*r12*x537))+((x533*x535)));\nevalcond[1]=((((-1.0)*r21*x540))+(((-1.0)*r20*x538))+(((-1.0)*r22*x539))+((r20*x541))+(((-1.0)*r21*x542)));\nevalcond[2]=((((-1.0)*r02*x539))+(((-1.0)*r01*x540))+((r00*x541))+(((-1.0)*r01*x542))+(((-1.0)*r00*x538)));\nevalcond[3]=((-1.0)+((r10*x541))+(((-1.0)*x535*x537))+(((-1.0)*r11*x542))+(((-1.0)*r12*x539))+(((-1.0)*x534*x537)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=0;\ncj11=-1.0;\nj11=3.14159265358979;\nIkReal x543=(cj16*r20);\nIkReal x544=(r02*sj15);\nIkReal x545=(r21*sj16);\nIkReal x546=(r22*sj15);\nIkReal x547=(cj15*cj16*r00);\nIkReal x548=(cj15*cj16*r20);\nIkReal x549=(cj15*r01*sj16);\nIkReal x550=(cj15*r21*sj16);\nIkReal x551=((((1.08)*x545))+(((2.82)*x550))+(((-1.08)*x543))+(((0.36)*x549))+(((-0.36)*x544))+(((-2.82)*x548))+(((12.0)*pz))+(((-2.82)*x546))+(((-0.36)*x547)));\nj12eval[0]=((IKabs(((1.0)+x551)))+(IKabs(((-1.0)+x551)))+(IKabs(((-1.0)+(((-0.12)*x547))+(((-0.94)*x548))+(((-0.94)*x546))+(((0.94)*x550))+(((4.0)*pz))+(((0.12)*x549))+(((-0.36)*x543))+(((0.36)*x545))+(((-0.12)*x544))))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x552=(cj16*r20);\nIkReal x553=(r02*sj15);\nIkReal x554=(r21*sj16);\nIkReal x555=(r22*sj15);\nIkReal x556=(cj15*cj16*r00);\nIkReal x557=(cj15*cj16*r20);\nIkReal x558=(cj15*r01*sj16);\nIkReal x559=(cj15*r21*sj16);\nIkReal x560=((((0.12)*x558))+(((-0.94)*x557))+(((0.94)*x559))+(((-0.12)*x553))+(((-0.36)*x552))+(((4.0)*pz))+(((-0.12)*x556))+(((0.36)*x554))+(((-0.94)*x555)));\nIkReal x561=((((-0.36)*x556))+(((-2.82)*x555))+(((-2.82)*x557))+(((-1.08)*x552))+(((-0.36)*x553))+(((0.36)*x558))+(((12.0)*pz))+(((1.08)*x554))+(((2.82)*x559)));\nop[0]=((-1.0)+x560);\nop[1]=0;\nop[2]=((-1.0)+x561);\nop[3]=0;\nop[4]=((1.0)+x561);\nop[5]=0;\nop[6]=((1.0)+x560);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x562=(cj16*r20);\nIkReal x563=((0.36)*x562);\nIkReal x564=(r21*sj16);\nIkReal x565=((0.36)*x564);\nIkReal x566=(r22*sj15);\nIkReal x567=(cj14*cj15*r22);\nIkReal x568=(cj15*cj16*r20);\nIkReal x569=(cj15*r21*sj16);\nIkReal x570=(cj16*r21*sj14);\nIkReal x571=(r20*sj14*sj16);\nIkReal x572=((0.12)*cj14*sj15);\nIkReal x573=((((0.12)*x570))+(((-0.12)*x567))+(((0.12)*x571))+(((-1.0)*x565))+(((0.94)*x568))+(((-1.0)*(4.0)*pz))+(((-1.0)*x564*x572))+((x562*x572))+(((0.94)*x566))+(((-0.94)*x569))+x563);\nIkReal x574=(cj14*sj15);\nIkReal x575=((((-2.82)*x569))+(((-1.0)*(12.0)*pz))+(((2.82)*x568))+(((1.08)*x562))+((x563*x574))+(((-1.08)*x564))+(((2.82)*x566))+(((0.36)*x570))+(((-1.0)*x565*x574))+(((0.36)*x571))+(((-0.36)*x567)));\nj12evalpoly[0]=((-1.0)+x573+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((1.0)+x573))))+(((htj12*htj12)*(((-1.0)+x575))))+(((htj12*htj12*htj12*htj12)*(((1.0)+x575)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x576=(r02*sj15);\nIkReal x577=(r22*sj15);\nIkReal x578=(cj12*cj15);\nIkReal x579=(cj16*r00);\nIkReal x580=(cj15*sj12);\nIkReal x581=(cj16*r20);\nIkReal x582=(r01*sj16);\nIkReal x583=((1.0)*cj12*cj15);\nIkReal x584=(r21*sj16);\nIkReal x585=((1.0)*cj15*sj12);\nif( IKabs((((sj12*x577))+((x578*x579))+(((-1.0)*x584*x585))+((cj12*x576))+(((-1.0)*x582*x583))+((x580*x581)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x582*x585))+((x578*x584))+(((-1.0)*x581*x583))+(((-1.0)*cj12*x577))+((x579*x580))+((sj12*x576)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj12*x577))+((x578*x579))+(((-1.0)*x584*x585))+((cj12*x576))+(((-1.0)*x582*x583))+((x580*x581))))+IKsqr(((((-1.0)*x582*x585))+((x578*x584))+(((-1.0)*x581*x583))+(((-1.0)*cj12*x577))+((x579*x580))+((sj12*x576))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((sj12*x577))+((x578*x579))+(((-1.0)*x584*x585))+((cj12*x576))+(((-1.0)*x582*x583))+((x580*x581))), ((((-1.0)*x582*x585))+((x578*x584))+(((-1.0)*x581*x583))+(((-1.0)*cj12*x577))+((x579*x580))+((sj12*x576))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x586=IKcos(j13);\nIkReal x587=(cj12*x586);\nIkReal x588=(cj15*cj16);\nIkReal x589=IKsin(j13);\nIkReal x590=(sj12*x589);\nIkReal x591=((1.0)*cj15*sj16);\nIkReal x592=(cj12*x589);\nIkReal x593=(sj12*x586);\nIkReal x594=((((-1.0)*x593))+(((-1.0)*x592)));\nIkReal x595=(cj16*sj14);\nIkReal x596=(sj14*sj16);\nIkReal x597=((1.0)*cj14*cj15);\nIkReal x598=(cj14*cj16*sj15);\nIkReal x599=((1.0)*cj14*sj15*sj16);\nIkReal x600=((0.09)*cj16);\nIkReal x601=((0.09)*sj16);\nevalcond[0]=((((-1.0)*r21*x591))+((r22*sj15))+((r20*x588))+(((-1.0)*x590))+x587);\nevalcond[1]=(((r02*sj15))+(((-1.0)*r01*x591))+((r00*x588))+x594);\nevalcond[2]=(((r00*x596))+(((-1.0)*r01*x599))+(((-1.0)*x587))+((r00*x598))+((r01*x595))+(((-1.0)*r02*x597))+x590);\nevalcond[3]=((((-1.0)*r22*x597))+((r21*x595))+((r20*x598))+(((-1.0)*r21*x599))+((r20*x596))+x594);\nevalcond[4]=((((0.03)*x593))+(((-1.0)*(1.0)*pz))+(((0.235)*x590))+(((-0.235)*x587))+(((-1.0)*(0.25)*cj12))+(((0.03)*x592))+(((-1.0)*r21*x601))+((r20*x600)));\nevalcond[5]=((((-1.0)*(1.0)*px))+(((0.235)*x593))+(((-0.03)*x590))+(((-1.0)*r01*x601))+(((0.235)*x592))+((r00*x600))+(((0.25)*sj12))+(((0.03)*x587)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x602=(cj16*r00);\nIkReal x603=(r01*sj16);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j11)))), 6.28318530717959)));\nevalcond[1]=(((cj15*x602))+((r02*sj15))+(((-1.0)*cj15*x603)));\nevalcond[2]=((-0.095)+(((-1.0)*(1.0)*px))+(((0.09)*x602))+(((-0.09)*x603)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j14eval[3];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x604=((1.0)*sj16);\nIkReal x605=(((cj15*cj16*r10))+((r12*sj15))+(((-1.0)*cj15*r11*x604)));\nIkReal x606=((1.0)*cj16);\nj14eval[0]=x605;\nj14eval[1]=IKsign(x605);\nj14eval[2]=((IKabs((((r21*sj15*sj16))+((cj15*r22))+(((-1.0)*r20*sj15*x606)))))+(IKabs(((((-1.0)*r20*x604))+(((-1.0)*r21*x606))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x607=((1.0)*cj16);\nIkReal x608=((((-1.0)*cj15*r20*x607))+(((-1.0)*(1.0)*r22*sj15))+((cj15*r21*sj16)));\nj14eval[0]=x608;\nj14eval[1]=IKsign(x608);\nj14eval[2]=((IKabs(((((-1.0)*r11*x607))+(((-1.0)*(1.0)*r10*sj16)))))+(IKabs((((r11*sj15*sj16))+((cj15*r12))+(((-1.0)*r10*sj15*x607))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x609=r00*r00;\nIkReal x610=r01*r01;\nIkReal x611=cj15*cj15;\nIkReal x612=((2.0)*cj15*r02);\nIkReal x613=(cj16*r00*sj15);\nIkReal x614=(x610*x611);\nIkReal x615=(r00*sj16);\nIkReal x616=cj16*cj16;\nIkReal x617=(x610+((x614*x616))+(((2.0)*cj16*r01*x611*x615))+((r01*sj15*sj16*x612))+(((-1.0)*x614))+(((-1.0)*x612*x613))+(((-1.0)*x609*x611*x616))+x609+((x611*(r02*r02))));\nIkReal x618=((1.0)*r01);\nj14eval[0]=x617;\nj14eval[1]=IKsign(x617);\nj14eval[2]=((IKabs(((((-1.0)*x615))+(((-1.0)*cj16*x618)))))+(IKabs((x613+(((-1.0)*sj15*sj16*x618))+(((-1.0)*cj15*r02))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j12, j13, j14]\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x619=(cj16*r00*sj15);\nIkReal x620=((1.0)*r01);\nIkReal x621=(r00*sj16);\nIkReal x622=r00*r00;\nIkReal x623=r01*r01;\nIkReal x624=cj15*cj15;\nIkReal x625=((2.0)*cj15*r02);\nIkReal x626=(x623*x624);\nIkReal x627=cj16*cj16;\nCheckValue<IkReal> x628 = IKatan2WithCheck(IkReal((x619+(((-1.0)*cj15*r02))+(((-1.0)*sj15*sj16*x620)))),IkReal(((((-1.0)*cj16*x620))+(((-1.0)*x621)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x628.valid){\ncontinue;\n}\nCheckValue<IkReal> x629=IKPowWithIntegerCheck(IKsign((((x624*(r02*r02)))+((r01*sj15*sj16*x625))+x622+x623+(((-1.0)*x626))+(((-1.0)*x619*x625))+((x626*x627))+(((-1.0)*x622*x624*x627))+(((2.0)*cj16*r01*x621*x624)))),-1);\nif(!x629.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x628.value)+(((1.5707963267949)*(x629.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x630=IKsin(j14);\nIkReal x631=(cj16*r01);\nIkReal x632=(r00*sj16);\nIkReal x633=IKcos(j14);\nIkReal x634=((1.0)*cj15*r02);\nIkReal x635=(cj16*r00*sj15);\nIkReal x636=(r01*sj15);\nIkReal x637=((1.0)*sj16*x633);\nIkReal x638=((1.0)*cj15*x630);\nIkReal x639=((1.0)*cj16*x633);\nIkReal x640=(cj16*sj15*x630);\nIkReal x641=((1.0)*sj15*sj16*x630);\nIkReal x642=((1.0)*x633);\nevalcond[0]=(((x630*x632))+((x633*x635))+(((-1.0)*x636*x637))+((x630*x631))+(((-1.0)*x633*x634)));\nevalcond[1]=((((-1.0)*r20*x637))+(((-1.0)*r21*x641))+(((-1.0)*r21*x639))+((r20*x640))+(((-1.0)*r22*x638)));\nevalcond[2]=((((-1.0)*r12*x638))+(((-1.0)*r10*x637))+(((-1.0)*r11*x641))+((r10*x640))+(((-1.0)*r11*x639)));\nevalcond[3]=((-1.0)+(((-1.0)*x631*x642))+((x630*x635))+(((-1.0)*x630*x634))+(((-1.0)*sj16*x630*x636))+(((-1.0)*x632*x642)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x643=(cj16*r20);\nIkReal x644=(r12*sj15);\nIkReal x645=(r21*sj16);\nIkReal x646=(r22*sj15);\nIkReal x647=(cj15*cj16*r10);\nIkReal x648=(cj15*cj16*r20);\nIkReal x649=(cj15*r11*sj16);\nIkReal x650=(cj15*r21*sj16);\nIkReal x651=((((1.08)*x643))+(((-2.82)*x650))+(((-1.0)*(12.0)*pz))+(((0.36)*x649))+(((-0.36)*x647))+(((2.82)*x648))+(((-0.36)*x644))+(((2.82)*x646))+(((-1.08)*x645)));\nj12eval[0]=((IKabs(((1.0)+x651)))+(IKabs(((-1.0)+x651)))+(IKabs(((1.0)+(((-0.12)*x644))+(((-0.12)*x647))+(((-0.36)*x645))+(((-1.0)*(4.0)*pz))+(((0.36)*x643))+(((-0.94)*x650))+(((0.94)*x648))+(((0.94)*x646))+(((0.12)*x649))))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x652=(cj16*r20);\nIkReal x653=(r12*sj15);\nIkReal x654=(r21*sj16);\nIkReal x655=(r22*sj15);\nIkReal x656=(cj15*cj16*r10);\nIkReal x657=(cj15*cj16*r20);\nIkReal x658=(cj15*r11*sj16);\nIkReal x659=(cj15*r21*sj16);\nIkReal x660=((((0.94)*x655))+(((-1.0)*(4.0)*pz))+(((0.36)*x652))+(((-0.36)*x654))+(((0.12)*x658))+(((-0.94)*x659))+(((0.94)*x657))+(((-0.12)*x653))+(((-0.12)*x656)));\nIkReal x661=((((-1.0)*(12.0)*pz))+(((1.08)*x652))+(((-1.08)*x654))+(((2.82)*x655))+(((-0.36)*x653))+(((2.82)*x657))+(((-2.82)*x659))+(((-0.36)*x656))+(((0.36)*x658)));\nop[0]=((1.0)+x660);\nop[1]=0;\nop[2]=((1.0)+x661);\nop[3]=0;\nop[4]=((-1.0)+x661);\nop[5]=0;\nop[6]=((-1.0)+x660);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x662=(cj16*r10);\nIkReal x663=(cj16*r20);\nIkReal x664=(r11*sj16);\nIkReal x665=(r21*sj16);\nIkReal x666=(r22*sj15);\nIkReal x667=(cj15*cj16*r20);\nIkReal x668=(cj15*r21*sj16);\nIkReal x669=((((0.2245)*x666))+(((-1.0)*(0.12)*py))+(((-0.0846)*x665))+(((-0.0108)*x664))+(((0.0846)*x663))+(((-0.2245)*x668))+(((-1.0)*(0.94)*pz))+(((0.0108)*x662))+(((0.2245)*x667)));\nIkReal x670=((((-0.6735)*x668))+(((0.6735)*x667))+(((-1.0)*(0.36)*py))+(((0.6735)*x666))+(((0.0324)*x662))+(((-0.0324)*x664))+(((0.2538)*x663))+(((-1.0)*(2.82)*pz))+(((-0.2538)*x665)));\nj12evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj12*htj12*htj12)))+(((-1.0)*(0.06)*htj12))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((0.235)+x669))))+(((htj12*htj12*htj12*htj12)*(((0.235)+x670))))+x669+(((htj12*htj12)*(((-0.235)+x670))))+(((-1.0)*(0.06)*(htj12*htj12*htj12*htj12*htj12))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x671=(r22*sj15);\nIkReal x672=((1.0)*cj12);\nIkReal x673=(r12*sj15);\nIkReal x674=(cj12*cj15*sj16);\nIkReal x675=(cj15*sj12);\nIkReal x676=(cj16*r20);\nIkReal x677=(cj16*r10);\nIkReal x678=((1.0)*cj12*cj15);\nIkReal x679=((1.0)*cj15*sj12);\nif( IKabs((((r11*x674))+((x675*x676))+(((-1.0)*r21*sj16*x679))+((sj12*x671))+(((-1.0)*x672*x673))+(((-1.0)*x677*x678)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x671*x672))+(((-1.0)*sj12*x673))+((r11*sj16*x675))+((r21*x674))+(((-1.0)*x677*x679))+(((-1.0)*x676*x678)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r11*x674))+((x675*x676))+(((-1.0)*r21*sj16*x679))+((sj12*x671))+(((-1.0)*x672*x673))+(((-1.0)*x677*x678))))+IKsqr(((((-1.0)*x671*x672))+(((-1.0)*sj12*x673))+((r11*sj16*x675))+((r21*x674))+(((-1.0)*x677*x679))+(((-1.0)*x676*x678))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((r11*x674))+((x675*x676))+(((-1.0)*r21*sj16*x679))+((sj12*x671))+(((-1.0)*x672*x673))+(((-1.0)*x677*x678))), ((((-1.0)*x671*x672))+(((-1.0)*sj12*x673))+((r11*sj16*x675))+((r21*x674))+(((-1.0)*x677*x679))+(((-1.0)*x676*x678))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x680=IKsin(j13);\nIkReal x681=(cj12*x680);\nIkReal x682=IKcos(j13);\nIkReal x683=(sj12*x682);\nIkReal x684=(cj15*cj16);\nIkReal x685=((1.0)*cj15*sj16);\nIkReal x686=(cj12*x682);\nIkReal x687=(sj12*x680);\nIkReal x688=((((-1.0)*x687))+x686);\nIkReal x689=(cj16*sj14);\nIkReal x690=(sj14*sj16);\nIkReal x691=((1.0)*cj14*cj15);\nIkReal x692=(cj14*cj16*sj15);\nIkReal x693=((1.0)*cj14*sj15*sj16);\nIkReal x694=((0.09)*cj16);\nIkReal x695=((0.09)*sj16);\nevalcond[0]=(((r12*sj15))+(((-1.0)*r11*x685))+((r10*x684))+x683+x681);\nevalcond[1]=(((r22*sj15))+((r20*x684))+(((-1.0)*r21*x685))+x688);\nevalcond[2]=((((-1.0)*r11*x693))+((r10*x690))+(((-1.0)*r12*x691))+x688+((r11*x689))+((r10*x692)));\nevalcond[3]=(((r20*x690))+(((-1.0)*r21*x693))+(((-1.0)*x683))+((r20*x692))+((r21*x689))+(((-1.0)*x681))+(((-1.0)*r22*x691)));\nevalcond[4]=((((-1.0)*(1.0)*pz))+(((0.03)*x681))+((r20*x694))+(((0.235)*x687))+(((-0.235)*x686))+(((-1.0)*r21*x695))+(((0.03)*x683))+(((-1.0)*(0.25)*cj12)));\nevalcond[5]=((((-1.0)*(1.0)*py))+(((-0.235)*x683))+((r10*x694))+(((-0.03)*x686))+(((-1.0)*(0.25)*sj12))+(((-1.0)*r11*x695))+(((-0.235)*x681))+(((0.03)*x687)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x696=((1.0)*cj16);\nCheckValue<IkReal> x697=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj15*r20*x696))+(((-1.0)*(1.0)*r22*sj15))+((cj15*r21*sj16)))),-1);\nif(!x697.valid){\ncontinue;\n}\nCheckValue<IkReal> x698 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x696))+(((-1.0)*(1.0)*r10*sj16)))),IkReal((((r11*sj15*sj16))+(((-1.0)*r10*sj15*x696))+((cj15*r12)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x698.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x697.value)))+(x698.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x699=IKsin(j14);\nIkReal x700=(cj16*r01);\nIkReal x701=(r00*sj16);\nIkReal x702=IKcos(j14);\nIkReal x703=((1.0)*cj15*r02);\nIkReal x704=(cj16*r00*sj15);\nIkReal x705=(r01*sj15);\nIkReal x706=((1.0)*sj16*x702);\nIkReal x707=((1.0)*cj15*x699);\nIkReal x708=((1.0)*cj16*x702);\nIkReal x709=(cj16*sj15*x699);\nIkReal x710=((1.0)*sj15*sj16*x699);\nIkReal x711=((1.0)*x702);\nevalcond[0]=(((x699*x700))+((x699*x701))+(((-1.0)*x705*x706))+(((-1.0)*x702*x703))+((x702*x704)));\nevalcond[1]=((((-1.0)*r21*x710))+(((-1.0)*r20*x706))+(((-1.0)*r21*x708))+(((-1.0)*r22*x707))+((r20*x709)));\nevalcond[2]=((((-1.0)*r11*x708))+((r10*x709))+(((-1.0)*r11*x710))+(((-1.0)*r10*x706))+(((-1.0)*r12*x707)));\nevalcond[3]=((-1.0)+(((-1.0)*sj16*x699*x705))+(((-1.0)*x701*x711))+(((-1.0)*x700*x711))+(((-1.0)*x699*x703))+((x699*x704)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x712=(cj16*r20);\nIkReal x713=(r12*sj15);\nIkReal x714=(r21*sj16);\nIkReal x715=(r22*sj15);\nIkReal x716=(cj15*cj16*r10);\nIkReal x717=(cj15*cj16*r20);\nIkReal x718=(cj15*r11*sj16);\nIkReal x719=(cj15*r21*sj16);\nIkReal x720=((((-1.0)*(12.0)*pz))+(((0.36)*x718))+(((-0.36)*x716))+(((1.08)*x712))+(((-1.08)*x714))+(((2.82)*x715))+(((2.82)*x717))+(((-0.36)*x713))+(((-2.82)*x719)));\nj12eval[0]=((IKabs(((-1.0)+x720)))+(IKabs(((1.0)+x720)))+(IKabs(((1.0)+(((-0.36)*x714))+(((-0.12)*x716))+(((0.94)*x717))+(((-1.0)*(4.0)*pz))+(((0.36)*x712))+(((-0.12)*x713))+(((-0.94)*x719))+(((0.12)*x718))+(((0.94)*x715))))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x721=(cj16*r20);\nIkReal x722=(r12*sj15);\nIkReal x723=(r21*sj16);\nIkReal x724=(r22*sj15);\nIkReal x725=(cj15*cj16*r10);\nIkReal x726=(cj15*cj16*r20);\nIkReal x727=(cj15*r11*sj16);\nIkReal x728=(cj15*r21*sj16);\nIkReal x729=((((-0.94)*x728))+(((0.12)*x727))+(((-0.12)*x725))+(((-1.0)*(4.0)*pz))+(((-0.36)*x723))+(((0.94)*x726))+(((-0.12)*x722))+(((0.36)*x721))+(((0.94)*x724)));\nIkReal x730=((((-2.82)*x728))+(((-1.08)*x723))+(((-1.0)*(12.0)*pz))+(((1.08)*x721))+(((2.82)*x726))+(((2.82)*x724))+(((-0.36)*x725))+(((0.36)*x727))+(((-0.36)*x722)));\nop[0]=((1.0)+x729);\nop[1]=0;\nop[2]=((1.0)+x730);\nop[3]=0;\nop[4]=((-1.0)+x730);\nop[5]=0;\nop[6]=((-1.0)+x729);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x731=(cj16*r10);\nIkReal x732=(cj16*r20);\nIkReal x733=(r11*sj16);\nIkReal x734=(r21*sj16);\nIkReal x735=(r22*sj15);\nIkReal x736=(cj15*cj16*r20);\nIkReal x737=(cj15*r21*sj16);\nIkReal x738=((((-1.0)*(0.12)*py))+(((0.0108)*x731))+(((0.0846)*x732))+(((-0.0108)*x733))+(((0.2245)*x735))+(((-1.0)*(0.94)*pz))+(((-0.0846)*x734))+(((0.2245)*x736))+(((-0.2245)*x737)));\nIkReal x739=((((-1.0)*(0.36)*py))+(((0.2538)*x732))+(((-0.6735)*x737))+(((-0.0324)*x733))+(((0.0324)*x731))+(((0.6735)*x736))+(((0.6735)*x735))+(((-0.2538)*x734))+(((-1.0)*(2.82)*pz)));\nj12evalpoly[0]=((-0.235)+(((-1.0)*(0.12)*(htj12*htj12*htj12)))+(((htj12*htj12)*(((-0.235)+x739))))+(((-1.0)*(0.06)*htj12))+x738+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((0.235)+x738))))+(((htj12*htj12*htj12*htj12)*(((0.235)+x739))))+(((-1.0)*(0.06)*(htj12*htj12*htj12*htj12*htj12))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x740=(r22*sj15);\nIkReal x741=((1.0)*cj12);\nIkReal x742=(r12*sj15);\nIkReal x743=(cj12*cj15*sj16);\nIkReal x744=(cj15*sj12);\nIkReal x745=(cj16*r20);\nIkReal x746=(cj16*r10);\nIkReal x747=((1.0)*cj12*cj15);\nIkReal x748=((1.0)*cj15*sj12);\nif( IKabs((((x744*x745))+(((-1.0)*x741*x742))+(((-1.0)*r21*sj16*x748))+((r11*x743))+((sj12*x740))+(((-1.0)*x746*x747)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x745*x747))+(((-1.0)*sj12*x742))+(((-1.0)*x746*x748))+((r11*sj16*x744))+(((-1.0)*x740*x741))+((r21*x743)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x744*x745))+(((-1.0)*x741*x742))+(((-1.0)*r21*sj16*x748))+((r11*x743))+((sj12*x740))+(((-1.0)*x746*x747))))+IKsqr(((((-1.0)*x745*x747))+(((-1.0)*sj12*x742))+(((-1.0)*x746*x748))+((r11*sj16*x744))+(((-1.0)*x740*x741))+((r21*x743))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((x744*x745))+(((-1.0)*x741*x742))+(((-1.0)*r21*sj16*x748))+((r11*x743))+((sj12*x740))+(((-1.0)*x746*x747))), ((((-1.0)*x745*x747))+(((-1.0)*sj12*x742))+(((-1.0)*x746*x748))+((r11*sj16*x744))+(((-1.0)*x740*x741))+((r21*x743))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x749=IKsin(j13);\nIkReal x750=(cj12*x749);\nIkReal x751=IKcos(j13);\nIkReal x752=(sj12*x751);\nIkReal x753=(cj15*cj16);\nIkReal x754=((1.0)*cj15*sj16);\nIkReal x755=(cj12*x751);\nIkReal x756=(sj12*x749);\nIkReal x757=((((-1.0)*x756))+x755);\nIkReal x758=(cj16*sj14);\nIkReal x759=(sj14*sj16);\nIkReal x760=((1.0)*cj14*cj15);\nIkReal x761=(cj14*cj16*sj15);\nIkReal x762=((1.0)*cj14*sj15*sj16);\nIkReal x763=((0.09)*cj16);\nIkReal x764=((0.09)*sj16);\nevalcond[0]=(((r12*sj15))+(((-1.0)*r11*x754))+((r10*x753))+x752+x750);\nevalcond[1]=(((r22*sj15))+(((-1.0)*r21*x754))+((r20*x753))+x757);\nevalcond[2]=(((r10*x761))+(((-1.0)*r11*x762))+(((-1.0)*r12*x760))+((r11*x758))+x757+((r10*x759)));\nevalcond[3]=(((r20*x761))+(((-1.0)*x750))+(((-1.0)*r22*x760))+(((-1.0)*x752))+((r21*x758))+(((-1.0)*r21*x762))+((r20*x759)));\nevalcond[4]=((((0.03)*x752))+(((0.235)*x756))+(((0.03)*x750))+(((-1.0)*(1.0)*pz))+(((-0.235)*x755))+(((-1.0)*r21*x764))+((r20*x763))+(((-1.0)*(0.25)*cj12)));\nevalcond[5]=((((-0.235)*x750))+(((-1.0)*(1.0)*py))+(((-1.0)*r11*x764))+(((-1.0)*(0.25)*sj12))+(((-0.235)*x752))+(((-0.03)*x755))+(((0.03)*x756))+((r10*x763)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x765=((1.0)*sj16);\nIkReal x766=((1.0)*cj16);\nCheckValue<IkReal> x767=IKPowWithIntegerCheck(IKsign((((cj15*cj16*r10))+((r12*sj15))+(((-1.0)*cj15*r11*x765)))),-1);\nif(!x767.valid){\ncontinue;\n}\nCheckValue<IkReal> x768 = IKatan2WithCheck(IkReal(((((-1.0)*r20*x765))+(((-1.0)*r21*x766)))),IkReal(((((-1.0)*r20*sj15*x766))+((r21*sj15*sj16))+((cj15*r22)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x768.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x767.value)))+(x768.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x769=IKsin(j14);\nIkReal x770=(cj16*r01);\nIkReal x771=(r00*sj16);\nIkReal x772=IKcos(j14);\nIkReal x773=((1.0)*cj15*r02);\nIkReal x774=(cj16*r00*sj15);\nIkReal x775=(r01*sj15);\nIkReal x776=((1.0)*sj16*x772);\nIkReal x777=((1.0)*cj15*x769);\nIkReal x778=((1.0)*cj16*x772);\nIkReal x779=(cj16*sj15*x769);\nIkReal x780=((1.0)*sj15*sj16*x769);\nIkReal x781=((1.0)*x772);\nevalcond[0]=(((x769*x770))+(((-1.0)*x772*x773))+(((-1.0)*x775*x776))+((x772*x774))+((x769*x771)));\nevalcond[1]=((((-1.0)*r21*x778))+(((-1.0)*r21*x780))+(((-1.0)*r22*x777))+(((-1.0)*r20*x776))+((r20*x779)));\nevalcond[2]=((((-1.0)*r11*x778))+(((-1.0)*r10*x776))+(((-1.0)*r11*x780))+(((-1.0)*r12*x777))+((r10*x779)));\nevalcond[3]=((-1.0)+((x769*x774))+(((-1.0)*x769*x773))+(((-1.0)*x770*x781))+(((-1.0)*x771*x781))+(((-1.0)*sj16*x769*x775)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=1.0;\ncj11=0;\nj11=1.5707963267949;\nIkReal x782=(cj16*r20);\nIkReal x783=(r12*sj15);\nIkReal x784=(r21*sj16);\nIkReal x785=(r22*sj15);\nIkReal x786=(cj15*cj16*r10);\nIkReal x787=(cj15*cj16*r20);\nIkReal x788=(cj15*r11*sj16);\nIkReal x789=(cj15*r21*sj16);\nIkReal x790=((((-1.0)*(12.0)*pz))+(((1.08)*x782))+(((-1.08)*x784))+(((-0.36)*x783))+(((0.36)*x788))+(((2.82)*x787))+(((-0.36)*x786))+(((-2.82)*x789))+(((2.82)*x785)));\nj12eval[0]=((IKabs(((-1.0)+x790)))+(IKabs(((1.0)+(((0.94)*x785))+(((-0.36)*x784))+(((-1.0)*(4.0)*pz))+(((-0.94)*x789))+(((0.94)*x787))+(((-0.12)*x786))+(((-0.12)*x783))+(((0.12)*x788))+(((0.36)*x782)))))+(IKabs(((1.0)+x790))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x791=(cj16*r20);\nIkReal x792=(r12*sj15);\nIkReal x793=(r21*sj16);\nIkReal x794=(r22*sj15);\nIkReal x795=(cj15*cj16*r10);\nIkReal x796=(cj15*cj16*r20);\nIkReal x797=(cj15*r11*sj16);\nIkReal x798=(cj15*r21*sj16);\nIkReal x799=((((0.94)*x796))+(((-1.0)*(4.0)*pz))+(((-0.12)*x795))+(((-0.36)*x793))+(((0.94)*x794))+(((-0.12)*x792))+(((0.36)*x791))+(((0.12)*x797))+(((-0.94)*x798)));\nIkReal x800=((((-1.0)*(12.0)*pz))+(((1.08)*x791))+(((-1.08)*x793))+(((-0.36)*x795))+(((-0.36)*x792))+(((0.36)*x797))+(((2.82)*x796))+(((-2.82)*x798))+(((2.82)*x794)));\nop[0]=((1.0)+x799);\nop[1]=0;\nop[2]=((1.0)+x800);\nop[3]=0;\nop[4]=((-1.0)+x800);\nop[5]=0;\nop[6]=((-1.0)+x799);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x801=(cj16*r10);\nIkReal x802=(cj16*r20);\nIkReal x803=(r11*sj16);\nIkReal x804=(r21*sj16);\nIkReal x805=(r22*sj15);\nIkReal x806=(cj15*cj16*r20);\nIkReal x807=(cj15*r21*sj16);\nIkReal x808=((((-1.0)*(0.12)*py))+(((0.0846)*x802))+(((0.2245)*x805))+(((-0.2245)*x807))+(((0.0108)*x801))+(((-1.0)*(0.94)*pz))+(((-0.0108)*x803))+(((-0.0846)*x804))+(((0.2245)*x806)));\nIkReal x809=((((-1.0)*(0.36)*py))+(((-0.6735)*x807))+(((-0.0324)*x803))+(((0.6735)*x805))+(((0.2538)*x802))+(((0.0324)*x801))+(((-1.0)*(2.82)*pz))+(((0.6735)*x806))+(((-0.2538)*x804)));\nj12evalpoly[0]=((-0.235)+(((htj12*htj12)*(((-0.235)+x809))))+x808+(((-1.0)*(0.12)*(htj12*htj12*htj12)))+(((htj12*htj12*htj12*htj12)*(((0.235)+x809))))+(((-1.0)*(0.06)*htj12))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((0.235)+x808))))+(((-1.0)*(0.06)*(htj12*htj12*htj12*htj12*htj12))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x810=(r22*sj15);\nIkReal x811=((1.0)*cj12);\nIkReal x812=(r12*sj15);\nIkReal x813=(cj12*cj15*sj16);\nIkReal x814=(cj15*sj12);\nIkReal x815=(cj16*r20);\nIkReal x816=(cj16*r10);\nIkReal x817=((1.0)*cj12*cj15);\nIkReal x818=((1.0)*cj15*sj12);\nif( IKabs(((((-1.0)*x816*x817))+((x814*x815))+((r11*x813))+((sj12*x810))+(((-1.0)*x811*x812))+(((-1.0)*r21*sj16*x818)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x810*x811))+((r11*sj16*x814))+(((-1.0)*x815*x817))+((r21*x813))+(((-1.0)*sj12*x812))+(((-1.0)*x816*x818)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x816*x817))+((x814*x815))+((r11*x813))+((sj12*x810))+(((-1.0)*x811*x812))+(((-1.0)*r21*sj16*x818))))+IKsqr(((((-1.0)*x810*x811))+((r11*sj16*x814))+(((-1.0)*x815*x817))+((r21*x813))+(((-1.0)*sj12*x812))+(((-1.0)*x816*x818))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*x816*x817))+((x814*x815))+((r11*x813))+((sj12*x810))+(((-1.0)*x811*x812))+(((-1.0)*r21*sj16*x818))), ((((-1.0)*x810*x811))+((r11*sj16*x814))+(((-1.0)*x815*x817))+((r21*x813))+(((-1.0)*sj12*x812))+(((-1.0)*x816*x818))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x819=IKsin(j13);\nIkReal x820=(cj12*x819);\nIkReal x821=IKcos(j13);\nIkReal x822=(sj12*x821);\nIkReal x823=(cj15*cj16);\nIkReal x824=((1.0)*cj15*sj16);\nIkReal x825=(cj12*x821);\nIkReal x826=(sj12*x819);\nIkReal x827=((((-1.0)*x826))+x825);\nIkReal x828=(cj16*sj14);\nIkReal x829=(sj14*sj16);\nIkReal x830=((1.0)*cj14*cj15);\nIkReal x831=(cj14*cj16*sj15);\nIkReal x832=((1.0)*cj14*sj15*sj16);\nIkReal x833=((0.09)*cj16);\nIkReal x834=((0.09)*sj16);\nevalcond[0]=((((-1.0)*r11*x824))+((r12*sj15))+x820+x822+((r10*x823)));\nevalcond[1]=(((r22*sj15))+(((-1.0)*r21*x824))+((r20*x823))+x827);\nevalcond[2]=((((-1.0)*r12*x830))+((r11*x828))+x827+((r10*x831))+(((-1.0)*r11*x832))+((r10*x829)));\nevalcond[3]=((((-1.0)*x820))+((r20*x829))+(((-1.0)*x822))+(((-1.0)*r21*x832))+((r20*x831))+((r21*x828))+(((-1.0)*r22*x830)));\nevalcond[4]=((((-1.0)*r21*x834))+(((-1.0)*(1.0)*pz))+(((0.235)*x826))+(((-0.235)*x825))+(((0.03)*x822))+(((-1.0)*(0.25)*cj12))+(((0.03)*x820))+((r20*x833)));\nevalcond[5]=((((-0.235)*x820))+(((0.03)*x826))+(((-1.0)*(1.0)*py))+(((-1.0)*(0.25)*sj12))+(((-0.03)*x825))+(((-1.0)*r11*x834))+((r10*x833))+(((-0.235)*x822)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nIkReal x835=(cj16*r00);\nIkReal x836=(r01*sj16);\nevalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j11)))), 6.28318530717959)));\nevalcond[1]=(((r02*sj15))+((cj15*x835))+(((-1.0)*cj15*x836)));\nevalcond[2]=((0.095)+(((-0.09)*x836))+(((-1.0)*(1.0)*px))+(((0.09)*x835)));\nif( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )\n{\nbgotonextstatement=false;\n{\nIkReal j14eval[3];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x837=((1.0)*cj15);\nIkReal x838=(((cj15*cj16*r10))+(((-1.0)*r11*sj16*x837))+((r12*sj15)));\nj14eval[0]=x838;\nj14eval[1]=IKsign(x838);\nj14eval[2]=((IKabs((((cj16*r20*sj15))+(((-1.0)*r22*x837))+(((-1.0)*(1.0)*r21*sj15*sj16)))))+(IKabs((((cj16*r21))+((r20*sj16))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x839=((1.0)*sj15);\nIkReal x840=((1.0)*cj15);\nIkReal x841=((((-1.0)*cj16*r20*x840))+(((-1.0)*r22*x839))+((cj15*r21*sj16)));\nj14eval[0]=x841;\nj14eval[1]=IKsign(x841);\nj14eval[2]=((IKabs((((r10*sj16))+((cj16*r11)))))+(IKabs(((((-1.0)*r11*sj16*x839))+((cj16*r10*sj15))+(((-1.0)*r12*x840))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\n{\nIkReal j14eval[3];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x842=r00*r00;\nIkReal x843=r01*r01;\nIkReal x844=cj15*cj15;\nIkReal x845=((2.0)*cj15*r02);\nIkReal x846=(cj16*r00*sj15);\nIkReal x847=(r01*sj15*sj16);\nIkReal x848=(x843*x844);\nIkReal x849=(r00*sj16);\nIkReal x850=cj16*cj16;\nIkReal x851=(((x848*x850))+((x845*x847))+(((-1.0)*x842*x844*x850))+x843+x842+(((-1.0)*x848))+(((-1.0)*x845*x846))+(((2.0)*cj16*r01*x844*x849))+((x844*(r02*r02))));\nj14eval[0]=x851;\nj14eval[1]=IKsign(x851);\nj14eval[2]=((IKabs((x849+((cj16*r01)))))+(IKabs((x847+(((-1.0)*x846))+((cj15*r02))))));\nif( IKabs(j14eval[0]) < 0.0000010000000000  || IKabs(j14eval[1]) < 0.0000010000000000  || IKabs(j14eval[2]) < 0.0000010000000000  )\n{\ncontinue; // no branches [j12, j13, j14]\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x852=(r01*sj15*sj16);\nIkReal x853=(cj16*r00*sj15);\nIkReal x854=(r00*sj16);\nIkReal x855=r00*r00;\nIkReal x856=r01*r01;\nIkReal x857=cj15*cj15;\nIkReal x858=((2.0)*cj15*r02);\nIkReal x859=(x856*x857);\nIkReal x860=cj16*cj16;\nCheckValue<IkReal> x861=IKPowWithIntegerCheck(IKsign(((((-1.0)*x853*x858))+(((-1.0)*x859))+((x857*(r02*r02)))+(((2.0)*cj16*r01*x854*x857))+((x859*x860))+x855+x856+((x852*x858))+(((-1.0)*x855*x857*x860)))),-1);\nif(!x861.valid){\ncontinue;\n}\nCheckValue<IkReal> x862 = IKatan2WithCheck(IkReal(((((-1.0)*x853))+x852+((cj15*r02)))),IkReal((x854+((cj16*r01)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x862.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x861.value)))+(x862.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x863=IKsin(j14);\nIkReal x864=(cj16*r01);\nIkReal x865=(r00*sj16);\nIkReal x866=IKcos(j14);\nIkReal x867=((1.0)*cj15*r02);\nIkReal x868=(cj16*r00*sj15);\nIkReal x869=(r01*sj15);\nIkReal x870=((1.0)*sj16*x866);\nIkReal x871=((1.0)*cj15*x863);\nIkReal x872=((1.0)*cj16*x866);\nIkReal x873=(cj16*sj15*x863);\nIkReal x874=((1.0)*sj15*sj16*x863);\nIkReal x875=((1.0)*x866);\nevalcond[0]=((((-1.0)*x866*x867))+((x863*x864))+((x863*x865))+(((-1.0)*x869*x870))+((x866*x868)));\nevalcond[1]=((((-1.0)*r21*x874))+(((-1.0)*r20*x870))+(((-1.0)*r22*x871))+((r20*x873))+(((-1.0)*r21*x872)));\nevalcond[2]=((((-1.0)*r10*x870))+(((-1.0)*r11*x874))+(((-1.0)*r12*x871))+(((-1.0)*r11*x872))+((r10*x873)));\nevalcond[3]=((1.0)+(((-1.0)*sj16*x863*x869))+(((-1.0)*x865*x875))+((x863*x868))+(((-1.0)*x863*x867))+(((-1.0)*x864*x875)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x876=(cj16*r20);\nIkReal x877=(r12*sj15);\nIkReal x878=(r21*sj16);\nIkReal x879=(r22*sj15);\nIkReal x880=(cj15*cj16*r10);\nIkReal x881=(cj15*cj16*r20);\nIkReal x882=(cj15*r11*sj16);\nIkReal x883=(cj15*r21*sj16);\nIkReal x884=((((-0.36)*x880))+(((-1.08)*x876))+(((-2.82)*x881))+(((-0.36)*x877))+(((-2.82)*x879))+(((2.82)*x883))+(((1.08)*x878))+(((0.36)*x882))+(((12.0)*pz)));\nj12eval[0]=((IKabs(((1.0)+x884)))+(IKabs(((-1.0)+x884)))+(IKabs(((-1.0)+(((-0.94)*x879))+(((-0.12)*x880))+(((-0.36)*x876))+(((0.36)*x878))+(((4.0)*pz))+(((0.12)*x882))+(((-0.94)*x881))+(((-0.12)*x877))+(((0.94)*x883))))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x885=(cj16*r20);\nIkReal x886=(r12*sj15);\nIkReal x887=(r21*sj16);\nIkReal x888=(r22*sj15);\nIkReal x889=(cj15*cj16*r10);\nIkReal x890=(cj15*cj16*r20);\nIkReal x891=(cj15*r11*sj16);\nIkReal x892=(cj15*r21*sj16);\nIkReal x893=((((0.12)*x891))+(((-0.94)*x890))+(((-0.36)*x885))+(((0.36)*x887))+(((-0.94)*x888))+(((4.0)*pz))+(((-0.12)*x889))+(((-0.12)*x886))+(((0.94)*x892)));\nIkReal x894=((((-1.08)*x885))+(((-0.36)*x886))+(((2.82)*x892))+(((-2.82)*x888))+(((-0.36)*x889))+(((1.08)*x887))+(((0.36)*x891))+(((-2.82)*x890))+(((12.0)*pz)));\nop[0]=((-1.0)+x893);\nop[1]=0;\nop[2]=((-1.0)+x894);\nop[3]=0;\nop[4]=((1.0)+x894);\nop[5]=0;\nop[6]=((1.0)+x893);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x895=(cj16*r20);\nIkReal x896=((0.36)*x895);\nIkReal x897=(r21*sj16);\nIkReal x898=((0.36)*x897);\nIkReal x899=(r22*sj15);\nIkReal x900=(cj14*cj15*r22);\nIkReal x901=(cj15*cj16*r20);\nIkReal x902=(cj15*r21*sj16);\nIkReal x903=(cj16*r21*sj14);\nIkReal x904=(r20*sj14*sj16);\nIkReal x905=((0.12)*cj14*sj15);\nIkReal x906=((((0.94)*x899))+(((-1.0)*x898))+(((0.94)*x901))+(((-1.0)*(4.0)*pz))+(((0.12)*x903))+(((-1.0)*x897*x905))+(((0.12)*x904))+((x895*x905))+(((-0.12)*x900))+x896+(((-0.94)*x902)));\nIkReal x907=(cj14*sj15);\nIkReal x908=((((-1.08)*x897))+(((1.08)*x895))+(((-1.0)*(12.0)*pz))+(((-2.82)*x902))+(((2.82)*x899))+(((0.36)*x904))+(((0.36)*x903))+(((-0.36)*x900))+(((-1.0)*x898*x907))+(((2.82)*x901))+((x896*x907)));\nj12evalpoly[0]=((-1.0)+x906+(((htj12*htj12)*(((-1.0)+x908))))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((1.0)+x906))))+(((htj12*htj12*htj12*htj12)*(((1.0)+x908)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x909=(r12*sj15);\nIkReal x910=(r22*sj15);\nIkReal x911=(cj12*cj15);\nIkReal x912=(cj16*r10);\nIkReal x913=(cj15*sj12);\nIkReal x914=(cj16*r20);\nIkReal x915=(r11*sj16);\nIkReal x916=((1.0)*cj12*cj15);\nIkReal x917=(r21*sj16);\nIkReal x918=((1.0)*cj15*sj12);\nif( IKabs(((((-1.0)*x915*x916))+((x913*x914))+((x911*x912))+((cj12*x909))+(((-1.0)*x917*x918))+((sj12*x910)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj12*x910))+((sj12*x909))+(((-1.0)*x915*x918))+((x911*x917))+(((-1.0)*x914*x916))+((x912*x913)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x915*x916))+((x913*x914))+((x911*x912))+((cj12*x909))+(((-1.0)*x917*x918))+((sj12*x910))))+IKsqr(((((-1.0)*cj12*x910))+((sj12*x909))+(((-1.0)*x915*x918))+((x911*x917))+(((-1.0)*x914*x916))+((x912*x913))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*x915*x916))+((x913*x914))+((x911*x912))+((cj12*x909))+(((-1.0)*x917*x918))+((sj12*x910))), ((((-1.0)*cj12*x910))+((sj12*x909))+(((-1.0)*x915*x918))+((x911*x917))+(((-1.0)*x914*x916))+((x912*x913))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x919=IKcos(j13);\nIkReal x920=(cj12*x919);\nIkReal x921=(cj15*cj16);\nIkReal x922=IKsin(j13);\nIkReal x923=(sj12*x922);\nIkReal x924=((1.0)*cj15*sj16);\nIkReal x925=(cj12*x922);\nIkReal x926=(sj12*x919);\nIkReal x927=((((-1.0)*x925))+(((-1.0)*x926)));\nIkReal x928=(cj16*sj14);\nIkReal x929=(sj14*sj16);\nIkReal x930=((1.0)*cj14*cj15);\nIkReal x931=(cj14*cj16*sj15);\nIkReal x932=((1.0)*cj14*sj15*sj16);\nIkReal x933=((0.09)*cj16);\nIkReal x934=((0.09)*sj16);\nevalcond[0]=(((r22*sj15))+(((-1.0)*r21*x924))+((r20*x921))+(((-1.0)*x923))+x920);\nevalcond[1]=(((r12*sj15))+((r10*x921))+(((-1.0)*r11*x924))+x927);\nevalcond[2]=(((r11*x928))+(((-1.0)*r11*x932))+(((-1.0)*x920))+((r10*x929))+(((-1.0)*r12*x930))+x923+((r10*x931)));\nevalcond[3]=(((r21*x928))+(((-1.0)*r21*x932))+((r20*x931))+(((-1.0)*r22*x930))+x927+((r20*x929)));\nevalcond[4]=((((-1.0)*(1.0)*pz))+(((0.03)*x925))+(((0.03)*x926))+(((-1.0)*r21*x934))+(((-0.235)*x920))+(((0.235)*x923))+(((-1.0)*(0.25)*cj12))+((r20*x933)));\nevalcond[5]=((((-1.0)*(1.0)*py))+(((0.235)*x926))+(((0.235)*x925))+(((-0.03)*x923))+(((0.25)*sj12))+((r10*x933))+(((-1.0)*r11*x934))+(((0.03)*x920)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x935=((1.0)*sj15);\nIkReal x936=((1.0)*cj15);\nCheckValue<IkReal> x937=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj16*r20*x936))+(((-1.0)*r22*x935))+((cj15*r21*sj16)))),-1);\nif(!x937.valid){\ncontinue;\n}\nCheckValue<IkReal> x938 = IKatan2WithCheck(IkReal((((r10*sj16))+((cj16*r11)))),IkReal(((((-1.0)*r11*sj16*x935))+((cj16*r10*sj15))+(((-1.0)*r12*x936)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x938.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x937.value)))+(x938.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x939=IKsin(j14);\nIkReal x940=(cj16*r01);\nIkReal x941=(r00*sj16);\nIkReal x942=IKcos(j14);\nIkReal x943=((1.0)*cj15*r02);\nIkReal x944=(cj16*r00*sj15);\nIkReal x945=(r01*sj15);\nIkReal x946=((1.0)*sj16*x942);\nIkReal x947=((1.0)*cj15*x939);\nIkReal x948=((1.0)*cj16*x942);\nIkReal x949=(cj16*sj15*x939);\nIkReal x950=((1.0)*sj15*sj16*x939);\nIkReal x951=((1.0)*x942);\nevalcond[0]=((((-1.0)*x945*x946))+((x942*x944))+(((-1.0)*x942*x943))+((x939*x941))+((x939*x940)));\nevalcond[1]=(((r20*x949))+(((-1.0)*r21*x948))+(((-1.0)*r22*x947))+(((-1.0)*r20*x946))+(((-1.0)*r21*x950)));\nevalcond[2]=((((-1.0)*r11*x950))+((r10*x949))+(((-1.0)*r12*x947))+(((-1.0)*r11*x948))+(((-1.0)*r10*x946)));\nevalcond[3]=((1.0)+(((-1.0)*x941*x951))+(((-1.0)*x940*x951))+(((-1.0)*sj16*x939*x945))+((x939*x944))+(((-1.0)*x939*x943)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x952=(cj16*r20);\nIkReal x953=(r12*sj15);\nIkReal x954=(r21*sj16);\nIkReal x955=(r22*sj15);\nIkReal x956=(cj15*cj16*r10);\nIkReal x957=(cj15*cj16*r20);\nIkReal x958=(cj15*r11*sj16);\nIkReal x959=(cj15*r21*sj16);\nIkReal x960=((((-1.08)*x952))+(((-2.82)*x957))+(((-0.36)*x953))+(((2.82)*x959))+(((-2.82)*x955))+(((0.36)*x958))+(((12.0)*pz))+(((-0.36)*x956))+(((1.08)*x954)));\nj12eval[0]=((IKabs(((1.0)+x960)))+(IKabs(((-1.0)+x960)))+(IKabs(((-1.0)+(((-0.36)*x952))+(((-0.12)*x953))+(((0.36)*x954))+(((4.0)*pz))+(((-0.94)*x957))+(((0.94)*x959))+(((-0.94)*x955))+(((0.12)*x958))+(((-0.12)*x956))))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x961=(cj16*r20);\nIkReal x962=(r12*sj15);\nIkReal x963=(r21*sj16);\nIkReal x964=(r22*sj15);\nIkReal x965=(cj15*cj16*r10);\nIkReal x966=(cj15*cj16*r20);\nIkReal x967=(cj15*r11*sj16);\nIkReal x968=(cj15*r21*sj16);\nIkReal x969=((((0.12)*x967))+(((-0.94)*x964))+(((-0.36)*x961))+(((0.94)*x968))+(((0.36)*x963))+(((4.0)*pz))+(((-0.12)*x965))+(((-0.94)*x966))+(((-0.12)*x962)));\nIkReal x970=((((-2.82)*x964))+(((2.82)*x968))+(((1.08)*x963))+(((-0.36)*x962))+(((0.36)*x967))+(((-2.82)*x966))+(((-0.36)*x965))+(((-1.08)*x961))+(((12.0)*pz)));\nop[0]=((-1.0)+x969);\nop[1]=0;\nop[2]=((-1.0)+x970);\nop[3]=0;\nop[4]=((1.0)+x970);\nop[5]=0;\nop[6]=((1.0)+x969);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x971=(cj16*r20);\nIkReal x972=((0.36)*x971);\nIkReal x973=(r21*sj16);\nIkReal x974=((0.36)*x973);\nIkReal x975=(r22*sj15);\nIkReal x976=(cj14*cj15*r22);\nIkReal x977=(cj15*cj16*r20);\nIkReal x978=(cj15*r21*sj16);\nIkReal x979=(cj16*r21*sj14);\nIkReal x980=(r20*sj14*sj16);\nIkReal x981=((0.12)*cj14*sj15);\nIkReal x982=((((0.12)*x979))+(((-0.94)*x978))+(((-1.0)*x974))+((x971*x981))+(((-1.0)*(4.0)*pz))+(((-0.12)*x976))+(((0.94)*x975))+(((-1.0)*x973*x981))+x972+(((0.94)*x977))+(((0.12)*x980)));\nIkReal x983=(cj14*sj15);\nIkReal x984=((((-1.0)*(12.0)*pz))+(((1.08)*x971))+(((0.36)*x980))+(((-1.08)*x973))+(((-1.0)*x974*x983))+(((-2.82)*x978))+(((2.82)*x975))+(((-0.36)*x976))+(((2.82)*x977))+(((0.36)*x979))+((x972*x983)));\nj12evalpoly[0]=((-1.0)+(((htj12*htj12)*(((-1.0)+x984))))+(((htj12*htj12*htj12*htj12)*(((1.0)+x984))))+x982+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((1.0)+x982)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x985=(r12*sj15);\nIkReal x986=(r22*sj15);\nIkReal x987=(cj12*cj15);\nIkReal x988=(cj16*r10);\nIkReal x989=(cj15*sj12);\nIkReal x990=(cj16*r20);\nIkReal x991=(r11*sj16);\nIkReal x992=((1.0)*cj12*cj15);\nIkReal x993=(r21*sj16);\nIkReal x994=((1.0)*cj15*sj12);\nif( IKabs(((((-1.0)*x991*x992))+(((-1.0)*x993*x994))+((x987*x988))+((sj12*x986))+((x989*x990))+((cj12*x985)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj12*x985))+(((-1.0)*cj12*x986))+((x988*x989))+(((-1.0)*x990*x992))+(((-1.0)*x991*x994))+((x987*x993)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x991*x992))+(((-1.0)*x993*x994))+((x987*x988))+((sj12*x986))+((x989*x990))+((cj12*x985))))+IKsqr((((sj12*x985))+(((-1.0)*cj12*x986))+((x988*x989))+(((-1.0)*x990*x992))+(((-1.0)*x991*x994))+((x987*x993))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*x991*x992))+(((-1.0)*x993*x994))+((x987*x988))+((sj12*x986))+((x989*x990))+((cj12*x985))), (((sj12*x985))+(((-1.0)*cj12*x986))+((x988*x989))+(((-1.0)*x990*x992))+(((-1.0)*x991*x994))+((x987*x993))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x995=IKcos(j13);\nIkReal x996=(cj12*x995);\nIkReal x997=(cj15*cj16);\nIkReal x998=IKsin(j13);\nIkReal x999=(sj12*x998);\nIkReal x1000=((1.0)*cj15*sj16);\nIkReal x1001=(cj12*x998);\nIkReal x1002=(sj12*x995);\nIkReal x1003=((((-1.0)*x1002))+(((-1.0)*x1001)));\nIkReal x1004=(cj16*sj14);\nIkReal x1005=(sj14*sj16);\nIkReal x1006=((1.0)*cj14*cj15);\nIkReal x1007=(cj14*cj16*sj15);\nIkReal x1008=((1.0)*cj14*sj15*sj16);\nIkReal x1009=((0.09)*cj16);\nIkReal x1010=((0.09)*sj16);\nevalcond[0]=(((r22*sj15))+(((-1.0)*x999))+(((-1.0)*r21*x1000))+((r20*x997))+x996);\nevalcond[1]=(((r12*sj15))+(((-1.0)*r11*x1000))+x1003+((r10*x997)));\nevalcond[2]=((((-1.0)*x996))+(((-1.0)*r12*x1006))+((r10*x1005))+(((-1.0)*r11*x1008))+((r10*x1007))+((r11*x1004))+x999);\nevalcond[3]=(((r21*x1004))+x1003+((r20*x1007))+(((-1.0)*r22*x1006))+(((-1.0)*r21*x1008))+((r20*x1005)));\nevalcond[4]=((((-0.235)*x996))+((r20*x1009))+(((-1.0)*(1.0)*pz))+(((-1.0)*r21*x1010))+(((0.03)*x1002))+(((0.235)*x999))+(((0.03)*x1001))+(((-1.0)*(0.25)*cj12)));\nevalcond[5]=((((-1.0)*(1.0)*py))+(((0.03)*x996))+(((-0.03)*x999))+(((0.235)*x1002))+(((0.25)*sj12))+(((0.235)*x1001))+(((-1.0)*r11*x1010))+((r10*x1009)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x1011=((1.0)*cj15);\nCheckValue<IkReal> x1012=IKPowWithIntegerCheck(IKsign(((((-1.0)*r11*sj16*x1011))+((cj15*cj16*r10))+((r12*sj15)))),-1);\nif(!x1012.valid){\ncontinue;\n}\nCheckValue<IkReal> x1013 = IKatan2WithCheck(IkReal((((cj16*r21))+((r20*sj16)))),IkReal(((((-1.0)*r22*x1011))+((cj16*r20*sj15))+(((-1.0)*(1.0)*r21*sj15*sj16)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1013.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1012.value)))+(x1013.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[4];\nIkReal x1014=IKsin(j14);\nIkReal x1015=(cj16*r01);\nIkReal x1016=(r00*sj16);\nIkReal x1017=IKcos(j14);\nIkReal x1018=((1.0)*cj15*r02);\nIkReal x1019=(cj16*r00*sj15);\nIkReal x1020=(r01*sj15);\nIkReal x1021=((1.0)*sj16*x1017);\nIkReal x1022=((1.0)*cj15*x1014);\nIkReal x1023=((1.0)*cj16*x1017);\nIkReal x1024=(cj16*sj15*x1014);\nIkReal x1025=((1.0)*sj15*sj16*x1014);\nIkReal x1026=((1.0)*x1017);\nevalcond[0]=((((-1.0)*x1017*x1018))+(((-1.0)*x1020*x1021))+((x1014*x1015))+((x1014*x1016))+((x1017*x1019)));\nevalcond[1]=(((r20*x1024))+(((-1.0)*r21*x1023))+(((-1.0)*r20*x1021))+(((-1.0)*r21*x1025))+(((-1.0)*r22*x1022)));\nevalcond[2]=((((-1.0)*r12*x1022))+(((-1.0)*r11*x1025))+((r10*x1024))+(((-1.0)*r10*x1021))+(((-1.0)*r11*x1023)));\nevalcond[3]=((1.0)+(((-1.0)*x1014*x1018))+((x1014*x1019))+(((-1.0)*sj16*x1014*x1020))+(((-1.0)*x1015*x1026))+(((-1.0)*x1016*x1026)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nsj11=-1.0;\ncj11=0;\nj11=-1.5707963267949;\nIkReal x1027=(cj16*r20);\nIkReal x1028=(r12*sj15);\nIkReal x1029=(r21*sj16);\nIkReal x1030=(r22*sj15);\nIkReal x1031=(cj15*cj16*r10);\nIkReal x1032=(cj15*cj16*r20);\nIkReal x1033=(cj15*r11*sj16);\nIkReal x1034=(cj15*r21*sj16);\nIkReal x1035=((((0.36)*x1033))+(((-1.08)*x1027))+(((-0.36)*x1028))+(((1.08)*x1029))+(((-2.82)*x1032))+(((2.82)*x1034))+(((-0.36)*x1031))+(((-2.82)*x1030))+(((12.0)*pz)));\nj12eval[0]=((IKabs(((1.0)+x1035)))+(IKabs(((-1.0)+x1035)))+(IKabs(((-1.0)+(((0.36)*x1029))+(((-0.12)*x1028))+(((0.12)*x1033))+(((4.0)*pz))+(((-0.36)*x1027))+(((-0.12)*x1031))+(((-0.94)*x1032))+(((-0.94)*x1030))+(((0.94)*x1034))))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x1036=(cj16*r20);\nIkReal x1037=(r12*sj15);\nIkReal x1038=(r21*sj16);\nIkReal x1039=(r22*sj15);\nIkReal x1040=(cj15*cj16*r10);\nIkReal x1041=(cj15*cj16*r20);\nIkReal x1042=(cj15*r11*sj16);\nIkReal x1043=(cj15*r21*sj16);\nIkReal x1044=((((-0.94)*x1039))+(((0.12)*x1042))+(((-0.94)*x1041))+(((-0.12)*x1037))+(((4.0)*pz))+(((-0.12)*x1040))+(((0.94)*x1043))+(((0.36)*x1038))+(((-0.36)*x1036)));\nIkReal x1045=((((-2.82)*x1041))+(((-0.36)*x1037))+(((-0.36)*x1040))+(((2.82)*x1043))+(((1.08)*x1038))+(((-1.08)*x1036))+(((12.0)*pz))+(((-2.82)*x1039))+(((0.36)*x1042)));\nop[0]=((-1.0)+x1044);\nop[1]=0;\nop[2]=((-1.0)+x1045);\nop[3]=0;\nop[4]=((1.0)+x1045);\nop[5]=0;\nop[6]=((1.0)+x1044);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x1046=(cj16*r20);\nIkReal x1047=((0.36)*x1046);\nIkReal x1048=(r21*sj16);\nIkReal x1049=((0.36)*x1048);\nIkReal x1050=(r22*sj15);\nIkReal x1051=(cj14*cj15*r22);\nIkReal x1052=(cj15*cj16*r20);\nIkReal x1053=(cj15*r21*sj16);\nIkReal x1054=(cj16*r21*sj14);\nIkReal x1055=(r20*sj14*sj16);\nIkReal x1056=((0.12)*cj14*sj15);\nIkReal x1057=((((-0.12)*x1051))+(((0.12)*x1054))+(((0.94)*x1050))+(((-1.0)*(4.0)*pz))+(((0.94)*x1052))+(((-0.94)*x1053))+x1047+((x1046*x1056))+(((0.12)*x1055))+(((-1.0)*x1049))+(((-1.0)*x1048*x1056)));\nIkReal x1058=(cj14*sj15);\nIkReal x1059=((((-0.36)*x1051))+(((-1.0)*(12.0)*pz))+(((-1.08)*x1048))+(((-2.82)*x1053))+(((0.36)*x1055))+(((0.36)*x1054))+(((-1.0)*x1049*x1058))+(((2.82)*x1050))+(((1.08)*x1046))+(((2.82)*x1052))+((x1047*x1058)));\nj12evalpoly[0]=((-1.0)+x1057+(((htj12*htj12*htj12*htj12)*(((1.0)+x1059))))+(((htj12*htj12)*(((-1.0)+x1059))))+(((htj12*htj12*htj12*htj12*htj12*htj12)*(((1.0)+x1057)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x1060=(r12*sj15);\nIkReal x1061=(r22*sj15);\nIkReal x1062=(cj12*cj15);\nIkReal x1063=(cj16*r10);\nIkReal x1064=(cj15*sj12);\nIkReal x1065=(cj16*r20);\nIkReal x1066=(r11*sj16);\nIkReal x1067=((1.0)*cj12*cj15);\nIkReal x1068=(r21*sj16);\nIkReal x1069=((1.0)*cj15*sj12);\nif( IKabs(((((-1.0)*x1068*x1069))+((x1064*x1065))+((cj12*x1060))+((sj12*x1061))+((x1062*x1063))+(((-1.0)*x1066*x1067)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x1063*x1064))+(((-1.0)*cj12*x1061))+(((-1.0)*x1066*x1069))+(((-1.0)*x1065*x1067))+((sj12*x1060))+((x1062*x1068)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1068*x1069))+((x1064*x1065))+((cj12*x1060))+((sj12*x1061))+((x1062*x1063))+(((-1.0)*x1066*x1067))))+IKsqr((((x1063*x1064))+(((-1.0)*cj12*x1061))+(((-1.0)*x1066*x1069))+(((-1.0)*x1065*x1067))+((sj12*x1060))+((x1062*x1068))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*x1068*x1069))+((x1064*x1065))+((cj12*x1060))+((sj12*x1061))+((x1062*x1063))+(((-1.0)*x1066*x1067))), (((x1063*x1064))+(((-1.0)*cj12*x1061))+(((-1.0)*x1066*x1069))+(((-1.0)*x1065*x1067))+((sj12*x1060))+((x1062*x1068))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[6];\nIkReal x1070=IKcos(j13);\nIkReal x1071=(cj12*x1070);\nIkReal x1072=(cj15*cj16);\nIkReal x1073=IKsin(j13);\nIkReal x1074=(sj12*x1073);\nIkReal x1075=((1.0)*cj15*sj16);\nIkReal x1076=(cj12*x1073);\nIkReal x1077=(sj12*x1070);\nIkReal x1078=((((-1.0)*x1076))+(((-1.0)*x1077)));\nIkReal x1079=(cj16*sj14);\nIkReal x1080=(sj14*sj16);\nIkReal x1081=((1.0)*cj14*cj15);\nIkReal x1082=(cj14*cj16*sj15);\nIkReal x1083=((1.0)*cj14*sj15*sj16);\nIkReal x1084=((0.09)*cj16);\nIkReal x1085=((0.09)*sj16);\nevalcond[0]=((((-1.0)*x1074))+((r22*sj15))+x1071+((r20*x1072))+(((-1.0)*r21*x1075)));\nevalcond[1]=(x1078+((r12*sj15))+(((-1.0)*r11*x1075))+((r10*x1072)));\nevalcond[2]=(((r10*x1082))+((r10*x1080))+(((-1.0)*x1071))+x1074+(((-1.0)*r12*x1081))+(((-1.0)*r11*x1083))+((r11*x1079)));\nevalcond[3]=(((r20*x1082))+(((-1.0)*r22*x1081))+x1078+(((-1.0)*r21*x1083))+((r20*x1080))+((r21*x1079)));\nevalcond[4]=((((0.03)*x1077))+(((-1.0)*(1.0)*pz))+(((-0.235)*x1071))+(((-1.0)*r21*x1085))+((r20*x1084))+(((0.03)*x1076))+(((-1.0)*(0.25)*cj12))+(((0.235)*x1074)));\nevalcond[5]=((((-1.0)*(1.0)*py))+(((0.235)*x1077))+(((0.235)*x1076))+(((-0.03)*x1074))+(((0.03)*x1071))+(((0.25)*sj12))+(((-1.0)*r11*x1085))+((r10*x1084)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n}\n} while(0);\nif( bgotonextstatement )\n{\nbool bgotonextstatement = true;\ndo\n{\nif( 1 )\n{\nbgotonextstatement=false;\ncontinue; // branch miss [j12, j13, j14]\n\n}\n} while(0);\nif( bgotonextstatement )\n{\n}\n}\n}\n}\n}\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x1086=((1.0)*cj16);\nIkReal x1087=((1.0)*cj11);\nIkReal x1088=(r11*sj11);\nIkReal x1089=(r10*sj11);\nIkReal x1090=(sj15*sj16);\nIkReal x1091=((1.0)*cj16*sj15);\nCheckValue<IkReal> x1092 = IKatan2WithCheck(IkReal(((((-1.0)*sj16*x1089))+(((-1.0)*r00*sj16*x1087))+(((-1.0)*x1086*x1088))+(((-1.0)*cj16*r01*x1087)))),IkReal((((cj11*cj15*r02))+((x1088*x1090))+((cj15*r12*sj11))+(((-1.0)*x1089*x1091))+(((-1.0)*cj11*r00*x1091))+((cj11*r01*x1090)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1092.valid){\ncontinue;\n}\nCheckValue<IkReal> x1093=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj15*r20*x1086))+(((-1.0)*r22*sj15))+((cj15*r21*sj16)))),-1);\nif(!x1093.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x1092.value)+(((1.5707963267949)*(x1093.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[3];\nIkReal x1094=IKsin(j14);\nIkReal x1095=((1.0)*cj15*x1094);\nIkReal x1096=IKcos(j14);\nIkReal x1097=((1.0)*cj16*x1096);\nIkReal x1098=((1.0)*sj16*x1096);\nIkReal x1099=(cj16*sj15*x1094);\nIkReal x1100=((1.0)*sj15*sj16*x1094);\nevalcond[0]=((((-1.0)*r22*x1095))+(((-1.0)*r21*x1100))+(((-1.0)*r20*x1098))+(((-1.0)*r21*x1097))+((r20*x1099)));\nevalcond[1]=((((-1.0)*r12*x1095))+(((-1.0)*r10*x1098))+cj11+((r10*x1099))+(((-1.0)*r11*x1100))+(((-1.0)*r11*x1097)));\nevalcond[2]=((((-1.0)*r00*x1098))+((r00*x1099))+(((-1.0)*r02*x1095))+(((-1.0)*r01*x1097))+(((-1.0)*r01*x1100))+(((-1.0)*(1.0)*sj11)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nIkReal x1101=(cj11*pz);\nIkReal x1102=(r02*sj15);\nIkReal x1103=(cj11*cj16*r20);\nIkReal x1104=(cj11*r21*sj16);\nIkReal x1105=(cj11*r22*sj15);\nIkReal x1106=(cj15*cj16*r00);\nIkReal x1107=(cj15*r01*sj16);\nIkReal x1108=(cj11*cj15*cj16*r20);\nIkReal x1109=(cj11*cj15*r21*sj16);\nIkReal x1110=((((-12.0)*x1101))+(((2.82)*x1108))+(((-2.82)*x1109))+(((-0.36)*x1102))+(((-0.36)*x1106))+(((0.36)*x1107))+(((1.08)*x1103))+(((-1.08)*x1104))+(((2.82)*x1105)));\nj12eval[0]=((IKabs(((((-1.0)*(1.0)*cj11))+x1110)))+(IKabs(((((0.12)*x1107))+(((0.94)*x1105))+cj11+(((-0.94)*x1109))+(((-0.12)*x1106))+(((0.94)*x1108))+(((-4.0)*x1101))+(((-0.36)*x1104))+(((-0.12)*x1102))+(((0.36)*x1103)))))+(IKabs((x1110+cj11))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x1111=(cj11*pz);\nIkReal x1112=(r02*sj15);\nIkReal x1113=(cj11*cj16*r20);\nIkReal x1114=(cj11*r21*sj16);\nIkReal x1115=(cj11*r22*sj15);\nIkReal x1116=(cj15*cj16*r00);\nIkReal x1117=(cj15*r01*sj16);\nIkReal x1118=(cj11*cj15*cj16*r20);\nIkReal x1119=(cj11*cj15*r21*sj16);\nIkReal x1120=((((-0.12)*x1112))+(((0.36)*x1113))+(((-4.0)*x1111))+(((0.94)*x1115))+(((-0.12)*x1116))+(((0.94)*x1118))+(((-0.36)*x1114))+(((0.12)*x1117))+(((-0.94)*x1119)));\nIkReal x1121=((((-0.36)*x1112))+(((1.08)*x1113))+(((0.36)*x1117))+(((2.82)*x1118))+(((2.82)*x1115))+(((-0.36)*x1116))+(((-12.0)*x1111))+(((-2.82)*x1119))+(((-1.08)*x1114)));\nIkReal x1122=((-1.0)*(((1.0)*cj11)));\nop[0]=(x1120+cj11);\nop[1]=0;\nop[2]=(x1121+cj11);\nop[3]=0;\nop[4]=(x1121+x1122);\nop[5]=0;\nop[6]=(x1122+x1120);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x1123=(pz*sj11);\nIkReal x1124=(r12*sj15);\nIkReal x1125=(cj15*cj16*r10);\nIkReal x1126=(cj15*r11*sj16);\nIkReal x1127=(cj16*r20*sj11);\nIkReal x1128=(r21*sj11*sj16);\nIkReal x1129=(r22*sj11*sj15);\nIkReal x1130=(cj15*cj16*r20*sj11);\nIkReal x1131=(cj15*r21*sj11*sj16);\nIkReal x1132=((((0.12)*x1126))+(((0.94)*x1129))+(((-0.36)*x1128))+(((0.94)*x1130))+(((-0.94)*x1131))+(((-4.0)*x1123))+(((0.36)*x1127))+(((-0.12)*x1125))+(((-0.12)*x1124)));\nIkReal x1133=((-1.0)*(((1.0)*sj11)));\nIkReal x1134=((((-0.36)*x1125))+(((2.82)*x1130))+(((1.08)*x1127))+(((-12.0)*x1123))+(((-2.82)*x1131))+(((-1.08)*x1128))+(((-0.36)*x1124))+(((0.36)*x1126))+(((2.82)*x1129)));\nj12evalpoly[0]=((((htj12*htj12*htj12*htj12)*((sj11+x1134))))+(((htj12*htj12*htj12*htj12*htj12*htj12)*((sj11+x1132))))+x1133+x1132+(((htj12*htj12)*((x1134+x1133)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x1135=(r22*sj15);\nIkReal x1136=(cj12*r21);\nIkReal x1137=(cj16*sj14);\nIkReal x1138=(r20*sj14*sj16);\nIkReal x1139=(cj15*cj16*r20);\nIkReal x1140=((1.0)*cj12);\nIkReal x1141=(cj14*cj15*r22);\nIkReal x1142=(cj15*sj16);\nIkReal x1143=((1.0)*r21*sj12);\nIkReal x1144=(cj14*cj16*r20*sj15);\nIkReal x1145=(cj14*sj15*sj16);\nif( IKabs(((((-1.0)*x1140*x1141))+(((-1.0)*cj12*r21*x1145))+((x1136*x1137))+(((-1.0)*x1142*x1143))+((sj12*x1139))+((cj12*x1144))+((cj12*x1138))+((sj12*x1135)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1139*x1140))+((sj12*x1144))+((sj12*x1138))+((r21*sj12*x1137))+(((-1.0)*x1135*x1140))+(((-1.0)*sj12*x1141))+((x1136*x1142))+(((-1.0)*x1143*x1145)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1140*x1141))+(((-1.0)*cj12*r21*x1145))+((x1136*x1137))+(((-1.0)*x1142*x1143))+((sj12*x1139))+((cj12*x1144))+((cj12*x1138))+((sj12*x1135))))+IKsqr(((((-1.0)*x1139*x1140))+((sj12*x1144))+((sj12*x1138))+((r21*sj12*x1137))+(((-1.0)*x1135*x1140))+(((-1.0)*sj12*x1141))+((x1136*x1142))+(((-1.0)*x1143*x1145))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2(((((-1.0)*x1140*x1141))+(((-1.0)*cj12*r21*x1145))+((x1136*x1137))+(((-1.0)*x1142*x1143))+((sj12*x1139))+((cj12*x1144))+((cj12*x1138))+((sj12*x1135))), ((((-1.0)*x1139*x1140))+((sj12*x1144))+((sj12*x1138))+((r21*sj12*x1137))+(((-1.0)*x1135*x1140))+(((-1.0)*sj12*x1141))+((x1136*x1142))+(((-1.0)*x1143*x1145))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[9];\nIkReal x1146=IKcos(j13);\nIkReal x1147=(cj12*x1146);\nIkReal x1148=(cj15*cj16);\nIkReal x1149=IKsin(j13);\nIkReal x1150=(sj12*x1149);\nIkReal x1151=((1.0)*x1150);\nIkReal x1152=((1.0)*cj15*sj16);\nIkReal x1153=(cj12*x1149);\nIkReal x1154=(cj11*x1153);\nIkReal x1155=(sj12*x1146);\nIkReal x1156=(cj11*x1155);\nIkReal x1157=(sj11*x1153);\nIkReal x1158=(sj11*x1155);\nIkReal x1159=(cj16*sj14);\nIkReal x1160=(sj14*sj16);\nIkReal x1161=((1.0)*cj14*cj15);\nIkReal x1162=(cj14*cj16*sj15);\nIkReal x1163=((1.0)*cj14*sj15*sj16);\nIkReal x1164=((0.09)*cj16);\nIkReal x1165=((0.09)*sj16);\nIkReal x1166=(cj11*x1147);\nIkReal x1167=(sj11*x1147);\nIkReal x1168=((0.25)*sj12);\nIkReal x1169=((0.03)*sj12*x1149);\nevalcond[0]=(((r22*sj15))+x1147+(((-1.0)*x1151))+((r20*x1148))+(((-1.0)*r21*x1152)));\nevalcond[1]=(x1154+x1156+((r02*sj15))+(((-1.0)*r01*x1152))+((r00*x1148)));\nevalcond[2]=(((r12*sj15))+x1158+x1157+(((-1.0)*r11*x1152))+((r10*x1148)));\nevalcond[3]=((((-1.0)*x1155))+((r21*x1159))+(((-1.0)*r21*x1163))+((r20*x1160))+(((-1.0)*r22*x1161))+(((-1.0)*x1153))+((r20*x1162)));\nevalcond[4]=((((-1.0)*(1.0)*pz))+((r20*x1164))+(((-1.0)*r21*x1165))+(((0.03)*x1155))+(((-0.235)*x1147))+(((0.235)*x1150))+(((-1.0)*(0.25)*cj12))+(((0.03)*x1153)));\nevalcond[5]=(((r01*x1159))+((r00*x1162))+(((-1.0)*cj11*x1151))+(((-1.0)*r01*x1163))+x1166+(((-1.0)*r02*x1161))+((r00*x1160)));\nevalcond[6]=((((-1.0)*sj11*x1151))+(((-1.0)*r12*x1161))+x1167+((r10*x1160))+((r11*x1159))+(((-1.0)*r11*x1163))+((r10*x1162)));\nevalcond[7]=((((-1.0)*(1.0)*px))+(((-1.0)*(0.095)*sj11))+(((-0.03)*x1166))+(((-0.235)*x1156))+((cj11*x1169))+((r00*x1164))+(((-0.235)*x1154))+(((-1.0)*r01*x1165))+(((-1.0)*cj11*x1168)));\nevalcond[8]=((((-1.0)*(1.0)*py))+((r10*x1164))+(((-1.0)*r11*x1165))+(((-0.03)*x1167))+(((0.095)*cj11))+(((-1.0)*sj11*x1168))+((sj11*x1169))+(((-0.235)*x1157))+(((-0.235)*x1158)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x1170=((1.0)*sj16);\nIkReal x1171=(r21*sj11);\nIkReal x1172=(r20*sj11);\nCheckValue<IkReal> x1173 = IKatan2WithCheck(IkReal(((((-1.0)*cj16*x1171))+(((-1.0)*x1170*x1172)))),IkReal((((cj15*r22*sj11))+((sj15*sj16*x1171))+(((-1.0)*cj16*sj15*x1172)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1173.valid){\ncontinue;\n}\nCheckValue<IkReal> x1174=IKPowWithIntegerCheck(IKsign((((cj15*cj16*r10))+((r12*sj15))+(((-1.0)*cj15*r11*x1170)))),-1);\nif(!x1174.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(x1173.value)+(((1.5707963267949)*(x1174.value))));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[3];\nIkReal x1175=IKsin(j14);\nIkReal x1176=((1.0)*cj15*x1175);\nIkReal x1177=IKcos(j14);\nIkReal x1178=((1.0)*cj16*x1177);\nIkReal x1179=((1.0)*sj16*x1177);\nIkReal x1180=(cj16*sj15*x1175);\nIkReal x1181=((1.0)*sj15*sj16*x1175);\nevalcond[0]=((((-1.0)*r20*x1179))+((r20*x1180))+(((-1.0)*r21*x1181))+(((-1.0)*r21*x1178))+(((-1.0)*r22*x1176)));\nevalcond[1]=((((-1.0)*r10*x1179))+(((-1.0)*r11*x1178))+cj11+((r10*x1180))+(((-1.0)*r11*x1181))+(((-1.0)*r12*x1176)));\nevalcond[2]=((((-1.0)*r01*x1178))+(((-1.0)*r01*x1181))+(((-1.0)*r00*x1179))+((r00*x1180))+(((-1.0)*(1.0)*sj11))+(((-1.0)*r02*x1176)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nIkReal x1182=(cj11*pz);\nIkReal x1183=(r02*sj15);\nIkReal x1184=(cj11*cj16*r20);\nIkReal x1185=(cj11*r21*sj16);\nIkReal x1186=(cj11*r22*sj15);\nIkReal x1187=(cj15*cj16*r00);\nIkReal x1188=(cj15*r01*sj16);\nIkReal x1189=(cj11*cj15*cj16*r20);\nIkReal x1190=(cj11*cj15*r21*sj16);\nIkReal x1191=((((-2.82)*x1190))+(((2.82)*x1189))+(((-0.36)*x1187))+(((-0.36)*x1183))+(((0.36)*x1188))+(((1.08)*x1184))+(((-1.08)*x1185))+(((-12.0)*x1182))+(((2.82)*x1186)));\nj12eval[0]=((IKabs(((((0.94)*x1189))+(((-4.0)*x1182))+cj11+(((-0.94)*x1190))+(((0.94)*x1186))+(((0.36)*x1184))+(((-0.36)*x1185))+(((-0.12)*x1183))+(((-0.12)*x1187))+(((0.12)*x1188)))))+(IKabs(((((-1.0)*(1.0)*cj11))+x1191)))+(IKabs((cj11+x1191))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x1192=(cj11*pz);\nIkReal x1193=(r02*sj15);\nIkReal x1194=(cj11*cj16*r20);\nIkReal x1195=(cj11*r21*sj16);\nIkReal x1196=(cj11*r22*sj15);\nIkReal x1197=(cj15*cj16*r00);\nIkReal x1198=(cj15*r01*sj16);\nIkReal x1199=(cj11*cj15*cj16*r20);\nIkReal x1200=(cj11*cj15*r21*sj16);\nIkReal x1201=((((0.94)*x1199))+(((0.12)*x1198))+(((0.94)*x1196))+(((-4.0)*x1192))+(((-0.36)*x1195))+(((-0.12)*x1193))+(((0.36)*x1194))+(((-0.12)*x1197))+(((-0.94)*x1200)));\nIkReal x1202=((((-0.36)*x1197))+(((1.08)*x1194))+(((0.36)*x1198))+(((-0.36)*x1193))+(((2.82)*x1199))+(((2.82)*x1196))+(((-1.08)*x1195))+(((-12.0)*x1192))+(((-2.82)*x1200)));\nIkReal x1203=((-1.0)*(((1.0)*cj11)));\nop[0]=(x1201+cj11);\nop[1]=0;\nop[2]=(x1202+cj11);\nop[3]=0;\nop[4]=(x1202+x1203);\nop[5]=0;\nop[6]=(x1203+x1201);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x1204=(pz*sj11);\nIkReal x1205=(r12*sj15);\nIkReal x1206=(cj15*cj16*r10);\nIkReal x1207=(cj15*r11*sj16);\nIkReal x1208=(cj16*r20*sj11);\nIkReal x1209=(r21*sj11*sj16);\nIkReal x1210=(r22*sj11*sj15);\nIkReal x1211=(cj15*cj16*r20*sj11);\nIkReal x1212=(cj15*r21*sj11*sj16);\nIkReal x1213=((((-0.12)*x1205))+(((0.36)*x1208))+(((-0.12)*x1206))+(((-0.94)*x1212))+(((0.12)*x1207))+(((0.94)*x1211))+(((-0.36)*x1209))+(((0.94)*x1210))+(((-4.0)*x1204)));\nIkReal x1214=((-1.0)*(((1.0)*sj11)));\nIkReal x1215=((((-1.08)*x1209))+(((0.36)*x1207))+(((-0.36)*x1206))+(((2.82)*x1211))+(((-2.82)*x1212))+(((2.82)*x1210))+(((-0.36)*x1205))+(((1.08)*x1208))+(((-12.0)*x1204)));\nj12evalpoly[0]=((((htj12*htj12*htj12*htj12*htj12*htj12)*((sj11+x1213))))+(((htj12*htj12)*((x1215+x1214))))+x1213+x1214+(((htj12*htj12*htj12*htj12)*((sj11+x1215)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x1216=(r22*sj15);\nIkReal x1217=(cj12*r21);\nIkReal x1218=(cj16*sj14);\nIkReal x1219=(r20*sj14*sj16);\nIkReal x1220=(cj15*cj16*r20);\nIkReal x1221=((1.0)*cj12);\nIkReal x1222=(cj14*cj15*r22);\nIkReal x1223=(cj15*sj16);\nIkReal x1224=((1.0)*r21*sj12);\nIkReal x1225=(cj14*cj16*r20*sj15);\nIkReal x1226=(cj14*sj15*sj16);\nif( IKabs((((cj12*x1219))+((x1217*x1218))+(((-1.0)*x1223*x1224))+((sj12*x1216))+(((-1.0)*x1221*x1222))+((sj12*x1220))+((cj12*x1225))+(((-1.0)*cj12*r21*x1226)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1220*x1221))+(((-1.0)*x1224*x1226))+((x1217*x1223))+((r21*sj12*x1218))+(((-1.0)*x1216*x1221))+((sj12*x1219))+((sj12*x1225))+(((-1.0)*sj12*x1222)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj12*x1219))+((x1217*x1218))+(((-1.0)*x1223*x1224))+((sj12*x1216))+(((-1.0)*x1221*x1222))+((sj12*x1220))+((cj12*x1225))+(((-1.0)*cj12*r21*x1226))))+IKsqr(((((-1.0)*x1220*x1221))+(((-1.0)*x1224*x1226))+((x1217*x1223))+((r21*sj12*x1218))+(((-1.0)*x1216*x1221))+((sj12*x1219))+((sj12*x1225))+(((-1.0)*sj12*x1222))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((cj12*x1219))+((x1217*x1218))+(((-1.0)*x1223*x1224))+((sj12*x1216))+(((-1.0)*x1221*x1222))+((sj12*x1220))+((cj12*x1225))+(((-1.0)*cj12*r21*x1226))), ((((-1.0)*x1220*x1221))+(((-1.0)*x1224*x1226))+((x1217*x1223))+((r21*sj12*x1218))+(((-1.0)*x1216*x1221))+((sj12*x1219))+((sj12*x1225))+(((-1.0)*sj12*x1222))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[9];\nIkReal x1227=IKcos(j13);\nIkReal x1228=(cj12*x1227);\nIkReal x1229=(cj15*cj16);\nIkReal x1230=IKsin(j13);\nIkReal x1231=(sj12*x1230);\nIkReal x1232=((1.0)*x1231);\nIkReal x1233=((1.0)*cj15*sj16);\nIkReal x1234=(cj12*x1230);\nIkReal x1235=(cj11*x1234);\nIkReal x1236=(sj12*x1227);\nIkReal x1237=(cj11*x1236);\nIkReal x1238=(sj11*x1234);\nIkReal x1239=(sj11*x1236);\nIkReal x1240=(cj16*sj14);\nIkReal x1241=(sj14*sj16);\nIkReal x1242=((1.0)*cj14*cj15);\nIkReal x1243=(cj14*cj16*sj15);\nIkReal x1244=((1.0)*cj14*sj15*sj16);\nIkReal x1245=((0.09)*cj16);\nIkReal x1246=((0.09)*sj16);\nIkReal x1247=(cj11*x1228);\nIkReal x1248=(sj11*x1228);\nIkReal x1249=((0.25)*sj12);\nIkReal x1250=((0.03)*sj12*x1230);\nevalcond[0]=(((r22*sj15))+(((-1.0)*r21*x1233))+(((-1.0)*x1232))+x1228+((r20*x1229)));\nevalcond[1]=(((r00*x1229))+((r02*sj15))+x1237+x1235+(((-1.0)*r01*x1233)));\nevalcond[2]=(((r10*x1229))+((r12*sj15))+x1238+x1239+(((-1.0)*r11*x1233)));\nevalcond[3]=((((-1.0)*r21*x1244))+(((-1.0)*x1234))+((r21*x1240))+((r20*x1243))+(((-1.0)*r22*x1242))+(((-1.0)*x1236))+((r20*x1241)));\nevalcond[4]=((((-1.0)*(1.0)*pz))+(((0.03)*x1234))+(((0.03)*x1236))+(((-0.235)*x1228))+((r20*x1245))+(((-1.0)*r21*x1246))+(((0.235)*x1231))+(((-1.0)*(0.25)*cj12)));\nevalcond[5]=((((-1.0)*r02*x1242))+(((-1.0)*cj11*x1232))+((r00*x1241))+((r00*x1243))+((r01*x1240))+(((-1.0)*r01*x1244))+x1247);\nevalcond[6]=((((-1.0)*sj11*x1232))+((r11*x1240))+((r10*x1241))+((r10*x1243))+x1248+(((-1.0)*r12*x1242))+(((-1.0)*r11*x1244)));\nevalcond[7]=((((-1.0)*(1.0)*px))+(((-1.0)*(0.095)*sj11))+(((-1.0)*r01*x1246))+(((-1.0)*cj11*x1249))+((cj11*x1250))+((r00*x1245))+(((-0.03)*x1247))+(((-0.235)*x1235))+(((-0.235)*x1237)));\nevalcond[8]=((((-0.235)*x1239))+(((-0.235)*x1238))+(((-1.0)*(1.0)*py))+((sj11*x1250))+(((-0.03)*x1248))+(((0.095)*cj11))+((r10*x1245))+(((-1.0)*sj11*x1249))+(((-1.0)*r11*x1246)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n\n} else\n{\n{\nIkReal j14array[1], cj14array[1], sj14array[1];\nbool j14valid[1]={false};\n_nj14 = 1;\nIkReal x1251=((1.0)*cj15);\nIkReal x1252=(cj11*cj16);\nIkReal x1253=(cj11*sj16);\nCheckValue<IkReal> x1254=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj16*r00*x1251))+((cj15*r01*sj16))+(((-1.0)*r02*sj15)))),-1);\nif(!x1254.valid){\ncontinue;\n}\nCheckValue<IkReal> x1255 = IKatan2WithCheck(IkReal((((r20*x1253))+((r21*x1252)))),IkReal(((((-1.0)*r21*sj15*x1253))+((r20*sj15*x1252))+(((-1.0)*cj11*r22*x1251)))),IKFAST_ATAN2_MAGTHRESH);\nif(!x1255.valid){\ncontinue;\n}\nj14array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1254.value)))+(x1255.value));\nsj14array[0]=IKsin(j14array[0]);\ncj14array[0]=IKcos(j14array[0]);\nif( j14array[0] > IKPI )\n{\n    j14array[0]-=IK2PI;\n}\nelse if( j14array[0] < -IKPI )\n{    j14array[0]+=IK2PI;\n}\nj14valid[0] = true;\nfor(int ij14 = 0; ij14 < 1; ++ij14)\n{\nif( !j14valid[ij14] )\n{\n    continue;\n}\n_ij14[0] = ij14; _ij14[1] = -1;\nfor(int iij14 = ij14+1; iij14 < 1; ++iij14)\n{\nif( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )\n{\n    j14valid[iij14]=false; _ij14[1] = iij14; break; \n}\n}\nj14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];\n{\nIkReal evalcond[3];\nIkReal x1256=IKsin(j14);\nIkReal x1257=((1.0)*cj15*x1256);\nIkReal x1258=IKcos(j14);\nIkReal x1259=((1.0)*cj16*x1258);\nIkReal x1260=((1.0)*sj16*x1258);\nIkReal x1261=(cj16*sj15*x1256);\nIkReal x1262=((1.0)*sj15*sj16*x1256);\nevalcond[0]=(((r20*x1261))+(((-1.0)*r22*x1257))+(((-1.0)*r21*x1259))+(((-1.0)*r20*x1260))+(((-1.0)*r21*x1262)));\nevalcond[1]=((((-1.0)*r11*x1262))+(((-1.0)*r11*x1259))+((r10*x1261))+cj11+(((-1.0)*r12*x1257))+(((-1.0)*r10*x1260)));\nevalcond[2]=((((-1.0)*r00*x1260))+(((-1.0)*r01*x1262))+(((-1.0)*r02*x1257))+((r00*x1261))+(((-1.0)*r01*x1259))+(((-1.0)*(1.0)*sj11)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nIkReal j12eval[1];\nIkReal x1263=(cj11*pz);\nIkReal x1264=(r02*sj15);\nIkReal x1265=(cj11*cj16*r20);\nIkReal x1266=(cj11*r21*sj16);\nIkReal x1267=(cj11*r22*sj15);\nIkReal x1268=(cj15*cj16*r00);\nIkReal x1269=(cj15*r01*sj16);\nIkReal x1270=(cj11*cj15*cj16*r20);\nIkReal x1271=(cj11*cj15*r21*sj16);\nIkReal x1272=((((0.36)*x1269))+(((-0.36)*x1264))+(((-2.82)*x1271))+(((2.82)*x1267))+(((-12.0)*x1263))+(((-0.36)*x1268))+(((1.08)*x1265))+(((2.82)*x1270))+(((-1.08)*x1266)));\nj12eval[0]=((IKabs((cj11+x1272)))+(IKabs(((((-0.12)*x1268))+(((0.94)*x1270))+(((-0.12)*x1264))+cj11+(((0.12)*x1269))+(((0.36)*x1265))+(((0.94)*x1267))+(((-4.0)*x1263))+(((-0.94)*x1271))+(((-0.36)*x1266)))))+(IKabs(((((-1.0)*(1.0)*cj11))+x1272))));\nif( IKabs(j12eval[0]) < 0.0000000010000000  )\n{\ncontinue; // no branches [j12, j13]\n\n} else\n{\nIkReal op[6+1], zeror[6];\nint numroots;\nIkReal j12evalpoly[1];\nIkReal x1273=(cj11*pz);\nIkReal x1274=(r02*sj15);\nIkReal x1275=(cj11*cj16*r20);\nIkReal x1276=(cj11*r21*sj16);\nIkReal x1277=(cj11*r22*sj15);\nIkReal x1278=(cj15*cj16*r00);\nIkReal x1279=(cj15*r01*sj16);\nIkReal x1280=(cj11*cj15*cj16*r20);\nIkReal x1281=(cj11*cj15*r21*sj16);\nIkReal x1282=((((-0.12)*x1274))+(((0.94)*x1280))+(((0.12)*x1279))+(((-0.12)*x1278))+(((-0.94)*x1281))+(((-0.36)*x1276))+(((0.36)*x1275))+(((-4.0)*x1273))+(((0.94)*x1277)));\nIkReal x1283=((((-2.82)*x1281))+(((-0.36)*x1278))+(((2.82)*x1280))+(((2.82)*x1277))+(((-1.08)*x1276))+(((-12.0)*x1273))+(((-0.36)*x1274))+(((0.36)*x1279))+(((1.08)*x1275)));\nIkReal x1284=((-1.0)*(((1.0)*cj11)));\nop[0]=(cj11+x1282);\nop[1]=0;\nop[2]=(cj11+x1283);\nop[3]=0;\nop[4]=(x1283+x1284);\nop[5]=0;\nop[6]=(x1282+x1284);\npolyroots6(op,zeror,numroots);\nIkReal j12array[6], cj12array[6], sj12array[6], tempj12array[1];\nint numsolutions = 0;\nfor(int ij12 = 0; ij12 < numroots; ++ij12)\n{\nIkReal htj12 = zeror[ij12];\ntempj12array[0]=((2.0)*(atan(htj12)));\nfor(int kj12 = 0; kj12 < 1; ++kj12)\n{\nj12array[numsolutions] = tempj12array[kj12];\nif( j12array[numsolutions] > IKPI )\n{\n    j12array[numsolutions]-=IK2PI;\n}\nelse if( j12array[numsolutions] < -IKPI )\n{\n    j12array[numsolutions]+=IK2PI;\n}\nsj12array[numsolutions] = IKsin(j12array[numsolutions]);\ncj12array[numsolutions] = IKcos(j12array[numsolutions]);\nnumsolutions++;\n}\n}\nbool j12valid[6]={true,true,true,true,true,true};\n_nj12 = 6;\nfor(int ij12 = 0; ij12 < numsolutions; ++ij12)\n    {\nif( !j12valid[ij12] )\n{\n    continue;\n}\n    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];\nhtj12 = IKtan(j12/2);\n\nIkReal x1285=(pz*sj11);\nIkReal x1286=(r12*sj15);\nIkReal x1287=(cj15*cj16*r10);\nIkReal x1288=(cj15*r11*sj16);\nIkReal x1289=(cj16*r20*sj11);\nIkReal x1290=(r21*sj11*sj16);\nIkReal x1291=(r22*sj11*sj15);\nIkReal x1292=(cj15*cj16*r20*sj11);\nIkReal x1293=(cj15*r21*sj11*sj16);\nIkReal x1294=((((-0.36)*x1290))+(((-0.94)*x1293))+(((-0.12)*x1287))+(((0.94)*x1292))+(((-0.12)*x1286))+(((0.94)*x1291))+(((-4.0)*x1285))+(((0.12)*x1288))+(((0.36)*x1289)));\nIkReal x1295=((-1.0)*(((1.0)*sj11)));\nIkReal x1296=((((2.82)*x1292))+(((1.08)*x1289))+(((2.82)*x1291))+(((-0.36)*x1286))+(((0.36)*x1288))+(((-12.0)*x1285))+(((-0.36)*x1287))+(((-2.82)*x1293))+(((-1.08)*x1290)));\nj12evalpoly[0]=((((htj12*htj12)*((x1295+x1296))))+(((htj12*htj12*htj12*htj12)*((x1296+sj11))))+x1294+x1295+(((htj12*htj12*htj12*htj12*htj12*htj12)*((x1294+sj11)))));\nif( IKabs(j12evalpoly[0]) > 0.0000000010000000  )\n{\n    continue;\n}\n_ij12[0] = ij12; _ij12[1] = -1;\nfor(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)\n{\nif( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )\n{\n    j12valid[iij12]=false; _ij12[1] = iij12; break; \n}\n}\n{\nIkReal j13array[1], cj13array[1], sj13array[1];\nbool j13valid[1]={false};\n_nj13 = 1;\nIkReal x1297=(r22*sj15);\nIkReal x1298=(cj12*r21);\nIkReal x1299=(cj16*sj14);\nIkReal x1300=(r20*sj14*sj16);\nIkReal x1301=(cj15*cj16*r20);\nIkReal x1302=((1.0)*cj12);\nIkReal x1303=(cj14*cj15*r22);\nIkReal x1304=(cj15*sj16);\nIkReal x1305=((1.0)*r21*sj12);\nIkReal x1306=(cj14*cj16*r20*sj15);\nIkReal x1307=(cj14*sj15*sj16);\nif( IKabs((((x1298*x1299))+((cj12*x1306))+((sj12*x1297))+(((-1.0)*x1302*x1303))+((sj12*x1301))+(((-1.0)*x1304*x1305))+(((-1.0)*cj12*r21*x1307))+((cj12*x1300)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1297*x1302))+((r21*sj12*x1299))+((x1298*x1304))+(((-1.0)*x1305*x1307))+(((-1.0)*sj12*x1303))+((sj12*x1306))+((sj12*x1300))+(((-1.0)*x1301*x1302)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1298*x1299))+((cj12*x1306))+((sj12*x1297))+(((-1.0)*x1302*x1303))+((sj12*x1301))+(((-1.0)*x1304*x1305))+(((-1.0)*cj12*r21*x1307))+((cj12*x1300))))+IKsqr(((((-1.0)*x1297*x1302))+((r21*sj12*x1299))+((x1298*x1304))+(((-1.0)*x1305*x1307))+(((-1.0)*sj12*x1303))+((sj12*x1306))+((sj12*x1300))+(((-1.0)*x1301*x1302))))-1) <= IKFAST_SINCOS_THRESH )\n    continue;\nj13array[0]=IKatan2((((x1298*x1299))+((cj12*x1306))+((sj12*x1297))+(((-1.0)*x1302*x1303))+((sj12*x1301))+(((-1.0)*x1304*x1305))+(((-1.0)*cj12*r21*x1307))+((cj12*x1300))), ((((-1.0)*x1297*x1302))+((r21*sj12*x1299))+((x1298*x1304))+(((-1.0)*x1305*x1307))+(((-1.0)*sj12*x1303))+((sj12*x1306))+((sj12*x1300))+(((-1.0)*x1301*x1302))));\nsj13array[0]=IKsin(j13array[0]);\ncj13array[0]=IKcos(j13array[0]);\nif( j13array[0] > IKPI )\n{\n    j13array[0]-=IK2PI;\n}\nelse if( j13array[0] < -IKPI )\n{    j13array[0]+=IK2PI;\n}\nj13valid[0] = true;\nfor(int ij13 = 0; ij13 < 1; ++ij13)\n{\nif( !j13valid[ij13] )\n{\n    continue;\n}\n_ij13[0] = ij13; _ij13[1] = -1;\nfor(int iij13 = ij13+1; iij13 < 1; ++iij13)\n{\nif( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )\n{\n    j13valid[iij13]=false; _ij13[1] = iij13; break; \n}\n}\nj13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];\n{\nIkReal evalcond[9];\nIkReal x1308=IKcos(j13);\nIkReal x1309=(cj12*x1308);\nIkReal x1310=(cj15*cj16);\nIkReal x1311=IKsin(j13);\nIkReal x1312=(sj12*x1311);\nIkReal x1313=((1.0)*x1312);\nIkReal x1314=((1.0)*cj15*sj16);\nIkReal x1315=(cj12*x1311);\nIkReal x1316=(cj11*x1315);\nIkReal x1317=(sj12*x1308);\nIkReal x1318=(cj11*x1317);\nIkReal x1319=(sj11*x1315);\nIkReal x1320=(sj11*x1317);\nIkReal x1321=(cj16*sj14);\nIkReal x1322=(sj14*sj16);\nIkReal x1323=((1.0)*cj14*cj15);\nIkReal x1324=(cj14*cj16*sj15);\nIkReal x1325=((1.0)*cj14*sj15*sj16);\nIkReal x1326=((0.09)*cj16);\nIkReal x1327=((0.09)*sj16);\nIkReal x1328=(cj11*x1309);\nIkReal x1329=(sj11*x1309);\nIkReal x1330=((0.25)*sj12);\nIkReal x1331=((0.03)*sj12*x1311);\nevalcond[0]=(((r20*x1310))+((r22*sj15))+x1309+(((-1.0)*r21*x1314))+(((-1.0)*x1313)));\nevalcond[1]=(((r02*sj15))+(((-1.0)*r01*x1314))+((r00*x1310))+x1318+x1316);\nevalcond[2]=(x1320+(((-1.0)*r11*x1314))+((r12*sj15))+((r10*x1310))+x1319);\nevalcond[3]=((((-1.0)*x1315))+(((-1.0)*x1317))+((r20*x1322))+((r21*x1321))+(((-1.0)*r21*x1325))+((r20*x1324))+(((-1.0)*r22*x1323)));\nevalcond[4]=((((0.235)*x1312))+(((0.03)*x1317))+(((-1.0)*(1.0)*pz))+(((-0.235)*x1309))+((r20*x1326))+(((-1.0)*r21*x1327))+(((0.03)*x1315))+(((-1.0)*(0.25)*cj12)));\nevalcond[5]=(x1328+(((-1.0)*r01*x1325))+((r00*x1324))+(((-1.0)*r02*x1323))+((r01*x1321))+(((-1.0)*cj11*x1313))+((r00*x1322)));\nevalcond[6]=((((-1.0)*sj11*x1313))+x1329+(((-1.0)*r12*x1323))+((r11*x1321))+((r10*x1324))+(((-1.0)*r11*x1325))+((r10*x1322)));\nevalcond[7]=((((-1.0)*(1.0)*px))+((cj11*x1331))+(((-1.0)*(0.095)*sj11))+(((-1.0)*cj11*x1330))+(((-0.235)*x1316))+(((-0.235)*x1318))+(((-0.03)*x1328))+(((-1.0)*r01*x1327))+((r00*x1326)));\nevalcond[8]=((((-1.0)*(1.0)*py))+((r10*x1326))+((sj11*x1331))+(((-0.235)*x1319))+(((-0.03)*x1329))+(((0.095)*cj11))+(((-0.235)*x1320))+(((-1.0)*sj11*x1330))+(((-1.0)*r11*x1327)));\nif( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )\n{\ncontinue;\n}\n}\n\n{\nstd::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);\nvinfos[0].jointtype = 1;\nvinfos[0].foffset = j11;\nvinfos[0].indices[0] = _ij11[0];\nvinfos[0].indices[1] = _ij11[1];\nvinfos[0].maxsolutions = _nj11;\nvinfos[1].jointtype = 1;\nvinfos[1].foffset = j12;\nvinfos[1].indices[0] = _ij12[0];\nvinfos[1].indices[1] = _ij12[1];\nvinfos[1].maxsolutions = _nj12;\nvinfos[2].jointtype = 1;\nvinfos[2].foffset = j13;\nvinfos[2].indices[0] = _ij13[0];\nvinfos[2].indices[1] = _ij13[1];\nvinfos[2].maxsolutions = _nj13;\nvinfos[3].jointtype = 1;\nvinfos[3].foffset = j14;\nvinfos[3].indices[0] = _ij14[0];\nvinfos[3].indices[1] = _ij14[1];\nvinfos[3].maxsolutions = _nj14;\nvinfos[4].jointtype = 1;\nvinfos[4].foffset = j15;\nvinfos[4].indices[0] = _ij15[0];\nvinfos[4].indices[1] = _ij15[1];\nvinfos[4].maxsolutions = _nj15;\nvinfos[5].jointtype = 1;\nvinfos[5].foffset = j16;\nvinfos[5].indices[0] = _ij16[0];\nvinfos[5].indices[1] = _ij16[1];\nvinfos[5].maxsolutions = _nj16;\nstd::vector<int> vfree(0);\nsolutions.AddSolution(vinfos,vfree);\n}\n}\n}\n    }\n\n}\n\n}\n}\n}\n\n}\n\n}\n}\n}\n// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])\nstatic inline bool checkconsistency8(const IkReal* Breal)\n{\n    IkReal norm = 0.1;\n    for(int i = 0; i < 7; ++i) {\n        norm += IKabs(Breal[i]);\n    }\n    // HACK should be 1e-5*norm\n    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved\n    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;\n}\n/// \\brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)\n///\n/// matcoeffs is of length 54*3, for 3 matrices\nstatic inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)\n{\n    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();\n    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};\n    IkReal IKFAST_ALIGNED16(A[8*8]);\n    IkReal IKFAST_ALIGNED16(work[16*16*15]);\n    int ipiv[8];\n    int info, coeffindex;\n    const int worksize=16*16*15;\n    const int matrixdim = 8;\n    const int matrixdim2 = 16;\n    numroots = 0;\n    // first setup M = [0 I; -C -B] and A\n    coeffindex = 0;\n    for(int j = 0; j < 4; ++j) {\n        for(int k = 0; k < 6; ++k) {\n            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];\n        }\n    }\n    for(int j = 0; j < 4; ++j) {\n        for(int k = 0; k < 6; ++k) {\n            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];\n        }\n    }\n    for(int j = 0; j < 4; ++j) {\n        for(int k = 0; k < 6; ++k) {\n            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];\n        }\n        for(int k = 0; k < 2; ++k) {\n            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;\n        }\n    }\n    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};\n    int lfindex = -1;\n    bool bsingular = true;\n    do {\n        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);\n        if( info == 0 ) {\n            bsingular = false;\n            for(int j = 0; j < matrixdim; ++j) {\n                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {\n                    bsingular = true;\n                    break;\n                }\n            }\n            if( !bsingular ) {\n                break;\n            }\n        }\n        if( lfindex == 3 ) {\n            break;\n        }\n        // transform by the linear functional\n        lfindex++;\n        const IkReal* lf = lfpossibilities[lfindex];\n        // have to reinitialize A\n        coeffindex = 0;\n        for(int j = 0; j < 4; ++j) {\n            for(int k = 0; k < 6; ++k) {\n                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];\n                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;\n                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);\n                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);\n                coeffindex++;\n            }\n            for(int k = 0; k < 2; ++k) {\n                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;\n            }\n        }\n    } while(lfindex<4);\n\n    if( bsingular ) {\n        return;\n    }\n    dgetrs_(\"No transpose\", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);\n    if( info != 0 ) {\n        return;\n    }\n\n    // set identity in upper corner\n    for(int j = 0; j < matrixdim; ++j) {\n        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;\n    }\n    IkReal IKFAST_ALIGNED16(wr[16]);\n    IkReal IKFAST_ALIGNED16(wi[16]);\n    IkReal IKFAST_ALIGNED16(vr[16*16]);\n    int one=1;\n    dgeev_(\"N\", \"V\", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);\n    if( info != 0 ) {\n        return;\n    }\n    IkReal Breal[matrixdim-1];\n    for(int i = 0; i < matrixdim2; ++i) {\n        // HACK should be tol*100\n        if( IKabs(wi[i]) < 5e-5 ) {\n            IkReal* ev = vr+matrixdim2*i;\n            if( IKabs(wr[i]) > 1 ) {\n                ev += matrixdim;\n            }\n            // consistency has to be checked!!\n            if( IKabs(ev[0]) < tol ) {\n                continue;\n            }\n            IkReal iconst = 1/ev[0];\n            for(int j = 1; j < matrixdim; ++j) {\n                Breal[j-1] = ev[j]*iconst;\n            }\n            if( checkconsistency8(Breal) ) {\n                if( lfindex >= 0 ) {\n                    const IkReal* lf = lfpossibilities[lfindex];\n                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);\n                }\n                else {\n                    rawroots[numroots++] = wr[i];\n                }\n                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);\n                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);\n                if( bsmall0 && bsmall1 ) {\n                    rawroots[numroots++] = ev[2]/ev[0];\n                    rawroots[numroots++] = ev[1]/ev[0];\n                }\n                else if( bsmall0 && !bsmall1 ) {\n                    rawroots[numroots++] = ev[3]/ev[1];\n                    rawroots[numroots++] = ev[1]/ev[0];\n                }\n                else if( !bsmall0 && bsmall1 ) {\n                    rawroots[numroots++] = ev[6]/ev[4];\n                    rawroots[numroots++] = ev[7]/ev[6];\n                }\n                else if( !bsmall0 && !bsmall1 ) {\n                    rawroots[numroots++] = ev[7]/ev[5];\n                    rawroots[numroots++] = ev[7]/ev[6];\n                }\n            }\n        }\n    }\n}};\n\n\n/// solves the inverse kinematics equations.\n/// \\param pfree is an array specifying the free joints of the chain.\nIKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {\nIKSolver solver;\nreturn solver.ComputeIk(eetrans,eerot,pfree,solutions);\n}\n\nIKFAST_API const char* GetKinematicsHash() { return \"a3efd6ebbec14ae1184319c65b8d1a99\"; }\n\nIKFAST_API const char* GetIkFastVersion() { return \"0x10000048\"; }\n\n#ifdef IKFAST_NAMESPACE\n} // end namespace\n#endif\n\n#ifndef IKFAST_NO_MAIN\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef IKFAST_NAMESPACE\nusing namespace IKFAST_NAMESPACE;\n#endif\nint main(int argc, char** argv)\n{\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n        return 1;\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n        return -1;\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    std::vector<IkReal> solvalues(GetNumJoints());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n#endif\n\nchar* ComputeFkWrapper(const IkReal* j) {\n    IkReal eetrans[3] = {0};\n    IkReal eerot[9] = {0};\n    char buffer [256] = {0};\n    ComputeFk(j, eetrans, eerot);\n    for(int i = 0; i < 3; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eetrans[i]);\n    for(int i = 0; i < 9 - 1; ++i)\n        sprintf(buffer + strlen(buffer), \"%.15f,\", eerot[i]);\n    sprintf(buffer + strlen(buffer), \"%.15f\", eerot[9 - 1]);\n    return buffer;\n}\n\nstd::vector<IkReal> TrueComputeIk(int argc, char** argv)\n{\n    std::vector<IkReal> solvalues(GetNumJoints());\n    if( argc != 12+GetNumFreeParameters()+1 ) {\n        printf(\"\\nKAKAKAK Usage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n\"\n               \"Returns the ik solutions given the transformation of the end effector specified by\\n\"\n               \"a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n\"\n               \"There are %d free parameters that have to be specified.\\n\\n\",GetNumFreeParameters());\n    }\n\n    IkSolutionList<IkReal> solutions;\n    std::vector<IkReal> vfree(GetNumFreeParameters());\n    IkReal eerot[9],eetrans[3];\n    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);\n    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);\n    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);\n    for(std::size_t i = 0; i < vfree.size(); ++i)\n        vfree[i] = atof(argv[13+i]);\n    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);\n\n    if( !bSuccess ) {\n        fprintf(stderr,\"Failed to get ik solution\\n\");\n    }\n\n    printf(\"Found %d ik solutions:\\n\", (int)solutions.GetNumSolutions());\n    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {\n        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);\n        printf(\"sol%d (free=%d): \", (int)i, (int)sol.GetFree().size());\n        std::vector<IkReal> vsolfree(sol.GetFree().size());\n        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);\n        for( std::size_t j = 0; j < solvalues.size(); ++j)\n            printf(\"%.15f, \", solvalues[j]);\n        printf(\"\\n\");\n    }\n    return solvalues;\n}\n"]}